# Introduction

Stacks: The leading Bitcoin L2.

<div data-with-frame="true"><figure><picture><source srcset="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fx09gHeYU67yvfXLh7Iis%2Fbitcoin-stacks.png?alt=media&#x26;token=7635e08d-2495-44ed-a93c-68351882fbf3" media="(prefers-color-scheme: dark)"><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fam7BqpV0sbUexW7Zpqoh%2Fbitcoin-stacks-dark.png?alt=media&#x26;token=28aa61b3-628a-4519-a574-0b5856762626" alt=""></picture><figcaption></figcaption></figure></div>

{% hint style="info" %}
For the official Stacks whitepaper: <https://stacks-network.github.io/stacks/stacks.pdf>
{% endhint %}

### Stacks: The TL;DR

Stacks activates the Bitcoin economy. Bitcoin is the most adopted, most valuable, and most decentralized cryptocurrency. The Stacks L2 enables fast, cheap BTC and full-featured smart contracts on the L2 without modifying Bitcoin itself. Users and developers can use BTC in their apps and pay gas fees with BTC. All transactions on Stacks L2 are secured by Bitcoin L1 with 100% finality, enabling you to build apps and digital assets that are integrated&#x20;with Bitcoin security.

The Stacks layer for smart contracts has the following innovations that make it unique:

**S**: Secured by the entire hash power of Bitcoin (Bitcoin finality).\
**T**: Trust-minimized Bitcoin peg mechanism; write to Bitcoin.\
**A**: Atomic BTC swaps and assets owned by BTC addresses.\
**C**: Clarity language for safe, decidable smart contracts.\
**K**: Knowledge of full Bitcoin state; read from Bitcoin.\
**S**: Scalable, fast transactions that settle on Bitcoin.

#### All of this is accomplished by three core components:

{% stepper %}
{% step %}

#### Proof of Transfer

Proof of Transfer (PoX) is the block production mechanism of the Stacks chain. Essentially, it attempts to recreate the block production patterns of PoW programmatically. Stacks miners spend BTC for a chance to mine new Stacks blocks. Under the hood, this block production mechanism anchors Stacks blocks to Bitcoin blocks, making it as hard to reverse a Stacks block as it is to reverse a Bitcoin block. That's a big claim, and we unpack it in further detail in the sections on Nakamoto block production.

[Learn more about PoX](https://docs.stacks.co/learn/stacks-101/proof-of-transfer)
{% endstep %}

{% step %}

#### Clarity

Clarity is the smart contract language that Stacks uses. It has been designed from the ground up to make it easier for developers to write safe, secure smart contracts. Additionally, since it has been purpose-built for Stacks and Bitcoin, there are built-in functions for reading Bitcoin state, which means you can use Bitcoin state to perform actions in Clarity. For example, you could set up a check to make sure a particular Bitcoin transaction has occurred before executing a mint function in Clarity, which just so happens to be what happens with the third component: sBTC.

[Learn more about Clarity](https://docs.stacks.co/learn/clarity)
{% endstep %}

{% step %}

#### sBTC

sBTC is the trust-minimized 2-way Bitcoin peg on the Stacks layer. sBTC is the key to making Bitcoin programmable and bringing full smart contract functionality to Bitcoin via Stacks. sBTC is not a federation, but operates as an open-network, decentralized 2-way peg solution to bring smart contract functionality to Bitcoin with as little counterparty risk as possible.

[Learn more about sBTC](https://docs.stacks.co/learn/sbtc)
{% endstep %}
{% endstepper %}

***

### Why you need to learn the fundamentals of Stacks?

Stacks fundamentals give you the intuition to build apps that are safer, more Bitcoin-aligned, and more future-proof. A developer who learns the basics doesn’t just write Clarity—they build apps that actually *feel like* Bitcoin apps.

1. You'll build apps that actually leverage Bitcoin
2. You'll avoid costly design mistakes
3. You'll write better smart contracts
4. You'll use sBTC and Bitcoin writes correctly

***

### What to learn next?

<table data-card-size="large" data-view="cards"><thead><tr><th></th><th></th><th data-hidden data-card-target data-type="content-ref"></th></tr></thead><tbody><tr><td><h4>Stacks 101</h4></td><td>Really dive into the nuts and bolts of how Stacks is built on Bitcoin.</td><td><a href="stacks-101">stacks-101</a></td></tr><tr><td><h4>Network Fundamentals</h4></td><td>Learn about accounts, testnets, SIPs, authentication, BNS, and more.</td><td><a href="network-fundamentals">network-fundamentals</a></td></tr><tr><td><h4>Block Production</h4></td><td>How do Stacks blocks get validated and mined?</td><td><a href="block-production">block-production</a></td></tr><tr><td><h4>Transactions</h4></td><td>Learn about the lifecycle of a transaction on Stacks.</td><td><a href="transactions">transactions</a></td></tr><tr><td><h4>Clarity</h4></td><td>Discover the philosophy and design principles of the Clarity smart contract language.</td><td><a href="clarity">clarity</a></td></tr><tr><td><h4>sBTC</h4></td><td>Understand how bitcoin is unwrapped into a productive and programmable asset.</td><td><a href="sbtc">sbtc</a></td></tr><tr><td><h4>Dual Stacking</h4></td><td>A financial innovation on top of the core foundation of Stacking. Earn bitcoin with bitcoin.</td><td><a href="dual-stacking">dual-stacking</a></td></tr></tbody></table>

***

### Additional Resources

* \[[Stacks YT](https://youtu.be/0erpW7IEo6Y?si=Ldu4RlVVnLqOL4eP)] How Stacks Will Grow In 2025 With Stacks Founder Muneeb Ali
* \[[Token2049 Dubai](https://youtu.be/DFTXAOmi0es?si=sMOO6Yfj_TCVdFTF)] Muneeb Ali - Building Bitcoin’s Future: The Role of Stacks L2&#x20;


# Stacks 101

Stacks has a very unique technical model in the blockchain world. This section will help you get a high-level overview of the essential components to understand how Stacks works.

We'll cover the basics of what Stacks is and how it works from both a philosophical and technical level, and you can dive into the further sections for more details.

First up, let's get an overview of exactly what Stacks is.


# What Is Stacks?

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-273720c2164bb69aeb720d97d2c2bd48c974507d%2FFrame%20316126258.jpg?alt=media" alt=""><figcaption></figcaption></figure>

We can get an idea of the goal and ethos behind Stacks by looking at [how Satoshi envisioned generalizing Bitcoin](https://satoshi.nakamotoinstitute.org/posts/bitcointalk/threads/244/#222) back in 2010:

> "...to be a completely separate network and separate block chain, yet share CPU power with Bitcoin...all networks in the world would share combined CPU power, increasing the total strength."

This is a major theme in the design decisions for Stacks. A bit of a contradiction in the Bitcoin world, the Stacks network is a Bitcoin L2, but it does have its own token.

This is an intentional and critical design decision primarily for the purpose of maintaining decentralization, rather than needing to rely on a federation.

If that's confusing or you are skeptical, that's understandable — we'll be diving deeper into these ideas as we go through the docs.

### Stacks and the Purpose of Blockchain Technology

When evaluating new blockchain technologies, it's important to keep the original intent and purpose of them intact. If we go back to Bitcoin, it was originally designed to be:

* Decentralized
* Immutable
* Secure

You've likely heard of the blockchain trilemma — the problem of trying to balance decentralization, scalability, and security of a blockchain network.

Stacks takes the approach of solving this trilemma by separating out chains into layers.

So at the bottom, you have the foundational layer: Bitcoin.

Bitcoin is the most decentralized, most secure, and most immutable blockchain network. However, that comes with a few tradeoffs.

* Bitcoin is very slow compared to other networks. Bitcoin only has a new block written once every \~10 minutes, making its throughput negligible compared to networks designed for speed like Solana.
* Bitcoin is also "boring". Ethereum came along after Bitcoin and sought to do the same thing for software that Bitcoin did for money. Ethereum's goal is to be a decentralized supercomputer of sorts, serving as a global compute environment for smart contracts (code that is written to a blockchain).
* Bitcoin is not scalable. Because every new block must propagate to every node on the network, Bitcoin can only run as fast as the slowest node in the network.

Now we are seeing the rise of modular blockchain networks like Cosmos that are designed to make it easy for people to spin up their own blockchain networks.

While most new blockchain protocols popping up these days see these properties as negatives and seek to eliminate them, the Stacks community sees things differently.

### The Stacks Way

Stacks takes a layered approach: the foundational settlement layer is Bitcoin, and scalability and functionality are added on top of that using layers.

There are many different types of L2s and different ways they can be built. They all come with [different tradeoffs](https://docs.stacks.co/learn/stacks-101/stacks-among-other-layers) and have their own way of accomplishing the goals of scalability or functionality.

By taking this layered approach, we are able to have all of the same functionality as chains like Ethereum, but built on Bitcoin.

So Stacks is a Bitcoin layer 2 with some unique properties, like having its own token, that acts as an incentive mechanism to maintain a historical ledger of all of its transactions and operate with its own security budget (in addition to Bitcoin's security budget — more on this in the next section).

This is one of the things that separates Stacks from other Bitcoin layers like Lightning.

* Lightning doesn't add any additional functionality to Bitcoin; it simply helps to scale functionality Bitcoin already has and helps it operate faster. Lightning is also ephemeral — it has no permanent state — and so is unsuitable for things like smart contracts that need to keep track of data and maintain state.
* Contrast this to Stacks, which adds additional functionality to Bitcoin but still ultimately settles to Bitcoin (we'll cover this in the next section as well).

The benefit is that we can maintain a separation of concerns and keep Bitcoin simple and sturdy, chugging along producing blocks, while adding additional layers for functionality and speed. If those other layers were compromised, the foundational layer would remain unaffected.

This is important when building systems intended to be a global decentralized money (Bitcoin) and a decentralized economy built on top of that money (Stacks).

The STX token is a separate token used to incentivize honest block production. It does not represent pegged Bitcoin (there is a separate Bitcoin peg called [sBTC](https://docs.stacks.co/learn/sbtc) for that purpose). While this may ruffle some feathers among parts of the Bitcoin community, it has several advantages.

By implementing a token into the Stacks chain, we provide additional economic incentive for miners to produce Stacks blocks honestly.

This token provides additional incentive as a way to grow the chain. Rather than relying on altruism to produce blocks and grow the chain, we can incentivize builders, token-holders, and investors all at the same time by having a token.

The ICO scams of 2017 put a bad taste in many people's mouths, which has justifiably made a lot of people skeptical of every new blockchain project that pops up with a new token.

But the problem with many of those projects was they had no actual value, weren't anchored to anything else of value, and provided no real utility.

With a project like Stacks, we have real utility in the sense of serving as a way to utilize Bitcoin and make it a productive asset in a decentralized way. This is a key point: currently the only common ways to make Bitcoin productive are to give it to a custodial service or transfer it off the Bitcoin chain via something like wBTC on Ethereum.

Stacks allows us to do this while ultimately still settling to the Bitcoin chain.

In addition, Stacks allows us to build decentralized and censorship-resistant software utilizing Bitcoin as the foundational settlement layer. Eventually, the goal is to build a network of financial systems and decentralized software products that all utilize Bitcoin as their money.

With that context, let's dive into exactly how Stacks is connected to Bitcoin.


# The Bitcoin Connection

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-dfb22d998899604417b072202f52fa3cdda377ef%2FFrame%20316126254.jpg?alt=media" alt=""><figcaption></figcaption></figure>

In the previous section, we described Stacks as bringing smart contract functionality to Bitcoin, without modifying Bitcoin itself, and explained a bit about how the chain works.

That's a big promise, but how does Stacks actually deliver on it? And what makes Stacks unique among other Bitcoin layers and other blockchains like Ethereum?

Before we get into the technical details of how Stacks works, it's important to get a high-level overview of the problem it's solving and how it actually does that. We'll dive deeper into some of these topics as we go through the docs, but it's good to get a high-level picture to bring everything together.

This topic is a bit of a rabbit hole, and this section is pretty long, but it will give you an in-depth understanding of exactly the problem Stacks is looking to solve, and how it solves it.

Let's get into it.

### Is Stacks a Bitcoin L2?

Stacks is a Bitcoin layer for smart contracts. The classification as a layer-1 (L1) or layer-2 (L2) or sidechain really depends on the definition used. With that said, generally speaking L1 chains are sovereign meaning that (a) they have their own security budget, and (b) they can survive without the need for any other L1 chain. L2 chains typically do not have their own security budget and share the security of the underlying L1 chain, and they cannot live without the underlying L1 chain. There are many different design mechanisms that L2s can use, and we cover several of them and how Stacks compares in the [Stacks Among Other Bitcoin Layers](https://docs.stacks.co/learn/stacks-101/stacks-among-other-layers) section.

The initial release of Stacks in early 2021 had a separate security budget from Bitcoin L1. Even though the Stacks layer could not function without Bitcoin L1, the developers working on the project described it as a different system that does not fit neatly into existing classifications, sometimes using the term layer 1.5 (see [this Decrypt article](https://decrypt.co/82019/bitcoin-defi-thing-says-stacks-founder-muneeb-ali) for example).

The upcoming planned release of Stacks, called the Nakamoto release, will no longer have a separate security budget from Bitcoin. Instead, a 100% of Bitcoin hashpower will determine finality on Stacks layer. After the next upgrade, to reorg Stacks blocks/transactions the attacker will need to reorg Bitcoin L1 itself (which is very hard to do and therefore a great security property for a Bitcoin layer to have). More details in the [Stacks paper](https://stacks.co/stacks.pdf).

The definition of [L2 used in Ethereum](https://ethereum.org/en/layer-2/) and other newer ecosystems is different and focuses on the ability to withdraw assets using only L1 security and L1 miners. According to that definition Stacks layer is not a clear L2, given the set of peg-out signers determine if users can withdraw sBTC. Bitcoin cannot support such verification without changes to Bitcoin L1 (which may happen in the future). The Ethereum L2 definition also does not apply that cleanly to Bitcoin L2s, given new assets are issued on L2s when it comes to Bitcoin and not issued on L1 (only BTC is the L1 asset). Therefore, using the definition of security of withdrawing assets is not directly applicable given assets are defined and used on L2s and not withdrawn out to Bitcoin L1 anyway (with the exception of BTC itself). Rather, what becomes more important is "settlement on Bitcoin" i.e., is contract data and state secured by 100% of Bitcoin's hashpower or not.

Remember that L2s on Bitcoin also have to serve the additional purpose of expanding both functionality and scalability, which means L2s accomplish fundamentally different goals depending on the functionality of the L1.

Users and developers organically call Stacks a Bitcoin L2, since it is a simpler concept to understand. There are certain properties of Stacks layer that also help the concept of Stacks as a Bitcoin L2:

{% stepper %}
{% step %}
**Bitcoin finality**

100% of the Bitcoin hashpower decides block ordering and transaction finality.
{% endstep %}

{% step %}
**Consensus runs on Bitcoin L1**

Stacks consensus runs on Bitcoin L1, and Stacks L2 cannot operate or survive without Bitcoin L1.
{% endstep %}

{% step %}
**sBTC and economic unit**

With the upcoming decentralized Bitcoin peg, called sBTC, most of the economy on Stacks layer will likely use BTC as the unit of economy. It is expected that most users will simply use Bitcoin in wallets and apps and then peg out their BTC to Bitcoin L1.
{% endstep %}

{% step %}
**Data hashed and stored on Bitcoin L1**

All data and transactions on Stacks are automatically hashed and permanently stored on Bitcoin L1 on every Bitcoin block. Anyone can verify that some data on Stacks is valid by checking the corresponding hash on Bitcoin L1. This compact storage of hashes on L1 is somewhat similar to rollups (although there are other differences). You can read more about this process in the [Block Production](https://docs.stacks.co/learn/block-production) section.
{% endstep %}

{% step %}
**Contracts can read Bitcoin L1**

Contracts on Stacks layer can read Bitcoin L1 transactions and respond to them. Assets on Stacks layer can be moved simply through Bitcoin L1 transactions.
{% endstep %}
{% endstepper %}

Given all the details above, why would some people think that Stacks is not a Bitcoin L2? There are a couple of reasons this question comes up often:

{% stepper %}
{% step %}
**Old security-budget material**

The initial version of Stacks (released early 2021) had a separate security budget which changed to following 100% Bitcoin hashpower with the Nakamoto release. There is old material and blog posts floating around that still talk about the initial Stacks version. The old materials will likely get updated with time.
{% endstep %}

{% step %}
**Ethereum L2 withdrawal definition doesn't map cleanly**

According to the Ethereum definition of L2s a user should be able to withdraw their base-layer assets purely by doing an L1 transaction and relying only on L1 security (this is true for Lightning for example). This definition does not apply cleanly to Bitcoin L2s because assets are not defined at Bitcoin L1 but are defined in L2s instead. The only asset where this matters is the pegged BTC asset from Bitcoin L1, given all other assets are native to L2s anyway. In the upcoming Stacks release, users can withdraw their BTC by sending just a Bitcoin L1 transaction but Bitcoin L1 cannot validate that complex transaction and a majority of peg-out signers will need to sign on the peg-out request. In an ideal world Bitcoin miners can validate such transactions but that would require a change to Bitcoin L1. Therefore, Stacks design optimizes for a method that is decentralized and can be deployed without any changes to Bitcoin L1. If in the future it is possible to make changes to Bitcoin L1 then Stacks layer security can benefit from that as well.
{% endstep %}

{% step %}
**Healthy Bitcoin skepticism**

Bitcoin community members are generally skeptical of claims and on the lookout for people making any false marketing claims. This is generally a healthy thing for the Bitcoin ecosystem and builds up the immune system. Some such community members might be skeptical about Stacks as a Bitcoin layer or L2 until they fully read the technical details and reasoning. There is a good [Twitter thread](https://twitter.com/lopp/status/1623756872976158722?s=20) about this topic as well.
{% endstep %}
{% endstepper %}

Why don't we use the term 'sidechain' for Stacks then? Sidechains in Bitcoin typically have a different security budget from Bitcoin L1, typically as a subset of Bitcoin miners who participate in the sidechain (they don't follow 100% Bitcoin finality), their consensus runs on the sidechain (vs running on Bitcoin L1), and they don't publish their data/hashes on Bitcoin L1. The Stacks layer does not fit that definition cleanly given the consensus runs on Bitcoin L1, it follows Bitcoin finality, and publishes data/hashes on L1.

Can Stacks layer work with rollups?

Yes! There is already an active R\&D effort to integrate rollups with the Stacks layer. Both with the Stacks layer and sovereign rollups the technically challenging part is how to get BTC in and out of the Stacks layer or the sovereign rollup. The decentralized BTC peg, [sBTC](https://docs.stacks.co/learn/sbtc), applies to both the Stacks layer and sovereign rollups. Without modifying Bitcoin L1, an sBTC-like design with a decentralized open-membership group of signers is the most trust-minimized way to move BTC in and out of Bitcoin layers. Once the necessary upgrades to Bitcoin L1 can be made to enable validity rollups i.e., Bitcoin L1 can enforce BTC withdrawal from a layer, then the Stacks layer can also upgrade to benefit from it.

Given a trust-minimized asset like sBTC is needed for sovereign rollups, with the launch of sBTC such sovereign rollups become even more interesting to deploy. The Stacks layer can potentially provide the decentralized group of signers for a trust-minimized BTC asset that can be used in a sovereign rollup, and DA comes directly from Bitcoin L1 e.g., with Ordinals.

### Why Does Stacks Need a Token?

This brings us to a central philosophical conversation in the world of crypto and Bitcoin, whether or not blockchains need tokens.

Let's start by looking at the fundamental reason why tokens exist: to fund the maintenance and forward progress of a blockchain.

Bitcoin is a token. It is a cryptocurrency that is used to incentivize miners to add new blocks to the chain. In Bitcoin's case, mining rewards are set on a predefined schedule, and once those mining rewards run out, the chain will need to survive on transaction fees alone.

The purpose of a blockchain is to have a permanent historical record of every transaction that has ever occurred on the chain. Blockchains are basically ledgers. The token aspect is used as an incentive mechanism to secure and maintain the chain.

This is why networks like Lightning and other P2P networks don't need tokens, they don't need to maintain a historical record. Channel-based solutions like Lightning rely on users opening 2-of-2 multisigs with each other. Once those channels are closed, the state disappears. When we are talking about a system that is supposed to maintain a global financial system, it is important for the maintenance of that system to be incentivized correctly.

Let's look at this concept in the context of Stacks and its goals. Stacks seeks to provide smart contract functionality to Bitcoin, to serve as the programming rails for building a decentralized economy on top of Bitcoin.

Many Bitcoin community members are skeptical of new tokens and rightly so. There are countless projects out there that force the use of a token on their project and in many cases a token is actually not needed. The Stacks project was started by Bitcoin builders who have a long history of building apps & protocols on Bitcoin L1 without any token (e.g., BNS launched in 2015 on Bitcoin L1 which was one of the largest protocols using OP\_RETURN on Bitcoin L1). So why did a bunch of Bitcoin builders decide to have a separate token for Stacks L2? Great question! Let's dig into the details.

The Stacks token (STX) is primarily meant to be used for two things:

{% stepper %}
{% step %}
**Incentives for Stacks L2 miners**

Newly minted STX are used to incentivize decentralized block production on Stacks L2.
{% endstep %}

{% step %}
**Incentives for peg-out signers**

Signers participating in peg-out operations receive incentives in STX to economically align them with protocol rules.
{% endstep %}
{% endstepper %}

The only way to remove the token is to build Stacks as a federated network like Liquid. In a federation the pre-selected group of companies control the mining and block production and a pre-selected group of companies need to be trusted for peg-out transactions.

Stacks developers wanted to design an open and permissionless system. The only way to have a decentralized mining process is through incentives. As mentioned above, this is how Bitcoin works as well, where newly minted BTC are used as incentives to mine new blocks and anyone in the world can decide to become a miner. Anyone with BTC can mine the Stacks L2 chain, it is open and permissionless.

Similarly, the way sBTC is designed is that the group of signers is open and permissionless (unlike a federation). These signers have economic incentives to correctly follow the protocol for peg-out requests. In a federation, users need to blindly trust the pre-set federation members to get their BTC out of the federation and back on Bitcoin L1. Stacks developers wanted to have an open, permissionless, and decentralized way to move BTC from Bitcoin L1 to Stacks L2 and back. This is made possible through economic incentives i.e., need for a token.

{% hint style="info" %}
With more and more Bitcoin layers emerging, there is some nuance in this federated vs open network design. Some protocols like Botanix's Spiderchain offer an open network but have different incentive mechanisms. We dig into these in detail in the [Stacks Among Other Layers](https://docs.stacks.co/learn/stacks-101/stacks-among-other-layers) section.
{% endhint %}

Other than these two reasons, STX is also used to pay gas fees for transactions. However, once the upcoming sBTC peg is live most of the economy of Stacks L2 is expected to follow a Bitcoin standard and work using BTC as the economic unit. It is expected that users will mostly interact just with Bitcoin and use BTC in wallets and apps (gas fees can be paid with BTC using atomic swaps in the background). It is important to note that BTC cannot be used for mining incentives on Stacks L2 because the only way to incentivize decentralized block production is through newly minted assets by the protocol (similar to how Bitcoin works itself) i.e., need for a token.

### The Symbiotic Relationship Between Stacks and Bitcoin

Stacks and Bitcoin complement each other. Stacks leverages the extreme decentralization of Bitcoin, its PoW consensus mechanism, and its value as a cryptocurrency.

But Stacks also complements Bitcoin by unlocking additional use cases, thereby increasing its value over time. This also helps to solve the additional problem of the future maintainability of Bitcoin after the coinbase rewards are gone and Bitcoin has to function on transaction fees alone.

If Bitcoin is seen as only a store of value, the economic density, meaning how much value is being exchanged, of each transaction will be minimal. But if Bitcoin is the underlying foundation for an entire decentralized economy, those [transactions become much more valuable](https://twitter.com/muneeb/status/1506976317618728963), increasing transaction fees. This is a crucial incentive for miners to continue securing the network as coinbase rewards drop.

### Reading from Bitcoin State

One of the things that gives the Stacks chain its superpowers in connecting with Bitcoin is not only how it connects to Bitcoin at a protocol level, discussed above, but also how we can utilize that Bitcoin at a programmatic level.

That's where Clarity comes in. Clarity is the smart contract language for Stacks, and is how we actually build out a lot of the functionality we are talking about here.

One of the often-touted features of Clarity is that it has access to the state of the Bitcoin chain built in, but how does it actually do that? Because of Stacks' PoX mechanism, every Stacks block is connected to a Bitcoin block, and can query Bitcoin block header hashes with the [`get-burn-block-info?` function](https://github.com/stacksgov/sips/blob/feat/sip-015/sips/sip-015/sip-015-network-upgrade.md#new-method-get-burn-block-info).

This function allows us to pass in a Bitcoin block height and get back the header hash. The [`burn-block-height` Clarity keyword](https://docs.stacks.co/docs/write-smart-contracts/clarity-language/language-keywords#burn-block-height) will give us the current block height of the Bitcoin chain.

However, `get-burn-block-info?` only returns data of the Bitcoin block at that height if it has already been processed and was created after the launch of the Stacks chain. So if we want to evaluate whether or not something happened on Bitcoin, we have to wait at least one block later to do so.

This is step 1 of Clarity contracts being able to serve as the programming layer for Bitcoin. When a BTC transaction is initiated, the first thing that needs to happen is that a Clarity contract needs to become aware of it. This can happen manually by utilizing Clarity functions discussed above with the [BTC library](https://explorer.stacks.co/txid/0x8b112f2b50c1fa864997b7496aaad1e3940700309a3fdcc6c07f1c6f8b9cfb7b?chain=mainnet), as [Catamaran Swaps](https://docs.catamaranswaps.org/en/latest/catamaran.html) do.

{% hint style="info" %}
Note that this process is made easier by the additional Clarity functions added in 2.1, like the `get-burn-block-info?` function we looked at above.
{% endhint %}

Or we can automate (albeit at a cost of some centralization in our dapp) using an event-based architecture using something like Hiro's [chainhooks](https://www.hiro.so/blog/meet-4-new-features-in-clarinet#setting-up-trigger-actions-with-chainhooks), which will allow us to automatically trigger a Clarity contract call when a certain BTC transaction is initiated.

This is the first component of using Stacks to build Bitcoin dapps, the read access to Bitcoin chain.

Next up, let's dig a bit deeper into how exactly Stacks is "built on Bitcoin" by taking a look at Stacks' block production mechanism, Proof of Transfer.


# Proof of Transfer (PoX)

<figure><picture><source srcset="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2FqhGYp66lKo0jjZ57rDpy%2Fpox-light.png?alt=media&#x26;token=0d44f0ac-4595-40b4-b554-a510af89fea4" media="(prefers-color-scheme: dark)"><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2FEUW1W0NPEuoCYBtienyL%2Fpox.png?alt=media&#x26;token=2edba99c-91f7-4df2-8ea1-aceb9f3bb712" alt=""></picture><figcaption></figcaption></figure>

In the previous sections, we took a look at the vision and ethos of Stacks and talked a lot about it being connected to Bitcoin and how it enables expanding functio nality without modifying Bitcoin itself.

In this section, we'll run through the block production mechanism that makes that happen, Proof of Transfer.

This section will be a conceptual overview of Proof of Transfer. For more details on exactly how block production happens at a technical level, check out the section on [Block Production](https://docs.stacks.co/learn/block-production).

Consensus algorithms for blockchains require compute or financial resources to secure the blockchain. The general practice of decentralized consensus is to make it practically infeasible for any single malicious actor to have enough computing power or ownership stake to attack the network.

Popular consensus mechanisms in modern blockchains include proof of work, in which nodes dedicate computing resources, and proof of stake, in which nodes dedicate financial resources to secure the network.

Proof of burn is another, less-frequently used consensus mechanism where miners compete by ‘burning’ (destroying) a proof of work cryptocurrency as a proxy for computing resources.

Proof of Transfer (PoX) is an extension of the proof of burn mechanism. PoX uses the proof of work cryptocurrency of an established blockchain (Bitcoin in this case) to secure a new blockchain. However, unlike proof of burn, rather than burning the cryptocurrency, miners transfer the committed cryptocurrency to some other participants in the network (Stackers in this case).

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2FDdAEe8T2U2HNgOsnAaFb%2FStacks_graphic%20-%2067.png?alt=media&#x26;token=2a4344b9-c8e8-4ab1-990d-2d2ab61d3932" alt=""><figcaption></figcaption></figure></div>

This allows network participants to secure the PoX cryptocurrency network and earn a reward in the base cryptocurrency (BTC). Thus, PoX blockchains are anchored on their chosen PoW chain. Stacks uses Bitcoin as its anchor chain.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fjt1GkSXIb4cL4d1e4SDo%2FStacks_graphic%20-%2080.png?alt=media&#x26;token=6ba8fe68-ad75-4178-9ebc-51ee2b2f7b7b" alt=""><figcaption></figcaption></figure></div>

### Why Bitcoin?

There are a number of reasons that Stacks chose Bitcoin as the blockchain to power consensus. It's the oldest blockchain protocol, having launched in 2009, and has become a recognized asset outside of the cryptocurrency community. BTC has held the highest market capitalization of any cryptocurrency for the past decade.

Bitcoin champions simplicity and stability, and has stood the test of time. Influencing or attacking the network is infeasible or impractical for any potential hackers. It's one of the only cryptocurrencies to capture public attention. Bitcoin is a household name, and is recognized as an asset by governments, large corporations, and legacy banking institutions. Lastly, Bitcoin is largely considered a reliable store of value, and provides extensive infrastructure to support the PoX consensus mechanism.

SIP-001 provides a full [list of reasons why Bitcoin was chosen to secure Stacks](https://github.com/stacksgov/sips/blob/main/sips/sip-001/sip-001-burn-election.md).

{% hint style="info" %}
By the way, SIP stands for Stacks Improvement Proposal, and it's the process by which community members agree on making changes to the network. Reading the SIPs in detail is an excellent way to familiarize yourself with Stacks at the implementation level. All of the SIPs are available in the [SIPs section](https://docs.stacks.co/learn/network-fundamentals/sips) of the docs.
{% endhint %}

### Unlocking Bitcoin capital

In the previous section we talked about Stacks being able to allow us to build a decentralized economy on top of Bitcoin and that PoX was a key piece of being able to do that.

The reason is two-fold. First, as a part of this PoX mining process we have covered here, a hash of each Stacks block is recorded to the OP\_RETURN opcode of a Bitcoin transaction. If you aren't familiar, the OP\_RETURN opcode allows us to store up to 40 bytes of arbitrary data in a Bitcoin transaction.

{% hint style="info" %}
This [Stack Exchange answer](https://bitcoin.stackexchange.com/questions/29554/explanation-of-what-an-op-return-transaction-looks-like) gives a good overview of the reasoning and history of this opcode.
{% endhint %}

This is the first part of how Stacks inherits Bitcoin's security: its history is anchored block-by-block to the Bitcoin chain. Anyone can use merkle roots to verify these hashes to determine if the history is correct.

Additionally, after the Nakamoto Upgrade, Stacks no longer forks on its own. Miners are required at a protocol level to build atop the last mined Stacks blocks, meaning that **Stacks is secured by both 100% of Bitcoin's hashrate in addition to the Stacks security budget from its miners.** We'll get into this process in more detail in the [Block Production](https://docs.stacks.co/learn/block-production) section.

Additionally, part of this PoX process involves each Stacks block also knowing which Bitcoin block it is anchored to. Clarity, Stacks' smart contract language, has built-in functions for reading this data, such as [`get-block-info`](https://docs.stacks.co/docs/write-smart-contracts/clarity-language/language-functions#get-block-info), which returns, among other things, a field called `burnchain-header-hash`, which gives us the hash of the Bitcoin header corresponding to this Stacks block.

This allows us to do really interesting things like trigger certain things to happen in a Clarity contract by watching the chain and verifying whether or not certain transactions occurred. You can see this in action in [Catamaran Swaps](https://docs.catamaranswaps.org/en/latest/catamaran.html), with other interesting projects like [Zest](https://www.zestprotocol.com/) seeking to expand on this functionality.

The ultimate goal of all this is to enable the vision of web3, building a decentralized economy and enabling true user ownership of assets and data, on top of Bitcoin as a settlement layer, and using Bitcoin as a base decentralized money.

### Proof of Transfer Contracts and Technical Details

The Proof of Transfer functionality is implemented on the Stacks chain via a [Clarity smart contract](https://explorer.hiro.so/txid/0xc6d6e6ec82cabb2d7a9f4b85fcc298778d01186cabaee01685537aca390cdb46?chain=mainnet). An overview of this contract is available in the docs.

You can see the original design for stacking and proof of transfer by reading the relevant SIP, [SIP-007](https://github.com/stacksgov/sips/blob/main/sips/sip-007/sip-007-stacking-consensus.md). You can also utilize [Hiro's API](https://docs.hiro.so/api#tag/Info/operation/get_pox_info) to get proof of transfer details including the relevant contract address.


# Stacks Among Other Layers

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2FHnpCVWQoXIlwJ3zHUMoU%2Fbitcoin-layer-2s.jpg?alt=media&#x26;token=e26f76f4-20af-49f0-a762-54e8409c6688" alt=""><figcaption></figcaption></figure>

Recently, we have seen a flurry of new "Bitcoin layers" popping up across the ecosystem as the market has finally woken up to the idea.

However, not all Bitcoin layers are made equal. While a large chunk of these projects are vaporware riding the hype train, there are several projects that are making a good faith effort to grow the Bitcoin economy and build on top of Bitcooin using various approaches.

The [Bitcoin Layers project](https://www.bitcoinlayers.org/) is an excellent place to begin learning about these different layers. In addition, here we've broken down how Stacks compares to some of the most promising Bitcoin L2 solutions so you can begin to learn about them all and make an educated decision on which to use.

### What is a Bitcoin Layer?

It's important to define terms, especially in a new and evolving ecosystem like web3, and an even newer and more rapidly evolving subecosystem like Bitcoin layers.

For the purpose of this document and comparison, we can use the following definition of a Bitcoin layer: A Bitcoin layer is a separate distributed computing system built either alongside or on top of Bitcoin for the purpose of enhancing its scalability, functionality, or both.

That definition is intentionally general, and encompasses many different projects like L2s, sidechains, federated, open network, etc.

#### Technical vs Economic Considerations

It's important to understand that when designing blockchains, especially layer 2 systems, we have to consider both technical and economic factors. Since a core component of a blockchain system is money, we need to make sure that our systems are both technically robust and economically efficient. And we need to accomplish both of these things while maintaining decentralization.

While it is trivial to create a trusted bridge to bridge BTC from the L1 to a L2, that defeats the purpose of blockchain technology in general, since the goal should be to create permissionless, trust-minimized systems.

At the same time, a great technical solution that doesn't consider the economic incentives of the decentralized actors running the network will not have a sustainable path to long-term adoption and viability.

This balance is why Stacks has chosen the design it has, to balance both achieving the technical features of a Bitcoin L2 like security inheritance and a trust-minimized BTC peg with the economic incentives for the participants in the ecosystem to maintain it in the long term.

As an example of this, Galaxy recently [conducted research](https://www.galaxy.com/insights/research/exploring-bitcoin-for-data-availability/) on this topic and found that a Bitcoin rollup "will need to generate approximately between $1.9m and $9.63m in revenue from L2 transaction fees per month." That is a significant number and again highlights the need to consider both technical and economic factors when designing Bitcoin layers.

### Popular Bitcoin Layers Compared

#### Lightning

Lightning is probably the most well-known Bitcoin layer, and is primarily designed to address scalability issues. Lightning functions as a separate P2P network from Bitcoin, allowing participants to move their BTC from the main chain to Lightning, conduct multiple transactions on Lightning, and then send the final result to the BTC chain where it is finalized.

This is actually a completely separate problem from what Stacks is trying to address. Where Lightning takes the existing functionality of Bitcoin and makes it much more scalable, Stacks is seeking to expand Bitcoin's functionality to do things you can't do now.

Crucially, Lightning is ephemeral, meaning it has no state management. There is no continuous record of what has happened on the Lightning network, only current channels. Once users close their channel and their transactions are written back to the Bitcoin chain, they are gone.

A key component of fully-expressive smart contracts is that they maintain a permanent historical record of all transactions that have happened on the chain.

Bitcoin does this now, but its scripting language is very limited. So where Lightning seeks to make existing Bitcoin functionality happen faster, Stacks seeks to add new functionality.

#### RSK

Like Stacks, [RSK](https://www.rsk.co/) seeks to add additional functionality to Bitcoin, but it goes about that process differently than Stacks.

RSK is a merge-mined chain, meaning that it is mined concurrently with Bitcoin. Stacks has its own miners and mining process, and its own economic value and security that is a function of that token value, more on this below.

There are multiple perspectives to look at this from. Because RSK is merge-mined, Bitcoin miners are also the ones mining RSK blocks, and RSK does not have its own token.

RSK can only exist with opt-in from Bitcoin miners and mining rewards are highly dependent on transaction volume.

This also opens up a wider discussion on the costs and benefits of having a separate token, which we'll get into below a bit when we discuss rollups.

RSK is also EVM-compatible, where Stacks uses Clarity and the Clarity VM.

#### Liquid

[Liquid](https://liquid.net/) is a federated network focused on unlocking more advanced financial capabilities with Bitcoin. Being federated, Liquid is not an open network, and thus not decentralized.

The Liquid consensus mechanism is managed by 15 functionaries, who handle the transaction processing and validating. Liquid also does not support general-purpose applications, but is solely focused on financial applications.

For another perspective, Hiro wrote an [excellent post](https://www.hiro.so/blog/building-on-bitcoin-project-comparison) comparing Stacks with other Bitcoin projects.

#### Bitcoin Rollups

Rollups are an exciting development for scaling decentralized applications. There are many different types of rollups; they're broadly divided into ZK rollups and Optimistic rollups, although other classifications are also there (see [this overview](https://era.zksync.io/docs/dev/fundamentals/rollups.html#what-are-rollups)).

Rollups are generally considered layer-2 (L2) technology that runs on top of a layer-1 blockchain like Bitcoin or Ethereum. A critical aspect of rollups is the trustless nature where logic running on the L1 chain can determine whether something that happened on the rollup was valid. This is not true for all types of rollups, and there is some fuzziness around exact definitions. [Sovereign rollups](https://blog.celestia.org/sovereign-rollup-chains/), for example, only use the underlying L1 for data availability (DA) and not for consensus.

Most of the rollups work on Ethereum uses Ethereum L1 both as a data availability layer, and for consensus, i.e., the validity of rollup transactions is determined by logic running on Ethereum L1. Newer systems, [like Celestia](https://celestia.org/), are taking a more modular approach and are separating DA from consensus. One interesting aspect of separating DA is that more established and durable chains like Bitcoin can be used for DA as well. Below is an interesting comparison of sidechains and two types of rollups possible on Bitcoin (John Light posted this [on Twitter](https://twitter.com/lightcoin/status/1630301411962388481?s=20)):

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-341e6adabafad87e3633375f45fdd4d8e4ba323d%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>

This image broadly means developers can build sovereign rollups on Bitcoin today, but you'll need a "trusted" setup for moving BTC in and out of the rollup. In fact, people are already doing this -- see the recent [Rollkit announcement](https://rollkit.dev/blog/sovereign-rollups-on-bitcoin/). To build validity rollups, meaning Bitcoin L1 enforces BTC withdrawals from the rollup, you'll need modifications to Bitcoin L1. See [this overview](https://bitcoinrollups.org/) for more details.

One important nuance here is the cost required to effectively run a rollup on Bitcoin as discussed in the Galaxy research report linked in the first section.

Now we have a solid grasp of how Stacks works and how it fits in among other layers. Let's begin to dig into some of the technical implementation details and see how Stacks actually works.

***

Additional Resources

* \[[Hiro Blog](https://www.hiro.so/blog/building-on-bitcoin-project-comparison)] Building on Bitcoin: a Comparison of Bitcoin Projects
* \[[Hiro Books](https://www.hiro.so/books/a-beginners-guide-to-bitcoin-layers)] A Beginner's Guide to Bitcoin Layers


# Financial Incentive And Security Budget

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-412a18b7879f6c85d7d9cb6d6290ded4fc1a1afc%2Fimage.png?alt=media" alt=""><figcaption><p>image source: <a href="https://www.hiro.so/blog/securing-web3-apps-through-bitcoin-an-overview-of-stacks-consensus-mechanism">Hiro blog</a></p></figcaption></figure>

In order to reorg the Stacks chain, someone must take control of at least 70% of the STX that are currently Stacked and conduct a 51% attack on Bitcoin itself. If acquired at market prices, then at the time of this writing, that amounts to spending nearly $1 billion USD in only the STX stacked.

In addition to this, because of how Stacks achieves Bitcoin finality by not allowing forks, Stacks security budget reaches 51% of Bitcoin's mining power because in order to reverse the chain state you would need to reverse the Bitcoin chain state as well.

Stackers have the new-found power to sign blocks in order to append them to the Stacks chain. However, some of them could refuse to sign, and ensure that no block ever reaches the 70% signature threshold. While this can happen by accident, this is not economically rational behavior -- if they stall the chain for too long, their STX loses their value, and furthermore, they cannot re-stack or liquidate their STX or activate PoX to earn BTC. Also, miners will stop mining if no blocks are getting confirmed, which eliminates their ongoing PoX payouts.

The technical details of how this all works are discussed in the [Block Production](https://docs.stacks.co/learn/block-production) section.


# Network Fundamentals

Now that you have a high-level understanding of what Stacks is and how it works, let's dive into some more details of all of the components that make up the Stacks Bitcoin L2.

We're going to start with the basics of how the network is actually structured and the components that comprise it.


# Network Basics

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-38bbfbae841ffaa0d8ed353ebfc33f0b6fcac882%2Fimage.png?alt=media" alt=""><figcaption><p>image source: <a href="https://www.hiro.so/blog/understanding-nakamotos-fast-blocks-on-stacks">Hiro blog</a></p></figcaption></figure>

### Tokens

Stacks (STX) tokens are the native tokens on the Stacks blockchain. The smallest fraction is one micro-STX. 1,000,000 micro-STX make one Stacks (STX).

STX amounts should be stored as integers (8 bytes long), and represent the amount of micro-STX.

### Fees

Fees are used to incentivize miners to confirm transactions on the Stacks blockchain. The fee is calculated based on the estimate fee rate and the size of the raw transaction in bytes. The fee rate is a market determined variable. For the testnet, it is set to 1 micro-STX.

Fee estimates can obtained through the [`GET /v2/fees/transfer`](https://docs.hiro.so/api#operation/get_fee_transfer) endpoint of the API.

{% hint style="info" %}
Note that this example uses an external tool, [Hiro's Stacks API](https://www.hiro.so/stacks-api). You can also use the native [Stacks API ](https://app.gitbook.com/u/ZrQItu6D9bMKmf1HfsLTnGc05WZ2)if you would rather run your own node or connect to one.
{% endhint %}

{% code title="terminal" %}

```bash
# for mainnet, replace `testnet` with `mainnet`
curl 'https://api.testnet.hiro.so/v2/fees/transfer'
```

{% endcode %}

The API will respond with the fee rate (as integer):

```json
1
```

[The Stacks Transactions JS library](https://github.com/stx-labs/stacks.js/tree/master/packages/transactions) supports fee estimation for:

* token transfers (`estimateTransfer`)
* contract deploys (`estimateContractDeploy`)
* non read-only contract calls (`estimateContractFunctionCall`)

{% hint style="info" %}
For an implementation using a different language than JavaScript, please review [this reference implementation](https://github.com/stx-labs/stacks.js/blob/master/packages/transactions/src/builders.ts#L97).
{% endhint %}

### Nonces

Every account carries a [nonce property](https://en.wikipedia.org/wiki/Cryptographic_nonce) that indicates the number of transactions processed for the given account. Nonces are one-time codes, starting at `0` for new accounts, and incremented by 1 on every transaction.

Nonces are added to all transactions and help identify them in order to ensure transactions are processed in order and to avoid duplicated processing.

{% hint style="info" %}
The consensus mechanism also ensures that transactions aren't "replayed" in two ways. First, nodes query its unspent transaction outputs (UTXOs) in order to satisfy their spending conditions in a new transaction. Second, messages sent between nodes review sequence numbers.
{% endhint %}

When a new token transfer transaction is constructed, the most recent nonce of the account needs to be fetched and set.

{% hint style="info" %}
The API provides an endpoint to [simplify nonce handling](https://docs.hiro.so/get-started/stacks-blockchain-api#nonce-handling).
{% endhint %}

### Querying

Stacks network details can be queried using the [Stacks Blockchain API](https://docs.hiro.so/get-started/stacks-blockchain-api).

#### Health check

The [status checker](https://status.stacks.org/) is a service that provides a user interface to quickly review the health of the Stacks blockchain.

#### Network info

The network information can be obtained using the [`GET /v2/info`](https://docs.hiro.so/api#operation/get_core_api_info) endpoint:

{% code title="curl (testnet)" %}

```bash
# for mainnet, replace `testnet` with `mainnet`
curl 'https://api.testnet.hiro.so/v2/info'
```

{% endcode %}

Sample response:

```js
{
    "peer_version": 385875968,
    "burn_consensus": "826401d65cf3671210a3fb135d827d549c0b4d37",
    "burn_block_height": 1972,
    "stable_burn_consensus": "e27ea23f199076bc41a729d76a813e125b725f64",
    "stable_burn_block_height": 1971,
    "server_version": "blockstack-core 0.0.1 => 23.0.0.0 (master:bdd042242+, release build, linux [x86_64]",
    "network_id": 2147483648,
    "parent_network_id": 3669344250,
    "stacks_tip_height": 933,
    "stacks_tip": "1f601823fbcc5b6b2215b2ff59d2818fba61ee4a3cea426d8bc3dbb268005d8f",
    "stacks_tip_burn_block": "54c56a9685545c45accf42b5dcb2787c97eda8185a1c794daf9b5a59d4807abc",
    "unanchored_tip": "71948ee211dac3b241eb65d881637f649d0d49ac08ee4a41c29217d3026d7aae",
    "exit_at_block_height": 28160
}
```


# Mainnet and Testnets

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-b9085514942994a4f51310436d9280ca02b58aca%2Fimage.png?alt=media" alt=""><figcaption><p>image source: <a href="https://www.hiro.so/blog/what-are-blockchain-layers">Hiro blog</a></p></figcaption></figure>

Stacks has both a mainnet and a testnet for different purposes. Mainnet and testnet are two completely different networks and tokens cannot be transferred between one or the other.

### Mainnet

Stacks mainnet is directly connected to the Bitcoin mainnet and its the network where tokens have actual monetary worth. This is the production network and should be treated as such.

You can view mainnet activity using the official [Stacks explorer](https://explorer.hiro.so/).

### Testnet

The Stacks testnet serves as a live public sandbox for developers, allowing them to build, test, and iterate on apps and smart contracts in an environment that mimics the mainnet. It provides a risk-free space to experiment with changes or new features before deploying them on the Stacks mainnet, ensuring that everything functions correctly without the risk of real financial loss.

You can view testnet activity using the official [Stacks explorer](https://explorer.hiro.so/?chain=testnet).

#### Testnet Faucets

Testnet faucets provide you with mock Stacks (STX) tokens to test with. These testnet STX have no value and are not the same as STX on mainnet. There are a couple of different options for getting testnet STX.

{% tabs %}
{% tab title="Hiro" %}
You can get testnet STX from the [Hiro Platform](https://platform.hiro.so/faucet), which is the recommended way.

To get STX tokens from within the Hiro Platform, navigate to the "Faucet" tab at the top. You can then choose either testnet STX or sBTC, and then paste in your desired testnet STX address to receive.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2FjjVK8GVvGbnDTQxzgJ5t%2Fimage.png?alt=media&#x26;token=e82a313d-4381-45cc-9a36-ba02a598d9f4" alt=""><figcaption></figcaption></figure></div>
{% endtab %}

{% tab title="Sandbox" %}
Using the faucet provided by the [Explorer Sandbox](https://explorer.hiro.so/sandbox/deploy?chain=testnet) is another option.

You'll first need to connect your wallet to the Explorer Sandbox and hit 'Request STX'. Be sure your wallet is on the testnet network before requesting.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2FQCTtyAN2r4btyxWOyJs3%2Fsandbox-faucet.png?alt=media&#x26;token=ac55a1c3-fbe8-4424-a513-3074c7befc5d" alt=""><figcaption></figcaption></figure></div>
{% endtab %}

{% tab title="LearnWeb3" %}
Alternatively, you can use the [LearnWeb3 faucet](https://learnweb3.io/faucets).

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-6b3929bea804b05efe83f4bb140709378b6024fb%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure></div>
{% endtab %}
{% endtabs %}


# Accounts

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-2d782448481ac5b6f078b0307da62a30af1d8d6f%2FFrame%20316126255.jpg?alt=media" alt=""><figcaption></figcaption></figure>

### Introduction

Stacks uses an accounts-based model, more similar to Ethereum, rather than a [UTXO](https://learnmeabitcoin.com/technical/transaction/utxo/) model like Bitcoin. In a UTXO model, the network operates as a ledger, with each UTXO being analagous to a cash bill.

With an accounts-based model, each account is associated with a balance and that balance can be added to or subtracted from.

Stacks accounts are entities that own assets, like Stacks (STX) tokens. An account has an address, private key, nonce, and one or more asset balances.

{% hint style="info" %}
The cryptographic signature algorithm used in Stacks is [**secp256k1**](https://en.bitcoinwiki.org/wiki/Secp256k1).

Additionally, [Ed25519](https://ed25519.cr.yp.to/) is also used just for the VRF (Verifiable Random Function).
{% endhint %}

Assets cannot leave an account without an action from the account owner. All changes to assets (and the balances of the account) require a corresponding transaction.

{% hint style="info" %}
The transaction type doesn't need to be a token transfer - contract deploy and contract call transactions can change the balances of an account
{% endhint %}

### Creation

An account is generated from a 24-word mnemonic phrase. This is often referred to as the **seed phrase**. The seed phrase provides access to Stacks accounts.

{% hint style="danger" %}
If the seed phrase is lost, access to the associated account cannot be restored. No person or organization can recover a lost seed phrase.
{% endhint %}

The easiest way to generate a new Stacks account is to use the [Stacks CLI](https://github.com/stx-labs/stacks.js/tree/master/packages/cli):

{% code title="Generate a new account (CLI)" %}

```bash
# install CLI globally
npm install --global @stacks/cli

# generate a new account and store details in a new file

# '-t' option makes this a testnet account
stx make_keychain -t > cli_keychain.json
```

{% endcode %}

`make_keychain` creates the following file:

```js
{
  "mnemonic": "aaa bbb ccc ddd ...",
  "keyInfo": {
    "privateKey": "5a3f1f15245bb3fb...",
    "address": "STJRM2AMVF90ER6G3RW1QTF85E3HZH37006D5ER1",
    "btcAddress": "biwSd6KTEvJcyX2R8oyfgj5REuLzczMYC1",
    "wif": "L4HXn7PLmzoNW...",
    "index": 0
  }
}
```

{% hint style="info" %}
Check out the [Stacks CLI reference](https://docs.hiro.so/references/stacks-cli) for more details
{% endhint %}

| Field                | Description                                                                                                                                                        |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `mnemonic`           | A 24-word seed phrase used to access the account, generated using [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) with 256 bits of entropy |
| `keyInfo.privateKey` | Private key for the account. Required for token transfers and often referred to as `senderKey`                                                                     |
| `keyInfo.address`    | Stacks address for the account                                                                                                                                     |
| `keyInfo.btcAddress` | Corresponding BTC address for the account.                                                                                                                         |
| `keyInfo.wif`        | Private key of the btcAddress in compressed format.                                                                                                                |
| `keyInfo.index`      | Nonce for the account, starting at 0                                                                                                                               |

Note that a new account automatically exists for each new private key. There is no need to manually instantiate an account on the Stacks blockchain.

{% hint style="info" %}
Addresses are created by generating the [RIPEMD-160 hash](https://en.wikipedia.org/wiki/RIPEMD#RIPEMD-160_hashes) of the [SHA256](https://en.bitcoinwiki.org/wiki/SHA-256) of the public key. BTC addresses are encoded with [Base58Check](https://bitcoin.it/wiki/Base58Check_encoding). For Stacks addresses, [c32check](https://github.com/stacks-network/c32check) is used. Deriving an address from a public key can be done without internet access, for instance using the c32check `c32addressDecode` method.
{% endhint %}

Alternatively to the CLI creation, the [Stacks Transactions JS](https://github.com/stx-labs/stacks.js/tree/master/packages/transactions) library can be used:

{% code title="Generate a private key & derive address (transactions library)" %}

```js
import {
  makeRandomPrivKey,
  privateKeyToString,
  getAddressFromPrivateKey,
  TransactionVersion,
  getPublicKey,
} from "@stacks/transactions";

const privateKey = makeRandomPrivKey();

// Get public key from private
const publicKey = getPublicKey(privateKey);

const stacksAddress = getAddressFromPrivateKey(
  privateKeyToString(privateKey),
  TransactionVersion.Testnet // remove for Mainnet addresses
);
```

{% endcode %}

Finally, you can generate new account using a Stacks-enabled wallet like [Leather](https://leather.io/), [Xverse](https://www.xverse.app/), or [Asigna](https://asigna.io/).

### Handling different formats

It's common for new Stacks developers to get tripped up on the different ways when specifying Stacks' principal (aka addresses) in their development.

Here's a breakdown of dealing with principals in 3 different use cases.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2F9habwlXLqQ25fu6TUVM5%2Fhandling-principal-formats.jpeg?alt=media&#x26;token=08fcc12c-ee57-48e9-9ab5-a18233773fe2" alt=""><figcaption></figcaption></figure></div>

### The Stacks and Bitcoin address connection

What makes Stacks beautifully connected to its L1 settlement layer, Bitcoin, is their many shared aspects. One being how both utilize a similar address generation scheme based on the P2PKH format, which allows for both a Bitcoin & Stacks address to share the same public key hash. If you base58check decode a legacy bitcoin address, you can reveal the public key hash, which can then be used to generate its respective c32check encoded Stacks address.

Programmatically, you could also use a method called `b58ToC32`, from the `c32check` library, which can abstract the conversion for you.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2FVqWJul0cMmHoNGXiwsg3%2Fbitcoin-stacks-address-connection.jpeg?alt=media&#x26;token=90fe1ed0-29dc-4a1f-a2d4-0a89d57acc23" alt=""><figcaption></figcaption></figure></div>

***

### Additional Resources

* \[[Hiro Blog](https://www.hiro.so/blog/understanding-the-differences-between-bitcoin-address-formats-when-developing-your-app)] Understanding the Differences Between Bitcoin Address Formats When Developing Your App
* \[[Hiro Blog](https://www.hiro.so/blog/how-every-stacks-address-has-a-corresponding-bitcoin-address)] How Every Stacks Address Has a Corresponding Bitcoin Address&#x20;


# Authentication

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-b5725bb6dcf6851197f3b5508e1addb40c1fa1be%2Fimage.png?alt=media" alt=""><figcaption><p>source: <a href="https://www.hiro.so/blog/how-to-authenticate-your-users">Hiro blog</a></p></figcaption></figure>

### Introduction

This guide explains how authentication is performed on the Stacks blockchain.

Authentication provides a way for users to identify themselves to an app while retaining complete control over their credentials and personal details.

Users who register for your app can subsequently authenticate to any other app with support for the [Bitcoin Name System](https://docs.stacks.co/learn/network-fundamentals/bitcoin-name-system) and vice versa.

### Web2 vs Web3 Authentication

If you come from the web2 world, you are likely used to authenticating with usernames and passwords, where the user's info is stored in a database. Upon entering the password, it is hashed and compared to the hash stored in the database and, if it matches, the user is logged in.

Web3 authentication works a bit differently. One of the core philosophies of web3 is data ownership, which means users are in control of their data, including their authentication.

Authentication in the Bitcoin and Stacks world makes use of cryptography to generate private keys, public keys and addresses.

We'll go over the basics here, but if you want to dig in, [Learn Me a Bitcoin](https://learnmeabitcoin.com/beginners/guide/keys-addresses/) is a great place to start.

To generate a Stacks account, we generate a private key from a 24 word mnemonic phrase, as discussed in the previous section. This private key is then used to generate a public key using a one-way hash function. Meaning you can derive a public key from a private key, but not vice versa.

A user's private key is their main source of security and is used to authenticate them. Do not lose your private key.

So, when I use a wallet app like [Leather](https://leather.io/) and I want to use it to authenticate with a dapp like StackingDAO, what I am doing is that I am giving my wallet my private key, proving that I own the corresponding address.

The wallet will then pass that information (my address and public key) to the app along with a signature.

A signature can be thought of as proof that I own the private key without actually revealing the private key. That mechanism is how I can use the same wallet and address to log in to any app that supports Stacks authentication.

Third Web has a great [conceptual primer](https://blog.thirdweb.com/web3-auth/) on web3 authentication.

For a more practical introduction, take a look at the [Quickstart tutorial ](https://app.gitbook.com/o/hoh4mQXTl8NvI3cETroY/s/Zz9BLmTU9oydDpL3qiUh/)and [Hiro's Stacks.js docs](https://docs.hiro.so/stacks/connect/guides/authenticate-users).

### How it works

The authentication flow with Stacks is similar to the typical client-server flow used by centralized sign in services (for example, OAuth). However, with Stacks the authentication flow happens entirely client-side.

{% hint style="info" %}
This explanation is here so you can understand how this process works, but the bulk of this functionality is handled by the wallet and the JS library you use. Take a look at the [Stacks.js docs](https://docs.hiro.so/stacks/stacks.js/concepts/accounts-and-addresses) for more info.
{% endhint %}

An app and authenticator, such as the [Leather wallet](https://leather.io/), communicate during the authentication flow by passing back and forth two tokens. The requesting app sends the authenticator an `authRequest` token. Once a user approves authentication, the authenticator responds to the app with an `authResponse` token.

These tokens are based on [a JSON Web Token (JWT) standard](https://tools.ietf.org/html/rfc7519) with additional support for the `secp256k1` curve used by Bitcoin and many other cryptocurrencies. They are passed via URL query strings.

When a user chooses to authenticate an app, it sends the `authRequest` token to the authenticator via a URL query string with an equally named parameter:

`https://wallet.hiro.so/...?authRequest=j902120cn829n1jnvoa...`

When the authenticator receives the request, it generates an `authResponse` token for the app using an ephemeral transit key. The ephemeral transit key is just used for the particular instance of the app, in this case, to sign the `authRequest`.

The app stores the ephemeral transit key during request generation. The public portion of the transit key is passed in the `authRequest` token. The authenticator uses the public portion of the key to encrypt an app private key which is returned via the `authResponse`.

The authenticator generates the app private key from the user's identity address private key and the app's domain. The app private key serves three functions:

{% stepper %}
{% step %}
**It is used to create credentials that give the app access to a storage bucket in the user's Gaia hub**

This allows the app to access the user's app-specific storage in their Gaia hub.
{% endstep %}

{% step %}
**It is used in the end-to-end encryption of files stored for the app in the user's Gaia storage**

This key is used to encrypt files so only the app (with the derived key) can decrypt them.
{% endstep %}

{% step %}
**It serves as a cryptographic secret that apps can use to perform other cryptographic functions**

Apps can use this deterministic secret for additional cryptographic operations tied to the user's identity and domain.
{% endstep %}
{% endstepper %}

Finally, the app private key is deterministic, meaning that the same private key will always be generated for a given Stacks address and domain.

### Key pairs

Authentication with Stacks makes extensive use of public key cryptography generally and ECDSA with the `secp256k1` curve in particular.

The following sections describe the three public-private key pairs used, including how they're generated, where they're used and to whom private keys are disclosed.

#### Transit private key

The transit private key is an ephemeral key that is used to encrypt secrets that need to be passed from the authenticator to the app during the authentication process. It is randomly generated by the app at the beginning of the authentication response.

The public key that corresponds to the transit private key is stored in a single element array in the `public_keys` key of the authentication request token. The authenticator encrypts secret data such as the app private key using this public key and sends it back to the app when the user signs in to the app. The transit private key signs the app authentication request.

#### Identity address private key

The identity address private key is derived from the user's keychain phrase and is the private key of the Stacks username that the user chooses to use to sign in to the app. It is a secret owned by the user and never leaves the user's instance of the authenticator.

This private key signs the authentication response token for an app to indicate that the user approves sign in to that app.

#### App private key

The app private key is an app-specific private key that is generated from the user's identity address private key using the `domain_name` as input.

The app private key is securely shared with the app on each authentication, encrypted by the authenticator with the transit public key. Because the transit key is only stored on the client side, this prevents a man-in-the-middle attack where a server or internet provider could potentially snoop on the app private key.


# Bitcoin Name System

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-402906fc4f7e845fcfdf66d4752cf3674090b37e%2Fimage.png?alt=media" alt=""><figcaption><p>source: <a href="https://www.hiro.so/blog/getting-started-on-chain-usernames-stacks">Hiro blog</a></p></figcaption></figure>

Bitcoin Name System (BNS) is a network system that binds Stacks usernames to off-chain state without relying on any central points of control.

The Stacks V1 blockchain implemented BNS through first-order name operations. In Stacks V2, BNS is instead implemented through a smart-contract loaded during the genesis block.

Names in BNS have three properties:

* **Names are globally unique.** The protocol does not allow name collisions, and all well-behaved nodes resolve a given name to the same state.
* **Names are human-meaningful.** Each name is chosen by its creator.
* **Names are strongly owned.** Only the name's owner can change the state it resolves to. Specifically, a name is owned by one or more ECDSA private keys.

The Stacks blockchain ensures that each node's BNS view is synchronized to all of the other nodes in the world, so queries on one node will be the same on other nodes. Stacks blockchain nodes allow a name's owner to bind up to 40Kb of off-chain state to their name, which will be replicated to all other Stacks blockchain nodes via a P2P network.

The biggest consequence for developers is that in BNS, reading name state is fast and cheap but writing name state is slow and expensive. This is because registering and modifying names requires one or more transactions to be sent to the underlying blockchain, and BNS nodes will not process them until they are sufficiently confirmed. Users and developers need to acquire and spend the requisite cryptocurrency (STX) to send BNS transactions.

### Motivation behind name systems

We rely on name systems in everyday life, and they play a critical role in many different applications. For example, when you look up a friend on social media, you are using the platform's name system to resolve their name to their profile. When you look up a website, you are using the Domain Name Service to resolve the hostname to its host's IP address. When you check out a Git branch, you are using your Git client to resolve the branch name to a commit hash. When you look up someone's PGP key on a keyserver, you are resolving their key ID to their public key.

What kinds of things do we want to be true about names? In BNS, names are globally unique, names are human-meaningful, and names are strongly owned. However, if you look at these examples, you'll see that each of them only guarantees two of these properties. This limits how useful they can be.

* In DNS and social media, names are globally unique and human-readable, but not strongly owned. The system operator has the final say as to what each name resolves to.
  * Problem: Clients must trust the system to make the right choice in what a given name resolves to. This includes trusting that no one but the system administrators can make these changes.
* In Git, branch names are human-meaningful and strongly owned, but not globally unique. Two different Git nodes may resolve the same branch name to different unrelated repository states.
  * Problem: Since names can refer to conflicting state, developers have to figure out some other mechanism to resolve ambiguities.
* In PGP, names are key IDs. They are globally unique and cryptographically owned, but not human-readable. PGP key IDs are derived from the keys they reference.
  * Problem: These names are difficult for most users to remember since they do not carry semantic information relating to their use in the system.

BNS names have all three properties, and none of these problems. This makes it a powerful tool for building all kinds of network applications. With BNS, we can do the following and more:

* Build domain name services where hostnames can't be hijacked.
* Build social media platforms where user names can't be stolen by phishers.
* Build version control systems where repository branches do not conflict.
* Build public-key infrastructure where it's easy for users to discover and remember each other's keys.

### Organization of BNS

BNS names are organized into a global name hierarchy. There are three different layers in this hierarchy related to naming:

* **Namespaces.** These are the top-level names in the hierarchy. An analogy to BNS namespaces are DNS top-level domains. Existing BNS namespaces include `.id`, `.podcast`, and `.helloworld`. All other names belong to exactly one namespace. Anyone can create a namespace, but in order for the namespace to be persisted, it must be *launched* so that anyone can register names in it. Namespaces are not owned by their creators.
* **BNS names.** These are names whose records are stored directly on the blockchain. The ownership and state of these names are controlled by sending blockchain transactions. Example names include `verified.podcast` and `muneeb.id`. Anyone can create a BNS name, as long as the namespace that contains it exists already.
* **BNS subdomains.** These are names whose records are stored off-chain, but are collectively anchored to the blockchain. The ownership and state for these names lives within the P2P network data. While BNS subdomains are owned by separate private keys, a BNS name owner must broadcast their subdomain state. Example subdomains include `jude.personal.id` and `podsaveamerica.verified.podcast`. Unlike BNS namespaces and names, the state of BNS subdomains is *not* part of the blockchain consensus rules.

A feature comparison matrix summarizing the similarities and differences between these name objects:

| Feature                                | **Namespaces** | **BNS names** | **BNS Subdomains** |
| -------------------------------------- | -------------- | ------------- | ------------------ |
| Globally unique                        | X              | X             | X                  |
| Human-meaningful                       | X              | X             | X                  |
| Owned by a private key                 |                | X             | X                  |
| Anyone can create                      | X              | X             | \[1]               |
| Owner can update                       |                | X             | \[1]               |
| State hosted on-chain                  | X              | X             |                    |
| State hosted off-chain                 |                | X             | X                  |
| Behavior controlled by consensus rules | X              | X             |                    |
| May have an expiration date            |                | X             |                    |

\[1] Requires the cooperation of a BNS name owner to broadcast its transactions

### Namespaces

Namespaces are the top-level name objects in BNS. They control a few properties about the names within them:

* How expensive they are to register
* How long they last before they have to be renewed
* Who (if anyone) receives the name registration fees
* Who is allowed to seed the namespace with its initial names

At the time of this writing, by far the largest BNS namespace is the `.id` namespace. Names in the `.id` namespace are meant for resolving user identities. Short names in `.id` are more expensive than long names, and have to be renewed by their owners every two years. Name registration fees are not paid to anyone in particular—they are instead sent to a "black hole" where they are rendered non-spendable (the intention is to discourage ID squatters).

Unlike DNS, anyone can create a namespace and set its properties. Namespaces are created on a first-come first-serve basis, and once created, they last forever.

However, creating a namespace is not free. The namespace creator must burn cryptocurrency to do so. The shorter the namespace, the more cryptocurrency must be burned (that is, short namespaces are more valuable than long namespaces). For example, it cost Blockstack PBC 40 BTC to create the `.id` namespace in 2015 (in transaction `5f00b8e609821edd6f3369ee4ee86e03ea34b890e242236cdb66ef6c9c6a1b281`).

Namespaces can be between 1 and 19 characters long, and are composed of the characters `a-z`, `0-9`, `-`, and `_`.

### Subdomains

BNS names are strongly owned because the owner of its private key can generate valid transactions that update its zone file hash and owner. However, this comes at the cost of requiring a name owner to pay for the underlying transaction in the blockchain. Moreover, this approach limits the rate of BNS name registrations and operations to the underlying blockchain's transaction bandwidth.

BNS overcomes this with subdomains. A **BNS subdomain** is a type of BNS name whose state and owner are stored outside of the blockchain, but whose existence and operation history are anchored to the blockchain. Like their on-chain counterparts, subdomains are globally unique, strongly owned, and human-readable. BNS gives them their own name state and public keys. Unlike on-chain names, subdomains can be created and managed cheaply, because they are broadcast to the BNS network in batches. A single blockchain transaction can send up to 120 subdomain operations.

This is achieved by storing subdomain records in the BNS name zone files. An on-chain name owner broadcasts subdomain operations by encoding them as `TXT` records within a DNS zone file. To broadcast the zone file, the name owner sets the new zone file hash with a `NAME_UPDATE` transaction and replicates the zone file. This, in turn, replicates all subdomain operations it contains, and anchors the set of subdomain operations to an on-chain transaction. The BNS node's consensus rules ensure that only valid subdomain operations from valid `NAME_UPDATE` transactions will ever be stored.

For example, the name `verified.podcast` once wrote the zone file hash `247121450ca0e9af45e85a82e61cd525cd7ba023`, which is the hash of the following zone file:

```bash
$TTL 3600
1yeardaily TXT "owner=1MwPD6dH4fE3gQ9mCov81L1DEQWT7E85qH" "seqn=0" "parts=1" "zf0=JE9SSUdJTiAxeWVhcmRhaWx5CiRUVEwgMzYwMApfaHR0cC5fdGNwIFVSSSAxMCAxICJodHRwczovL3BoLmRvdHBvZGNhc3QuY28vMXllYXJkYWlseS9oZWFkLmpzb24iCg=="
2dopequeens TXT "owner=1MwPD6dH4fE3gQ9mCov81L1DEQWT7E85qH" "seqn=0" "parts=1" "zf0=JE9SSUdJTiAyZG9wZXF1ZWVucwokVFRMIDM2MDAKX2h0dHAuX3RjcCBVUkkgMTAgMSAiaHR0cHM6Ly9waC5kb3Rwb2RjYXN0LmNvLzJkb3BlcXVlZW5zL2hlYWQuanNvbiIK"
10happier TXT "owner=1MwPD6dH4fE3gQ9mCov81L1DEQWT7E85qH" "seqn=0" "parts=1" "zf0=JE9SSUdJTiAxMGhhcHBpZXIKJFRUTCAzNjAwCl9odHRwLl90Y3AgVVJJIDEwIDEgImh0dHBzOi8vcGguZG90cG9kY2FzdC5jby8xMGhhcHBpZXIvaGVhZC5qc29uIgo="
31thoughts TXT "owner=1MwPD6dH4fE3gQ9mCov81L1DEQWT7E85qH" "seqn=0" "parts=1" "zf0=JE9SSUdJTiAzMXRob3VnaHRzCiRUVEwgMzYwMApfaHR0cC5fdGNwIFVSSSAxMCAxICJodHRwczovL3BoLmRvdHBvZGNhc3QuY28vMzF0aG91Z2h0cy9oZWFkLmpzb24iCg=="
359 TXT "owner=1MwPD6dH4fE3gQ9mCov81L1DEQWT7E85qH" "seqn=0" "parts=1" "zf0=JE9SSUdJTiAzNTkKJFRUTCAzNjAwCl9odHRwLl90Y3AgVVJJIDEwIDEgImh0dHBzOi8vcGguZG90cG9kY2FzdC5jby8zNTkvaGVhZC5qc29uIgo="
30for30 TXT "owner=1MwPD6dH4fE3gQ9mCov81L1DEQWT7E85qH" "seqn=0" "parts=1" "zf0=JE9SSUdJTiAzMGZvcjMwCiRUVEwgMzYwMApfaHR0cC5fdGNwIFVSSSAxMCAxICJodHRwczovL3BoLmRvdHBvZGNhc3QuY28vMzBmb3IzMC9oZWFkLmpzb24iCg=="
onea TXT "owner=1MwPD6dH4fE3gQ9mCov81L1DEQWT7E85qH" "seqn=0" "parts=1" "zf0=JE9SSUdJTiBvbmVhCiRUVEwgMzYwMApfaHR0cC5fdGNwIFVSSSAxMCAxICJodHRwczovL3BoLmRvdHBvZGNhc3QuY28vb25lYS9oZWFkLmpzb24iCg=="
10minuteteacher TXT "owner=1MwPD6dH4fE3gQ9mCov81L1DEQWT7E85qH" "seqn=0" "parts=1" "zf0=JE9SSUdJTiAxMG1pbnV0ZXRlYWNoZXIKJFRUTCAzNjAwCl9odHRwLl90Y3AgVVJJIDEwIDEgImh0dHBzOi8vcGguZG90cG9kY2FzdC5jby8xMG1pbnV0ZXRlYWNoZXIvaGVhZC5qc29uIgo="
36questionsthepodcastmusical TXT "owner=1MwPD6dH4fE3gQ9mCov81L1DEQWT7E85qH" "seqn=0" "parts=1" "zf0=JE9SSUdJTiAzNnF1ZXN0aW9uc3RoZXBvZGNhc3RtdXNpY2FsCiRUVEwgMzYwMApfaHR0cC5fdGNwIFVSSSAxMCAxICJodHRwczovL3BoLmRvdHBvZGNhc3QuY28vMzZxdWVzdGlvbnN0aGVwb2RjYXN0bXVzaWNhbC9oZWFkLmpzb24iCg=="
_http._tcp URI 10 1 "https://dotpodcast.co/"
```

Each `TXT` record in this zone file encodes a subdomain-creation. For example, `1yeardaily.verified.podcast` resolves to:

```json
{
  "address": "1MwPD6dH4fE3gQ9mCov81L1DEQWT7E85qH",
  "blockchain": "bitcoin",
  "last_txid": "d87a22ebab3455b7399bfef8a41791935f94bc97aee55967edd5a87f22cce339",
  "status": "registered_subdomain",
  "zonefile_hash": "e7acc97fd42c48ed94fd4d41f674eddbee5557e3",
  "zonefile_txt": "$ORIGIN 1yeardaily\n$TTL 3600\n_http._tcp URI 10 1 \"https://ph.dotpodcast.co/1yeardaily/head.json\"\n"
}
```

This information was extracted from the `1yeardaily` `TXT` resource record in the zone file for `verified.podcast`.

Subdomain lifecycle

{% stepper %}
{% step %}
**Creation**

A subdomain-creation operation is created by the subdomain owner and encoded into a `TXT` record in an on-chain name owner's zone file. The on-chain name owner broadcasts the zone file by issuing a `NAME_UPDATE` transaction, which anchors the subdomain-creation on-chain.
{% endstep %}

{% step %}
**Update**

Subdomain updates are done off-chain by creating signed operations from the subdomain owner's private key. Any on-chain name owner can include these signed operations in their zone file and broadcast via `NAME_UPDATE`. Operations are ordered by a sequence number and require a valid signature that links to the previous operation's public key.
{% endstep %}

{% step %}
**Transfer**

To change the address (public key hash) owning a subdomain, the subdomain owner signs a subdomain-transfer operation and asks an on-chain name owner (typically the one who created the subdomain) to broadcast it via `NAME_UPDATE`. The broadcasting on-chain name owner's zone file must be present in the Atlas network to prove absence of conflicting operations.
{% endstep %}
{% endstepper %}

Sequence and validation rules

* Subdomain operations are ordered by sequence number, starting at 0. Each new operation must include:
  * The next sequence number
  * The public key that hashes to the previous subdomain transaction's address
  * A signature from the corresponding private key over the entire subdomain operation
* If two correctly signed but conflicting operations have the same sequence number, the one earlier in blockchain history is accepted. Invalid operations are ignored.

Subdomain creation and management rules

* A subdomain-creation transaction can only be processed by the owner of the on-chain name that shares its suffix (e.g., only the owner of `res_publica.id` can broadcast creations for `*.res_publica.id`).
* A subdomain-transfer transaction can only be broadcast by the owner of the on-chain name that created it.
* To send a subdomain-creation or subdomain-transfer, all of an on-chain name owner's zone files must be present in the Atlas network. This allows proving the absence of conflicting operations.
* A subdomain update can be broadcast by any on-chain name owner, but the subdomain owner needs to find a cooperating on-chain name owner to include and broadcast it.

To create a subdomain, the subdomain owner generates the creation operation and gives it to the on-chain name owner. Once created, the subdomain owner can use any on-chain name owner to broadcast updates by providing signed operations packaged into zone files.

Subdomain registrars

Because subdomain names are cheap, developers may run subdomain registrars for their applications. For example, the name `personal.id` is used to register usernames without requiring users to spend Bitcoin.

A reference implementation is available: <https://github.com/stacks-network/subdomain-registrar>. Users still own their subdomain names; the registrar helps developers broadcast subdomain operations.

### BNS and DID Standards

BNS names are compliant with the emerging Decentralized Identity Foundation (DIF) protocol specification for decentralized identifiers (DIDs): <http://identity.foundation>

Each name in BNS has an associated DID. The DID format for BNS is:

```bash
did:stack:v0:{address}-{index}
```

Where:

* `{address}` is an on-chain public key hash (for example a Bitcoin address).
* `{index}` refers to the `nth` name this address created.

Examples:

* `personal.id` → `did:stack:v0:1dARRtzHPAFRNE7Yup2Md9w18XEQAtLiV-0` (first name created by that address)
* `jude.id` → `did:stack:v0:16EMaNw3pkn3v6f2BgnSSs53zAKH4Q8YJg-1` (the address had created one earlier name before this one)

Purpose: a DID provides an eternal identifier for a public key. The public key may change, but the DID will not.

For a DID to be resolvable, all of the following must be true for a name:

* The name must exist
* The name's zone file hash must be the hash of a well-formed DNS zone file
* The DNS zone file must be present in the Stacks node's data
* The DNS zone file must contain a `URI` resource record that points to a signed JSON Web Token
* The public key that signed the JSON Web Token (and is included with it) must hash to the address that owns the name

Not all names will have DIDs that resolve to public keys. Names created by standard tooling will have DIDs that do.

A RESTful API is under development.

### DID Encoding for Subdomains

Every name and subdomain in BNS has a DID. Encoding differs so software can determine which code-path to take.

* For on-chain BNS names, the `{address}` is the same as the Bitcoin address that owns the name. Currently, both version byte 0 and version byte 5 addresses are supported (addresses starting with `1` or `3`, meaning `p2pkh` and `p2sh` addresses).
* For off-chain BNS subdomains, the `{address}` has version byte 63 for subdomains owned by a single private key, and version byte 50 for subdomains owned by an m-of-n set of private keys. That is, subdomain DID addresses start with `S` or `M`, respectively.

The `{index}` field for a subdomain's DID is distinct from the `{index}` field for a BNS name's DID, even if the same address created both names and subdomains. Example:

* The name `abcdefgh123456.id` → `did:stack:v0:16EMaNw3pkn3v6f2BgnSSs53zAKH4Q8YJg-0` (first name created by that address)
* The subdomain `jude.statism.id` created by the same address → `did:stack:v0:SSXMcDiCZ7yFSQSUj7mWzmDcdwYhq97p2i-0`

Note: The address `SSXMcDiCZ7yFSQSUj7mWzmDcdwYhq97p2i` encodes the same public key hash as `16EMaNw3pkn3v6f2BgnSSs53zAKH4Q8YJg`—the difference is base58check version byte (63 vs 0).


# SIPs

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-572743764da9de034230b5391cab0ddf4ef89337%2Fimage.png?alt=media" alt=""><figcaption><p>source: <a href="https://www.hiro.so/blog/announcing-hiros-token-metadata-api">Hiro blog</a></p></figcaption></figure>

### Stacks Improvement Proposals (SIPs)

Stacks improvement proposals (SIPs) are aimed at describing the implementation of the Stacks blockchain, as well as proposing improvements.

The SIP process [(SIP-000)](https://github.com/stacksgov/sips/blob/main/sips/sip-000/sip-000-stacks-improvement-proposal-process.md) describes how to make a SIP and get it ratified.

They should contain concise technical specifications of features or standards and the rationale behind it. SIPs are intended to be the primary medium for proposing new features, for collecting community input on a system-wide issue, and for documenting design decisions.

The SIPs are located in the [stacksgov/sips](https://github.com/stacksgov/sips) repository as part of the [Stacks Community Governance organization](https://github.com/stacksgov).

Anyone in the Stacks community can submit a SIP.

{% hint style="info" %}
Stacks Improvement Proposals Community Calls Add the [weekly community SIP call](https://www.addevent.com/event/wS15955379) to your calendar.

SIP Meeting calls are recorded and available [here](https://www.youtube.com/playlist?list=PLg717Ri_rTnx5kuaWqp3cUAtwQk_yzslT)

More details of the meetings are available [here](https://github.com/stacksgov/sips/issues/79)
{% endhint %}

### Ratified SIPSs

* [x] [SIP 000: Improvement Proposal Process](https://github.com/stacksgov/sips/blob/main/sips/sip-000/sip-000-stacks-improvement-proposal-process.md)
* [x] [SIP 001: Burn Election](https://github.com/stacksgov/sips/blob/main/sips/sip-001/sip-001-burn-election.md)
* [x] [SIP 002: Clarity, a language for predictable smart contracts](https://github.com/stacksgov/sips/blob/main/sips/sip-002/sip-002-smart-contract-language.md)
* [x] [SIP 003: Peer Network](https://github.com/stacksgov/sips/blob/main/sips/sip-003/sip-003-peer-network.md)
* [x] [SIP 004: Cryptographic Commitment to Materialized Views](https://github.com/stacksgov/sips/blob/main/sips/sip-004/sip-004-materialized-view.md)
* [x] [SIP 005: Blocks, Transactions, and Accounts](https://github.com/stacksgov/sips/blob/main/sips/sip-005/sip-005-blocks-and-transactions.md)
* [x] [SIP 006: Clarity Execution Cost Assessment](https://github.com/stacksgov/sips/blob/main/sips/sip-006/sip-006-runtime-cost-assessment.md)
* [x] [SIP 007: Stacking Consensus](https://github.com/stacksgov/sips/blob/main/sips/sip-007/sip-007-stacking-consensus.md)
* [x] [SIP 008: Clarity Parsing and Analysis Cost Assessment](https://github.com/stacksgov/sips/blob/main/sips/sip-008/sip-008-analysis-cost-assessment.md)
* [x] [SIP 009: Standard Trait Definition for Non-Fungible Tokens](https://github.com/stacksgov/sips/blob/main/sips/sip-009/sip-009-nft-standard.md)
* [x] [SIP 010: Standard Trait Definition for Fungible Tokens](https://github.com/stacksgov/sips/blob/main/sips/sip-010/sip-010-fungible-token-standard.md)
* [x] [SIP 012: Burn Height Selection for a Network Upgrade to Introduce New Cost-Limits](https://github.com/stacksgov/sips/blob/main/sips/sip-012/sip-012-cost-limits-network-upgrade.md)
* [x] [SIP 013: Standard Trait Definition for Semi-Fungible Tokens](https://github.com/stacksgov/sips/blob/main/sips/sip-013/sip-013-semi-fungible-token-standard.md)
* [x] [SIP-015: Stacks Upgrade of Proof-of-Transfer and Clarity](https://github.com/stacksgov/sips/blob/main/sips/sip-015/sip-015-network-upgrade.md)
* [x] [SIP-016: Metadata for Tokens](https://github.com/stacksgov/sips/blob/main/sips/sip-016/sip-016-token-metadata.md)
* [x] [SIP-018: Signed Structured Data](https://github.com/stacksgov/sips/blob/main/sips/sip-018/sip-018-signed-structured-data.md)
* [x] [SIP-019: Notifications for Token Metadata Updates](https://github.com/stacksgov/sips/blob/main/sips/sip-019/sip-019-token-metadata-update-notifications.md)
* [x] [SIP-020: Bitwise Operations in Clarity](https://github.com/stacksgov/sips/blob/main/sips/sip-020/sip-020-bitwise-ops.md)
* [x] [SIP-022: Emergency Fix to PoX Stacking Increases](https://github.com/stacksgov/sips/blob/main/sips/sip-022/sip-022-emergency-pox-fix.md)
* [x] [SIP-023: Emergency Fix to Trait Invocation Behavior](https://github.com/stacksgov/sips/blob/main/sips/sip-023/sip-023-emergency-fix-traits.md)
* [x] [SIP-024: Emergency Fix to Data Validation and Serialization Behavior](https://github.com/stacksgov/sips/blob/main/sips/sip-024/sip-024-least-supertype-fix.md)

### How to Get Involved

There are several ways you can get involved with the SIP process:

* **Join the weekly SIP Meeting call** listed [here](https://community.stacks.org/events).
* **SIP Editor**. SIP editors help SIP authors make sure their SIPs are well-formed and follow the right process. They help get SIPs ready for deep review by advancing it them from Draft to Accepted status. If you want to become a SIP editor, open an issue with your name and email to ask to be added to the list of SIP editors.
* **Join a CAB** (Consideration Advisory Board). SIPs fall under the purview of one or more considerations. A full list is in [this github](https://github.com/stacksgov/sips/tree/main/considerations) directory. Currently they are: Diversity, Economics, Ethics, Governance and Technical. Members of SIP consideration advisory boards use their domain expertise to give Accepted SIPs a deep read, and give the authors any/all feedback to help make the SIP workable. If you want to join a board, reach out to the board's chairperson via the listed contact information.
* **Steering Committee**. The Steering Committee organizes the consideration advisory boards and votes to advance Recommended SIPs to Activation-in-Progress status, and then to either Ratified or Rejected status. Once they are in the process of being activated, they use a SIP's Activation section to determine whether or not the Stacks ecosystem has ratified or rejected the SIP. Joining this committee requires the consent of the Stacks Foundation board.


# Technical Specifications

### Consensus

* Proof of Transfer (PoX) as described in [SIP-007](https://github.com/stacksgov/sips/blob/main/sips/sip-007/sip-007-stacking-consensus.md)
* Network will transition to Proof of Burn (PoB) as described in [SIP-001](https://github.com/stacksgov/sips/blob/main/sips/sip-001/sip-001-burn-election.md) after 10 years. [Learn more about Proof-of-Burn in SIP-001](https://github.com/stacksgov/sips/blob/main/sips/sip-001/sip-001-burn-election.md).
* Threat model
  * 51% of malicious Bitcoin mining power can reorg the Stacks chain or perform a double-spend attack
  * Chain can halt if Stackers cannot meet 70% consensus on block validity
* Different actors and their roles
  * Stacks Miners package transactions into blocks and propose them to stackers
  * Stacks Holders may alter the calculation of block limits (subject to a miner veto) and may vote to disable Proof-of-Transfer rewards for a reward cycle.
  * Stackers validate and append blocks to the chain and validate sBTC deposit and withdrawal transactions

### Proof of Transfer Mining

* Coinbase reward schedule:
  * 1000 STX/block for first 4 years
  * 500 STX/block for following 4 years
  * 250 STX/block for subsequent 4 years
  * 125 STX/block in perpetuity after that
* Coinbase rewards accumulate for "missed sortitions": If a Bitcoin block has no sortition (at height N), then any Stacks block mined in a subsequent sortition that builds off of any Stacks chain tip that existed at the penultimate sortition (at height N-1) may claim its coinbase. This encourages miners to keep mining even if Bitcoin fees are high.
* Initial mining bonus: This is a special case of the above to incentivize early miners. Coinbase for all burnchain blocks between the first burn block height (to be chosen by independent miners as part of the Stacks 2.0 launch) and the first sortition winner accumulate and are distributed to miners over a fixed window (to be determined). For instance, say burn block height is 10,000 and first sortition is at block 10500 and distribution window is 100 blocks, then coinbase for the first 500 blocks (10,500 - 10,000) will be distributed evenly to miners who win sortition over the subsequent 100 blocks.
* Reward maturity window: 100 blocks, meaning leaders will earn the coinbase reward 100 blocks after the block they successfully mine.
* Block interval: Stacks blockchain produces fast blocks roughly every 10 seconds with a miner tenure change occurring every Bitcoin block
* BTC commitment: Miners must commit at least 11,000 satoshis (5,500 sats / [UTXO output](https://learnmeabitcoin.com/technical/utxo)); 2 outputs / block) to avoid "dust."
* For more details, see Block Production.

### Stacking

{% stepper %}
{% step %}
**Prepare phase**

An "anchor block" is chosen. The qualifying set of addresses ("reward set") is determined based on the snapshot of the chain at the anchor block. Length of prepare phase is 100 blocks. Stacking commitments need to be confirmed before this phase starts.
{% endstep %}

{% step %}
**Reward phase**

Miner BTC commitments are distributed amongst the reward set. Reward cycle length is 2000 BTC blocks (\~2 weeks).
{% endstep %}
{% endstepper %}

* Two reward addresses / block, for a total of 4000 addresses every reward cycle. The addresses are chosen using a VRF (verifiable random function), so each node can deterministically arrive at the same reward addresses for a given block.
* Stacking threshold: 0.025% of the participating amount of STX when participation is between 25% and 100% and when participation is below 25%, the threshold level is always 0.00625 of the liquid supply of STX.
* Delegation: An STX address can designate another address to participate in Stacking on its behalf. [Relevant section in SIP-007](https://github.com/stacksgov/sips/blob/main/sips/sip-007/sip-007-stacking-consensus.md#stacker-delegation).
* Pooling: STX holders that individually do not meet the Stacking threshold can pool together their holdings to participate in Stacking. To do this, STX holders must set the (optional) reward address to the "delegate address." For more details, see [this reference](https://docs.stacks.co/references/stacking-contract#delegate-stx).
* Legacy, SegWit, Native Segwit, and Taproot addresses are supported

### Accounts and Addresses

* Transactions in the Stacks blockchain originate from, are paid for by, and execute under the authority of accounts
* An account is fully specified by its address + nonce + assets
* Address contains 2 or 3 fields: 1 byte version, 20 byte public key hash (RIPEMD160(SHA256(input))), optional name (variable length, max 128 bytes)
* Two types of accounts: standard accounts are owned by one or more private keys; contract accounts are materialized when a smart-contract is instantiated (specified by the optional name field above)
* Nonce counts number of times an account has authorized a transaction. Starts at 0, valid authorization must include the *next* nonce value.
* Assets are a map of all asset types -- STX, any on-chain assets specified by a Clarity contract (for example NFTs) -- to quantities owned by that account.
* Accounts need not be explicit "created" or registered; all accounts implicitly exist and are instantiated on first-use.

### Transactions

* Transaction types: coinbase, token-transfer, contract-deploy, contract-call, tenure-change.
* Only standard accounts (not contracts) can pay transaction fees.
* Transaction execution is governed by:

{% stepper %}
{% step %}
**Originating account**

The account that creates, authorizes and sends the transaction.
{% endstep %}

{% step %}
**Paying account**

The account that is billed by the leader for the cost of validating and executing the transaction.
{% endstep %}

{% step %}
**Sending account**

The account that identifies who is currently executing the transaction: this can change as a transaction executes via the `as-contract` Clarity function.
{% endstep %}
{% endstepper %}

* Transactions can be batched or streamed into blocks. The behavior can be controlled by the anchor mode of a transaction. With streaming (microblocks), a faster confirmation time is possible.
* Two types of authorizations: standard authorization is where originating account is the same as paying account. *Sponsored* authorization is where originating account and paying account are distinct. For instance, developers or service providers could pay for users to call their smart-contracts.
* For sponsored authorization, first a user signs with the originating account and then a sponsor signs with the paying account.
* Mempool limit for concurrent pending transactions is 25 per account
* Pending mempool transactions will be garbage-collected [256 blocks after receipt](https://github.com/stacks-network/stacks-blockchain/blob/master/src/core/mempool.rs#L62). With 10 minutes target block time, this would equal \~42 hours
* [Learn more about transaction encoding in SIP-005](https://github.com/stacksgov/sips/blob/main/sips/sip-005/sip-005-blocks-and-transactions.md#transaction-encoding)
* [Transaction signing and verification are described in SIP-005](https://github.com/stacksgov/sips/blob/main/sips/sip-005/sip-005-blocks-and-transactions.md#transaction-signing-and-verifying)
* All transactions impacting account balance are atomic, a transfer operation can not increment one account’s balance without decrementing another’s. However, transactions that perform multiple account actions (for example, transferring from multiple accounts) may partially complete.
* Transactions can include a memo string (max 34 bytes)


# Audits

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-5e2e14ea3986509bfcb836fe9be357ca3b56106b%2Fimage.png?alt=media" alt=""><figcaption><p>source: <a href="https://www.hiro.so/blog/smart-contracts-cant-afford-to-fail-and-with-clarity-language-they-wont">Hiro blog</a></p></figcaption></figure>

#### Audits are just part of the story

For any project, layers of security are crucial. Audits represent one layer, while core developers and contributors collaborate to provide many more. Notable security programs, designs, and partners beyond audits include:

* Embedded security researchers [via Asymmetric Research](https://stacks.org/asymmetric-joins-stacks-ecosystem)
* Attackathon programs in partnership with Immunefi
* sBTC’s decentralized [network of validators/signers](https://www.stacks.co/sbtc) (removing the need to entrust a single entity and mitigating counterparty risk)
* Stacks’ underlying design that offers 100% Bitcoin finality, securing sBTC at the consensus level of a $2.5 billion network.
* Support at the app layer via [Hypernative](https://hackernoon.com/hypernative-bolsters-bitcoin-l2-security-as-stacks-ecosystem-gets-real-time-protection)
* Bitcoin L2 Labs' [whitehat security program](https://bitcoinl2-labs.github.io/2024/06/04/orange-hats.html)
* Stacks Foundation's partnership with Staking Defense League
* Stacks Founation's ongoing [Immunefi bug bounty program](https://immunefi.com/bug-bounty/stacks/information/)
* Dedicated Stacks Foundation Residents focused exclusively on fuzz and penetration testing (created [Rendezvous](https://stacks-network.github.io/rendezvous/))

{% hint style="warning" %}
*All 'high' or 'critical' issues listed in audits have either been mitigated or otherwise made obsolete, even if the report states otherwise.*
{% endhint %}

#### Stacks Core

Audits on Stacks Core

{% file src="<https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-150723b09151584d6e0acf37bae5cf3abbaac3f1%2FQuantstamp_Network%20State%20Machine.pdf?alt=media>" %}

{% file src="<https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-4a733d4e4ff9eb8f4d9e6f09f6f4c644796ff82c%2FCoinFabrik%20-%20Stacks%20Signer%20Audit.pdf?alt=media>" %}

{% file src="<https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-e9678769eadb5de09cc9a02c006f1fa9109657ad%2FCoinfabrik%20-%20Stacks%20PoX.pdf?alt=media>" %}

{% file src="<https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-6e1a11c2727047c85a12cc0df3730e665cd3f0e4%2FCoinFabrik%20-%20Stacks%20LibSigner.pdf?alt=media>" %}

{% file src="<https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-b0e846fba315845bd8e276bdf347ad90a119f9a0%2FCoinFabrik_StackerDB.pdf?alt=media>" %}

{% file src="<https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-dc059e72dc60cebf121d5e76e2eb926e11d0342d%2FCoinFabrik_Signer%20Binary.pdf?alt=media>" %}

#### Other audits

{% file src="<https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-cd00d448fac4fb740a472d0ae8264b46395e2afb%2FNCC_Group_Stacks_Wallet_Report_2020-11-17_v1.0.pdf?alt=media>" %}

{% file src="<https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-bed4f3bd8be8417603de69557d56f833c76466b0%2FNCC_Group_Stacks_Blockchain_Audit_Report_2020-11-23_v1.0.pdf?alt=media>" %}

{% file src="<https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-72b6b717bf79ab81a1223330095de6807ed63efe%2FBlockstack_Desktop_Wallet_Pentest_Report_11-12-2020.pdf?alt=media>" %}

Trail of Bits Report, Stacks Blockchain (No PDF, [Github Issues List provided](https://github.com/diwakergupta/stacks-blockchain-tob-audit/issues))


# Block Production

Block production is a key concept to understand how Stacks operates under the hood. This section walks through the three main actions that need to happen for the Stacks chain to operate.

{% stepper %}
{% step %}
**Mining**

Miners are responsible for building and proposing new blocks on the Stacks chain.
{% endstep %}

{% step %}
**Signing**

Signing is the process used to validate blocks and sign sBTC deposits and withdrawals. Stackers participate in signing once they meet stacking prerequisites.
{% endstep %}

{% step %}
**Stacking**

Stacking is an action performed by stackers that is a necessary prerequisite to signing. It enables participation in validation and earning rewards.
{% endstep %}
{% endstepper %}

There are two primary parties in Stacks block production: miners and stackers. Miners build and propose new blocks, while stackers validate those blocks and sign sBTC deposits and withdrawals. Stacking enables stackers to participate in signing.

{% hint style="info" %}
For an in-depth technical overview of block production after the Nakamoto Upgrade, see SIP-021:

<https://github.com/stacksgov/sips/blob/feat/sip-021-nakamoto/sips/sip-021/sip-021-nakamoto.md>
{% endhint %}

Here's a diagram outlining the block production process under Nakamoto rules. The following docs dig into each part in detail.

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-26036ee1fa63afce21d6b4a96771bbc4f8477c08%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>


# Mining

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-27ae573accf25c7fed3398c1cce7321d3788c9eb%2Fimage.png?alt=media" alt=""><figcaption><p>source: <a href="https://www.hiro.so/blog">Hiro blog</a></p></figcaption></figure>

{% hint style="info" %}
This is conceptual guide that covers how mining works. For practical steps on how to setup your own miner please refer to the guides to running a miner on [mainnet](https://app.gitbook.com/s/4cpTb2lbw0LAOuMHrvhA/run-a-miner/mine-mainnet-stacks-tokens) and [testnet](https://app.gitbook.com/s/4cpTb2lbw0LAOuMHrvhA/run-a-miner/mine-testnet-stacks-tokens).
{% endhint %}

### Miner Tenures

In previous version of Stacks (before the Nakamoto Upgrade), Stacks miners would mine new Stacks blocks at a one-to-one cadence with Bitcoin blocks.

After Nakamoto, this is no longer the case. Under Nakamoto rules, miners are instead selected for a tenure that corresponds to a Bitcoin block. During this tenure, miners build and propose several Stacks blocks (roughly every 10 seconds) and stackers will approve and append them (next section).

To be considered for a tenure, a miner must have a block commit included in a Bitcoin block. If a miner wishes to update their commitment after submission, they may use Bitcoin Replace-By-Fee.

### Coinbase rewards

Miners receive coinbase rewards for tenures they win.

The reward amounts are:

* 1000 STX per tenure are released in the first 4 years of mining
* 500 STX per tenure are released during the following 4 years
* 250 STX per tenure are released during the following 4 years
* 125 STX per tenure are released from then on indefinitely.

These "halvings" are synchronized with Bitcoin halvings.

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-1df8dcc9ca886e6b787bc34ae896c1f7fae0a600%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>

### Transaction fees

Miners receive Stacks fees for transactions mined in any block they produce.

### Reward maturity

Block rewards and transaction fees take 100 blocks on the Bitcoin blockchain to mature. After successfully mining a block your rewards appear in your Stacks account after \~24 hours.

### Mining with proof-of-transfer

Miners commit Bitcoin to **two** addresses in every leader block commit. The amount committed to each address must be the same. The addresses are chosen from the current reward set of stacking participants. Addresses are chosen using a verifiable-random-function, and determining the correct two addresses for a given block requires monitoring the Stacks chain.

For more detailed information on this process, read [SIP-007](https://github.com/stacksgov/sips/blob/main/sips/sip-007/sip-007-stacking-consensus.md), which describes proof of transfer in detail.

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-26b4e9ac6cc7d7af044042d0a9ddfedb6ce4bc4f%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>

PoX mining is a modification of Proof-of-Burn (PoB) mining, where instead of sending the committed Bitcoin to a burn address, it's transferred to eligible STX holders that participate in the stacking protocol.

{% hint style="info" %}
A PoX miner can only receive newly minted STX tokens when they transfer Bitcoin to eligible owners of STX tokens
{% endhint %}

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-462a9ff6b7460b7059f20c863c0037f769972760%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>

Miners run Stacks nodes with mining enabled to participate in the PoX mechanism. The node implements the PoX mechanism, which ensures proper handling and incentives through four key phases:

* Registration: miners register for a future election by sending consensus data to the network
* Commitment: registered miners transfer Bitcoin to participate in the election. Committed BTC are sent to a set participating STX token holders
* Election: a verifiable random function chooses one miner for a new tenure to write blocks on the Stacks blockchain
* Assembly: the elected miner writes the new blocks by pulling transactions from the mempool and collects rewards in form of new STX tokens

### Probability to mine next block

The miner who is selected to mine the next block is chosen depending on the amount of BTC the miners sent, that is, transferred or burnt.

The probability for a miner to mine the next block is determined using a variation of the Assumed Total Commitment with Carryforward (ATC-C) MEV mitigation strategy described in [this document](https://github.com/stacksgov/sips/blob/feat/sip-021-nakamoto/sips/sip-021/MEV-Report.pdf) to allocate block rewards to miners. The probability a miner will win the sortition and be granted the current tenure will be based on a function that accounts for the total block commit spend on the blocks leading up to the current sortition.

You can read more about this in the [MEV section of SIP-021](https://github.com/stacksgov/sips/blob/feat/sip-021-nakamoto/sips/sip-021/sip-021-nakamoto.md#block-reward-distribution-and-mev).

While there is no minimum BTC commitment enforced by the protocol, in practice, there's a floor constrained by [dust](https://unchained-capital.com/blog/dust-thermodynamics/): basically, if the fees for a transaction exceed the value of the spent output, it's considered dust. How dust is [calculated](https://github.com/bitcoin/bitcoin/blob/master/src/policy/policy.cpp#L14) depends on a number of factors, we've found 5,500 satoshis to be good lower bound per [output](https://learnmeabitcoin.com/technical/output). Bitcoin transactions from Stacks miners contain two outputs (for Proof-of-Transfer), so a commitment of at least 11,000 satoshis / block is recommended.

To calculate the amount of BTC to send miners should:

* Guess the price BTC/STX for the next day (100 blocks later)
* Guess the total amount of BTCs committed by all miners

Stackers are in charge of both validating and appending new blocks and conducting miner tenure changes. The next section will explain how that works, and then we'll see how this process results in Bitcoin finality.

### Stacks mining in practice

If you take a look at [SIgnal21's mining dashboard](https://app.signal21.io/stacks/mining), you can view some interesting data about mining on the Stacks network, including BTC spent per block, STX earned per block, the total number of miners over the course of the chain's history, and the number of miners for any given block.

Many people notice the seemingly small number of miners on Stacks. Without context, this can sometimes raise eyebrows. Let's dig into how mining works on Stacks so we can understand why this isn't an issue for decentralization.

Stacks miners function similarly to sequencers in L2 systems in that they are only responsible for constructing and proposing new blocks, not appending them to the chain. But unlike most Ethereum L2s that operate with just a single centralized sequencer, Stacks consistently has at least 4-5 miners with open membership allowing anyone to join.

It's important to note that there are two primary parties involved in the block production process on Stacks: miners and stackers.

These two roles serve complementary relationships in the [block production process](file:///), and stackers drastically reduce any potential destructive power miners have over the chain.

Miners cannot reorganize the chain. In the worst case, all miners can do is omit (some kinds of) transactions, and all that is required to address this is to run your own miner.

Furthermore, more miners on the network would mean fewer BTC rewards for Stackers, as miners would have to spend more of their funds on Bitcoin L1 fees rather than sending it to the Stackers.

{% hint style="info" %}
**Wouldn't more miners mean more competition, meaning more rewards?**

The reason more miners means fewer rewards is because miners act economically rationally, and they don't have an unlimited amount of BTC to work with.

Miners are paying their PoX commitments plus their Bitcoin fees for a chance to win the coinbase (1,000 STX) plus fees for a tenure. If there are more miners, they will each pay less, because they will have a lower chance of winning. They can't pay ever-increasing amounts of BTC because at some point they will never be profitable, so there is a limit to how much BTC they can spend in order to try and win a tenure.

As they pay less, the Bitcoin fee becomes a more significant portion of their expenses, and that also decreases their odds of winning the tenure.

Here's a concrete example:

Let's say Stacks is trading at 1,000 Sats per STX.

The total spend from all miners, if everyone is acting logically and we ignore Stacks fees, would be less than 1,000,000 Sats (1,000 STX coinbase \* 1000 Sats/STX).

If that is from 5 miners, then it could be 10,000 Sats (2,000 Sats for each transaction) going to Bitcoin fees and 990,000 Sats going to PoX.

If there are 100 miners, then it would be 200,000 Sats going to Bitcoin fees, and 800,000 Sats going to PoX.
{% endhint %}

This creates a natural economic equilibrium where:

{% stepper %}
{% step %}
**Enough miners participate to ensure blocks are produced reliably**

Content as above describing reliability.
{% endstep %}

{% step %}
**Stackers receive optimal BTC rewards**

Content as above describing rewards optimization.
{% endstep %}

{% step %}
**The network maintains censorship resistance without unnecessary mining competition**

Content as above describing censorship resistance.
{% endstep %}
{% endstepper %}

This design is intentional - by having stackers as complimentary security guarantors who receive BTC rewards via PoX, Stacks achieves security without requiring an excessive number of miners competing solely to win block production rights.

Unlike other chains where miners alone determine the canonical chain, Stacks' two-party system provides stronger guarantees:

* Miners cannot force invalid transactions or blocks (stackers won't sign them, and even if they did, the nodes would not accept them)
* No miner can unilaterally reorg the chain (stackers control chain finality)
* The 70% stacker threshold signature requirement ensures broad consensus before blocks are accepted

This separation of concerns between miners and stackers is what makes Stacks uniquely secure despite having a small number of miners.

### What About Microblocks?

Microblocks are a legacy feature of the previous version of Stacks that no longer exist. They were originally created as a way to improve transaction throughput, but without the functionality of Nakamoto, they never worked in practice.

Instead of microblocks, Nakamoto instead utilizes a block production structure that creates Stacks blocks at a rapid cadence as described here.


# Signing

Stackers play an essential role in the Nakamoto system that had previously been the responsibility of miners. Before, miners both decided the contents of blocks, and decided whether or not to include them in the chain (i.e. by deciding whether or not to confirm them). In this system each actor has the following responsibilities necessary to make the system function reliably without forks:

* **Miners** decide the contents of blocks.
* **Stackers** decide whether or not the block is included in the chain.

The bulk of the complexity of the Nakamoto changes is in separating these two concerns while ensuring that both mining and Stacking remain open-membership processes. **Crucially, anyone can become a miner and anyone can become a Stacker, just as before.** The most substantial changes are in getting miners and Stackers to work together in their new roles to achieve this proposal's goals.

The key idea is that Stackers are required to acknowledge and validate a miner's block before it can be appended to the chain. To do so, Stackers must first agree on the canonical chain tip, and then apply (and roll back) the block on this chain tip to determine its validity. Once Stackers agree that the block is both canonical and valid, they collectively sign it and replicate it to the rest of the Stacks peer network. Only at this point do nodes append the block to their chain histories.

This new behavior prevents forks from arising. If a miner builds a block atop a stale tip, Stackers will refuse to sign the block. If Stackers cannot agree on the canonical Stacks tip, then no block will be appended in the first place. While this behavior creates a new failure mode for Stacks -- namely, the chain can halt indefinitely if Stackers cannot agree on the chain tip -- this is mitigated by having a large and diverse body of Stackers such that enough of them are online at all times to meet quorum and incentivizing them via PoX rewards to act as such.

### Stacker Signing

{% hint style="info" %}
You can view a list of all of the [active signers](https://explorer.hiro.so/signers?chain=mainnet) on Hiro's block explorer.
{% endhint %}

We'll cover how stacking works in the Stacking section and the sBTC signing in the sBTC section; here we'll cover the signing process as it relates to Stacks block production.

The means by which Stackers agree on the canonical chain tip and agree to append blocks is tied to PoX. In each reward cycle, a Stacker clinches one or more reward slots; there are at most 4,000 reward slots per reward cycle. Stackers vote to accept blocks by producing a weighted threshold signature over the block. The signature must represent a substantial fraction of the total STX locked in PoX (the threshold), and each Stacker's share of the signature (its weight) is proportional to the fraction of locked STX it owns.

The weighted threshold signature is a Schnorr signature generated through a variation of the [FROST protocol](https://eprint.iacr.org/2020/852.pdf). Each Stacker generates a signing key pair, and they collectively generate an aggregate public key for nodes to use to verify signatures computed through a distributed signing protocol. This signing protocol allocates shares of the associated aggregate private key to Stackers proportional to the number of reward slots they clinch. No Stacker learns the aggregate private key; Stackers instead compute shares of the private key and use them to compute shares of a signature, which can be combined into a single Schnorr signature.

When a miner produces a block, Stackers execute a distributed signing protocol to collectively generate a single Schnorr signature for the block. Crucially, the signing protocol will succeed only if at least X% of the reward slots are accounted for in the aggregate signature. Nakamoto is currently set to use a 70% signing threshold -- at least 70% of the reward slots (by proxy, 70% of the stacked STX) must sign a block in order to append it to the Stacks blockchain.

Nakamoto uses the [WSTS protocol with the FIRE extension](https://trust-machines.github.io/wsts/wsts.pdf), which admits a distributed key generation and signature generation algorithm pair whose CPU and network bandwidth complexity grows with the number of distinct Stackers. The FIRE extension enables WSTS to tolerate byzantine Stackers.

Here is a diagram outlining the relationship between signing and stacking.

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-afa91fa7dd99707993d314e58aec9c4aec5c98d7%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>

### Validating and Appending New Blocks

When miners are selected for a new tenure, they begin building new blocks from transactions in the mempool. They then send those blocks to stackers for approval. Stackers must approve the blocks with a quorum of at least 70% for them to be appended to the chain.

Stackers will approve a block based on several properties:

* The block is well-formed
  * It has the correct version and mainnet/testnet flag
  * Its header contains the right number of Stacks blocks preceding this one.
  * Its header contains the correct total Bitcoin spent in the sortition that elected the current tenure.
  * Its header contains the same Bitcoin block hash as the Bitcoin block that contains its tenure's block-commit transaction\*
  * Its header contains the correct parent block ID of the immediate parent of this block.\*
  * The transaction Merkle tree root is consistent with the transactions
  * The state root hash matches the MARF tip root hash once all transactions are applied
  * The block header has a valid ECDSA signature from the miner.
  * The block header has a valid WSTS Schnorr signature from the set of Stackers.
* All Bitcoin transactions since the last valid sortition up to (but not including) this tenure's block-commit’s Bitcoin block have been applied to the Stacks chain state\*
* In the case of a tenure start block:
  * The first transaction is the `TenureChange` transaction.
  * The first transaction after the `TenureChange` transaction is a `Coinbase`.

The properties marked with \* are collectively how Stacks ensures Bitcoin finality. By adhering to these properties, it ensures that miners are only able to append blocks if they build atop the correct chain tip, which also anchors the history to Bitcoin.

Stackers, by validating these rules, ensure Bitcoin finality. We'll talk about this more in the next section.

### Conducting Miner Tenure Changes

The other primary signing responsibility in block production involves conducting tenure change transactions. As discussed in the mining section, miners will submit a `block-commit` transaction on the Bitcoin chain to initiate mining. If they are selected, stackers will detect that and create a `tenure-change` transaction.

This tenure change transaction includes:

| Name                           | Description                                                                                                                                                                                                                                                                                                                                           | Representation      |
| ------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------- |
| tenure consensus hash          | Consensus hash of this tenure. Corresponds to the sortition in which the miner of this block was chosen. It may be the case that this miner's tenure gets extended across subsequent sortitions; if this happens, then this `consensus hash` value remains the same as the sortition in which the winning block-commit was mined.                     | 20 bytes            |
| previous tenure consensus hash | Consensus hash of the previous tenure. Corresponds to the sortition of the previous winning block-commit.                                                                                                                                                                                                                                             | 20 bytes            |
| burn view consensus hash       | Current consensus hash on the underlying burnchain. Corresponds to the last-seen sortition.                                                                                                                                                                                                                                                           | 20 bytes            |
| previous tenure end            | The index block hash of the last Stacks block from the previous tenure.                                                                                                                                                                                                                                                                               | 32 bytes            |
| previous tenure blocks         | The number of blocks produced since the last sortition-linked tenure.                                                                                                                                                                                                                                                                                 | 4 bytes, big-endian |
| cause                          | <p>A flag to indicate the cause of this tenure change<br>- <code>0x00</code> indicates that a sortition occurred, and a new miner should begin producing blocks.<br>- <code>0x01</code> indicates that the current miner should continue producing blocks. The current miner’s tenure execution budget is reset upon processing this transaction.</p> | 1 byte              |
| pubkey hash                    | The ECDSA public key hash of the current tenure.                                                                                                                                                                                                                                                                                                      | 20 bytes            |

This tenure change transaction is then sent to the newly elected miner and they must include it as the first transaction in their first block, otherwise stackers will not approve it.

This process is then repeated over and over as new miners are elected for tenures.

Be sure to take a look at [SIP-021](https://github.com/stacksgov/sips/blob/feat/sip-021-nakamoto/sips/sip-021/sip-021-nakamoto.md) to get a detailed description of exactly what happens under the hood during these processes.

Next up, let's dig a little deeper into this idea of Bitcoin finality and how the Stacks block production mechanism achieves it.


# Bitcoin Finality

The concept of 100% Bitcoin finality is crucial to the design of Stacks. This is what turns Stacks into a true Bitcoin L2 and allows it to leverage all of the security inherent in Bitcoin.

Finality refers to the point at which transactions are irreversible. Once a blockchain reaches finality, it is nearly impossible to change the ledger's history without undertaking extraordinary measures that are often computationally and economically prohibitive.

When we talk about Stacks blocks having 100% Bitcoin finality, we mean that they are as hard to reverse as Bitcoin transactions themselves.

That's a bold claim, so how does Stacks accomplish that?

As discussed above, miners are responsible for producing Stacks blocks in their tenure, which corresponds to a single Bitcoin block. As part of their block commit transaction, which is the transaction that previously committed the hash of the next Stacks block to the Bitcoin chain, miners will instead be required to add an indexed block hash.

The indexed block hash is the hash of the first block produced by the last Stacks miner in their tenure. This is the SHA512/256 hash of both the consensus hash of all previously-accepted Bitcoin transactions that Stacks recognizes, as well as the hash of the block itself.

This will anchor the Stacks chain history to Bitcoin up to the start of the previous miner's tenure, as well as all causally-dependent Bitcoin state that Stacks has processed. This ensures Bitcoin finality, resolves miner connectivity issues by putting fork prevention on stackers, and allows nodes with up-to-date copies of the Stacks chain state to identify which Stacks blocks are affected by a Bitcoin reorg and recover the affected Stacks transactions.

This relationship between Stackers, miners, Bitcoin blocks, and Stacks blocks is what maintains Bitcoin finality while allowing miners to rapidly produce Stacks blocks. Bitcoin finality is achieved because at every Bitcoin block N + 1, the state of the Stacks chain as of the start of tenure N is written to Bitcoin. Even if at a future date all of the former Stackers’ signing keys were compromised, they would be unable to rewrite Stacks history for tenure N without rewriting Bitcoin history back to tenure N + 1.

Because of this, Stacks transactions can be considered to have Bitcoin finality after the tenure they are a part of concludes, or Bitcoin block N + 1. As an example, if I initiate a Stacks transaction that gets confirmed by a Stacks miner, at the conclusion of that miner's tenure (the end of the current Bitcoin block) that transaction will be written to Bitcoin as part of the Stacks chain state and all future miners are required to build off of that chain tip, making reversing the transaction as difficult as reversing the corresponding Bitcoin transaction.

{% hint style="info" %}
Key point: At every Bitcoin block N + 1 the state of the Stacks chain as of the start of tenure N is anchored to Bitcoin. This makes reversing Stacks history for tenure N as hard as rewriting Bitcoin history back to N + 1.
{% endhint %}

## Nakamoto Transactions and Bitcoin Reorgs

If Nakamoto transactions follow Bitcoin finality, what happens if Bitcoin forks?

In order to answer this question, we need to distinguish between two types of Stacks transactions: Bitcoin-reliant and internal.

{% hint style="info" %}

* **Bitcoin-reliant** transactions are transactions that read Bitcoin state. If Bitcoin forks, these transactions will change. For these, you cannot do better than following Bitcoin finality. For example, if you moved BTC from L1 to L2, you must wait for Bitcoin finality before your L2 BTC can be used (you don’t have any L2 BTC if the L1 transaction becomes unconfirmed due to a fork).
* **Internal** transactions don't rely on Bitcoin state, and thus won't change if Bitcoin forks. These can have faster confirmations because even if Bitcoin forks, signers can ensure they are re-processed in the same order.
  {% endhint %}

The key takeaway is this:

Under Nakamoto Stacks, transactions won’t impactfully reorganize due to a Bitcoin fork. Not only is reorging relatively infrequent, but transactions on Stacks that got reorganized due to a Bitcoin fork behave just as reorganized Bitcoin transactions do. With some future analysis, transactions purely on the L2 chain may one day be entirely unaffected.

<details>

<summary>Read more about Bitcoin reorg behavior</summary>

If you are interested in learning more about how this works, see the [Bitcoin Reorgs](https://docs.stacks.co/learn/block-production/bitcoin-reorgs) page of the docs.

</details>


# Bitcoin Reorgs

Under Nakamoto Stacks transactions don’t impactfully reorganize due to a Bitcoin fork. Not only is reorging relatively infrequent, but transactions on Stacks that got reorganized due to a Bitcoin fork behave just as reorganized Bitcoin transactions do. With some future analysis, transactions purely on the L2 chain may one day be entirely unaffected.

Understanding this concept fundamentally comes down to understanding finality on post-Nakamoto Stacks.

{% hint style="info" %}
Under Nakamoto the Stacks chain won’t fork on its own. It is designed not to fork with only special exceptions, and it’s entirely infeasible for Stacks to fork on its own if even 31% of Stackers don’t want it to fork, and even then it would likely only happen within the span of a single tenure.

The only case in which Stacks forks post-Nakamoto is if Bitcoin forks cause it to fork.
{% endhint %}

Under Nakamoto, instead of winning the right to make a single block, miners win the right to make a ton of blocks, and during that time we say they’re under “tenure”. Every single Stacks block produced in a tenure requires at least 70% of Stackers to approve (sign) it for it to be included in the Stacks blockchain. The Stackers are watching the Bitcoin blockchain and will only sign blocks from the miner that won the latest sortition.

Now, let’s imagine that Bitcoin reorganizes itself and the Stackers were watching a Bitcoin fork that is now sub-optimal. The Stackers would essentially go back in time to the latest common sortition between the fork that they were watching and the new best Bitcoin fork and start signing the blocks within the tenures from there. Note that 70% of the Stackers will be doing the same thing all at once, and the moment 70% agree to start signing from the latest tenure on the new Bitcoin fork there’s a new singularly optimal Stacks blockchain.

So what happens to the transactions that were confirmed on the tenure that got reorganized? Nothing. Still in the mempool as if the reorganized tenure didn’t happen. For anything within the Stacks blockchain everything is fine.

This is 1:1 with a Bitcoin fork reorganizing a Bitcoin transaction. You shouldn’t consider a transaction on Bitcoin final if it’s near the chain tip, and you shouldn’t consider a Stacks transaction final if it’s near the tenure tip.

<details>

<summary>Replaying Transactions</summary>

Since 70% of the signers have to sign any Stacks block included in the chain at least 70% of signers know the state of the chain before and after a Bitcoin fork causes a Stacks reorg.

There’s a catch to this that makes enforcing it difficult: if a transaction were dependent on something on the Bitcoin blockchain that also got reorganized (a peg-in, for example), that transaction would now be invalid. Taint analysis is when you attempt to answer the questions “which transaction interacted with the now-orphaned Bitcoin blockchain in a way that makes them invalid (tainted) in the new chain” and then also “which transactions interacted with the now invalid (tainted) transaction such that they are now also invalid”. There’s a cascading effect, but enforcing any kind of replay requires that the Stackers and the Miners can identify which transactions can get replayed at all.

Taint analysis, and subsequently replay enforcement, can be added in the future.

For the first release, Nakamoto explicitly ties the Stacks blockchain to the Bitcoin blockchain such that there’s only one optimal Stacks fork tied to Bitcoin at any given point. This is completely 1:1 with the Bitcoin Blockchain behavior, but on the tenure scale.

</details>


# Stacking

### Introduction

Stacking rewards Stacks (STX) token holders with bitcoin for providing a valuable service to the network by locking up their tokens for a certain time and participating as consensus-critical signers. If you aren't familiar with the concept of signers in Stacks, be sure to check out the [Signing section](https://docs.stacks.co/learn/block-production/signing). This document is a conceptual overview of stacking and how it works.

`pox-4.clar` is the stacking contract. If you are interested in experimenting with proof of transfer use cases including state changes, solo stacking, and pool stacking, all the functions you’ll need can be found at the deployed contract:

* Testnet: <https://explorer.hiro.so/txid/0xfba7f786fae1953fa56f4e56aeac053575fd48bf72360523366d739e96613da3?chain=testnet>
* Mainnet: <https://explorer.hiro.so/txid/0xc6d6e6ec82cabb2d7a9f4b85fcc298778d01186cabaee01685537aca390cdb46?chain=mainnet>

### Stacking vs Staking

While stacking on the Stacks network can be conceptually similar to staking, Stacks is not a PoS network and there are a couple key differences.

There are two primary differences between stacking in Stacks and staking in PoS networks.

#### Yield generated in burnchain token

In staking, users lock one token and earn their yield in the same token. In stacking, users lock one token (STX) and earn a yield in the "burnchain" token (BTC), rather than the same token that was locked. In PoX, the yield comes from a finite, external source (Bitcoin deposits from Stacks miners). In PoS, the yield comes from the currency's issuance schedule itself.

How are these issuance rates set? In Ethereum, issuance rates are determined by network usage. Ethereum's goal is to create a deflationary money supply, so the issuance rate is determined depending on the usage of the network. In order for an Ethereum transaction to be considered valid, it must include a base fee that is burned during transaction execution. The [issuance rate is algorithmically determined](https://ethereum.org/en/roadmap/merge/issuance/#post-merge) block-by-block depending on how much ETH is being burned by these base fees plus normal gas fees.

Stacking doesn't generate yield in the same token and therefore doesn't need to issue new STX for stacking rewards. Stacking yield requires an input of an external token (BTC). Stacks does have an issuance rate and does generate new STX tokens, but that process is separate from stacking and the stacking yield mechanism.

#### No slashing

Although stackers do fulfill a consensus-critical role in Stacks by serving as signers, there is no concept of slashing in PoX (Proof of Transfer).

Rather, if stackers do not perform their duties as signers, they simply cannot unlock their STX tokens and will not receive their BTC rewards.

Stacking is a built-in action, required by the "proof-of-transfer" (PoX) mechanism. The PoX mechanism is executed by every miner on the Stacks network.

{% hint style="info" %}
Stacking functionality is implemented as a smart contract, using Clarity. Read more about [the contract](https://app.gitbook.com/s/GVj1Z9vMuEOMe7oH7Wnq/clarity/example-contracts/stacking).
{% endhint %}

### Locking and Unlocking STX

When STX tokens are "locked", no transfer of STX tokens occurs. Locking STX tokens is non-custodial, and STX tokens remain in your wallet. When you initiate a stacking transaction those tokens are locked and unspendable at the protocol level, but they do not leave the stacker's wallet.

At the end of the lock period, they will be automatically unlocked (spendable at the protocol level). This occurs implicitly; there is no direct transaction that unlocks them.

### Stacking flow

The Stacking mechanism can be presented as a flow of actions:

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-56cb1a4122cf42076f96ff6dafc6bf1d4f01835d%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>

{% stepper %}
{% step %}
**Make API calls to get details about the upcoming reward cycle**

Query the network to discover the upcoming cycle parameters and timing.
{% endstep %}

{% step %}
**Confirm eligibility for a specific Stacks account**

Verify the account meets the minimum requirements and is eligible to participate.
{% endstep %}

{% step %}
**Confirm the BTC reward address and lockup duration**

Specify the Bitcoin address to receive payouts and input the desired lockup period.
{% endstep %}

{% step %}
**Broadcast the stacking transaction to lock STX**

The transaction is broadcast and the STX tokens are locked. This must happen before the prepare phase of the next reward cycle (the last 100 Bitcoin blocks of the ongoing reward phase).
{% endstep %}

{% step %}
**Reward cycles execute and BTC rewards are sent**

The stacking mechanism executes reward cycles and sends out rewards to the configured BTC reward address.
{% endstep %}

{% step %}
**Monitor unlocking timing and rewards during lockup**

During the lockup period, you can obtain details about unlocking timing, expected rewards, and more.
{% endstep %}

{% step %}
**Tokens are released after the lockup period**

Once the lockup period has passed, the tokens become spendable again.
{% endstep %}

{% step %}
**Display reward history**

Show historical details like earnings for previous reward cycles.
{% endstep %}
{% endstepper %}

{% hint style="info" %}
Keep in mind that the target duration for a reward cycle is \~2 weeks. This duration is based on the target block time of the Bitcoin network (10 minutes) and can be higher at times due to [confirmation time variances](https://www.blockchain.com/charts/median-confirmation-time) of the Bitcoin network.
{% endhint %}

### Stacking delegation flow

There are two main ways you can stack: solo stacking and delegated stacking.

{% stepper %}
{% step %}
**Solo stacking**

Solo stacking follows the general stacking flow. You stack your own STX tokens and run your own signer. To operate as a solo stacker, you must have a minimum amount of STX tokens. This minimum is dynamic and can be found by viewing the [pox endpoint of the API](https://api.testnet.hiro.so/v2/pox) in the `min_threshold_ustx` field.
{% endstep %}

{% step %}
**Delegated stacking**

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-4b4b6fb18a0cb6d97d141d9bb370408575c8c49e%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>

Delegated stacking differs:

* Before stacking on behalf of a token holder, the delegator must be granted permission by the account owner. Permission is restricted to a maximum amount the delegator may stack; the maximum can be set higher than available funds. An account can be associated with only one delegator.
* The account sets the delegation relationship. They can optionally restrict the Bitcoin reward address that must be used for payouts and specify an expiration burn block height to limit the delegation duration.
* Delegators lock STX from different accounts ("pooling phase") until they reach the minimum required to participate in stacking.
* Once the delegator locks enough STX, they can finalize and commit participation in the next reward cycle.
* Some delegation relationships may allow the STX holder to receive payouts directly from the miner.
* Delegation can terminate automatically based on expiration rules or by actively revoking delegation rights.
  {% endstep %}
  {% endstepper %}

### Token holder eligibility

Stacks (STX) token holders don't automatically receive stacking rewards. To participate, they must:

* Commit to participation before a reward cycle begins
* Commit at least the minimum amount of STX tokens to secure a reward slot, or pool with others to reach the minimum
* Lock up STX tokens for a specified period
* Provide a supported Bitcoin address to receive rewards
* Maintain their signer software (if they operate a signer)

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-a2f699bc2a05391ac67413518e9e7a44bbacce3a%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>

Token holders have a variety of providers and tools to support their participation in stacking. The Stacks website contains a [list of pools and stacking options](https://www.stacks.co/learn/stacking#startstacking).

### Stacking in the PoX consensus algorithm

Stacking is a built-in capability of PoX and occurs through a set of actions on the Stacks blockchain. The [full proof-of-transfer implementation details](https://github.com/stacks-network/stacks-blockchain/blob/develop/sip/sip-007-stacking-consensus.md) are in SIP-007. Below is a summary of the most relevant actions of the algorithm.

{% hint style="info" %}
Note that SIP-007 describes stacking before Nakamoto. While much of the functionality remains the same, stackers now have the additional responsibility of operating as signers as outlined in [SIP-021](https://github.com/stacksgov/sips/blob/feat/sip-021-nakamoto/sips/sip-021/sip-021-nakamoto.md).
{% endhint %}

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-4b4a05513919821cd98f9325c95a55ddc4cfbccd%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>

Stacking happens in reward cycles of 2100 Bitcoin blocks (roughly two weeks). Reward cycles are split into two phases: the prepare phase and the reward phase.

* The prepare phase lasts 100 Bitcoin blocks and is where the new stackers for the upcoming reward phase are selected by the PoX anchor block (see SIP-007 for details).
* Because Stacks does not fork after the Nakamoto upgrade, the PoX anchor block is always known 100 Bitcoin blocks before the start of the next reward cycle. It is the last tenure-start block that precedes the prepare phase.
* The PoX anchor block identifies the next stackers. They have 100 Bitcoin blocks to prepare for signing Stacks blocks, including completing a Distributed Key Generation round for signing blocks.
* The PoX contract requires stackers to register their block-signing keys when they stack or delegate-stack STX, so the entire network can validate signatures on blocks.

This process is handled by [running a signer](https://app.gitbook.com/s/4cpTb2lbw0LAOuMHrvhA/run-a-signer) and then subsequently conducting stacking operations as that signer.

### Stacking and Signing

Stacking and signing are distinct actions, but both are necessary. Signers must stack their STX tokens, and you cannot stack STX without associated signing information. The nuance depends on solo vs delegated stacking.

### Solo Stacking

If you are solo stacking, you have two options for signing.

#### Run your own signer

You can run your own signer by following the How to Run a Signer guide. This requires technical knowledge and resources for running a machine. See the guide for details.

#### Work with another signer

If you don't want to run your own signer, you can collaborate with another signer and include their signature in your stacking transactions. Details on how to do this are in the [Stack STX](https://app.gitbook.com/s/4cpTb2lbw0LAOuMHrvhA/stacking-stx) guide.

### Delegated Stacking

If you delegate your STX to a pool operator, you do not need to run a signer. The pool operator conducts the actual stacking transaction and is responsible for running the signer.

If you are a pool operator, see the [operate-a-pool guide](https://app.gitbook.com/s/4cpTb2lbw0LAOuMHrvhA/stacking-stx/operate-a-stacking-pool).

### How and Where to Stack

Options for stacking include solo stacking, participating in a pool, using an exchange, and liquid stacking. The Stacks website has a [stacking page](https://www.stacks.co/learn/stacking) describing these options.

For detailed instructions on how to stack, see the [Stack STX guides](https://app.gitbook.com/s/4cpTb2lbw0LAOuMHrvhA/stacking-stx).

Tools and explorers for stacking data and statistics:

* <https://app.signal21.io/>
* <https://www.stacking-tracker.com/>
* <https://www.stakingrewards.com/calculator?asset=stacks>
* <https://stacking.tools/>


# Transactions

Transactions are a key component of the Stacks chain and are the primary way users will interact with it. In this section, we'll cover how transactions work and give an introduction to post conditions, an additional security feature of Stacks that allows client-side developers to enforce certain conditions to protect users from interacting with malicious contracts.


# How Transactions Work

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-47111d002c520e55941486d8efa9eb9b330864dd%2Fimage.png?alt=media" alt=""><figcaption><p>source: <a href="https://www.hiro.so/blog/dissecting-a-transaction-signature-on-stacks">Hiro blog</a></p></figcaption></figure>

### Introduction

Transactions are the fundamental unit of execution in the Stacks blockchain. Each transaction is originated from a Stacks account, and is retained in the Stacks blockchain history for eternity. This guide helps you understand Stacks transactions.

### Lifecycle

Transactions go through phases before being finally confirmed, and available for all, on the Stacks 2.0 network.

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-0f140b843bc4816542284a80c67e350f505dae57%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>

{% stepper %}
{% step %}
**Generate**

Transactions are assembled according to the encoding specification.
{% endstep %}

{% step %}
**Validate and sign**

Transactions are validated to confirm they are well-formed. Required signatures are filled in.
{% endstep %}

{% step %}
**Broadcast**

Transactions are sent to a node.
{% endstep %}

{% step %}
**Register**

A miner receives transactions, verifies, and adds them to the ["mempool,"](https://academy.binance.com/en/glossary/mempool) a holding area for all the pending transactions.
{% endstep %}

{% step %}
**Process**

Miners review the mempool and select transactions for the next block to be mined. Depending on the transaction type, different actions can happen during this step. For example, post-conditions could be verified for a token transfer, smart-contract defined tokens could be minted, or an attempt to call an existing smart contract method could be made.
{% endstep %}

{% step %}
**Confirm**

Miners successfully propose blocks with a set of transactions. The transactions inside are successfully propagated to the network when the stackers approve them.
{% endstep %}
{% endstepper %}

{% hint style="info" %}
A transaction can have one of three states once it is registered: `pending`, `success`, or `failed`.
{% endhint %}

### Types

Stacks supports a set of different transaction types:

| **Type**                  | **Value**                 | **Description**                                                                                                                                                                                                                                                             |
| ------------------------- | ------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Tenure change             | `TenureChange`            | A tenure change is an event in the existing Stacks blockchain when one miner assumes responsibility for creating new stacks blocks from another miner. A change in tenure occurs when a Stacks block is discovered from a cryptographic sortition. Carried out by stackers. |
| Tenure change block found | `TenureChange-BlockFound` | A `TenureChange-BlockFound` transaction is induced by a winning sortition. This causes the new miner to start producing blocks, and stops the current miner from producing more blocks.                                                                                     |
| Tenure change extend      | `TenureChange-Extend`     | A `TenureChange-Extend`, which is induced by Stackers, resets the current tenure's ongoing execution budget, thereby allowing the miner to continue producing blocks.                                                                                                       |
| Token transfer            | `token_transfer`          | Asset transfer from a sender to a recipient                                                                                                                                                                                                                                 |
| Contract deploy           | `smart_contract`          | Contract instantiation                                                                                                                                                                                                                                                      |
| Contract call             | `contract_call`           | Contract call for a public, non read-only function                                                                                                                                                                                                                          |

A sample of each transaction type can be found in the [Stacks Blockchain API response definition for transactions](https://docs.hiro.so/stacks/api/transactions/get-transaction).

{% hint style="info" %}
Read-only contract call calls do **not** require transactions. Read more about it in the network guide.
{% endhint %}


# Post Conditions

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-3716767855649150a8a31e6cedc4c9d4139a7500%2Fimage.png?alt=media" alt=""><figcaption><p>source: <a href="https://www.hiro.so/blog/a-developers-guide-to-post-conditions">Hiro blog</a></p></figcaption></figure>

Post conditions are one of the most interesting and unique aspects of Stacks.

From the beginning, safety and security has been at the heart of the Stacks ethos and formed the foundation of architecture decisions when building it.

Like Clarity, Stacks' smart contract programming language, post conditions were specifically built and designed to solve the problem of user safety when interacting with blockchain applications.

So what are they and how do they work?

### How Post Conditions Work

Post conditions are conditions that are set on the client side to ensure that a smart contract does not perform any unexpected behavior.

Let's look at an example to make this more concrete.

Let's say a user is on an NFT marketplace and is expecting to purchase an NFT for 100 STX. Using post conditions, the developer who is building the frontend of the application can add in post conditions to ensure that this is in fact what happens when the user initiates the transaction.

If it does not, the transaction will abort and the user won't be out anything except the transaction fee.

It's important to note that post conditions do not live in smart contracts. They are designed to be an extra layer of security on top of smart contracts.

The problem they help address is a user interacting with a malicious smart contract that attempts to do something the user does not expect.

But rather than simply being a UI feature of a wallet, these post conditions are built into the Stacks blockchain itself and are enforced at the protocol level.

When you use a Stacks wallet like the Hiro web wallet and initiate a transaction, the wallet will display the post conditions set by the developer and tell the user exactly what is going to happen. If the action taken by the smart contract matches, the transaction goes through fine, otherwise it aborts.

Here's what that looks like:

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-5b26b1c9eb08397ee84db2af8b95bf04ded839bb%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>

In this example, if the smart contract does not transfer one fabulous-frog NFT and and take 50 STX from the user, the transaction will abort.

You can learn more about how post conditions work in [SIP-005](https://github.com/stacksgov/sips/blob/main/sips/sip-005/sip-005-blocks-and-transactions.md#transaction-post-conditions) and how to utilize them in your applications in Hiro's excellent [post conditions tutorial](https://docs.hiro.so/stacks/stacks.js/guides/post-conditions).


# Clarity

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-287069d054107785b86964fac1af4aab57d82728%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>

Clarity is the smart contract language that Stacks uses. It has been built from the ground up to make it easier for developers to write safe, secure smart contracts. Clarity has several unique features that make it an ideal choice for writing smart contracts. We'll go over an overview of Clarity here, and highly recommend checking out the [Clarity Crash Course](https://app.gitbook.com/u/ZrQItu6D9bMKmf1HfsLTnGc05WZ2) guide to dig in and get started learning Clarity.

Clarity is a **decidable** smart contract language that optimizes for predictability and security, designed for the Stacks blockchain. Smart contracts allow developers to encode essential business logic on a blockchain.

The design decisions behind Clarity were based heavily on taking lessons learned in common Solidity exploits and creating a language that has been purpose-built for safety and security in mind.

These docs serve primarily as a reference for the functions and keywords that you can use in Clarity.

In order to learn Clarity, we recommend diving into the [Clarity of Mind](https://book.clarity-lang.org/), an online book to teach you everything you need to know to build robust smart contracts, or joining a [Clarity Camp](https://clarity-lang.org/universe#camp), the cohort-based immersive Clarity experience.

### What makes Clarity different

The following section is an excerpt from the book, [Clarity of Mind](https://book.clarity-lang.org/ch00-00-introduction.html):

The number of smart contract languages grows by the year. Choosing a first language can be challenging, especially for a beginner. The choice is largely dictated by the ecosystem you are interested in, although some languages are applicable to more than just one platform. Each language has its own upsides and downsides and it is out of the scope of this book to look at all of them. Instead, we will focus on what sets Clarity apart and why it is a prime choice if you require the utmost security and transparency.

One of the core precepts of Clarity is that it is secure by design. The design process was guided by examining common pitfalls, mistakes, and vulnerabilities in the field of smart contract engineering as a whole. There are countless real world examples of where developer failure led to the loss or theft of vast amounts of tokens. To name two big ones: an issue that has become known as the Parity bug led to the irreparable loss of millions of dollars worth of Ethereum. Second, the hacking of The DAO (a "Decentralized Autonomous Organization") caused financial damage so great that the Ethereum Foundation decided to issue a contentious hard fork that undid the theft. These and many other mistakes could have been prevented in the design of the language itself.

#### Clarity is interpreted, not compiled

Clarity code is interpreted and committed to the chain exactly as written. Solidity and other languages are compiled to byte-code before it is submitted to the chain. The danger of compiled smart contract languages is two-fold: first, a compiler adds a layer of complexity. A bug in the compiler may lead to different byte-code than was intended and thus carries the risk of introducing a vulnerability. Second, byte-code is not human-readable, which makes it very hard to verify what the smart contract is actually doing. Ask yourself, would you sign a contract you cannot read? If your answer is no, then why should it be any different for smart contracts? With Clarity, what you see is what you get.

#### Clarity is decidable

A decidable language has the property that from the code itself, you can know with certainty what the program will do. This avoids issues like the halting problem. With Clarity you know for sure that given any input, the program will halt in a finite number of steps. In simple terms: it is guaranteed that program execution will end. Decidability also allows for complete static analysis of the call graph so you get an accurate picture of the exact cost before execution. There is no way for a Clarity call to "run out of gas" in the middle of the call. We explore this idea more, along with a discussion on Turing completeness, in the security deep dive on decidability.

#### Clarity does not permit reentrancy

Reentrancy is a situation where one smart contract calls into another, which then calls back into the first contract—the call "re-enters" the same logic. It may allow an attacker to trigger multiple token withdrawals before the contract has had a chance to update its internal balance sheet. Clarity's design considers reentrancy an anti-feature and disallows it on the language level.

#### Clarity guards against overflow and underflows

Overflows and underflows happen when a calculation results in a number that is either too large or too small to be stored, respectively. These events throw smart contracts into disarray and may intentionally be triggered in poorly written contracts by attackers. Usually this leads to a situation where the contract is either frozen or drained of tokens. Overflows and underflows of any kind automatically cause a transaction to be aborted in Clarity.

#### Support for custom tokens is built-in

Issuance of custom fungible and non-fungible tokens is a popular use-case for smart contracts. Custom token features are built into the Clarity language. Developers do not need to worry about creating an internal balance sheet, managing supply, and emitting token events. Creating custom tokens is covered in depth in later chapters.

#### On Stacks, transactions are secured by post conditions

In order to further safeguard user tokens, post conditions can be attached to transactions to assert the chain state has changed in a certain way once the transaction has completed. For example, a user calling into a smart contract may attach a post condition that states that after the call completes, exactly 500 STX should have been transferred from one address to another. If the post condition check fails, then the entire transaction is reverted. Since custom token support is built right into Clarity, post conditions can also be used to guard any other token in the same way.

#### Returned responses cannot be left unchecked

Public contract calls must return a so-called response that indicates success or failure. Any contract that calls another contract is required to properly handle the response. Clarity contracts that fail to do so are invalid and cannot be deployed on the network. Other languages like Solidity permit the use of low level calls without requiring the return value to be checked. For example, a token transfer can fail silently if the developer forgets to check the result. In Clarity it is not possible to ignore errors, although that obviously does prevent buggy error handling on behalf of the developer. Responses and error handling are covered extensively in the chapters on functions and control flow.

#### Composition over inheritance

Clarity adopts a composition over inheritance. It means that Clarity smart contracts do not inherit from one another like you see in languages like Solidity. Developers instead define traits which are then implemented by different smart contracts. It allows contracts to conform to different interfaces with greater flexibility. There is no need to worry about complex class trees and contracts with implicit inherited behavior.

#### Access to the base chain: Bitcoin

Clarity smart contracts can read the state of the Bitcoin base chain. It means you can use Bitcoin transactions as a trigger in your smart contracts! Clarity also features a number of built-in functions to verify secp256k1 signatures and recover keys.


# Overview

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-bc81eabb22ca77afec8b60c7ab22398941f9639c%2Fimage.png?alt=media" alt=""><figcaption><p>source: <a href="https://www.hiro.so/blog/write-better-smart-contracts-with-the-programming-language-clarity">Hiro blog</a></p></figcaption></figure>

Clarity is a **decidable** smart contract language that optimizes for predictability and security, designed for the Stacks blockchain. Smart contracts allow developers to encode immutable business logic on a blockchain.

The design decisions behind Clarity were based heavily on taking lessons learned in common Solidity exploits and creating a language that has been purpose-built for safety and security in mind.

These docs serve primarily as a reference for the functions and keywords that you can use in Clarity.

In order to learn Clarity, we recommend diving into the [Clarity of Mind](https://book.clarity-lang.org/), an online book to teach you everything you need to know to build robust smart contracts, or joining a [Clarity Camp](https://clarity-lang.org/universe#camp), the cohort-based immersive Clarity experience.

### What makes Clarity different

The following section is an excerpt from the excellent book, [Clarity of Mind](https://book.clarity-lang.org/ch00-00-introduction.html):

The number of smart contract languages grows by the year. Choosing a first language can be challenging, especially for a beginner. The choice is largely dictated by the ecosystem you are interested in, although some languages are applicable to more than just one platform. Each language has its own upsides and downsides and it is out of the scope of this book to look at all of them. Instead, we will focus on what sets Clarity apart and why it is a prime choice if you require the utmost security and transparency.

One of the core precepts of Clarity is that it is secure by design. The design process was guided by examining common pitfalls, mistakes, and vulnerabilities in the field of smart contract engineering as a whole. There are countless real world examples of where developer failure led to the loss or theft of vast amounts of tokens. To name two big ones: an issue that has become known as the Parity bug led to the irreparable loss of millions of dollars worth of Ethereum. Second, the hacking of The DAO (a "Decentralized Autonomous Organization") caused financial damage so great that the Ethereum Foundation decided to issue a contentious hard fork that undid the theft. These and many other mistakes could have been prevented in the design of the language itself.

#### Clarity is interpreted, not compiled

Clarity code is interpreted and committed to the chain exactly as written. Solidity and other languages are compiled to byte-code before it is submitted to the chain. The danger of compiled smart contract languages is two-fold: first, a compiler adds a layer of complexity. A bug in the compiler may lead to different byte-code than was intended and thus carries the risk of introducing a vulnerability. Second, byte-code is not human-readable, which makes it very hard to verify what the smart contract is actually doing. Ask yourself, would you sign a contract you cannot read? If your answer is no, then why should it be any different for smart contracts? With Clarity, what you see is what you get.

#### Clarity is decidable

A decidable language has the property that from the code itself, you can know with certainty what the program will do. This avoids issues like the halting problem. With Clarity you know for sure that given any input, the program will halt in a finite number of steps. In simple terms: it is guaranteed that program execution will end. Decidability also allows for complete static analysis of the call graph so you get an accurate picture of the exact cost before execution. There is no way for a Clarity call to "run out of gas" in the middle of the call. We explore this idea more, along with a discussion on Turing completeness, in the security deep dive on decidability.

#### Clarity does not permit reentrancy

Reentrancy is a situation where one smart contract calls into another, which then calls back into the first contract—the call "re-enters" the same logic. It may allow an attacker to trigger multiple token withdrawals before the contract has had a chance to update its internal balance sheet. Clarity's design considers reentrancy an anti-feature and disallows it on the language level.

#### Clarity guards against overflow and underflows

Overflows and underflows happen when a calculation results in a number that is either too large or too small to be stored, respectively. These events throw smart contracts into disarray and may intentionally be triggered in poorly written contracts by attackers. Usually this leads to a situation where the contract is either frozen or drained of tokens. Overflows and underflows of any kind automatically cause a transaction to be aborted in Clarity.

#### Support for custom tokens is built-in

Issuance of custom fungible and non-fungible tokens is a popular use-case for smart contracts. Custom token features are built into the Clarity language. Developers do not need to worry about creating an internal balance sheet, managing supply, and emitting token events. Creating custom tokens is covered in depth in later chapters.

#### On Stacks, transactions are secured by post conditions

In order to further safeguard user tokens, post conditions can be attached to transactions to assert the chain state has changed in a certain way once the transaction has completed. For example, a user calling into a smart contract may attach a post condition that states that after the call completes, exactly 500 STX should have been transferred from one address to another. If the post condition check fails, then the entire transaction is reverted. Since custom token support is built right into Clarity, post conditions can also be used to guard any other token in the same way.

#### Returned responses cannot be left unchecked

Public contract calls must return a so-called response that indicates success or failure. Any contract that calls another contract is required to properly handle the response. Clarity contracts that fail to do so are invalid and cannot be deployed on the network. Other languages like Solidity permit the use of low level calls without requiring the return value to be checked. For example, a token transfer can fail silently if the developer forgets to check the result. In Clarity it is not possible to ignore errors, although that obviously does prevent buggy error handling on behalf of the developer. Responses and error handling are covered extensively in the chapters on functions and control flow.

#### Composition over inheritance

Clarity adopts a composition over inheritance. It means that Clarity smart contracts do not inherit from one another like you see in languages like Solidity. Developers instead define traits which are then implemented by different smart contracts. It allows contracts to conform to different interfaces with greater flexibility. There is no need to worry about complex class trees and contracts with implicit inherited behavior.

#### Access to the base chain: Bitcoin

Clarity smart contracts can read the state of the Bitcoin base chain. It means you can use Bitcoin transactions as a trigger in your smart contracts! Clarity also features a number of built-in functions to verify secp256k1 signatures and recover keys.


# Decidability

### What does it mean for a language to be Non-Turing Complete or Decidable?

Non-Turing complete and decidable are two terms you will often hear about the security advantages of Clarity, but what do they mean?

While related, they are not quite interchangeable, since there are a few differences.

#### Non-Turing Complete

A system or language is non-Turing complete if it cannot simulate a Turing machine, which is an abstract model of computation. Non-Turing complete systems have limited computational power compared to Turing complete systems. A Turing-complete system or language can simulate any Turing machine. Examples of non-Turing complete systems include finite state machines and some domain-specific languages (like Clarity).

Non-Turing complete languages typically cannot express all possible algorithms. Specifically, some problems whose solutions require unbounded loops or recursion cannot be expressed using non-Turing complete languages. This last property is especially important in the context of Clarity, as it makes it so that features like unbounded loops and reentrancy are disallowed at a language level.

#### Decidable

A problem is decidable if there exists an algorithm that can always determine whether a given input has a particular property or not in a finite amount of time. In other words, a decidable problem can be solved by a Turing machine that is guaranteed to halt for all input instances. Decidability is a property of problems, whereas Turing completeness is a property of languages or computational systems.

The fact that Clarity is decidable means that developers (and tooling) can more easily reason about and predict with certainty the behavior of Clarity contracts, regardless of the input.

### Mindset of a Smart Contract Developer

Before we dive into specifics, let's first set the context and viewpoint we should hold as smart contract developers who want to write secure code.

As you explore further into the security properties of Solidity and Clarity, you'll see that there are always mitigation steps that *can* be taken by developers to help address some of these security issues.

The main issue, with this line of thinking, is it increases the odds of human error in smart contract security. If we can preserve functionality while mitigating the chance of human error as much as possible, we should do so.

### Should smart contracts be Turing complete?

We will discover new applications for smart contracts. These applications will go beyond current smart contracts, traditional contracts, and may even open new economic opportunities. Given these possibilities, how should we build our smart contracts? What characteristics should our smart contract languages have?

It is good practice to separate data from programs. Should smart contracts be data, or programs, or something in between? If smart contracts are data, then should the programs that execute them be Turing complete or perhaps less powerful? If smart contracts are programs, then what language should smart contracts be written in? What characteristics should this programming language have?

The Church–Turing thesis is the hypothesis that all formal notions of computation are captured by Turing machines or modern computers. A programming language is Turing complete if it captures all formal notions of computation. Many programming languages are Turing complete. For example, Python, C++, Rust, Java, Lisp, and Solidity are all Turing complete.

Consider a program and its input. In the worst case, determining this program’s output is impossible. Validating a program, on a particular input, is done by generating a proof-of-correctness.

Proofs-of-correctness are logical proofs that can be mechanically validated. Finding proofs-of-correctness for programs and their input is undecidable. Kurt Gödel showed there are undecidable logical statements.

This indicates all programs in Turing complete languages cannot be validated in the worst case. Thus, Turing complete smart contract languages must allow contracts that cannot be validated.

Alonzo Church and Alan Turing showed there are problems that are uncomputable. Uncomputable problems cannot be solved by any Turing machine. Hence, assuming the Church–Turing thesis, these uncomputable problems cannot be solved by any computer.

We'll explore this idea further later in this section.

Turing complete languages are very expressive. In fact, assuming the Church–Turing thesis, Turing complete languages are as expressive as possible in some sense.

Is there a trade-off? What types of problems can occur with uncomputable problems and programs whose validity may be undecidable?

As smart contracts subsume parts of contract law, consider the large body of laws and regulations for tax law.

For instance, US tax law and regulations take up several million words. International tax law and regulations pushes these numbers much higher.

Are these laws and regulations programs or are they data? If tax law were to be written in a Turing complete language, then the law may codify uncomputable problems. It is an accountant’s nightmare for their advice to be undecidable.

Clarity is non-Turing complete, yet very expressive. This makes it so that Clarity is decidable and cannot encode uncomputable problems. There are discussions and papers on smart contract languages such as Solidity that propose subsets of Solidity that are non-Turing complete. These subsets are decidable and cannot encode uncomputable problems. However, there is no consensus on which subsets to work with and they are not widely used.

### Advantages of Decidability in Smart Contracts

Why is decidability important in the context of smart contracts?

First, it is not possible for a Clarity call to run out of gas in the middle of a call. Because of its decidability, it is possible to get a complete static analysis of the call graph to get an accurate picture of the cost before execution.

Solidity allows for unbounded loops, recursion, and dynamic function calls, which makes it difficult to accurately predict the execution cost or gas usage beforehand. As a result, Solidity contracts may run out of gas during execution if the gas limit is not set appropriately or if the contract encounters a scenario with unexpectedly high computational requirements.

One practical example is the issue of a specific kind of DoS attack in Solidity, where the contract is rendered inoperable because of unbounded execution constraints. An example of this is the GovernMental attack, where a mapping that needed to be deleted for a payout became so large that working with it exceeded the block gas limit.

There are a few different properties of Clarity's language design that prevents such DoS attacks.

The reason that the analysis system can accurately estimate the execution cost is because certain functionality is intentionally limited in Clarity.

For example, there is no recursion in Clarity, so we can't infinitely call into a function over and over.

Data types in Clarity are also restricted. Any data types that don't require a hard length limit are not iterable.

Maps and tuples, for example, do not require you to enter a maximum length when defining them, but you also can't iterate over them.

Lists, on the other hand, which are iterable, do require the developer to define an upper limit when defining them. This is a large part of what allows an accurate static analysis of Clarity contracts.

So how would we implement a mapping of an undefined size in Clarity? We wouldn't, because it's an anti-pattern in smart contract design.

Instead, Clarity forces us to think of a better solution to our problem. For example, implementing a way for users to handle mapping/list element operations themselves, instead of mass operations handled at the contract level.

If you [analyze the GovernMental attack](https://hackernoon.com/smart-contract-attacks-part-2-ponzi-games-gone-wrong-d5a8b1a98dd8#h-attack-2-call-stack-attack), you'll see that it took advantage of multiple security issues, all of which are mitigated in Clarity. You'll also see that a fix was added to make it economically infeasible to carry out this type of attack again.

This brings up another crucial point when setting appropriate mental models for smart contracts and blockchain systems: complexity means more potential bugs, which means adding more complexity to address those bugs.

When this happens over and over again, we are trapping ourselves into creating an evermore complex system. Addressing these issues at the language level prevents this ever-growing complexity.

For a deep dive into how Clarity was designed, check out [SIP-002](https://github.com/stacksgov/sips/blob/main/sips/sip-002/sip-002-smart-contract-language.md).

{% hint style="info" %}
You can view some more common smart contract vulnerabilities and how they are mitigated in [this article](https://stacks.org/bringing-clarity-to-8-dangerous-smart-contract-vulnerabilities/).
{% endhint %}

This has second-order effects as well when we look at security testing and auditing. One of the common tools for testing smart contracts is formal verification, where we mathematically prove that certain properties of smart contracts will or will not remain true in all cases.

This can lead to the path explosion problem, where there are so many paths available that formal verification becomes incredibly difficult. This problem is mitigated in Clarity, since there is not chance of a program encountering an unbounded loop.

This leads us to a more general mental model for thinking about decidability as smart contracts continue to become a larger part of our economy. Remember that the goal with blockchain systems is to create an open, transparent, fair financial system.

This means that smart contracts will be responsible for managing large amounts of wealth for ever-growing amounts of people. As smart contracts encompass more financial structures, their complexity and usage will grow.

Complexity is the enemy of security. The more complex a system is, the more danger there is in creating uncomputable problems when there are no hard restrictions on the execution steps that can be taken.

This is deadly in financial infrastructure that is not only open and transparent, but immutable. Let's explore this idea of uncomputability a bit more.

### Intuition on Uncomputability

Intuitively, uncomputability is an algorithmic view of undecidability. Uncomputability has the same foundations as undecidability. Undecidable questions are framed as logic statements or statements about integers. Of course, programs are logic statements and may even be viewed as integers, though we view programs differently. We often view programs with additional details of memory models, implementation details, and execution semantics.

The [Halting problem](https://en.wikipedia.org/wiki/Halting_problem): As an example, given any program `P` and any finite input `I` for `P`, then the Halting Problem is the challenge of determining if `P` halts on input `I`.

Alonzo Church and Alan Turing showed the Halting Problem is unsolvable.

Christopher Strachey gave an intuitive proof-by-contradiction showing the Halting problem is uncomputable. This is set up by supposing there is a program `H` that can solve the Halting problem for any program `P`. `H(P)` returns true if `P` halts and false otherwise. Then build a program `P` that does not halt when `H(P)` is true, giving a contradiction. Similarly, this program `P` halts when `H(P)` is false, also a contradiction.

Uncomputable problems are problems that cannot be solved by an algorithm or a computer, no matter how much time or resources are provided. These problems exist in various forms, and one such example is the Post correspondence problem, which was proposed by Emil Post.

The Post correspondence problem can be described using pairs of strings and an integer. Imagine you have n pairs of strings, called P. These strings are made up of characters from a character set, such as UTF-8 or any other alphabet with at least two symbols. The pairs of strings look like this:

```
P = { (x1, y1), (x2, y2), … , (xn, yn) }
```

Now, you also have an integer m that is greater than 0. The Post correspondence problem asks whether there is a way to create a list of indices (i1, i2, …, im) using the given pairs of strings. You can repeat these indices if needed, with one condition: when you combine the x strings from the pairs using the indices, the resulting string must be equal to the combined y strings from the same pairs using the same indices. In other words:

```
x(i1) x(i2) … x(im) = y(i1) y(i2) … y(im)
```

When developers try to solve the Post correspondence problem, they often attempt to use indeterminate loops (loops without a fixed number of iterations) rather than recursion. This is because the problem seems to require searching through different combinations of indices until a solution is found or it's proven that no solution exists.

In simple terms, the Post correspondence problem involves trying to find a sequence of indices that, when applied to the given pairs of strings, produces equal concatenated strings from both the x and y components. This problem is considered uncomputable because there is no general algorithm that can solve it for all possible input pairs of strings and integers.

It turns out, many questions about how programs behave are uncomputable. This has a number of consequences for smart contracts that are built in Turing complete languages, many of which we are not aware of yet but will surely become aware of as we encounter them in the future.

### Raymond Smullyan’s Intuition on Undecidability

This is a part of Raymond Smullyan’s approach to understanding undecidability in propositional logic. It uses meta-information to show something must be true, though it cannot be proved in propositional logic. This is based on a paradox.

In propositional logic, a logical statement is undecidable if we cannot prove it true or false. Given a propositional logic statement S, a proof is a sequence of formal logical deductions, starting from basic facts and ending by indicating if S is true or false.

Smullyan starts with an island of Knights and Knaves. Knights always tell the truth. Knaves always lie. We cannot distinguish islanders otherwise.

There is a great logician named Ray. Whatever Ray proves is true. This is just like a good theorem prover.

An islander Jack proclaims: “You cannot prove I am a Knight” to the logician Ray.

The next reasoning is based on meta-knowledge of this situation. This meta-knowledge shows that some problems are undecidable in propositional logic.

If Ray can prove Jack is a Knight, then Jack must be a Knave, since Jack must have lied. That is because Ray proved Jack is a Knight. Since Jack is a Knave, Ray’s proof contradicts the assumption that Ray only proves true things. So, this case cannot hold.

If Ray cannot prove Jack is a Knight, then Jack must be a Knight, since Jack stated the truth. But Ray cannot prove the fact that Jack is a Knight.

In the context of smart contracts and programming languages, Turing complete languages like Solidity come with the possibility of undecidable problems.

These undecidable problems are similar to the paradox presented in the Knights and Knaves story, where it's impossible to determine whether Jack is a Knight or a Knave based on the given information.

In the Knights and Knaves story, Ray is analogous to a theorem prover or a smart contract in a Turing complete language. Ray is faced with a statement that is undecidable within the constraints of the system (Knights and Knaves), which leads to a paradox.

Similarly, a Turing complete smart contract language might face undecidable problems that can't be resolved, leading to unexpected behavior, vulnerabilities, or resource consumption issues (like running out of gas in Ethereum).

On the other hand, non-Turing complete languages like Clarity are designed to avoid undecidable problems by limiting their expressiveness.

In the context of the Knights and Knaves story, a non-Turing complete language would simply not allow Jack to make a statement that could lead to a paradox. By disallowing certain features like unbounded loops and recursion, non-Turing complete languages can provide stronger guarantees about the behavior and resource usage of smart contracts.

This predictability is desirable in many cases, especially when dealing with high-value transactions or critical systems.

### Reference

The Mathematics of Various Entertaining Subjects: Research in Recreational Math Illustrated Edition, Jennifer Beineke (Editor), Jason Rosenhouse (Editor), Raymond M. Smullyan (Foreword), Princeton University Press, 2016.


# sBTC

Design of a Trustless Two-way Peg for Bitcoin

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-4ecdf4182030ceb46a4ac036ea938a92a0013602%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}

#### For builders and developers, head to the [sBTC pages](https://app.gitbook.com/s/Zz9BLmTU9oydDpL3qiUh/more-guides/sbtc) under the Build section to start integrating sBTC into your Clarity smart contracts and front-end application.

{% endhint %}

### Introduction to sBTC

sBTC is a SIP-010 token on the Stacks blockchain that represents Bitcoin (BTC) in a 1:1 ratio. It enables Bitcoin holders to participate in DeFi applications and other smart contract functionalities while maintaining a peg to the underlying Bitcoin.

#### Purpose

The primary purpose of sBTC is to bridge Bitcoin to DeFi via the Stacks blockchain, providing Bitcoin holders with access to the rich functionality of smart contracts without sacrificing the security and value of their BTC holdings.

> *Unlocking Bitcoin to be a fully programmable, productive asset would allow Bitcoin to be the*\
> \&#xNAN;*backbone of DeFi and a more secure web3. The ability to move Bitcoin assets in and out of*\
> \&#xNAN;*smart contracts freely and for these contracts to trustlessly write to the Bitcoin blockchain can*\
> \&#xNAN;*unlock hundreds of billions of dollars of passive BTC for web3.*\
> \
> \- sBTC: Design of a Trustless Two-way Peg for Bitcoin

#### Key Benefits

1. **Bitcoin Compatibility**: Allows Bitcoin holders to participate in the Stacks ecosystem without selling their BTC.
2. **Quick Conversions**: Facilitates rapid movement between BTC and sBTC (within 3 Bitcoin blocks for deposit, 6 for withdrawal).
3. **Decentralized Management**: Initially utilizes a set of 15 community-chosen signers for maintaining the peg wallet.
4. **Community Governance**: Involves the community in key decisions, such as selecting the initial signing set.

### Key Concepts of sBTC

Understanding sBTC requires familiarity with several key concepts:

**sBTC**

sBTC is a [SIP-010](https://github.com/stacksgov/sips/blob/main/sips/sip-010/sip-010-fungible-token-standard.md) token on the Stacks Blockchain that can be converted back to BTC on the Bitcoin Blockchain. The key property of sBTC is its 1:1 peg to Bitcoin, meaning 1 sBTC is always equivalent to 1 BTC.

**sBTC UTXO**

The sBTC UTXO is the single unspent transaction output (UTXO) on the Bitcoin blockchain that holds the entire BTC balance pegged into sBTC. This UTXO is managed and maintained by the set of sBTC Signers.

This UTXO resides in a secure multi-signature taproot address controlled by the sBTC Signers:\
[bc1prcs82tvrz70jk8u79uekwdfjhd0qhs2mva6e526arycu7fu25zsqhyztuy](https://mempool.space/address/bc1prcs82tvrz70jk8u79uekwdfjhd0qhs2mva6e526arycu7fu25zsqhyztuy)

**sBTC Signer**

In sBTC, the sBTC Signer is a signer entity separate from the Stacks Nakamoto signer. sBTC signer responsibilities include:

* Signing sBTC operations
* Communicating with the sBTC contracts on the Stacks chain
* Managing the sBTC UTXO

**sBTC Signer Set**

The sBTC Signer Set is the group of all sBTC signers. This set has full democratic access to the sBTC UTXO and is responsible for maintaining the security of the peg wallet. The signers also have the ability to rotate their private keys for enhanced security.

For more info on who the sBTC Signers are, check out this section on the Bitcoin L2 Labs website [here](https://bitcoinl2labs.com/sbtc-rollout#sbtc-signers).

**Emily API**

Emily is an API that helps facilitate and supervise the sBTC Bridge in addition to serving as a programmatic liaison between sBTC users and signers.

**SIP-010 Token**

sBTC adheres to the [SIP-010](https://github.com/stacksgov/sips/blob/main/sips/sip-010/sip-010-fungible-token-standard.md) standard for fungible tokens on the Stacks blockchain. This ensures compatibility with wallets and applications that support the SIP-010 standard.

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-6dbb8304c63d2bde407f714cb5cb94ea14661ed5%2FGroup%20316124848.png?alt=media" alt=""><figcaption></figcaption></figure>

Understanding these concepts is crucial for grasping the overall architecture and functionality of sBTC. In the following sections, we'll explore how these concepts come together to create sBTC.

***

#### Extra Resources

* \[[sBTC Whitepaper](https://stacks-network.github.io/stacks/sbtc.pdf)] The official sBTC whitepaper
* \[[Stacks Foundation](https://stacks.org/sbtc-on-mainnet)] Official sBTC launch announcement (December 2024)
* \[[Bitcoin Writes](https://www.bitcoinwrites.com/)] Weekly sBTC Updates (last update: August 2024)
* \[[Hiro Blog](https://www.hiro.so/blog/who-are-the-sbtc-signers-breaking-down-sip-028)] Who Are the sBTC Signers: Breaking Down SIP-028


# Core Features

sBTC offers several core features that make it a powerful trust-minimized Bitcoin bridge between Stacks and Bitcoin:

{% stepper %}
{% step %}
**1:1 Bitcoin Backing**

Each sBTC token is backed by an equivalent amount of Bitcoin in the peg wallet. This ensures that sBTC maintains a stable value relative to BTC.
{% endstep %}

{% step %}
**Decentralized Management**

The sBTC peg wallet is maintained and managed by a set of sBTC signers. This decentralized approach enhances security and reduces single points of failure.
{% endstep %}

{% step %}
**Quick Conversions**

sBTC facilitates rapid movement between BTC and sBTC:

* BTC to sBTC conversion can be completed within 3 Bitcoin blocks
* sBTC to BTC conversion can be completed within 6 Bitcoin blocks
  {% endstep %}

{% step %}
**SIP-010 Compatibility**

sBTC adheres to the SIP-010 fungible token standard on the Stacks blockchain. This ensures wide compatibility with Stacks wallets and applications.
{% endstep %}

{% step %}
**Community Governance**

The initial sBTC signing set is determined by a community vote, weighted by STX holdings. This approach ensures that the community has a say in the management of the sBTC system.
{% endstep %}

{% step %}
**Signer Key Rotation**

sBTC signers have the ability to rotate their private keys, enhancing long-term security of the system.
{% endstep %}

{% step %}
**Transaction Fee Sponsorship**

sBTC transactions on Stacks can be sponsored, allowing users to pay transaction fees in sBTC instead of STX.
{% endstep %}
{% endstepper %}


# sBTC Operations

This section covers the main operations in the sBTC system. These operations form the core functionality of sBTC, allowing users to permissionlessly move value between the Bitcoin and Stacks ecosystems.

{% stepper %}
{% step %}
**Deposit**

Converting BTC to sBTC.

* **Increased Utility**: Users can leverage their Bitcoin on the Stacks network by converting BTC to sBTC, providing access to smart contracts and decentralized applications (dApps) that are not natively possible on the Bitcoin network.
* **DeFi Opportunities**: By utilizing sBTC, users can participate in decentralized finance (DeFi) activities such as lending, borrowing, and earning yield on their assets.
* **Cost Efficiency**: Operating on the Stacks network might offer lower transaction fees compared to the Bitcoin network, making it cost-effective for conducting transactions and executing smart contracts.
* **Interoperability**: sBTC allows users to enjoy the benefits of blockchain interoperability, moving their value seamlessly between the Bitcoin and Stacks ecosystems.
* **Network Security**: Stacks enhance security by building on Bitcoin's robustness, providing an added layer of trust and reliability when using sBTC.
  {% endstep %}

{% step %}
**Withdrawal**

Converting sBTC back to BTC.

* **Liquidity Needs**: Users might want to convert sBTC back to BTC to access the deep liquidity available on the Bitcoin network, facilitating easier and potentially faster transactions.
* **Off-Ramping**: Converting sBTC to BTC can allow users to withdraw their funds from the cryptocurrency ecosystem into fiat currency through exchanges that primarily support Bitcoin.
* **Security Preferences**: Some users might prefer holding their assets directly on the Bitcoin network due to its reputation for security and decentralization.
* **Network Preference**: Individuals may choose to operate exclusively within the Bitcoin network for its simplicity and widespread acceptance as a method of payment.
  {% endstep %}
  {% endstepper %}


# Deposit

Converting BTC to sBTC.

The deposit operation enables users to mint sBTC, anchored to the BTC they have placed in the threshold wallet on the Bitcoin chain. This process can be completed within a single Bitcoin block, streamlining the user experience.

## Process Overview

<div data-with-frame="true"><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2FFRo9Sa9MGCHhlOSqT1XF%2FStacks_graphic%20-%2064.png?alt=media&#x26;token=e6d1fc78-05f4-4080-b725-b29da62e8f27" alt="deposit diagram"></div>

The deposit process begins when a user initiates a specific Bitcoin transaction that has two outputs. The depositor (usually through the application they are using to deposit) then initiates an API call referencing that Bitcoin transaction. This call triggers the Emily API, which relays deposit information to the sBTC Signers. These signers verify and process the deposit. Once verified, an equivalent amount of sBTC is minted on the Stacks blockchain.

{% stepper %}
{% step %}
**Script output**

A script that lets the signers spend the funds.
{% endstep %}

{% step %}
**Time-locked output**

A time lock that allows the depositor to reclaim the funds if necessary.
{% endstep %}
{% endstepper %}

The deposit is usually completed within a single Bitcoin block, but is guaranteed to be completed within 3. For more information on deposit and withdrawal confirmation times and why deposits can be so fast, check out the [Deposit and Withdrawal Times](https://docs.stacks.co/learn/sbtc/sbtc-operations/deposit-vs-withdrawal-times) doc.

## Bitcoin Deposit Requirements

For a deposit to be considered valid, it must adhere to specific requirements:

* The deposit must be made to a taproot address.
* The output must be spendable by a consensus threshold of signers.
* The deposit must follow a format that prevents short-term clawbacks, ensuring the security and integrity of the system.

## User Experience

From a user's perspective, the deposit process is straightforward:

1. Initiate a BTC transaction to the specified address.
2. Wait for the transaction to be confirmed on the Bitcoin blockchain.
3. Receive the equivalent amount of sBTC in the Stacks wallet once the deposit is verified and processed.

To enhance the user experience, an sBTC bridge web application is currently in development which will provide an intuitive interface for users to track the status of their deposit operations, allowing users to stay informed throughout the process from initiation to completion.


# Withdrawal

Converting sBTC back to BTC.

The sBTC withdrawal operation enables users to convert their sBTC back to BTC. This process involves burning sBTC on the Stacks blockchain and releasing an equivalent amount of BTC on the Bitcoin blockchain.

## Process Overview

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2FD1Aj5Shr7N4dAFa8FpCP%2FStacks_graphic%20-%2065.png?alt=media&#x26;token=acfa516e-72e9-42d1-97d5-5786129c4e02" alt=""><figcaption></figcaption></figure></div>

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXeNx03RFtUIZTzKCbSnakHtStQl69RWZ7TWRYsW4KvIS2HS-93ghvu3s2U-g5PXbdeCvV_PZUZv1JL3CdPo3Zkm2ZHHmW8BDJIvMoZMFBf256K0fVH07TEazw7EPu7Wixex-inhIAwIzy4WCHwzoUbzpPph_?key=LMMtMf3zwOdkwel07ZrRiw" alt=""><figcaption></figcaption></figure>

{% stepper %}
{% step %}
**Initiate withdrawal**

A user initiates a Clarity contract call (via a Stacks wallet or dApp) specifying:

* the amount of sBTC to withdraw
* the destination Bitcoin address
  {% endstep %}

{% step %}
**Stacks transaction finality**

The Stacks transaction must reach finality. The protocol requires six Bitcoin block confirmations before proceeding to the next step.
{% endstep %}

{% step %}
**Signer verification and BTC release**

After confirmations, sBTC Signers verify the withdrawal request and create the withdrawal transaction on the Bitcoin network, releasing the equivalent BTC to the specified Bitcoin address.
{% endstep %}
{% endstepper %}

The withdrawal process requires six Bitcoin block confirmations to complete. After these confirmations, sBTC Signers create the withdrawal transaction on the Bitcoin network.

## Withdrawal Confirmation

The six-block confirmation requirement serves multiple purposes:

* Ensures finality of the Stacks transaction and prevents potential reversals or conflicts.
* Mitigates issues from potential Bitcoin forks by allowing time for network stability.
* Gives sBTC Signers sufficient time to verify and process the withdrawal request accurately.

For more information on deposit and withdrawal confirmation times and why deposits can be faster than withdrawals, see the [Deposit and Withdrawal Times](https://docs.stacks.co/learn/sbtc/sbtc-operations/deposit-vs-withdrawal-times) doc.

## Failure Cases

Some withdrawal failures can be identified and resolved before the six confirmations are complete. Other failures may only become apparent after the sBTC Bootstrap Signer attempts to create the withdrawal transaction on the Bitcoin network. These delays stem from the complexity of cross-chain operations and the need for thorough verification at each step.

<details>

<summary>More about failure detection timing</summary>

Because cross-chain operations involve verification on both Stacks and Bitcoin, certain issues (for example: insufficient signer consensus, malformed Bitcoin transaction construction, or Bitcoin network conditions) may only be detectable when the signer attempts to broadcast the Bitcoin transaction. This can cause failure detection to occur after confirmations on Stacks are already complete.

</details>

## Security Considerations

{% hint style="info" %}
The multi-block confirmation process is a critical security measure to help prevent double-spending attempts. Requiring multiple block confirmations ensures the withdrawal request is valid and final before processing on the Bitcoin network. Additionally, sBTC Signers perform verification of each withdrawal request prior to creating the Bitcoin transaction, providing an extra security layer.
{% endhint %}

## User Experience

From a user's perspective:

* Initiate a withdrawal through a Stacks wallet or dApp.
* Specify the sBTC amount and destination Bitcoin address.
* Wait for the required six Bitcoin blocks to confirm.
* Once confirmations complete and signers process the request, BTC is sent to the specified Bitcoin address.

The sBTC bridge web application offers a user-friendly interface that lets users track the status of their withdrawal operations in real time, providing updates at each stage so users can understand progress and estimate when they will receive BTC.


# Deposit vs Withdrawal Times

Understanding why the time is takes to deposit BTC to sBTC is different than withdrawing sBTC back into BTC.

### Why are Deposits So Fast and Withdrawals So Slow?

sBTC allows users to use their BTC on the Stacks L2 by using a wrapped token called sBTC. Moving sBTC onto the Stacks L2 can take as little time as 1 Bitcoin block, but moving sBTC off the Stacks L2 into the native Bitcoin blockchain takes 6 Bitcoin blocks. Why is that?

> To understand why moving onto the Stacks layer can be so fast and yet moving off must be so slow, we need to first understand the consensus mechanism of the Stacks blockchain.

The Stacks blockchain uses a consensus mechanism called Proof of Transfer, or PoX, in order to mint new blocks. On each Bitcoin block, miners, on the Stacks blockchain, each sacrifice some amount of Bitcoin in a bid to win the right to make the next few Stacks blocks, where they retain the right to keep making Stacks blocks until the next Bitcoin block occurs and the latest bidding round elects a new Stacks miner.

#### Determining which Stacks blocks should be tied to which Bitcoin block

Signers (validators equivalents for the Stacks Blockchain) look at the Bitcoin blocks and approve new Stacks blocks based on which miner currently has the right to make Stacks blocks, and they only approve new blocks from the miner that won the most recent bid on the Bitcoin block within the fork that they collectively consider to be the “best”. The Stacks blockchain can only have new blocks added if the Signers agree that the miner who proposed it is the winner of the bid on the Bitcoin blockchain, and all the Signers are voting on which block should be added, effectively collectively deciding which Bitcoin fork is the best one.

**Here’s an important part**: if the Signers believe that there’s a new and better Bitcoin fork that differs from the one that the last several Stacks blocks had been mined on, they’ll then only approve new Stacks blocks that build off of existing Stacks blocks that are tied to that new Bitcoin fork. As in, every Stacks block that was built on Bitcoin blocks in the other Bitcoin fork that aren’t in this new canonical fork are considered invalid; thus the Stacks blockchain forks too.

> “The Stacks blockchain forks with the Bitcoin blockchain.”

Now that we understand this forking mechanism, let's take a look at why moving off the Stacks layer must be so slow.

#### **Why moving from sBTC to BTC takes more time**

sBTC exists on the Stacks layer as a token that smart contracts can interact with. To move sBTC over from the Stacks layer to the Bitcoin layer, the owner of the sBTC calls a smart contract to initiate what we call the “withdrawal” sequence. This lets the “sBTC Signers” (these are different from the earlier Signers mentioned) know that they need to create a transaction on the Bitcoin blockchain to distribute the BTC back to the user.

If the sBTC Signers create a Bitcoin transaction to enact the withdrawal, they can’t take it back, and it will be valid on every fork of the Bitcoin blockchain. So what happens if, say, the Bitcoin blockchain forks and the withdrawal on the Stacks layer got reorganized out? Then there’s an irretrievable withdrawal transaction on the Bitcoin blockchain giving precious BTC to a user who never withdrew their sBTC on the Stacks layer.

<details>

<summary>Can the Signers that maintain the original chain force miners to replay all previously confirmed transactions?</summary>

The Stacks blockchain is a true Layer 2 on top of Bitcoin, and you can write a smart contract to have different behavior based on observations of the Bitcoin blockchain underneath. You can, for example, write a Stacks contract that says “Pay to Jeff if the latest Bitcoin block hash ends in an even hex digit, and pay to Abigail if it’s an odd hex digit.” Now when there’s a reorg of the Bitcoin blockchain you can replay this transaction which originally paid to Jeff, but it now pays to Abigail, and what happens if this contract was giving out sBTC, and further what happens if Jeff then immediately executed a withdrawal?

</details>

So in the end, to process a withdrawal safely you need to be sufficiently sure it won’t get reorganized out. That means it can only be processed 6 Bitcoin blocks (the finality criteria the sBTC Signers are comfortable with) after the sBTC withdrawal transaction was made on the Stacks blockchain.

#### But then, why can deposits be done in one Bitcoin block at its fastest?

Remember how Stacks forks with Bitcoin? Let's say someone makes a deposit on the Bitcoin blockchain in an attempt to mint sBTC, and then lets say the sBTC Signers immediately mint sBTC. What happens if the Bitcoin chain forks causing the Stacks blockchain to fork? The mint gets reorganized out! Sure, the deposit is no longer on the Bitcoin blockchain, but it’s not on the Stacks blockchain either. If that deposit doesn’t ever arrive on the Bitcoin blockchain the sBTC signers will never mint sBTC, so there’s nothing to take back!

#### The Bitcoin chain gets the final say

So all in all, for movements of sBTC from the Stacks layer into the Bitcoin layer the protocol needs to wait for Bitcoin to be sufficiently final, but movements from the Bitcoin layer to the Stacks layer don’t need to wait for finality to mint because the Stacks layer will just reorganize itself if the Bitcoin layer reorganizes too.

But then conceptually remember, the mint call on the Stacks blockchain is just as final as the Bitcoin block that contains the deposit of BTC onto the Stacks layer. If you’re minting sBTC on the Stacks layer and you want to wait for it to be final you’ll need to wait a suitable number of Bitcoin blocks to consider it finally minted, but that’s up to you and not the sBTC Signers.


# Emily API

[Emily](https://github.com/stacks-network/sbtc/tree/main/emily) is an API that helps facilitate and supervise the sBTC Bridge, serving as a programmatic liaison between sBTC users and signers.

## Overview

The Emily API is designed to track deposits and withdrawals, providing information about the status of in-flight sBTC operations. It serves two primary user groups: sBTC users and sBTC app developers.

### Why Call it Emily?

The Emily API is given an indirect name because it handles more than just Deposits and Withdrawals; it can detect the health of the system and will likely be extended to handle more as user requirements mature. It was once called the “Revealer API”, which stopped making sense after a few design changes, and then “Deposit API” which also stopped making sense after a few changes. The most obvious choice “sBTC API” gives the wrong impression of what the API is responsible for as well, since the API itself isn’t managing the entirety of the protocol.

Large companies name their APIs after something loosely related but ambiguous enough that extensions of the API don’t make the original name of the API misleading. Following this, we chose “Emily” after Emily Warren Roebling who was the liaison between the builders and chief engineer, her husband, of the Brooklyn bridge. She was, in effect, the supervisor of the bridge’s construction; similarly, the Emily API supervises the sBTC bridge and liaises between the users of the protocol and the sBTC signers.

### Key Features

* Track Deposits: Monitor the process of converting BTC to sBTC.
* Track Withdrawals: Monitor the process of converting sBTC back to BTC.
* Provide Operation Status: Offer real-time status updates for ongoing sBTC operations.
* Retrieve Historical Data: Allow querying of past sBTC operations.

## Core Concepts

#### sBTC Operations

sBTC operations are the fundamental processes tracked by Emily:

* Deposits: Converting BTC to sBTC
* Withdrawals: Converting sBTC back to BTC

#### Operation States

Each sBTC operation goes through several states:

* PENDING: The operation has been initiated.
* ACCEPTED: The operation has been approved by the signers.
* CONFIRMED: The operation has been completed and confirmed on the blockchain.
* FAILED: The operation could not be completed.

### Where Emily is involved in the sBTC flows

In each of the deposit and withdrawal flows for sBTC, Emily plays a vital role. Here's where Emily sits in both the Deposit and Withdrawal flows.

#### **During the Deposit Flow**

1. User creates a deposit transaction on Bitcoin
2. User submits proof of deposit to the Deposit API
3. **Emily records the deposit as PENDING**
4. Signers validate and vote on the deposit
5. **If accepted, Emily updates status to ACCEPTED**
6. Signers process the Bitcoin transaction
7. Signers mint sBTC on Stacks
8. **Emily updates the deposit status to CONFIRMED**

#### **During the Withdrawal Flow**

1. User initiates withdrawal through the sBTC Clarity contract
2. **Emily records the withdrawal as PENDING**
3. Signers decide to accept or reject the withdrawal
4. **If accepted, Emily updates status to ACCEPTED**
5. Signers process the Bitcoin transaction
6. Signers burn sBTC on Stacks
7. **Emily updates the withdrawal status to CONFIRMED**


# Peg Wallet UTXO

The Peg Wallet UTXO is a fundamental element of the sBTC system, serving as the Bitcoin backing for all sBTC tokens in circulation. The system uses a Single UTXO Model: the sBTC peg wallet is consistently represented as a single Unspent Transaction Output (UTXO) on the Bitcoin blockchain. This design offers simplicity and improved efficiency in managing the peg wallet.

{% hint style="info" %}
This UTXO resides in a secure multi-signature taproot address controlled by the sBTC Signers:\
[bc1prcs82tvrz70jk8u79uekwdfjhd0qhs2mva6e526arycu7fu25zsqhyztuy](https://mempool.space/address/bc1prcs82tvrz70jk8u79uekwdfjhd0qhs2mva6e526arycu7fu25zsqhyztuy)
{% endhint %}

## Overview

* Single UTXO Model: the peg wallet is always a single UTXO.
* Responsibility: UTXO management is performed by the Signer set.
* Purpose: simplify tracking and management, reduce Bitcoin transactions required for sBTC operations, and centralize funds in a single, well-secured output.

## How the Single UTXO is maintained

{% stepper %}
{% step %}
**Constructing the new UTXO**

A Signer coordinator constructs the UTXO by creating a new Bitcoin output that will represent the peg wallet going forward.
{% endstep %}

{% step %}
**Consolidating requests into a batch**

The Signer set collectively consolidates all deposit and withdrawal requests and creates optimized batches that can be processed within a single UTXO.
{% endstep %}

{% step %}
**Creating the new UTXO from the previous UTXO**

The new UTXO is created by:

* spending the amount from the previous UTXO,
* adding confirmed deposits,
* subtracting confirmed withdrawals.
  {% endstep %}

{% step %}
**Optimizing batching with approval sets**

When multiple sBTC operation requests are present, the Signer coordinator groups them by approval sets. If differing approval sets exist across active operations, the coordinator batches deposit UTXOs into groups with the maximum size per approval set to preserve the single UTXO invariant while maximizing batch efficiency.
{% endstep %}
{% endstepper %}

## Benefits

* Simplified tracking and management of peg funds.
* Fewer Bitcoin transactions for sBTC operations.
* Centralized funds in a single, well-secured output improves operational efficiency.

{% hint style="info" %}
The Single UTXO Model is designed to balance simplicity and operational efficiency for the sBTC peg wallet.
{% endhint %}

## Security considerations

* The single UTXO is managed by the sBTC Bootstrap Signer Set, which requires a threshold of signers to approve any spending (multi-signature).
* Regular audits and continuous monitoring are essential to ensure the UTXO accurately represents the total sBTC in circulation at all times.

{% hint style="warning" %}
Security is paramount: multi-signature approval, audits, and monitoring are core controls to protect the peg wallet.
{% endhint %}


# Clarity Contracts

The Clarity contracts responsible for sBTC's logic and interactions on Stacks.

### Deployed Mainnet Contracts

* [sbtc-token](https://explorer.hiro.so/txid/SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token?chain=mainnet)
* [sbtc-registry](https://explorer.hiro.so/txid/SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-registry?chain=mainnet)
* [sbtc-deposit](https://explorer.hiro.so/txid/SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-deposit?chain=mainnet)
* [sbtc-withdrawal](https://explorer.hiro.so/txid/SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-withdrawal?chain=mainnet)
* [sbtc-bootstrap-signers](https://explorer.hiro.so/txid/SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-bootstrap-signers?chain=mainnet)

This graph summarizes the Clarity portion of the sBTC protocol.

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXe6LEEESrk6Az-iRR5ZeEuqOQvBESKtFvBIjSYPhAjLZ2LpEwM-UOnSWn4b6hFFv0uFnysxL6wO-BVgJaPTAdYUkbvBenJrY8rY-YrGT9CSwqdCl2kuS5ZhNheumR-yBPAOHtccAt1eOD4dU5Zi-14gBgwv?key=uPKXlfIDnNUlnyka_NtgIw" alt=""><figcaption></figcaption></figure>

### sBTC Clarity Contracts

At a high level, the sBTC Clarity contracts are responsible for the following:

#### sbtc-bootstrap signers

Core contract for meta signer functionality such as registration & the rotation process.

#### sbtc-deposit

Processing contract called by the signers to record a consumed Bitcoin transaction & mint some amount of sBTC to a principal contained in the payload.

#### sbtc-registry

State storage for maintaining upgradability across protocol.

#### sbtc-withdrawal

Interaction points for users and signers to update withdrawal request state.

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-6dbb8304c63d2bde407f714cb5cb94ea14661ed5%2FGroup%20316124848.png?alt=media" alt=""><figcaption></figcaption></figure>

### User Types

In addition to the contracts themselves, there are two main user types that will interact with these contracts.

#### Signer

A signer that is part of the current sBTC signer set. More information on signers and their role in sBTC can be found in the [Signer Process Walkthrough](https://docs.stacks.co/learn/sbtc/walkthroughs/signer-process-walkthrough).

#### Wallet

A participant in the Stacks/Bitcoin ecosystem that wants to deposit/withdraw/use sbtc.


# sBTC Signers

### Overview

The [sBTC Signers contract](https://github.com/stacks-network/sbtc/blob/main/contracts/contracts/sbtc-bootstrap-signers.clar) (`sbtc-bootstrap-signers.clar`) manages the signer set for the sBTC system. It handles rotation of signer keys and provides utilities for generating multisig addresses.

**Constants**

* `key-size`: The required length of public keys (33 bytes).

**Error Constants**

* `ERR_KEY_SIZE_PREFIX`: Prefix for key size errors in batch processing.
* `ERR_KEY_SIZE` (u200): Indicates that a provided key is not the correct length.
* `ERR_INVALID_CALLER` (u201): Signifies that the function caller is not the current signer principal.
* `ERR_SIGNATURE_THRESHOLD` (u202): Indicates an invalid signature threshold (must be >50% and ≤100% of total signer keys).

#### Public Functions

**`rotate-keys-wrapper`**

Rotates the keys of the signers. Called when the signer set is updated.

* Parameters:
  * `new-keys`: `(list 128 (buff 33))` - List of new signer public keys
  * `new-aggregate-pubkey`: `(buff 33)` - New aggregate public key
  * `new-signature-threshold`: `uint` - New signature threshold
* Returns: `(response (buff 33) uint)`

Function flow:

{% stepper %}
{% step %}
**Validate signature threshold**

Ensure the new signature threshold is valid (must be >50% and ≤100% of total signer keys).
{% endstep %}

{% step %}
**Verify caller**

Verify that the caller is the current signer principal.
{% endstep %}

{% step %}
**Validate keys**

Check the length of each new key and the aggregate public key (must be 33 bytes).
{% endstep %}

{% step %}
**Update registry**

Call the sBTC Registry contract to update the keys and address.
{% endstep %}
{% endstepper %}

#### Read-only Functions

**`pubkeys-to-spend-script`**

Generates the p2sh redeem script for a multisig.

* Parameters:
  * `pubkeys`: `(list 128 (buff 33))` - List of public keys
  * `m`: `uint` - Number of required signatures
* Returns: `(buff 1024)` - The p2sh redeem script

**`pubkeys-to-hash`**

Computes the hash160 of the p2sh redeem script.

* Parameters:
  * `pubkeys`: `(list 128 (buff 33))` - List of public keys
  * `m`: `uint` - Number of required signatures
* Returns: `(buff 20)` - The hash160 of the redeem script

**`pubkeys-to-principal`**

Generates a principal (Stacks address) from a set of pubkeys and an m-of-n threshold.

* Parameters:
  * `pubkeys`: `(list 128 (buff 33))` - List of public keys
  * `m`: `uint` - Number of required signatures
* Returns: `principal` - The generated Stacks address

**`pubkeys-to-bytes`**

Concatenates a list of pubkeys into a buffer with length prefixes.

* Parameters:
  * `pubkeys`: `(list 128 (buff 33))` - List of public keys
* Returns: `(buff 510)` - Concatenated pubkeys with length prefixes

**`concat-pubkeys-fold`**

Concatenates a pubkey buffer with a length prefix.

* Parameters:
  * `pubkey`: `(buff 33)` - A single public key
  * `iterator`: `(buff 510)` - Accumulator for concatenation
* Returns: `(buff 510)` - Updated concatenated buffer

**`bytes-len`**

Returns the length of a byte buffer as a single byte.

* Parameters:
  * `bytes`: `(buff 33)` - Input byte buffer
* Returns: `(buff 1)` - Length as a single byte

**`uint-to-byte`**

Converts a uint to a single byte.

* Parameters:
  * `n`: `uint` - Input number
* Returns: `(buff 1)` - Number as a single byte

#### Private Functions

**`signer-key-length-check`**

Checks that the length of each key is exactly 33 bytes.

* Parameters:
  * `current-key`: `(buff 33)` - Public key to check
  * `helper-response`: `(response uint uint)` - Accumulator for error handling
* Returns: `(response uint uint)` - Updated accumulator or error

#### Constants

**`BUFF_TO_BYTE`**

A constant list mapping uint values (0-255) to their corresponding byte representations.

Interactions with Other Contracts

* `.sbtc-registry`: Calls `get-current-signer-data` and `rotate-keys` to manage signer data.

Security Considerations

{% hint style="warning" %}

* Access Control: Only the current signer principal can call the key rotation function.
* Key Validation: Ensures all provided keys are the correct length.
* Signature Threshold: Enforces a minimum threshold of over 50% of signers and a maximum of 100%.
* Multisig Generation: Provides utilities for secure generation of multisig addresses.
  {% endhint %}


# sBTC Token

## Overview

The [sBTC Token contract](https://github.com/stacks-network/sbtc/blob/main/contracts/contracts/sbtc-token.clar) (`sbtc-token.clar`) implements the fungible token functionality for sBTC. It manages both unlocked and locked sBTC tokens and provides functions for minting, burning, transferring, and querying token information. sBTC is a SIP-010 standard fungible token.

## Constants

* `ERR_NOT_OWNER` (u4): Error when the sender tries to move a token they don't own.
* `ERR_NOT_AUTH` (u5): Error when the caller is not an authorized protocol caller.
* `token-decimals` (u8): The number of decimal places for the token.

## Fungible Tokens

* `sbtc-token`: The main sBTC fungible token.
* `sbtc-token-locked`: Represents locked sBTC tokens.

## Data Variables

* `token-name`: The name of the token (default: "sBTC").
* `token-symbol`: The symbol of the token (default: "sBTC").
* `token-uri`: An optional URI for token metadata.

## Protocol Functions

These functions can only be called by authorized protocol contracts:

### protocol-transfer

* Parameters: `amount: uint`, `sender: principal`, `recipient: principal`
* Returns: `(response bool uint)`

### protocol-lock

* Parameters: `amount: uint`, `owner: principal`
* Returns: `(response bool uint)`

### protocol-unlock

* Parameters: `amount: uint`, `owner: principal`
* Returns: `(response bool uint)`

### protocol-mint

* Parameters: `amount: uint`, `recipient: principal`
* Returns: `(response bool uint)`

### protocol-burn

* Parameters: `amount: uint`, `owner: principal`
* Returns: `(response bool uint)`

### protocol-burn-locked

* Parameters: `amount: uint`, `owner: principal`
* Returns: `(response bool uint)`

### protocol-set-name

* Parameters: `new-name: (string-ascii 32)`
* Returns: `(response bool uint)`

### protocol-set-symbol

* Parameters: `new-symbol: (string-ascii 10)`
* Returns: `(response bool uint)`

### protocol-set-token-uri

* Parameters: `new-uri: (optional (string-utf8 256))`
* Returns: `(response bool uint)`

### protocol-mint-many

* Parameters: `recipients: (list 200 {amount: uint, recipient: principal})`
* Returns: `(response (list 200 (response bool uint)) uint)`

## Public Functions (SIP-010 Trait)

### transfer

* Parameters: `amount: uint`, `sender: principal`, `recipient: principal`, `memo: (optional (buff 34))`
* Returns: `(response bool uint)`

### get-name

* Returns: `(response (string-ascii 32) uint)`

### get-symbol

* Returns: `(response (string-ascii 10) uint)`

### get-decimals

* Returns: `(response uint uint)`

### get-balance

Returns the total balance (locked + unlocked) for a principal.

* Parameters: `who: principal`
* Returns: `(response uint uint)`

### get-balance-available

Returns the available (unlocked) balance for a principal.

* Parameters: `who: principal`
* Returns: `(response uint uint)`

### get-balance-locked

Returns the locked balance for a principal.

* Parameters: `who: principal`
* Returns: `(response uint uint)`

### get-total-supply

* Returns: `(response uint uint)`

### get-token-uri

* Returns: `(response (optional (string-utf8 256)) uint)`

## Private Functions

### protocol-mint-many-iter

* Helper function for minting tokens to multiple recipients.
* Parameters: `item: {amount: uint, recipient: principal}`
* Returns: `(response bool uint)`

## Security Considerations

{% stepper %}
{% step %}
**Access Control**

Protocol functions can only be called by authorized contracts, enforced through the `sbtc-registry` contract.
{% endstep %}

{% step %}
**Ownership Verification**

The `transfer` function checks that the sender owns the tokens being transferred.
{% endstep %}

{% step %}
**Separate Token Tracking**

The contract maintains separate tracking for locked and unlocked tokens, ensuring proper accounting.
{% endstep %}
{% endstepper %}

## Interactions with Other Contracts

* `.sbtc-registry`: Used to validate protocol callers for privileged operations.


# sBTC Registry

## Overview

The [sBTC Registry contract](https://github.com/stacks-network/sbtc/blob/main/contracts/contracts/sbtc-registry.clar) (`sbtc-registry.clar`) serves as the central registry for the sBTC system. It manages withdrawal requests, completed deposits, and the current signer set. This contract is crucial for maintaining the state and coordinating operations within the sBTC ecosystem.

## Error Constants

* `ERR_UNAUTHORIZED` (u400): Indicates unauthorized access.
* `ERR_INVALID_REQUEST_ID` (u401): Signifies an invalid withdrawal request ID.
* `ERR_AGG_PUBKEY_REPLAY` (u402): Indicates an attempt to replay an aggregate public key.
* `ERR_MULTI_SIG_REPLAY` (u403): Signifies an attempt to replay a multi-signature address.

## State Variables

* `last-withdrawal-request-id`: Tracks the latest withdrawal request ID.
* `current-signature-threshold`: Stores the current threshold for required signatures.
* `current-signer-set`: Maintains a list of current signer public keys.
* `current-aggregate-pubkey`: Holds the current aggregate public key.
* `current-signer-principal`: Stores the current signer's principal address.

## Data Maps

### withdrawal-requests

Stores withdrawal request details indexed by request ID.

* Fields:
  * `amount`: Amount of sBTC being withdrawn (in sats)
  * `max-fee`: Maximum fee for the withdrawal
  * `sender`: Principal of the sender
  * `recipient`: BTC recipient address (version and hashbytes)
  * `block-height`: Burn block height where the request was created

### withdrawal-status

Tracks the status of withdrawal requests indexed by request ID.

* Value: `bool` (true if accepted, false if rejected, none if pending)

### completed-deposits

Records completed deposit transactions to prevent replay attacks.

* Key: `{txid: (buff 32), vout-index: uint}`
* Value: `{amount: uint, recipient: principal}`

### aggregate-pubkeys

Tracks used aggregate public keys to prevent replay attacks.

* Key: `(buff 33)` (aggregate public key)
* Value: `bool`

### multi-sig-address

Tracks used multi-signature addresses to prevent replay attacks.

* Key: `principal` (multi-sig address)
* Value: `bool`

### protocol-contracts

Stores authorized protocol contract addresses.

* Key: `principal` (contract address)
* Value: `bool`

## Read-only Functions

### get-withdrawal-request

Retrieves a withdrawal request by its ID.

* Parameters:
  * `id`: `uint`
* Returns: `(optional {amount: uint, max-fee: uint, sender: principal, recipient: {version: (buff 1), hashbytes: (buff 32)}, block-height: uint, status: (optional bool)})`

### get-completed-deposit

Fetches a completed deposit by transaction ID and output index.

* Parameters:
  * `txid`: `(buff 32)`
  * `vout-index`: `uint`
* Returns: `(optional {amount: uint, recipient: principal})`

### get-current-signer-data

Returns current signer set information.

* Returns: `{current-signer-set: (list 128 (buff 33)), current-aggregate-pubkey: (buff 33), current-signer-principal: principal, current-signature-threshold: uint}`

### get-current-aggregate-pubkey

Returns the current aggregate public key.

* Returns: `(buff 33)`

### get-current-signer-principal

Returns the current signer's principal.

* Returns: `principal`

### get-current-signer-set

Returns the current set of signer public keys.

* Returns: `(list 128 (buff 33))`

## Public Functions

### create-withdrawal-request

Creates a new withdrawal request. Only callable by protocol contracts.

* Parameters:
  * `amount`: `uint`
  * `max-fee`: `uint`
  * `sender`: `principal`
  * `recipient`: `{version: (buff 1), hashbytes: (buff 32)}`
  * `height`: `uint`
* Returns: `(response uint uint)`

### complete-withdrawal-accept

Marks a withdrawal request as accepted.

* Parameters:
  * `request-id`: `uint`
  * `bitcoin-txid`: `(buff 32)`
  * `output-index`: `uint`
  * `signer-bitmap`: `uint`
  * `fee`: `uint`
* Returns: `(response bool uint)`

### complete-withdrawal-reject

Marks a withdrawal request as rejected.

* Parameters:
  * `request-id`: `uint`
  * `signer-bitmap`: `uint`
* Returns: `(response bool uint)`

### complete-deposit

Records a completed deposit transaction.

* Parameters:
  * `txid`: `(buff 32)`
  * `vout-index`: `uint`
  * `amount`: `uint`
  * `recipient`: `principal`
* Returns: `(response bool uint)`

### rotate-keys

Updates the signer set, multi-sig principal, and aggregate public key.

* Parameters:
  * `new-keys`: `(list 128 (buff 33))`
  * `new-address`: `principal`
  * `new-aggregate-pubkey`: `(buff 33)`
  * `new-signature-threshold`: `uint`
* Returns: `(response (buff 33) uint)`

## Private Functions

### increment-last-withdrawal-request-id

Increments and returns the next withdrawal request ID.

* Returns: `uint`

### is-protocol-caller

Checks if the caller is an authorized protocol contract.

* Returns: `(response bool uint)`

### validate-protocol-caller

Validates if a given principal is an authorized protocol contract.

* Parameters:
  * `caller`: `principal`
* Returns: `(response bool uint)`

## Events

The contract emits events (via `print`) for important actions:

* Withdrawal request creation: "withdrawal-create"
* Withdrawal acceptance: "withdrawal-accept"
* Withdrawal rejection: "withdrawal-reject"
* Deposit completion: "completed-deposit"

{% hint style="info" %}
Events are emitted via `print` statements in the contract for the actions listed above.
{% endhint %}

## Security Considerations

{% stepper %}
{% step %}
**Access Control**

Only authorized protocol contracts can call certain functions.
{% endstep %}

{% step %}
**Replay Prevention**

The contract prevents replay attacks on deposits, aggregate public keys, and multi-signature addresses.
{% endstep %}

{% step %}
**State Management**

The contract carefully manages the state of withdrawals and the current signer set.
{% endstep %}
{% endstepper %}


# sBTC Withdrawal

## Overview

The [sBTC Withdrawal contract](https://github.com/stacks-network/sbtc/blob/main/contracts/contracts/sbtc-withdrawal.clar) (`sbtc-withdrawal.clar`) manages the withdrawal process for the sBTC system. It handles the initiation, acceptance, and rejection of withdrawal requests, ensuring proper validation and interaction with other sBTC contracts.

## Constants

### Error Codes

* `ERR_INVALID_ADDR_VERSION` (u500): Invalid address version.
* `ERR_INVALID_ADDR_HASHBYTES` (u501): Invalid address hashbytes.
* `ERR_DUST_LIMIT` (u502): Withdrawal amount below dust limit.
* `ERR_INVALID_REQUEST` (u503): Invalid withdrawal request ID.
* `ERR_INVALID_CALLER` (u504): Caller is not the current signer principal.
* `ERR_ALREADY_PROCESSED` (u505): Withdrawal request already processed.
* `ERR_FEE_TOO_HIGH` (u505): Paid fee higher than requested.
* `ERR_WITHDRAWAL_INDEX_PREFIX`: Prefix for withdrawal index errors.
* `ERR_WITHDRAWAL_INDEX` (u506): General withdrawal index error.

### Other Constants

* `MAX_ADDRESS_VERSION` (u6): Maximum value of an address version.
* `MAX_ADDRESS_VERSION_BUFF_20` (u4): Maximum version for 20-byte hashbytes.
* `MAX_ADDRESS_VERSION_BUFF_32` (u6): Maximum version for 32-byte hashbytes.
* `DUST_LIMIT` (u546): Minimum amount of sBTC for withdrawal.

## Public Functions

### initiate-withdrawal-request

Initiates a new withdrawal request.

* Parameters:
  * `amount`: `uint` - Amount of sBTC to withdraw
  * `recipient`: `{ version: (buff 1), hashbytes: (buff 32) }` - Bitcoin address details
  * `max-fee`: `uint` - Maximum fee for the withdrawal
* Returns: `(response uint uint)`

### accept-withdrawal-request

Accepts a withdrawal request.

* Parameters:
  * `request-id`: `uint` - Withdrawal request ID
  * `bitcoin-txid`: `(buff 32)` - Bitcoin transaction ID
  * `signer-bitmap`: `uint` - Bitmap of signers
  * `output-index`: `uint` - Output index in the Bitcoin transaction
  * `fee`: `uint` - Actual fee paid
* Returns: `(response bool uint)`

### reject-withdrawal-request

Rejects a withdrawal request.

* Parameters:
  * `request-id`: `uint` - Withdrawal request ID
  * `signer-bitmap`: `uint` - Bitmap of signers
* Returns: `(response bool uint)`

### complete-withdrawals

Processes multiple withdrawal requests (accept or reject).

* Parameters:
  * `withdrawals`: `(list 600 {...})` - List of withdrawal details
* Returns: `(response uint uint)`

## Read-only Functions

### validate-recipient

Validates the recipient's Bitcoin address format.

* Parameters:
  * `recipient`: `{ version: (buff 1), hashbytes: (buff 32) }` - Bitcoin address details
* Returns: `(response bool uint)`

## Private Functions

### complete-individual-withdrawal-helper

Helper function to process individual withdrawals in the batch operation.

* Parameters:
  * `withdrawal`: `{...}` - Individual withdrawal details
  * `helper-response`: `(response uint uint)` - Accumulator for processing
* Returns: `(response uint uint)`

## Interactions with Other Contracts

* `.sbtc-token`: Calls `protocol-lock`, `protocol-burn-locked`, `protocol-mint`, and `protocol-unlock` for token operations.
* `.sbtc-registry`: Calls `create-withdrawal-request`, `get-withdrawal-request`, `get-current-signer-data`, `complete-withdrawal-accept`, and `complete-withdrawal-reject` for managing withdrawal requests and signer data.

## Security Considerations

{% stepper %}
{% step %}
**Access Control**

Only the current signer principal can accept or reject withdrawal requests.
{% endstep %}

{% step %}
**Dust Limit**

Enforces a minimum withdrawal amount to prevent spam and ensure economic viability.
{% endstep %}

{% step %}
**Fee Management**

Ensures that the actual fee doesn't exceed the maximum fee set by the user.
{% endstep %}

{% step %}
**Address Validation**

Implements thorough validation of Bitcoin address formats.
{% endstep %}

{% step %}
**State Management**

Prevents double-processing of withdrawal requests.
{% endstep %}
{% endstepper %}

## Bitcoin Address Types

The contract supports various Bitcoin address types, including:

* P2PKH (Pay-to-Public-Key-Hash)
* P2SH (Pay-to-Script-Hash)
* P2SH-P2WPKH (P2SH nested P2WPKH)
* P2SH-P2WSH (P2SH nested P2WSH)
* P2WPKH (Pay-to-Witness-Public-Key-Hash)
* P2WSH (Pay-to-Witness-Script-Hash)
* P2TR (Pay-to-Taproot)

Each address type is represented by a specific version byte and hashbytes format in the recipient structure.


# sBTC Deposit

## Overview

The [sBTC Deposit contract](https://github.com/stacks-network/sbtc/blob/main/contracts/contracts/sbtc-deposit.clar) (`sbtc-deposit.clar`) manages the deposit process for the sBTC system. It handles the validation and minting of sBTC tokens when users deposit Bitcoin, and interacts with the sBTC Registry contract to update the protocol state.

## Constants

* `txid-length`: The required length of a transaction ID (32 bytes).
* `dust-limit`: The minimum amount for a valid deposit (546 satoshis).

## Error Constants

* `ERR_TXID_LEN` (u300): Indicates that the provided transaction ID is not the correct length.
* `ERR_DEPOSIT_REPLAY` (u301): Signifies an attempt to replay a deposit that has already been completed.
* `ERR_LOWER_THAN_DUST` (u302): Indicates that the deposit amount is below the dust limit.
* `ERR_DEPOSIT_INDEX_PREFIX`: Used as a prefix for deposit-related errors in batch processing.
* `ERR_DEPOSIT` (u303): General deposit error.
* `ERR_INVALID_CALLER` (u304): Indicates that the caller is not authorized to perform the operation.

***

## Public Functions

### complete-deposit-wrapper

Processes a single deposit request.

* Parameters:
  * `txid`: `(buff 32)` - The Bitcoin transaction ID
  * `vout-index`: `uint` - The output index of the deposit transaction
  * `amount`: `uint` - The amount of sBTC to mint (in satoshis)
  * `recipient`: `principal` - The Stacks address to receive the minted sBTC
* Returns: `(response bool uint)`

{% stepper %}
{% step %}
**Validation and authorization**

1. Verifies that the caller is the current signer principal.
2. Checks that the deposit amount is above the dust limit.
3. Validates the transaction ID length.
   {% endstep %}

{% step %}
**Replay protection**

4. Ensures the deposit hasn't been processed before (prevents replay).
   {% endstep %}

{% step %}
**Execution**

5. Mints sBTC tokens to the recipient via `.sbtc-token`'s `protocol-mint`.
6. Updates the deposit state in the sBTC Registry contract via `.sbtc-registry`'s `complete-deposit`.
   {% endstep %}
   {% endstepper %}

***

### complete-deposits-wrapper

Processes multiple deposit requests in a single transaction.

* Parameters:
  * `deposits`: `(list 650 {txid: (buff 32), vout-index: uint, amount: uint, recipient: principal})` - List of deposit data
* Returns: `(response uint uint)`

{% stepper %}
{% step %}
**Authorization**

1. Verifies that the caller is the current signer principal.
   {% endstep %}

{% step %}
**Batch processing**

2. Iterates through the list of deposits, processing each one using the `complete-individual-deposits-helper` function.
   {% endstep %}
   {% endstepper %}

***

## Private Functions

### complete-individual-deposits-helper

Helper function to process individual deposits within the batch operation.

* Parameters:
  * `deposit`: `{txid: (buff 32), vout-index: uint, amount: uint, recipient: principal}` - Single deposit data
  * `helper-response`: `(response uint uint)` - Accumulator for tracking processed deposits
* Returns: `(response uint uint)`

{% stepper %}
{% step %}
**Call deposit wrapper**

1. Calls `complete-deposit-wrapper` for the individual deposit.
   {% endstep %}

{% step %}
**Success handling**

2. If successful, increments the processed deposit count.
   {% endstep %}

{% step %}
**Error handling**

3. If an error occurs, it's propagated with additional index information (using `ERR_DEPOSIT_INDEX_PREFIX` or related error constants).
   {% endstep %}
   {% endstepper %}

***

## Interactions with Other Contracts

* `.sbtc-registry`: Calls `get-current-signer-data`, `get-completed-deposit`, and `complete-deposit` to manage deposit state.
* `.sbtc-token`: Calls `protocol-mint` to create new sBTC tokens.

***

## Security Considerations

1. Access Control: Only the current signer principal can call the deposit completion functions.
2. Replay Prevention: The contract checks for previously processed deposits to prevent replay attacks.
3. Dust Limit: Enforces a minimum deposit amount to prevent spam and ensure economic viability.
4. Transaction ID Validation: Ensures the provided transaction ID is the correct length.


# Auxiliary Features

This section covers additional features that enhance the functionality and security of the sBTC system. These auxiliary features contribute to the overall robustness and user-friendliness of the sBTC ecosystem.

{% stepper %}
{% step %}
**Transaction Fee Sponsorship**

Allowing sBTC transactions to be sponsored.
{% endstep %}

{% step %}
**Signer Wallet Rotation**

Enabling secure key rotation for sBTC Signers.
{% endstep %}
{% endstepper %}


# Transaction Fee Sponsorship

Transaction Fee Sponsorship is a feature in sBTC that allows users to pay for Stacks transaction fees using sBTC instead of STX.

## Overview

* sBTC transactions on Stacks can be sponsored in return for some sBTC.
* This feature improves user experience by allowing sBTC holders to use their tokens for gas fees.

## Implementation

The fee sponsorship system is implemented using the approach suggested in [stacks-network/stacks-core#4235](https://github.com/stacks-network/stacks-core/issues/4235).

{% stepper %}
{% step %}
**Sponsor support for fees**

sBTC users can get support from existing STX holders for transaction fees.
{% endstep %}

{% step %}
**Sponsor receives sBTC**

The sponsor pays the STX fee and receives sBTC in return.
{% endstep %}
{% endstepper %}

## User Experience

From a user's perspective:

{% stepper %}
{% step %}
**Opt into fee sponsorship**

When initiating an sBTC transaction, they can opt for fee sponsorship.
{% endstep %}

{% step %}
**Agree to sponsorship terms**

The user agrees to pay a small amount of sBTC for the sponsorship.
{% endstep %}

{% step %}
**Transaction processed**

The transaction is then processed with the fees paid in STX by the sponsor.
{% endstep %}
{% endstepper %}

## Benefits

* Improved UX: Users don't need to hold STX to use sBTC.
* Lower Barrier to Entry: New users can start using sBTC without first acquiring STX.
* Flexibility: Provides an additional option for handling transaction fees.


# Signer Wallet Rotation

Signer wallet rotation allows sBTC signers to update their private keys and modify the signer set composition. This mechanism is how the network maintains security over time and adapts to changing participants.

## How it works

The sBTC system uses a multi-signature wallet on Bitcoin to custody BTC deposits. When the system needs to change who controls this wallet—either by rotating keys or changing the signer set—it uses the rotation mechanism.

As of v1.1.0, the system supports:

* Adding new signers to the set
* Removing existing signers
* Replacing specific signers
* Rotating keys for current signers

When signers agree on a new configuration, the system automatically runs a Distributed Key Generation (DKG) protocol to create new signing shares for the updated group. Once complete, control of the sBTC wallet transfers to the new configuration.

## The rotation process

{% stepper %}
{% step %}
**Signers coordinate off-chain**

Signers agree on the new signer set.
{% endstep %}

{% step %}
**Update configuration**

Each signer operator updates their configuration with the newly decided set.
{% endstep %}

{% step %}
**DKG runs automatically**

Once all signers have configured the exact same set of signers, DKG occurs automatically to generate new signing shares.
{% endstep %}

{% step %}
**New signer set takes control**

The new signer set takes control of the sBTC wallet.
{% endstep %}
{% endstepper %}

The Bitcoin UTXOs remain under continuous control throughout this process—there's no moment where funds are unsecured.

## When rotation occurs

Key rotation typically happens when:

* **Signer changes**: When someone leaves the signer set or new participants join, the configuration must be updated to reflect the new membership.
* **Security events**: If a key might be compromised, an emergency rotation can be initiated to secure the system.


# Walkthroughs

These walkthroughs describe at a high level exactly how users and signers can expect to interact with the sBTC system.

Read these to get a firm understanding of what is actually happening under the hood of the sBTC system.


# Signer Process Walkthrough

## Introduction

This document provides a detailed overview of the sBTC system, focusing on the operations of an sBTC signer node. We'll explore the automated processes and software interactions that occur in the sBTC ecosystem.

A step-by-step guide for setting up and running a sBTC signer node is in the works. This is a conceptual guide to help signers understand what their role looks like in the sBTC system.

## Signer Node Setup

As an sBTC signer, your primary responsibility is to run and maintain a signer node. Here's what that entails:

{% stepper %}
{% step %}
**Hardware setup**

Ensure your node has sufficient computational power and storage.
{% endstep %}

{% step %}
**Software installation**

Install the sBTC signer node software and its dependencies.
{% endstep %}

{% step %}
**Key management**

The node software securely generates and stores the Bitcoin private key and corresponding public key.
{% endstep %}

{% step %}
**Node registration**

Upon first run, the node automatically registers its public key with the sBTC Registry contract on the Stacks blockchain.
{% endstep %}
{% endstepper %}

## Day-to-Day Operations

Once set up, your signer node operates autonomously, performing the following tasks:

{% stepper %}
{% step %}
**Monitoring Deposit Requests**

Your node continuously monitors for sBTC minting requests:

* The node connects to the Bitcoin network and the Stacks blockchain.
* It watches for Bitcoin transactions sent to the sBTC UTXO address.
* When a deposit is detected, the node verifies the transaction details.
  {% endstep %}

{% step %}
**Processing Mint Requests**

Upon confirming a deposit:

* The node automatically prepares a signature for the mint operation using its private key.
* It submits this signature to the sBTC Deposit contract on the Stacks blockchain.
* The contract verifies the signature and combines it with signatures from other signer nodes.
* Once enough valid signatures are collected, the contract mints the corresponding amount of sBTC.
  {% endstep %}

{% step %}
**Handling Withdrawal Requests**

For sBTC withdrawal requests:

* The node monitors the sBTC Withdrawal contract for new requests.
* Upon detecting a request, it verifies the user's sBTC balance and the request's validity.
* The node automatically signs the withdrawal operation and submits its signature.
* Once enough signatures are collected and the sBTC is burned, the node participates in creating and signing a Bitcoin transaction to fulfill the withdrawal.
* The signed Bitcoin transaction is broadcast to the Bitcoin network.
  {% endstep %}
  {% endstepper %}


# sBTC Transaction Walkthrough

Let's follow the journey of 1 BTC as it moves through the sBTC system, from initial deposit to final withdrawal.

## Part 1: Deposit (BTC → sBTC)

{% stepper %}
{% step %}
**Initiation**

* Alice decides to convert 1 BTC to sBTC to participate in Stacks DeFi.
* Alice creates a deposit transaction on the Bitcoin network (typically via a UI such as the sBTC bridge or a DeFi application).
* The transaction enters the Bitcoin mempool.
  {% endstep %}

{% step %}
**Proof Submission**

* Alice submits proof of her deposit to the Deposit API (usually via the application's UI).
* The Deposit API sets the deposit status to PENDING.
  {% endstep %}

{% step %}
**Signer Validation**

The sBTC Signer Set:

* Detects the deposit.
* Validates the UTXO format.
* Votes on the deposit.

If the deposit is rejected:

* Signers notify the API of the rejection.
* The Deposit API updates the status to FAILED.

If the deposit is accepted:

* The Deposit API updates the status to ACCEPTED.
  {% endstep %}

{% step %}
**Bitcoin Transaction**

If accepted, the sBTC Signer Set:

* Creates a new Bitcoin transaction consuming Alice's deposited BTC.
* Broadcasts this transaction to the Bitcoin network.

If this transaction fails:

* Signers notify the API of the failure.
* The Deposit API updates the status to FAILED.
  {% endstep %}

{% step %}
**sBTC Minting**

Upon successful Bitcoin transaction:

* The sBTC Signer Set interacts with the Stacks blockchain.
* They fulfill the deposit by minting 1 sBTC to Alice's Stacks address.
  {% endstep %}

{% step %}
**Confirmation**

* The Deposit API updates the deposit status to CONFIRMED.
* Alice now has 1 sBTC in her Stacks wallet.
  {% endstep %}
  {% endstepper %}

***

## Part 2: sBTC Usage

Alice can now use her 1 sBTC in the Stacks ecosystem:

* Transfer it to other users via the `sbtc-token` contract (typically via an application UI).
* Participate in DeFi applications.
* Use it in any application that supports SIP-010 tokens.

***

## Part 3: Withdrawal (sBTC → BTC)

{% stepper %}
{% step %}
**Initiation**

* Alice initiates a withdrawal by interacting with the Clarity contract on the Stacks blockchain.
* She specifies her Bitcoin address for the withdrawal.
* If successful, the contract locks her sBTC and the withdrawal status is set to PENDING.
* If the transaction fails, no withdrawal occurs.
  {% endstep %}

{% step %}
**Signer Validation**

The sBTC Signer Set:

* Detects the withdrawal request.
* Decides whether to accept or reject the withdrawal.

If the withdrawal is rejected:

* Signers unlock the sBTC.
* The withdrawal status is updated to FAILED.

If the withdrawal is accepted:

* The withdrawal status is updated to ACCEPTED.
* Signers wait for 6 Bitcoin block confirmations (for security purposes).
  {% endstep %}

{% step %}
**Bitcoin Transaction**

After the waiting period, if accepted:

* The sBTC Signer Set creates a new Bitcoin transaction fulfilling Alice's withdrawal.
* They broadcast this transaction to the Bitcoin network.

If this transaction fails:

* Signers unlock the sBTC.
* The withdrawal status is updated to FAILED.
  {% endstep %}

{% step %}
**sBTC Burning and Confirmation**

Upon successful Bitcoin transaction:

* The sBTC Signer Set burns the locked 1 sBTC on the Stacks blockchain.
* The withdrawal status is updated to CONFIRMED.
  {% endstep %}

{% step %}
**Completion**

* Alice now has her 1 BTC back in her specified Bitcoin address.
* The withdrawn sBTC has been permanently removed from circulation.
  {% endstep %}
  {% endstepper %}


# How to Earn sBTC Rewards

{% hint style="danger" %}
The last day for earning rewards through the sBTC Rewards Program will be on November 4, 2025. But don’t worry, you can earn even more sBTC with [Dual Stacking](https://docs.stacks.co/learn/dual-stacking) - a new way to stack both STX and sBTC to create stronger alignment between Bitcoin capital and the Stacks network.
{% endhint %}

As part of the launch of sBTC, you can enroll in the sBTC rewards program and earn real yield on your BTC, paid in sBTC.

The rewards program is non-custodial — your sBTC remains in your wallet.

There are only 3 steps to participate in the sBTC rewards.

{% stepper %}
{% step %}
**Mint sBTC**

To get started, first mint your sBTC by using the bridge at [sbtc.stacks.co](https://sbtc.stacks.co/).
{% endstep %}

{% step %}
**Connect your wallet**

After your sBTC has been minted to your wallet, visit the rewards program site at [bitcoinismore.org](https://bitcoinismore.org/) and connect your wallet. Then click the "Earn Rewards" button.

<figure><img src="https://github.com/stacks-network/docs/blob/master/docs/learn/sbtc/.gitbook/assets/image%20(4).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
You may need to enable the sBTC token listing display in your wallet before it is visible. In Leather, you can do this by clicking "Manage Tokens" and toggling on sBTC.

<img src="https://github.com/stacks-network/docs/blob/master/docs/learn/sbtc/.gitbook/assets/image%20(3).png" alt="" data-size="original">
{% endhint %}
{% endstep %}

{% step %}
**Enroll in the rewards program**

Finally, execute a Stacks transaction using your connected wallet to enroll in the program. You will need enough STX to cover the transaction fee to enroll in the rewards program.

<figure><img src="https://github.com/stacks-network/docs/blob/master/docs/learn/sbtc/.gitbook/assets/image%20(5).png" alt=""><figcaption></figcaption></figure>
{% endstep %}
{% endstepper %}


# Using the sBTC Bridge App

Start bridging over your BTC into sBTC on Stacks with the official sBTC Bridge app.

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-559c3cfed55c4e4d757873ef67050886cb27b878%2Fimage.png?alt=media" alt=""><figcaption><p><a href="https://sbtc.stacks.co/">https://sbtc.stacks.co/</a></p></figcaption></figure>

The purpose of the user-facing sBTC Bridge app is to facilitate seamless and secure conversion between BTC and sBTC. You can deposit (peg-in) your BTC into sBTC. Or you can withdraw (peg-out) your sBTC back into BTC. The app also provides an intuitive interface for safely managing the history of your transactions.

{% hint style="info" %}
The official sBTC Bridge app is found at <https://sbtc.stacks.co/>
{% endhint %}

Refer to the following guides below to learn how you can securely convert your BTC into sBTC.

* [How to Use the sBTC Bridge with Xverse/Leather](https://docs.stacks.co/learn/sbtc/using-the-sbtc-bridge-app/how-to-use-the-sbtc-bridge)
* [How to Use the sBTC Bridge with Fordefi](https://docs.stacks.co/learn/sbtc/using-the-sbtc-bridge-app/how-to-use-the-sbtc-bridge-with-fordefi)
* [How to Use the sBTC Bridge with Asigna](https://docs.stacks.co/learn/sbtc/using-the-sbtc-bridge-app/how-to-use-the-sbtc-bridge-with-asigna)


# How to Use the sBTC Bridge with Xverse/Leather

The sBTC bridge is a web application allowing you to convert your BTC into sBTC on the Stacks chain.

{% hint style="danger" %}
Ensure that you are using the bridge located at [sbtc.stacks.co](https://sbtc.stacks.co/). This is the only official sBTC bridge.
{% endhint %}

If you aren't familiar with sBTC, be sure to check out the [sBTC Conceptual Guide](https://docs.stacks.co/learn/sbtc) to understand how it works.

The bridge has been designed to be as simple as possible to use. In order to utilize sBTC, all you need to do is send a Bitcoin transaction using a supported wallet (like [Leather](https://leather.io/) or [Xverse](https://www.xverse.app/)). This guide will show screenshots of Xverse but the flow is the same if using Leather as well.

Below you'll find both a video and written walkthrough of using the bridge.

### Video Walkthrough

{% embed url="<https://youtu.be/XZruuDgTo4k>" %}

### Written Walkthrough

There are 5 simple steps to convert your BTC to sBTC.

{% stepper %}
{% step %}
**Connect your wallet**

First, you'll need to connect your wallet to the bridge UI. Currently Leather and Xverse are supported, with more on the way.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-8f6083d420c2ef0d94f229b5a179f5cebff75632%2Fimage%20(9)-sbtc-bridge.png?alt=media" alt=""><figcaption></figcaption></figure></div>
{% endstep %}

{% step %}
**Choose the amount to deposit**

After your wallet is connected, choose how much BTC you would like to convert to sBTC.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-8177a768393bd7505be951136ecaf1ba70719264%2Fimage%20(10)-sbtc-bridge.png?alt=media" alt=""><figcaption></figcaption></figure></div>

{% hint style="info" %}
There are two transaction fees required to mint your sBTC. The first is set by the user manually when they initiate the deposit transaction within their wallet. The second is a fee used to consolidate the deposit UTXOs into the single signer UTXO. This separate transaction fee happens automatically and is set to a max of 80k sats. This is automatically deducted from your minted sBTC. This is not a signer fee but a regular Bitcoin transaction fee.
{% endhint %}
{% endstep %}

{% step %}
**Choose the Stacks address to mint to**

Next, enter the Stacks address you would like your sBTC minted to.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-ac78447329ceb9f3e2a07a6dc3e9c5a0dc53be3c%2Fimage%20(11)-sbtc-bridge.png?alt=media" alt=""><figcaption></figcaption></figure></div>
{% endstep %}

{% step %}
**Initiate the transaction**

After you choose your Stacks address, you'll use your connected wallet to transfer the BTC.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-9210b58c1ab51f4f105f90c0f5c96e3cb694a8e5%2Fimage%20(12)-sbtc-bridge.png?alt=media" alt=""><figcaption></figcaption></figure></div>
{% endstep %}

{% step %}
**Receive your sBTC**

In the UI, you can monitor the status of your transaction to see when it has been completed, at which point you can see the sBTC in your wallet. It will go through three stages:

* Pending - Your Bitcoin transaction is processing
* Minting - Your Bitcoin transaction has processed and the sBTC signers are minting your sBTC
* Completed - Your sBTC has been minted to your wallet

Note that you may need to enable the display of the sBTC token within your wallet by clicking on 'Manage Tokens' and enabling sBTC.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-715ec833fe1c9ef9d08f432fbc302c5e710585dc%2Fimage%20(13)-sbtc-bridge.png?alt=media" alt=""><figcaption></figcaption></figure></div>
{% endstep %}
{% endstepper %}

### Reclaiming BTC

If your sBTC mint fails, you can reclaim your sBTC. You can do this via the bridge by visiting the reclaim page at <https://sbtc.stacks.co/\\>\<TX\_ID>/reclaim and replacing the bracketed text with your transaction ID, eg. <https://sbtc.stacks.co/8f37f750b6646f0a217121201967170bd3cfef5f2ebd4f30f359b5e9308470c4/reclaim>

There is an intermediate step in between depositing BTC and the sBTC signers consolidating it into the single signer UTXO. If the transaction is not picked up by signers, you can reclaim it using this UI. Note there is a 'Lock Time' field on the Reclaim page. That indicates the amount of blocks that must have passed in order to reclaim your BTC.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-514951c8b0d9633e03d2c3aa3c95cd381b85201c%2Fimage%20(14)-sbtc-bridge.png?alt=media" alt=""><figcaption></figcaption></figure></div>

This initiates a Bitcoin transaction that will transfer your BTC back to you.


# How to Use the sBTC Bridge with Fordefi

{% hint style="warning" %}
This guide is specifically for entities or teams that use [Fordefi](https://fordefi.com/) as it will demonstrate the flow for a multi-approval transaction policy setup. This assumes you have the Fordefi wallet setup with its browser extension and with its mobile app.
{% endhint %}

The sBTC Bridge is a web application allowing you to convert your BTC into sBTC on the Stacks chain. If you aren't familiar with sBTC, be sure to check out the [sBTC Conceptual Guide](https://docs.stacks.co/learn/sbtc) to understand how it works.

{% hint style="danger" %}
Ensure that you are using the bridge located at [sbtc.stacks.co](https://sbtc.stacks.co/). This is the only official sBTC bridge.
{% endhint %}

The sBTC Bridge has been designed to be as simple as possible to use. But specifically for this guide, a **2-of-2 approval transaction policy**, targeting Bitcoin transactions, has already been setup in the Fordefi UI. It is assumed you have a similar setup as this guide will walkthrough the different steps needed to take in such a scenario where multiple parties need to approve a transaction.

If you need assistance in setting up such a transaction policy in Fordefi, check out their dedicated [docs](https://docs.fordefi.com/user-guide/policies).

### Walkthrough for minting sBTC

Here are the necessary steps to convert your BTC to sBTC using Fordefi:

{% stepper %}
{% step %}
**Confirm your BTC and STX vaults**

First, you'll need to make sure you have a vault for Bitcoin, and a separate vault for Stacks. Both of these vaults will be used later when connecting with the sBTC Bridge app.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-b9cb30d7a1b85399a22372827e8ee28734029e6f%2Fimage%202-with-fordefi.png?alt=media" alt=""><figcaption><p>A vault for native Bitcoin assets</p></figcaption></figure></div>

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-6d0423b88b96c6653c45f0e8aab4e1f506940d8a%2Fimage%203-with-fordefi.png?alt=media" alt=""><figcaption><p>A vault for native Stacks assets</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Connect your Fordefi wallet extension**

First, you'll need to connect your Fordefi wallet to the sBTC Bridge app.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-3842a7c913fb40abeb1e4ca5ddb655c3d0f44c33%2Fimage%204-with-fordefi.png?alt=media" alt=""><figcaption><p>Choose the option for Fordefi in the wallet selector modal</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Choose which Bitcoin and Stacks vault you want to use**

Next, the Fordefi extension will want you to select which Bitcoin vault, and then which Stacks vault you'd want to use. The reasoning for this is because you'll be needing to send a bitcoin transaction first from your Bitcoin vault, then you'll be receiving sBTC to your Stacks vault.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-6edd5519d73eaf4e3160dc8d060de615b24c70ef%2Fimage%205-with-fordefi.png?alt=media" alt=""><figcaption><p>The selected Bitcoin vault needs to have at least the minimum required amount (0.001 BTC) of bitcoin to peg-in</p></figcaption></figure></div>

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-55f9302b8362b1278bc2dcd5842bd1b802376b0a%2Fimage%206-with-fordefi.png?alt=media" alt=""><figcaption><p>When both vaults are selected, you'll be able to see both at the top of the Fordefi extension when connected</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Choose the amount of BTC to deposit**

After your wallet is connected, choose how much BTC you would like to convert to sBTC.

{% hint style="info" %}
There are two transaction fees required to mint your sBTC. The first is when they initiate the bitcoin deposit transaction within their wallet. The second is a fee used to consolidate the deposit UTXOs into the single Signer's UTXO. This separate transaction fee happens automatically and is set to a max of 80k sats. This is automatically deducted from your minted sBTC. This is not a Signer fee but a regular bitcoin transaction fee.
{% endhint %}

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-26d2b2a603740e301561d5b437a6cea7f3c65f3f%2Fimage%207-with-fordefi.png?alt=media" alt=""><figcaption></figcaption></figure></div>
{% endstep %}

{% step %}
**Choose the Stacks address to mint the sBTC to**

Next, enter the Stacks address you would like your sBTC minted to. This will just be the Stacks address associated with the Stacks vault that you selected earlier when connecting your Fordefi wallet extension.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-1d60b4bce29e269849950e640f8295bd26cfb18b%2Fimage%208-with-fordefi.png?alt=media" alt=""><figcaption><p>Review the inputted STX address and then confirm</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Create initial BTC transfer**

Your Fordefi wallet extension will pop up prompting you to create the BTC transaction. This transaction is the initial peg-in transfer for your BTC to the sBTC Signers. Hit 'Create' after you confirm the transaction details and necessary approval details.

{% hint style="info" %}
If you have a transaction policy setup with certain approvals required, hitting 'Create' will not initiate the bitcoin transaction, it will simply store this unsigned transaction in your Fordefi wallet until all necessary approvals are met and then finally signed.
{% endhint %}

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-01595e7d39d4b7d5873edf6c77dabfc613d3d045%2Fimage%2011-with-fordefi.png?alt=media" alt=""><figcaption><p>You'll notice near the bottom of the Create Transaction view of the Fordefi extension is the required approval details. Be certain the other approvers are available to approve the transaction in a timely manner.</p></figcaption></figure></div>

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-5bfe3c487a3806dffa2caf9efb607292224479df%2FGroup%20316124778%20(1)-with-fordefi.png?alt=media" alt=""><figcaption><p>If you ever navigate back to your Fordefi web UI or extension UI, you'll notice this transaction will be marked as 'Pending approval'.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Approve transaction by approvers**

Upon notice of transaction to approvers, each approver will need to approve transaction in their Fordefi mobile wallets before the completion of the final step, which is signing the transaction by the initiator.

Each approver will need to pull up the pending transaction in their Fordefi mobile wallet and hit 'Approve'.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-9b806f1b58f58f5052a69b1396b27299f1db8366%2FGroup%20316124778%20(2)-with-fordefi.png?alt=media" alt=""><figcaption><p>POV of approving transaction by approver</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Sign approved transaction**

Once all transaction policies are satisfied and approved, the initiator will need to officially sign the transaction in their Fordefi mobile wallet.

This mobile signature action will then notify the sBTC Bridge app.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-3319d3c070cef54c71d8a2ffa23ee4e50d9d6493%2FGroup%20316124778%20(3)-with-fordefi.png?alt=media" alt=""><figcaption><p>The initiator will need to hit 'Sign' once approvals and transaction details are confirmed</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Receive your sBTC**

Back in the sBTC Bridge app UI, you can monitor the status of your transaction to see when it has been completed, at which point you can see the sBTC in your Fordefi wallet. It will go through three stages:

* Pending - Your [Bitcoin transaction](https://mempool.space/tx/6b5e63fbe4e4a4835dcf096ca2d2a8c112898692e28a4c5b38cb39e3e9837604) is processing
* Minting - Your Bitcoin transaction has processed and the [sBTC signers are minting](https://explorer.hiro.so/txid/a9e232289d2c6e50150b034894182d341343e7064b27c8dccbd25ebca79b2947?chain=mainnet) your sBTC
* Completed - Your sBTC has been minted to your wallet

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-099e6b71c7f44d9ce44da3021f013d331fcf1387%2Fimage%2016-with-fordefi.png?alt=media" alt=""><figcaption><p>The bitcoin and sBTC transactions will take some time to be completely processed by the Signers</p></figcaption></figure></div>

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-ff2615e1140651852f8fae8e3b28e3ed81f0f65e%2Fimage%2022-with-fordefi.png?alt=media" alt=""><figcaption><p>Once both the bitcoin and sBTC mint transactions are confirmed, the sBTC Bridge app will show a 'Complete' status</p></figcaption></figure></div>

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-86eb052ce8d5d34a9132728d15f3cbe5a6e81888%2FGroup%20316124778%20(4)-with-fordefi.png?alt=media" alt=""><figcaption><p>You'll be able to see the results of these transactions in your Fordefi wallet</p></figcaption></figure></div>
{% endstep %}
{% endstepper %}

### Reclaiming BTC

If your sBTC mint fails, you can reclaim your sBTC. You can do this via the bridge by visiting the reclaim page at <https://sbtc.stacks.co/\\>\<TX\_ID>/reclaim and replacing the bracketed text with your transaction ID as shown below:\
<https://sbtc.stacks.co/8f37f750b6646f0a217121201967170bd3cfef5f2ebd4f30f359b5e9308470c4/reclaim>

There is an intermediate step in between depositing BTC and the sBTC signers consolidating it into the single signer UTXO. If the transaction is not picked up by signers, you can reclaim it using this UI. Note there is a 'Lock Time' field on the Reclaim page. That indicates the amount of blocks that must have passed in order to reclaim your BTC.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-514951c8b0d9633e03d2c3aa3c95cd381b85201c%2Fimage%20(14)-sbtc-bridge.png?alt=media" alt=""><figcaption></figcaption></figure></div>

This initiates a Bitcoin transaction that will transfer your BTC back to you.


# How to Use the sBTC Bridge with Asigna

{% hint style="warning" %}
This guide is specifically for entities or teams that use [Asigna](https://www.asigna.io/) as it will demonstrate the flow for a multi-signature setup. This assumes you have the Asigna web wallet setup with its browser extension.
{% endhint %}

The sBTC Bridge is a web application allowing you to convert your BTC into sBTC on the Stacks chain. If you aren't familiar with sBTC, be sure to check out the [sBTC Conceptual Guide](https://docs.stacks.co/learn/sbtc) to understand how it works.

{% hint style="danger" %}
Asigna has the sBTC Bridge as an embedded app within its web wallet. This guide will be using that embedded app.
{% endhint %}

The sBTC Bridge has been designed to be as simple as possible to use. But specifically for this guide, a **2-of-2 multi-signature setup of a Bitcoin vault AND a separate Stacks vault**. It is assumed you have a similar setup as this guide will walkthrough the different steps needed to take in such a scenario where 2 parties of this 2-of-2 multi-signature setup need to sign transactions.

### Walkthrough for minting sBTC

Here are the necessary steps to convert your BTC to sBTC using Asigna:

{% stepper %}
{% step %}
**Confirm your BTC and STX vaults**

First, you'll need to make sure you have a vault for Bitcoin, and a separate vault for Stacks. In this scenario, the same 2-of-2 signature setup are applied for both vaults. Throughout the guide, we'll refer to each party of this setup as Member\_1 and Member\_2.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-72f2b66bcc201f7fe5dfcc444b40fa92c6bdb58f%2FGroup%20316124779-with-asigna.png?alt=media" alt=""><figcaption><p>Member_2's POV of both its Bitcoin vault and Stacks vault setup.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Navigate and open the embedded sBTC Bridge app in Bitcoin vault**

Click into the Bitcoin vault and scroll down to the 'Trending Apps' section where you'll locate the sBTC Bridge embedded app. Open this embedded app and choose the 'Asigna Multisig' wallet to connect with.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-c61a905f630669f69095234fa2db6c116a5aff34%2Fimage%2033%20(1)-with-asigna.png?alt=media" alt=""><figcaption><p>Locate the sBTC Bridge embedded app and open it.</p></figcaption></figure></div>

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-e37f5211d0ed40789a7c9715e74ad31b2207e068%2Fimage%2035-with-asigna.png?alt=media" alt=""><figcaption><p>Connect with the Asigna Multisig wallet option. This app will auto connect with the Bitcoin vault that is being using in this context of the embedded app. You won't need to connect to a Stacks vault but you will need a Stacks vault address to use as the receiving address of the minted sBTC.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Choose the amount of BTC to deposit**

After your Bitcoin vault is connected, choose how much BTC you would like to convert to sBTC.

{% hint style="info" %}
There are two transaction fees required to mint your sBTC. The first is when they initiate the bitcoin deposit transaction within their wallet. The second is a fee used to consolidate the deposit UTXOs into the single Signer's UTXO. This separate transaction fee happens automatically and is set to a max of 80k sats. This is automatically deducted from your minted sBTC. This is not a Signer fee but a regular bitcoin transaction fee.
{% endhint %}

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-45a57ac76a7839329f2b20c20cd62fc907c0bc95%2Fimage%2036-with-asigna.png?alt=media" alt=""><figcaption><p>Currently the minimum to peg-in is 0.001 BTC.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Choose the Stacks address from the Stacks vault**

Next, enter the Stacks address you would like your sBTC minted to. For this guide, we'll be using the Stacks address of the Stacks vault that is assumed to be setup by both Member\_1 and Member\_2.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-748ca889959123b46f9d3662a8c84198f6f3caca%2Fimage%2037-with-asigna.png?alt=media" alt=""><figcaption><p>Copy the multi-signature Stacks address from the Stacks vault setup.</p></figcaption></figure></div>

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-b676da7c7e65c054cc3bac9c5698762de9852bcf%2Fimage%2038-with-asigna.png?alt=media" alt=""><figcaption><p>Review the inputted STX address, hit 'NEXT', and then 'CONFIRM'.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Select Fee Rate**

Depending on congestion of the Bitcoin network, choose the appropriate fee rate based on your vault's preferences for timely confirmation.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-d06a74bc72d23271c1d7e5b1ae9d015062254c88%2FGroup%20316124780-with-asigna.png?alt=media" alt=""><figcaption></figcaption></figure></div>
{% endstep %}

{% step %}
**Confirm the transaction creation**

Whomever member, of the 2-of-2 multi-signature setup, is currently acting as the context of the sBTC Bridge embedded app, a popup modal of that member's wallet will appear for confirmation. In this guide, is it Member\_1 that is acting as the context and is currently connected with the Bitcoin vault using Xverse. Therefore, the Xverse wallet popup will appear for confirmation.

Remember, this transaction is the initial peg-in transfer for your BTC to the sBTC Signers.

{% hint style="info" %}
If you have a multi-signature setup with certain signatures required, hitting 'Confirm' will not broadcast the bitcoin transaction, it will simply store this partially signed transaction in your Bitcoin vault until all required signatures are met.
{% endhint %}

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-660e9484341b9d6a54dfe0d625958696e7ce03fe%2FGroup%20316124780%20(1)-with-asigna.png?alt=media" alt=""><figcaption><p>Review the transaction and hit confirm to create the partially signed bitcoin transaction where it will be waiting for the other members to sign in their respective Asigna Bitcoin vaults.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Sign and approve transaction by other members**

Upon notice of transaction to the other members of the multi-signature setup, each necessary member will need to approve the pending transaction in their own respective Asigna Bitcoin vaults.

In our case, Member\_2 will navigate to their own Bitcoin vault and find the pending partially signed bitcoin transaction waiting for signature.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-16b82a5480bdee3f17e30a62f376c7f9af399e02%2Fimage%2042%20(1)-with-asigna.png?alt=media" alt=""><figcaption><p>Member_2 will locate the pending transaction and complete signature as their approval.</p></figcaption></figure></div>

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-8e5cfbc05ef64393bc3add29ac225f45686a9c91%2Fimage%2043%20(1)-with-asigna.png?alt=media" alt=""><figcaption><p>Member_2 will see their connected wallet, in this case Leather, popup for them to confirm transaction.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Broadcasting of transaction**

Once all transaction policies are satisfied and approved, the sBTC Bridge embedded app will appear with a prompt confirming that all signatures have been gathered successfully which will then automatically prompt the broadcasting of the transaction.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-e09c9131d47ee49ac08fb2c70e4f3fe634d46045%2Fimage%2044-with-asigna.png?alt=media" alt=""><figcaption><p>Great! All signatures have been gathered for the transaction to be broadcasted.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Receive your sBTC**

Back in the sBTC Bridge app UI, you can monitor the status of your transaction to see when it has been completed, at which point you can see the sBTC in your Fordefi wallet. It will go through three stages:

* Pending - Your [Bitcoin transaction](https://mempool.space/tx/838ebd2c78091ca805ff00c2a2182d2e9c652bd9b43ef286c3af33d1a414f587) is processing
* Minting - Your Bitcoin transaction has processed and the [sBTC signers are minting](https://explorer.hiro.so/txid/fef3dd3f6d4e6c89f3482fdec3816822261f29739ee81d1af6deb01d11e43961?chain=mainnet) your sBTC
* Completed - Your sBTC has been minted to your Asigna Stacks vault wallet

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-30ad78dfbefa746278ebd2fa02251f99c8e67cf8%2Fimage%2045%20(1)-with-asigna.png?alt=media" alt=""><figcaption><p>The bitcoin and subsequent sBTC mint transaction will take some time to be completely processed by the Signers</p></figcaption></figure></div>

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-c78859d24f4a85d936dd5733ff4b52c060a30b80%2Fimage%2046-with-asigna.png?alt=media" alt=""><figcaption><p>Once both the bitcoin and sBTC mint transactions are confirmed, the sBTC Bridge app will show a 'Completed' status</p></figcaption></figure></div>

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-186243f9cff3ae45ff9cf9e6fb58c8415644781c%2Fimage%2047-with-asigna.png?alt=media" alt=""><figcaption><p>You'll then be able to see the sBTC balance in your Asigna Stacks vault.</p></figcaption></figure></div>
{% endstep %}
{% endstepper %}

### Reclaiming BTC

If your sBTC mint fails, you can reclaim your sBTC. You can do this via the bridge by visiting the reclaim page at <https://sbtc.stacks.co/\\>\<TX\_ID>/reclaim and replacing the bracketed text with your transaction ID as shown below:\
<https://sbtc.stacks.co/8f37f750b6646f0a217121201967170bd3cfef5f2ebd4f30f359b5e9308470c4/reclaim>

There is an intermediate step in between depositing BTC and the sBTC signers consolidating it into the single signer UTXO. If the transaction is not picked up by signers, you can reclaim it using this UI. Note there is a 'Lock Time' field on the Reclaim page. That indicates the amount of blocks that must have passed in order to reclaim your BTC.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-514951c8b0d9633e03d2c3aa3c95cd381b85201c%2Fimage%20(14)-sbtc-bridge.png?alt=media" alt=""><figcaption></figcaption></figure></div>

This initiates a Bitcoin transaction that will transfer your BTC back to you.


# Security Model of sBTC

Explaining the security model of sBTC

### sBTC Security: A Multi-layered Approach

Security is the foundation of this rollout. Partnerships with top-tier security experts have been established to ensure the protocol is fortified at every level:

1. **Asymmetric Research**: Known for their rigorous research and top embedded security researchers, Asymmetric brings security expertise to sBTC to identify and mitigate potential vulnerabilities.
2. **ImmuneFi**: A robust bug bounty program incentivizes ethical hackers to uncover and address potential issues, adding an additional layer of defense. ImmuneFi is the [leading crowdsource bounty platform for DeFi](https://stacks.org/best-and-brightest-sbtc#immunefi).
3. **3rd Party Audits**: Independent audit reports have been made for additional security reviews, ensuring the protocol is thoroughly vetted by external experts.

### The components that make up the security model of sBTC

#### **sBTC Signer Network**

The sBTC Signer network is a decentralized group of entities responsible for managing the locking and unlocking of BTC during the minting and redemption of sBTC. This network operates in a distributed manner to enhance security and reduce the risks associated with centralized custodians.

Signers are responsible for approving all sBTC deposit and withdrawal operations, ensuring the integrity of the system. With a requirement of 70% consensus for transaction approval, Signers maintain the protocol's liveness and security.\
\
As approved by the Stacks community via [SIP-028](https://github.com/stacksgov/sips/blob/69d40a5f4f0ad98eb448ba44e7c31ca054820aa3/sips/sip-028/sip-028-sbtc_peg.md), the criteria for selecting signers include technical expertise, reliability, performance, and decentralization. An initial set of 15 institutional Signers will be used in Phase 1 to maintain simplicity and minimize operational risks. This group will grow as the protocol evolves.\
\
As sBTC evolves, the Signer set will transition to a fully decentralized model, further strengthening the protocol's resilience.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-3a3b31caabb095da66e2ad2811b91c397dbfab6c%2Fimage.png?alt=media" alt=""><figcaption><p>source: <a href="https://bitcoinl2labs.com/sbtc-rollout#sbtc-signers">Bitcoin L2 Labs</a></p></figcaption></figure></div>

For more info on who the sBTC Signers are, check out this section on the Bitcoin L2 Labs website [here](https://bitcoinl2labs.com/sbtc-rollout#sbtc-signers).

#### **Trust-Minimized Bridge Model**

The trust-minimized bridge model for sBTC ensures that the exchange between BTC and sBTC happens without relying on a single entity. Instead, it leverages cryptographic proofs and smart contracts on the Stacks blockchain, allowing for secure and transparent conversion processes.

The permissionless nature of the sBTC model empowers Bitcoin holders to freely peg their BTC into sBTC and vice versa. This process utilizes a decentralized network of Signers along with smart contracts, eliminating the need for centralized custody or intermediaries. Bitcoin holders initiate a peg by sending BTC to a predetermined address, automatically triggering the issuance of an equivalent amount of sBTC on the Stacks blockchain. Similarly, holders can burn their sBTC, prompting the smart contracts to release BTC back to their control. This model enhances user autonomy and aligns with the decentralized ethos of Bitcoin.

#### **Bitcoin Finality and Stacks**

Stacks' Bitcoin Finality mechanism aligns sBTC's security closely with Bitcoin itself. By anchoring blocks and transactions to the Bitcoin blockchain, this ensures that the finality and security of asset holdings on Stacks are as robust as those on the Bitcoin network. This integration helps maintain trust and stability for sBTC within the broader Bitcoin ecosystem.

### How sBTC's security contrasts with other wrapped Bitcoin alternatives

While the sBTC model leverages decentralization to minimize trust, other wrapped Bitcoin solutions often face centralization risks. Typically, these alternatives rely on a centralized custodian to hold the underlying BTC, introducing a significant point of failure. Such custodians act as the trust anchor in the conversion process, which can potentially lead to issues such as censorship, mismanagement, or even security breaches. As a result, these models may not fully align with the decentralized principles of Bitcoin, posing challenges to the security and autonomy intended for Bitcoin holders.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-d79336d2e24f391daaeef9f8814b8932d601a731%2Fimage.png?alt=media" alt=""><figcaption><p>source: <a href="https://www.stacks.co/sbtc">stacks.co</a></p></figcaption></figure></div>

***

#### Resources

* \[[Stacks Roadmap](https://stacksroadmap.com/#sbtc)] Upcoming technical advancements and security designs for sBTC
* \[[Hiro Blog](https://www.hiro.so/blog/sbtc-vs-wbtc-a-comparison-of-tokenized-bitcoin)] sBTC vs WBTC: A Comparison of Tokenized Bitcoin&#x20;


# sBTC Audits

Several third-party security audits have been conducted on the sBTC system and can be referenced here.

{% file src="<https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-b3929dbb3984758aec1a4236ffb21bfe7e556e3a%2FOttersec%20-%20WSTS.pdf?alt=media>" %}

{% file src="<https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-b093ed87bffaefb052a1d8b9544a3b6cdf7cc91d%2FOttersec%20-%20sBTC%20Withdrawal.pdf?alt=media>" %}

{% file src="<https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-1b73a0857ef6ff21bfa24cc4982fdee88313d46c%2FCoinFabrik_WSTS.pdf?alt=media>" %}

{% file src="<https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-46fb8bb7ca5e38063b45b9491b8699fc230c9e69%2FClarity%20Alliance%20-%20sBTC.pdf?alt=media>" %}


# sBTC FAQ

### sBTC Basics

<details>

<summary>What is sBTC?</summary>

sBTC is a decentralizedl 1:1 Bitcoin-backed asset on the Stacks Bitcoin Layer. Read more about Stacks [here](https://www.stacks.co/) and sBTC [here](https://www.stacks.co/sbtc).

</details>

<details>

<summary>How does sBTC work?</summary>

sBTC as a SIP-010 tokensBTC is a SIP-010 token on the Stacks blockchain that represents Bitcoin (BTC) in a 1:1 ratio. sBTC is always backed 1:1 against BTC.Peg wallet and signersThe sBTC peg wallet is maintained and managed by a set of sBTC signers. This decentralized approach enhances security and reduces single points of failure. Read more about Stacker Signing here.

</details>

<details>

<summary>What is Bitcoin Finality, and why is it important?</summary>

Stacks and sBTC state automatically fork with Bitcoin. As such, all transactions settle to Bitcoin with 100% Bitcoin Finality. This protects users against attacks to sBTC via a hard fork. This is a critical security measure that aligns sBTC security with Bitcoin. Read more in [the Stacks Documentation](https://docs.stacks.co/concepts/block-production/bitcoin-finality).

</details>

<details>

<summary>How does the Stacks Signer network improve security?</summary>

Signers are responsible for approving all sBTC deposit and withdrawal operations, ensuring the integrity of the system. With a requirement of 70% consensus for transaction approval, Signers maintain the protocol's liveness and security.

To launch sBTC, the Stacks community approved [SIP-028](https://github.com/stacksgov/sips/blob/69d40a5f4f0ad98eb448ba44e7c31ca054820aa3/sips/sip-028-sbtc_peg.md), defining the criteria for selecting signers based on factors such as technical expertise, reliability, performance, and decentralization. An initial group of 15 institutional Signers has been chosen for Phase 1 to maintain simplicity and reduce operational risks. This group will expand over time as the protocol matures.

The list of sBTC signers is public and listed [here](https://bitcoinl2labs.com/sbtc-rollout#sbtc-signers).

</details>

<details>

<summary>What security measures have been put in place to ensure sBTC is safe?</summary>

sBTC is always backed 1:1 against BTC, and it's verifiably secure through threshold cryptography. sBTC removes the need for 3rd party custodian or trusted setup. Instead, BTC is secured by a decentralized signer set.

Partnerships with top-tier security experts have been established to ensure the protocol is fortified at every level:

Asymmetric Research is a core security contributor. Known for their rigorous research and protocol audits, Asymmetric brings security expertise to sBTC to identify and mitigate potential vulnerabilities. ImmuneFiA robust bug bounty program incentivizes ethical hackers to uncover and address potential issues, adding an additional layer of defense. 3rd Party AuditsSeveral third-party security audits have been conducted on the sBTC system and can be referenced on the sBTC Audits page.

</details>

<details>

<summary>What sets sBTC apart?</summary>

Here are the main differentiating characteristics of sBTC:

* sBTC is a true Bitcoin native product
* sBTC is backed by respected leaders in the Bitcoin community (signer network)
* sBTC's security is provided by a decentralized network of validators/signers rather than a single custodian, removing the need to trust a single entity or exchange
* sBTC leverages 100% Bitcoin finality
* sBTC's technology offers optimal UX and DevEx for an L2
* sBTC is a fully transparent project/product working in the open with public code

</details>

<details>

<summary>Where can I learn more about the sBTC signers?</summary>

Read the "[Selection of sBTC Signer Set](https://github.com/stacks-network/sbtc/discussions/624)" post for more information about each signer and their qualifications.

</details>

### sBTC Rewards Program

<details>

<summary>Where does the yield paid in BTC come from?</summary>

The sBTC Rewards Program is powered by a group of Stackers "Stacking" STX to a designated reward address, contributing their BTC rewards to the program.

When Stacking STX, Stackers receive BTC through Stack's [Proof-of-Transfer](https://docs.stacks.co/concepts/stacks-101/proof-of-transfer) (PoX) consensus mechanism. For example, over a given 2-week period, the Stacks protocol has historically [distributed around 10% APY to Stackers](https://www.stacking-tracker.com/), paid in BTC.

To enable the sBTC Rewards Program, these stackers contribute the corresponding Proof of Transfer BTC rewards to the sBTC incentive pool. This BTC from the incentive pool is directly deposited into a smart contract that bridges the BTC to sBTC and distributes the rewards pro rata to sBTC holders.

The program is designed to increase sBTC liquidity and drive early usage of the protocol.

Here's a handy illustration to show the sBTC incentives design:

</details>

<details>

<summary>How are rewards distributed?</summary>

sBTC is automatically distributed every two weeks to the STX address used to enroll in your non-custodial wallet.

</details>

<details>

<summary>What do I have to do to be eligible for rewards?</summary>

To be eligible, you must enroll in the rewards program at bitcoinismore.org.

</details>

<details>

<summary>Do I need to re-enroll in the sBTC Rewards Program if I previously enrolled in the sBTC Rewards Program and have received additional sBTC?</summary>

No re-enrollment is needed. The Yield smart contract will automatically calculate enrolled users updated balance, as long as the sBTC contract address remains the same.

</details>

<details>

<summary>What level of rewards should I expect?</summary>

The level of rewards users can expect will vary based on the amount of STX in the rewards pool, the PoX yield rate, and the amount of sBTC that has been minted.

</details>

<details>

<summary>What is the difference between PoX Rewards and the sBTC Rewards Program?</summary>

PoX Bitcoin rewards are earned by Stackers who lock up their STX tokens to secure the Stacks network, a process that has been ongoing since the launch of Stacks.

The sBTC Rewards Program, on the other hand, offers additional BTC rewards specifically for early adopters who hold sBTC without requiring them to participate in network consensus or lock up any tokens.

</details>

### Using sBTC

<details>

<summary>When will sBTC be available?</summary>

sBTC deposits first went live on December 16, 2024, quickly hitting the 1,000 BTC cap. The second cap will go live on February 25th, 2025, quickly hitting the 3,000 BTC cap. Withdrawals went live on April 30, 2025.

Full decentralization of the Signer set will follow in [a subsequent phase](https://bitcoinl2labs.com/sbtc-rollout), gradually expanding beyond the initial 15 community-elected signers.

</details>

<details>

<summary>What wallets are supported for sBTC?</summary>

[Xverse](https://www.xverse.app/) and [Leather](https://leather.io/) wallets are supported — two leading wallets with seamless integrations designed for Bitcoin and Stacks users.

In addition, [Ledger](https://www.ledger.com/) and [Asigna](https://www.asigna.io/) support sBTC.

We are actively working with institutional custodians, staking providers, and other 3rd party wallets to support sBTC. More will be announced.

</details>

<details>

<summary>Why is there a .01 BTC minimum for BTC to sBTC deposits?</summary>

A .01 BTC minimum is imposed for BTC to sBTC deposits to ensure the system does not get spammed by many smaller transactions. We are exploring reducing the deposit minimum for future phases.

</details>

<details>

<summary>What are the steps to use the sBTC Bridge and earn rewards?</summary>

In the Stacks Documentation, find a [video](https://www.youtube.com/watch?v=XZruuDgTo4k\&t=1s) and a [more detailed walkthrough](https://docs.stacks.co/guides-and-tutorials/sbtc/how-to-use-the-sbtc-bridge).

Ensure BTC is accessible in a supported walletEnsure BTC is accessible via one of the following non-custodial wallets: Xverse, Leather, Ledger, or Asigna.Connect your wallet to the sBTC appTo interact with the sBTC protocol and mint sBTC, head to app.stacks.co and connect your non-custodial wallet with BTC ready to deposit.Enter BTC amountEnter the BTC amount to convert to sBTC (app.stacks.co will guide you through this step).Provide your Stacks receiving addressEnter your Stacks receiving address to initiate the transfer (app.stacks.co will guide you through this step).Enroll in the rewards programAfter your sBTC has been minted to your wallet, visit the rewards program site at bitcoinismore.org and connect your wallet. Then click the 'Earn Rewards' button. Read more in the Stacks Documentation.Start earningSeamlessly start earning sBTC rewards. sBTC is automatically paid every two weeks to the STX address used to enroll in your non-custodial wallet.Note: There is an initial lock-up period until withdrawals are activated in March. Following the lock-up period, sBTC can always be withdrawn.

</details>

<details>

<summary>How long will it take for my BTC deposit to confirm?</summary>

sBTC facilitates rapid movement between BTC and sBTC.

BTC to sBTCBTC to sBTC conversion can be completed within 3 Bitcoin blocks (under an hour).sBTC to BTCsBTC to BTC conversion can be completed within 6 Bitcoin blocks (Approximately two hours)

Read more in the [Stacks Documentation](https://docs.stacks.co/concepts/sbtc/operations/deposit-withdrawal-times).

</details>

<details>

<summary>Why is there a cap on the total BTC pegged in?</summary>

A BTC cap will be implemented to ensure a smooth rollout process with a focus on security.

In addition, the BTC cap will give developers the time to focus on the sBTC user experience and integration with DeFi applications across the Stacks ecosystem prior to opening sBTC for all users.

</details>

<details>

<summary>Are there any associated fees with minting sBTC?</summary>

There are two transaction fees required to mint your sBTC. The first is set by the user manually when they initiate the deposit transaction within their wallet.

The second is a fee used to consolidate the deposit UTXOs into the single signer UTXO. This separate transaction fee happens automatically and is set to a max of 80k sats. This is automatically deducted from your minted sBTC. This is not a signer fee but a regular Bitcoin transaction fee.

</details>

<details>

<summary>Are there multi-signature solutions for sBTC?</summary>

Yes. [Asigna](https://www.asigna.io/) provides a multi-signature solution for sBTC users.

</details>

<details>

<summary>Are custodians available to support sBTC?</summary>

At the moment, there is no custodian support for sBTC. However, we are actively working with institutional custodians to support sBTC.

Copper and BitGo already support Stacks and Stacking; however, we are working to prioritize SIP-10 and sBTC integration.

</details>

### sBTC Troubleshooting

<details>

<summary>My Bitcoin transaction confirmed, but I'm not seeing the sBTC token in my wallet.</summary>

You may need to enable the display of the sBTC token within your wallet by clicking on 'Manage Tokens' and enabling sBTC.

</details>

<details>

<summary>I received an "Errors.Invalid_Transaction" error when using an Xverse Wallet</summary>

If you received a "Errors.Invalid\_Transaction" error when using an Xverse Wallet, you may be using a "Nested SegWit" wallet. To resolve the issue, change your Xverse wallet to use the "Native SegWit".

</details>

<details>

<summary>sBTC still isn't showing up in wallet after 3 Bitcoin blocks. How much longer do I have to wait?</summary>

BTC to sBTC conversions are typically completed within 3 Bitcoin blocks. Due to the speed of Bitcoin blocks, deposits can take up to two hours to see sBTC in your wallet.

However, there may be a lag with your Leather or Xverse wallet where the sBTC will take another 20 minutes to show up in the wallet.

</details>

<details>

<summary>I didn't receive a confirmation that I enrolled in the rewards program. How can I ensure I'm enrolled?</summary>

Visit [bitcoinismore.org](https://bitcoinismore.org/). On the enroll page, when your wallet is linked, it will say enrolled if you are enrolled in the program.

</details>


# Dual Stacking

An overview of the BTC-denominated rewards mechanism on Stacks

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-56afba24267678e3274116702bf2c87a982bbf25%2FOG%20Image.png?alt=media" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Check out the official blog announcement of Dual Stacking [here](https://www.stacks.co/blog/dual-stacking-launches-on-stacks).
{% endhint %}

Dual Stacking enables Bitcoin holders to earn Bitcoin-denominated rewards through Stacks' [Proof of Transfer](https://docs.stacks.co/learn/stacks-101/proof-of-transfer) consensus. Rewards are paid in [sBTC](https://docs.stacks.co/learn/sbtc).\
\
Dual Stacking is the only way to earn Bitcoin rewards while stacking Bitcoin. Other blockchains pay rewards in their native token (ETH, SOL, etc.). They have no mechanism to generate real Bitcoin. **Stacks' Proof of Transfer (PoX)** is the architectural difference that makes Bitcoin earning Bitcoin rewards possible.\
\
As more BTC enters the Stacks network, rates will adjust. But the multiplier effect remains: pairing STX with your BTC and deploying sBTC into DeFi always amplify your returns.

***

Additional Resources

* \[[Stacks YT](https://youtu.be/bfWPr_qMQmc?si=A9R2OKRHZ-N6Uwhe)] Dual Stacking Explained: Earn Bitcoin on Your Bitcoin


# How to Start Dual Stacking

Getting starting in Dual Stacking is simple.

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-3d7305b5c385e2b734bb87b8eee5d1e7b6a422fe%2FGroup%20316124782.png?alt=media" alt=""><figcaption><p><a href="http://app.stacks.co/">app.stacks.co</a></p></figcaption></figure>

{% hint style="warning" %}
Coinciding with the Dual Stacking launch, the existing sBTC Rewards Program will sunset on October 31, 2024. Starting October 30th, enroll in the Dual Stacking Rewards Contract (specific instructions to follow).

NOTE: you will have until \~ Nov 4 (end of Cycle 121) to enroll, and you will continue to earn rewards from the current program until this date.
{% endhint %}

### **Overview of how to start Dual Stacking**

1. **Mint sBTC** → 1:1 Bitcoin-backed. Enroll in dual stacking to earn baseline reward.
2. **Stack STX** → Stack STX alongside your sBTC to multiply returns up to 10x.
3. **Use in DeFi** → Deploy sBTC across protocols while still earning rewards.
4. **Earn sBTC** → and redeem 1:1 for BTC anytime.

PS: your stacked STX continues to earn bitcoin while in dual stacking.

### Dual Stacking Web App

The [Dual Stacking Web App](https://app.stacks.co/) is the primary user interface for participating in Dual Stacking — a mechanism that allows Bitcoin holders to earn BTC-denominated rewards through sBTC, and maximize those rewards by either stacking STX or using sBTC in DeFi.

{% hint style="info" %}
The minimum to mint sBTC via the sBTC Bridge app is currently at 0.001 BTC (100,000 sats).

The minimum to enroll in Dual Stacking with your minted sBTC will be 0.0001 sBTC (10,000 sats).
{% endhint %}

Once connected to the web app, you'll see the dashboard that lays out all the metrics regarding your rewards composition and different methods for boosting rewards. Track your balances, rewards and payouts at anytime.

The 'Boost your rewards' section will layout the steps for you to enroll and boost your rewards. All rewards are distributed in sBTC, redeemable 1:1 for BTC anytime.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-55bbbe3eca556c971d18f3a93dc12c07ba6d0aa4%2Fimage%2075%20(1).png?alt=media" alt=""><figcaption><p>Track your balances, rewards and payouts at anytime on the Dual Stacking dashboard.</p></figcaption></figure></div>

Use the Dual Stacking calculator for estimated rewards based on the ratio of sBTC in your wallet and STX stacked. For more details on how your rewards are calculated and the math behind it, check out the section on the Dual Stacking [reward function](https://docs.stacks.co/learn/economic-model#reward-function-parameters).

Start Dual Stacking now with the following wallets:

* [Dual Stack with Fordefi](https://docs.stacks.co/learn/dual-stacking/how-to-start-dual-stacking/using-fordefi)
* [Dual Stacking with Asigna](https://docs.stacks.co/learn/dual-stacking/how-to-start-dual-stacking/using-asigna)
* [Dual Stack with Leather](https://docs.stacks.co/learn/dual-stacking/how-to-start-dual-stacking/using-leather)

### Who is this app for?

{% tabs %}
{% tab title="sBTC holders" %}
At the end of October, users participating in sBTC Rewards program will need to enroll in Dual Stacking in order to continue earning sBTC rewards. This web app is the main way for them to do that.
{% endtab %}

{% tab title="BTC holders" %}
There are relatively few options to earn yield on BTC. This app gives BTC holders an option to earn BTC denominated rewards in an easy, trust minimized way.
{% endtab %}

{% tab title="STX holders" %}
STX holders who have participated in regular Stacking might be intrigued about a new type of Stacking, dual stacking. This app lets them try out a new iteration of a familiar flow.
{% endtab %}
{% endtabs %}

***

It's simple: Stack bitcoin, Earn bitcoin 🟧

For more questions and help with Dual Stacking, reach out to us and the community in our [Discord](https://discord.gg/5DJaBrf) and on our official [Stacks twitter](https://twitter.com/Stacks).


# Dual Stack with Fordefi

A guide in getting started with Dual Stacking using the Fordefi MPC wallet

{% hint style="warning" %}
This guide is specifically for entities or teams that use [Fordefi](https://fordefi.com/). This assumes you have the Fordefi wallet setup with its browser extension and with its mobile app.
{% endhint %}

The Dual Stacking Web App is the primary user interface for participating in Dual Stacking — a mechanism that allows Bitcoin holders to earn BTC-denominated rewards through sBTC, and maximize those rewards by either stacking STX or using sBTC in DeFi.

{% hint style="danger" %}
Ensure that you are using the official Dual Stacking app located at [app.stacks.co](https://app.stacks.co/).
{% endhint %}

For this guide, we'll walkthrough how you can use your Fordefi wallet in enrolling Dual Stacking and participating in DeFi for boosted rewards. This guide assumes you have a dedicated Bitcoin vault and Stacks vault setup in your Fordefi wallet.

If you need assistance in setting up your vaults in Fordefi, check out their dedicated [docs](https://docs.fordefi.com/user-guide/policies).

Before enrolling in Dual Stacking, you'll need sBTC. Peg in BTC to sBTC through the [sBTC bridge](https://app.stacks.co/) (where it remains 1:1 Bitcoin-backed at all times). Check out the dedicated guide on how you can mint sBTC to your Fordefi [wallet](https://docs.stacks.co/build/sbtc/how-to-use-the-sbtc-bridge-with-fordefi).

### Walkthrough for enrolling in Dual Stacking

Here are the necessary steps to enroll your sBTC using Fordefi:

{% stepper %}
{% step %}
**Connect Fordefi to the Dual Stacking app**

Upon popup of the connect wallet modal, select the Fordefi option to connect with. As per the usual flow of connecting your Fordefi wallet with other Stacks apps, it'll prompt you to first select your Bitcoin vault, and then your Stacks vault.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-1068a1749be3d4181df736dfd958520e4a957967%2Fimage%2051.png?alt=media" alt=""><figcaption><p>Select which Bitcoin vault you want to connect with first.</p></figcaption></figure></div>

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-1e2f1817fab50f4aabfb24f1611ee73d0602cc62%2Fimage%2052.png?alt=media" alt=""><figcaption><p>Then choose which Stacks vault you want to connect with.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Enroll now for Dual Stacking**

On the dashboard, you'll be able to see stats regarding your current sBTC in wallet, sBTC in DeFi, STX currently stacked, and estimated APY you could be earning.

Let's get started by enrolling your sBTC into Dual Stacking.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-b631433dc08e5229ecc64a18e9efa8c92fe0bc22%2Fimage%2054.png?alt=media" alt=""><figcaption><p>Click on 'Enroll now' under the 'Enroll for rewards' step.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Create transaction**

Your Fordefi extension will appear with a popup asking you to review the transaction for creation. This will create the transaction which you will later sign and broadcast in your Fordefi mobile wallet.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-2f38ecdc2f78de05eaa36ee29afb6d3870e5ced9%2Fimage%2059%20(1).png?alt=media" alt=""><figcaption><p>Create the transaction to queue it up in your Fordefi wallet for signing and broadcasting.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Sign transaction in Fordefi mobile app**

If you navigate back to your Fordefi web wallet, you'll see the transaction queued up for signatures. Depending on the transaction policy that is setup with your Fordefi vaults, you may need to instruct the designated approvers to all confirm and sign the transaction in their Fordefi mobile wallets.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-511198ba4964919c8a3dcc3d7659ba785c2d8744%2Fimage%2061.png?alt=media" alt=""><figcaption><p>The 'enroll' transaction will be queued up in your Fordefi web wallet. You'll need to sign the transaction via the mobile wallet.</p></figcaption></figure></div>

Within the Fordefi mobile wallet, you'll see the same transaction waiting for signing. Go ahead and sign the transaction which will then broadcast the transaction to the network.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-ec89052ddb498a17583560f94c02babda05c044d%2FGroup%20316124781.png?alt=media" alt=""><figcaption><p>Complete all signatures in the Fordefi mobile wallet.</p></figcaption></figure></div>

Your enroll transaction will look like this [here](https://explorer.hiro.so/txid/0x3b4ea853df54825adad3ab475d93be18c6a12f04033c665d4597984786feb608?chain=mainnet).
{% endstep %}

{% step %}
**You are now enrolled in Dual Stacking**

You'll notice your sBTC now enrolled in Dual Stacking and when the rewards cycle will start for your enrolled sBTC.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-1baf7eb30e86b887beeaa961aa665b412e39d22c%2Fimage%2063.png?alt=media" alt=""><figcaption><p>You are now Dual Stacking!</p></figcaption></figure></div>

The dashboard will also provide a view of your Dual Stacking portfolio.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-bda195f724b6fbda41913982508d629f99c6329a%2Fimage%2064.png?alt=media" alt=""><figcaption><p>View when your sBTC will start earning rewards and the breakdown of rewards composition.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Boost rewards by stacking STX**

So what's next? You could then boost your rewards by stacking STX. Let's start by stacking STX via [StackingDAO](https://www.stackingdao.com/). StackingDAO is a popular stacking option in Stacks as it is a liquid stacking method.

{% hint style="info" %}
There are other options for stacking your STX that you can find [here](https://app.leather.io/stacking).
{% endhint %}

Navigate to the StackingDAO app, connect your wallet, and start stacking. There are many methods to start liquid stacking or native stacking within StackingDAO. In this example, we'll use our STX to liquid stack with sBTC yield.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-3d9caedca84c35a7b59fb7105957bc233d53e767%2Fimage%2067.png?alt=media" alt=""><figcaption><p>Liquid stacking with sBTC yield allows us to stay liquid and earn sBTC while stacking.</p></figcaption></figure></div>

You'll then notice the Dual Stacking app to detect your stacked positions and include that as part of your portfolio's reward composition for boosted rewards.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-c276c29218076f7ed8b40423d6f4a0638b939201%2Fimage%2068.png?alt=media" alt=""><figcaption><p>Notice the change in estimated APY and total portfolio value after stacking.</p></figcaption></figure></div>

Let's then boost reward with Stacks DeFi. This will help reach the maximum APY boost for your sBTC.
{% endstep %}

{% step %}
**Deploy your sBTC to Stacks DeFi protocols**

You'll notice near the bottom of the dashboard page, there is a section highlighting popular DeFi protocols in Stacks. Each one of these protocols are eligible for the boosted rewards you can realize.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-ce091cec2b9f7544f47f640f6b314c8ba35f9c53%2Fimage%2069.png?alt=media" alt=""><figcaption></figcaption></figure></div>

Let's deploy sBTC with Zest. Supplying sBTC in Zest will provide users with a supply APY. Confirm the 'Supply' transaction via the same signature flow with Fordefi.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-a9a9a34bd765b9c5a86d6836ef9e1774a3ff8d5c%2Fimage%2074.png?alt=media" alt=""><figcaption></figcaption></figure></div>

After deploying sBTC into Zest, navigate back to the Dual Stacking web app to see your current estimated APY and rewards composition.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-55bbbe3eca556c971d18f3a93dc12c07ba6d0aa4%2Fimage%2075%20(1).png?alt=media" alt=""><figcaption></figcaption></figure></div>

Check back on the Dual Stacking dashboard to stay current with your rewards and rewards composition. All rewards are distributed in sBTC, redeemable 1:1 for BTC anytime.
{% endstep %}
{% endstepper %}

***

Reach out to us on [Discord](https://discord.com/invite/stacks-621759717756370964) for any further questions regarding Dual Stacking.


# Dual Stack with Asigna

A guide in getting started with Dual Stacking using the Asigna wallet.

{% hint style="warning" %}
This guide is specifically for entities or teams that use [Asigna](https://www.asigna.io/). This assumes you have the Asigna wallet setup with its browser extension and a multi-signature setup.
{% endhint %}

The Dual Stacking Web App is the primary user interface for participating in Dual Stacking — a mechanism that allows Bitcoin holders to earn BTC-denominated rewards through sBTC, and maximize those rewards by either stacking STX or using sBTC in DeFi.

{% hint style="danger" %}
Ensure that you are using the official Dual Stacking app located at [app.stacks.co](https://app.stacks.co/).
{% endhint %}

For this guide, we'll walkthrough how you can use your Asigna wallet in enrolling Dual Stacking and participating in DeFi for boosted rewards. This guide assumes you have a dedicated Stacks vault setup with multi-signature in your Asigna wallet.

If you need assistance in setting up your vaults in Asigna, check out their dedicated [docs](https://asigna.gitbook.io/asigna).

Before enrolling in Dual Stacking, you'll need sBTC. Peg in BTC to sBTC through the [sBTC bridge](https://app.stacks.co/) (where it remains 1:1 Bitcoin-backed at all times). Check out the dedicated [guide](https://docs.stacks.co/build/sbtc/how-to-use-the-sbtc-bridge-with-asigna) on how you can mint sBTC to your Asigna wallet.

### Walkthrough for enrolling in Dual Stacking

Here are the necessary steps to enroll your sBTC using Asigna:

{% stepper %}
{% step %}
**Connect Asigna to the Dual Stacking app**

Upon popup of the connect wallet modal, select the Asigna option to connect with. As per the usual flow of connecting your Asigna wallet with other Stacks apps, you'll most likely also need to connect the Asigna web wallet view with the Asigna browser extension before connecting with the app.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-3aeef02d164de0e2239c3e3dd384e2f7b779a8f6%2Fimage%2078%20(1).png?alt=media" alt=""><figcaption><p>Select which safe (Stacks vault) you want to connect with.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Enroll now for Dual Stacking**

On the dashboard, you'll be able to see stats regarding your current sBTC in wallet, sBTC in DeFi, STX currently stacked, and estimated APY you could be earning.

Let's get started by enrolling your sBTC into Dual Stacking.

Your Asigna extension will appear with a popup asking you to review the transaction for approval. This will create the transaction which you will later sign and broadcast in your Asigna web wallet view.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-351df29025ba910e53bd60aa529177bda1cd7c29%2Fimage%2080.png?alt=media" alt=""><figcaption><p>Click on 'Enroll now' under the 'Enroll for rewards' step and approve transaction in the extension popup.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Sign transaction in Asigna web view**

If you navigate back to your Asigna web wallet view, you'll see the transaction queued up for signatures. In this scenario, we have a 2-of-2 multi-signature scheme setup so we'll need to sign the transaction by both parties involved.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-17b1bfe101456e57433d582307a194afee6e055a%2FGroup%20316124783.png?alt=media" alt=""><figcaption><p>The first signature of the 2-of-2 setup will need to be signed in the Asigna web wallet view.</p></figcaption></figure></div>

Once the first signature is completed, the second signature will also need to take place in that respective signer's Asigna web wallet view. After signing, that same signer will then need to hit 'Execute' to complete the broadcasting of the transaction.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-3dbb1bbb7046ba43b774aee277e358cf1417edff%2FGroup%20316124783%20(1).png?alt=media" alt=""><figcaption><p>The second signature of the 2-of-2 setup will need to be signed in the Asigna web wallet view. After all signatures are completed, hit 'Execute' to broadcast the transaction and navigate back to the Dual Stacking app.</p></figcaption></figure></div>

Execute the signed transaction to broadcast it to the Stacks network.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-fe418d2a94b97797942e3cf7505e5a6686a72f70%2Fimage%2085.png?alt=media" alt=""><figcaption></figcaption></figure></div>

Your enroll transaction will look like this [here](https://explorer.hiro.so/txid/0x3b4ea853df54825adad3ab475d93be18c6a12f04033c665d4597984786feb608?chain=mainnet).
{% endstep %}

{% step %}
**You are now enrolled in Dual Stacking**

You'll notice your sBTC now enrolled in Dual Stacking and when the rewards cycle will start for your enrolled sBTC.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-1baf7eb30e86b887beeaa961aa665b412e39d22c%2Fimage%2063.png?alt=media" alt=""><figcaption><p>You are now Dual Stacking!</p></figcaption></figure></div>

The dashboard will also provide a view of your Dual Stacking portfolio.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-d253139871df5d1d97eea8a413c61bf95bfc526b%2Fimage%2086.png?alt=media" alt=""><figcaption></figcaption></figure></div>

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-bda195f724b6fbda41913982508d629f99c6329a%2Fimage%2064.png?alt=media" alt=""><figcaption><p>View when your sBTC will start earning rewards and the breakdown of rewards composition.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Boost rewards by stacking STX**

So what's next? You could then boost your rewards by stacking STX. Let's start by stacking STX via [StackingDAO](https://www.stackingdao.com/). StackingDAO is a popular stacking option in Stacks as it is a liquid stacking method.

{% hint style="info" %}
There are other options for stacking your STX that you can find [here](https://app.leather.io/stacking).
{% endhint %}

Navigate to the StackingDAO embedded app within your Asigna web wallet view, connect your wallet, and start stacking. There are many methods to start liquid stacking or native stacking within StackingDAO. In this example, we'll use our STX to liquid stack with sBTC yield.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-510d2f5c99fa612e6d5759dfbd6ab06def77fc4e%2Fimage%2092.png?alt=media" alt=""><figcaption><p>Liquid stacking with sBTC yield allows us to stay liquid and earn sBTC while stacking.</p></figcaption></figure></div>

Complete the same 2-of-2 multi-signature flow in your Asigna web wallet views.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-ec171c271c508df3bb8c632f49805d3fd018b18a%2Fimage%2094.png?alt=media" alt=""><figcaption><p>After all signatures are completed, execute the transaction to broadcast it to the network.</p></figcaption></figure></div>

Navigate back to the Dual Stacking app, and you'll then notice the Dual Stacking app has instantly detect your stacked positions and include that as part of your portfolio's reward composition for boosted rewards.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-08abb6b42c2fe5a1003a04833127e83ee14a427a%2Fimage%2095.png?alt=media" alt=""><figcaption><p>Notice the change in estimated APY and total portfolio value after stacking.</p></figcaption></figure></div>

Let's then boost reward with Stacks DeFi. This will help reach the maximum APY boost for your sBTC.
{% endstep %}

{% step %}
**Deploy your sBTC to Stacks DeFi protocols**

You'll notice near the bottom of the dashboard page, there is a section highlighting popular DeFi protocols in Stacks. Each one of these protocols are eligible for the boosted rewards you can realize.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-ce091cec2b9f7544f47f640f6b314c8ba35f9c53%2Fimage%2069.png?alt=media" alt=""><figcaption></figcaption></figure></div>

Let's deploy sBTC with Zest.

{% hint style="info" %}
As with using the embedded StackingDAO app, we'll also be using the embedded Zest app found in the Asigna web wallet view.
{% endhint %}

Supplying sBTC in Zest will provide users with a supply APY. Confirm the 'Supply' transaction via the same signature flow with Asigna.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-a9a9a34bd765b9c5a86d6836ef9e1774a3ff8d5c%2Fimage%2074.png?alt=media" alt=""><figcaption></figcaption></figure></div>

After deploying sBTC into Zest, navigate back to the Dual Stacking web app to see your current estimated APY and rewards composition.

Check back on the Dual Stacking dashboard to stay current with your rewards and rewards composition. All rewards are distributed in sBTC, redeemable 1:1 for BTC anytime.
{% endstep %}
{% endstepper %}

***

Reach out to us on [Discord](https://discord.com/invite/stacks-621759717756370964) for any further questions regarding Dual Stacking.


# Dual Stack with Leather

A guide in getting started with Dual Stacking using the Leather wallet.

{% hint style="warning" %}
This guide is specifically for users that use the Leather wallet. This assumes you have the Leather wallet extension setup. The flow will also be similar for Xverse wallet users.
{% endhint %}

The Dual Stacking Web App is the primary user interface for participating in Dual Stacking — a mechanism that allows Bitcoin holders to earn BTC-denominated rewards through sBTC, and maximize those rewards by either stacking STX or using sBTC in DeFi.

{% hint style="danger" %}
Ensure that you are using the official Dual Stacking app located at [app.stacks.co](https://app.stacks.co/).
{% endhint %}

For this guide, we'll walkthrough how you can use your Leather wallet in enrolling Dual Stacking and participating in DeFi for boosted rewards. This guide assumes you have already setup a Leather wallet extension.

If you need assistance in setting up your Leather wallet extension, check out their webpage [here](https://leather.io/).

Before enrolling in Dual Stacking, you'll need sBTC. Peg in BTC to sBTC through the [sBTC bridge](https://app.stacks.co/) (where it remains 1:1 Bitcoin-backed at all times). Check out the dedicated [guide](https://docs.stacks.co/build/sbtc/how-to-use-the-sbtc-bridge) on how you can mint sBTC to your Leather wallet.

### Walkthrough for enrolling in Dual Stacking

Here are the necessary steps to enroll your sBTC using Leather:

{% stepper %}
{% step %}
**Connect Leather to the Dual Stacking app**

Upon popup of the connect wallet modal, select the Leather option to connect with.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-e697c990dd7a95a0c09ec68b85259ea4322c9536%2Fimage.png?alt=media" alt=""><figcaption><p>Confirm connecting in your Leather modal popup.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Enroll now for Dual Stacking**

On the dashboard, you'll be able to see stats regarding your current sBTC in wallet, sBTC in DeFi, STX currently stacked, and estimated APY you could be earning.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-77d893cfa58afad2c762ebb6bf4ed77913d25695%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure></div>

Let's get started by enrolling your sBTC into Dual Stacking.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-4286197b5872ade0949a41dc95cbd691b882b678%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure></div>

Your Leather extension will appear with a popup asking you to review the transaction for approval. This will create the transaction which you will sign and broadcast in your Leather web wallet view.

Your enroll transaction will look like this [here](https://explorer.hiro.so/txid/0x3b4ea853df54825adad3ab475d93be18c6a12f04033c665d4597984786feb608?chain=mainnet).
{% endstep %}

{% step %}
**You are now enrolled in Dual Stacking**

You'll notice your sBTC now enrolled in Dual Stacking and when the rewards cycle will start for your enrolled sBTC.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-1baf7eb30e86b887beeaa961aa665b412e39d22c%2Fimage%2063.png?alt=media" alt=""><figcaption><p>You are now Dual Stacking!</p></figcaption></figure></div>

The dashboard will also provide a view of your Dual Stacking portfolio. Track your balances, rewards and payouts at anytime.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-9577dcdcd093284717cfcc39c056543e461f7b31%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure></div>

Use the Dual Stacking calculator for estimated rewards based on the ratio of sBTC in your wallet and STX stacked. For more details on your rewards are calculated and the math behind it, check out the section on the [reward function](https://docs.stacks.co/learn/economic-model#reward-function-parameters).

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-983ff96f5294db640d9a76b626e5e002755dd968%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure></div>
{% endstep %}

{% step %}
**Boost rewards by stacking STX**

So what's next? You could then boost your rewards by stacking STX. Let's start by stacking STX via [StackingDAO](https://www.stackingdao.com/). StackingDAO is a popular stacking option in Stacks as it is a liquid stacking method.

{% hint style="info" %}
There are other options for stacking your STX that you can find [here](https://app.leather.io/stacking).
{% endhint %}

Navigate to the StackingDAO app, connect your wallet, and start stacking. There are many methods to start liquid stacking or native stacking within StackingDAO. In this example, we'll use our STX to liquid stack with sBTC yield.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-510d2f5c99fa612e6d5759dfbd6ab06def77fc4e%2Fimage%2092.png?alt=media" alt=""><figcaption><p>Liquid stacking with sBTC yield allows us to stay liquid and earn sBTC while stacking.</p></figcaption></figure></div>

Choose the amount in STX that you want to stack and click on 'Confirm Stack', your Leather wallet extension will then appear prompting you to approve transaction.

Navigate back to the Dual Stacking app, and you'll then notice the Dual Stacking app has instantly detect your stacked positions and include that as part of your portfolio's reward composition for boosted rewards.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-08abb6b42c2fe5a1003a04833127e83ee14a427a%2Fimage%2095.png?alt=media" alt=""><figcaption><p>Notice the change in estimated APY and total portfolio value after stacking.</p></figcaption></figure></div>

Let's then boost reward with Stacks DeFi. This will help reach the maximum APY boost for your sBTC.
{% endstep %}

{% step %}
**Deploy your sBTC to Stacks DeFi protocols**

You'll notice near the bottom of the dashboard page, there is a section highlighting popular DeFi protocols in Stacks. Each one of these protocols are eligible for the boosted rewards you can realize.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-ce091cec2b9f7544f47f640f6b314c8ba35f9c53%2Fimage%2069.png?alt=media" alt=""><figcaption></figcaption></figure></div>

Let's deploy sBTC with Zest. Supplying sBTC in Zest will provide users with a supply APY. Confirm the 'Supply' transaction via the same signature flow using Leather.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-a9a9a34bd765b9c5a86d6836ef9e1774a3ff8d5c%2Fimage%2074.png?alt=media" alt=""><figcaption></figcaption></figure></div>

After deploying sBTC into Zest, navigate back to the Dual Stacking web app to see your current estimated APY and rewards composition.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-8af2350646d52a85d13fd5c9c409546a223064d9%2Fimage.png?alt=media" alt=""><figcaption><p>View a breakdown of rewards per reward cycle.</p></figcaption></figure></div>

Check back on the Dual Stacking dashboard to stay current with your rewards and rewards composition. Depending on when your rewards cycle start for your enrollment, you'll see the rewards breakdown in the middle section. All rewards are distributed in sBTC, redeemable 1:1 for BTC anytime.
{% endstep %}
{% endstepper %}

***

Reach out to us on [Discord](https://discord.com/invite/stacks-621759717756370964) for any further questions regarding Dual Stacking.


# Economic Model

Understanding the economics behind Dual Stacking.

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-62a239656a550f8d9a05a8645aee1c33edab992a%2Fimage.png?alt=media" alt=""><figcaption><p>Users stake BTC, STX, or both to earn BTC-denominated rewards (via sBTC and BTC).</p></figcaption></figure>

Dual Stacking introduces an economic model in which BTC-denominated rewards scale with the participant’s ratio of sBTC to stacked STX as well as sBTC deployed in DeFi. This creates a direct link between Bitcoin capital and the growth of the Stacks ecosystem.

All participants receive a baseline BTC-denominated reward on the sBTC enrolled in Dual Stacking. They have the option of earning additional rewards by stacking STX as well as deploying sBTC into DeFi.

For Stacking STX, Bitcoin rewards grow based on an individuals STX-to-sBTC ratio relative to other participants, up to 10× the base yield. The system uses a square-root curve, meaning the first stacked STX has the greatest impact, with smaller boosts as more STX is stacked. The DeFi boost is straightforward, you automatically earn 10x multiple for any amount of sBTC deployed in DeFi.

At the same time, an individual's stacked STX continues earning standard [stacking](https://docs.stacks.co/learn/block-production/stacking) rewards.

{% hint style="info" %}
The following Reward Function Parameters section is taken directly from the [Dual Stacking litepaper](https://github.com/stx-labs/papers/blob/main/Dual%20Stacking%20Litepaper.pdf).
{% endhint %}

#### Reward Function Parameters

* **Rewards Boost Multiplier** – Defines the maximum multiple of base reward attainable by users\
  with the highest STX/BTC ratio. For example, with a 10× multiplier, a user earning 0.5%\
  base reward could reach 5% if staking the maximum effective ratio of STX to BTC.
* **Reward Function Curve** – Defines how rewards scale across intermediate STX/BTC\
  ratios. A square-root curve introduces diminishing returns, encouraging broad\
  participation rather than concentration of rewards among large holders.
* **Max Reference STX/BTC Ratio** – Set to the BTC-weighted 95th percentile of STX/BTC\
  ratios among users. That is, the value above which only 5% of total locked BTC has a\
  higher STX/BTC ratio. Under this approach, for a user to unilaterally set the max\
  reference STX/BTC ratio, the user would need both 5% of the total BTC locked and have\
  the highest STX/BTC ratio for those BTC. This design minimizes manipulation by\
  preventing outliers from disproportionately setting the maximum yield threshold.

To describe the reward function more precisely, we’ll define some terms:

* 𝑌 − 𝑇𝑜𝑡𝑎𝑙 𝐵𝑇𝐶 𝑑𝑖𝑠𝑡𝑟𝑖𝑏𝑢𝑡𝑒𝑑 𝑎𝑠 𝑟𝑒𝑤𝑎𝑟𝑑𝑠 𝑡𝑜 𝑑𝑢𝑎𝑙 𝑠𝑡𝑎𝑐𝑘𝑖𝑛𝑔 𝑑𝑢𝑟𝑖𝑛𝑔 𝑎 𝑆𝑡𝑎𝑐𝑘𝑖𝑛𝑔 𝑐𝑦𝑐𝑙𝑒
* 𝐵<sub>𝑖</sub> − 𝐴𝑚𝑜𝑢𝑛𝑡 𝑜𝑓 𝐵𝑇𝐶 𝑡ℎ𝑒 𝑖𝑡ℎ 𝑢𝑠𝑒𝑟 𝑙𝑜𝑐𝑘𝑠 𝑖𝑛 𝑎 𝑆𝑡𝑎𝑐𝑘𝑖𝑛𝑔 𝑐𝑦𝑐𝑙𝑒
* 𝑆<sub>𝑖</sub> − 𝐴𝑚𝑜𝑢𝑛𝑡 𝑜𝑓 𝑆𝑇𝑋 𝑡ℎ𝑒 𝑖𝑡ℎ 𝑢𝑠𝑒𝑟 𝑙𝑜𝑐𝑘𝑠 𝑖𝑛 𝑎 𝑆𝑡𝑎𝑐𝑘𝑖𝑛𝑔 𝑐𝑦𝑐𝑙𝑒
* 𝑑<sub>𝑖</sub> = 𝑆<sub>𝑖</sub> */* 𝐵<sub>𝑖</sub> − 𝐴𝑚𝑜𝑢𝑛𝑡 𝑜𝑓 𝑆𝑇𝑋 𝑝𝑒𝑟 𝐵𝑇𝐶 𝑡ℎ𝑒 𝑖𝑡ℎ 𝑢𝑠𝑒𝑟 𝑙𝑜𝑐𝑘𝑠 𝑖𝑛 𝑎 𝑆𝑡𝑎𝑐𝑘𝑖𝑛𝑔 𝑐𝑦𝑐𝑙𝑒
* 𝐷 − 𝑀𝑎𝑥 𝑟𝑒𝑓𝑒𝑟𝑒𝑛𝑐𝑒 𝑑<sub>𝑖</sub> , 𝑤ℎ𝑖𝑐ℎ 𝑖𝑠 𝑠𝑒𝑡 𝑡𝑜 𝑡ℎ𝑒 95𝑡ℎ 𝑝𝑒𝑟𝑐𝑒𝑛𝑡𝑖𝑙𝑒 𝑜𝑓 𝐵𝑇𝐶𝑤𝑒𝑖𝑔ℎ𝑡𝑒𝑑 𝑑<sub>𝑖</sub>
* 𝑀 − 𝑟𝑒𝑤𝑎𝑟𝑑𝑠 𝑏𝑜𝑜𝑠𝑡 𝑚𝑢𝑙𝑡𝑖𝑝𝑙𝑖𝑒𝑟 𝑚𝑖𝑛𝑢𝑠 𝑜𝑛𝑒

The first step in our reward function is to determine a normalized ratio, 𝑟<sub>𝑖</sub> , for all users:

$$
𝑟\_𝑖 = 𝑚𝑖𝑛(\frac{𝑑\_𝑖}{𝐷}, 1)
$$

With the normalized ratio, we can then determine normalized weights, *w*<sub>𝑖</sub> , for all users:

$$
𝑤\_𝑖 = 𝐵\_𝑖\cdot(1 + 𝑀\cdot \sqrt{𝑟\_𝑖})
$$

Ultimately, the rewards for each user, *y*<sub>𝑖</sub> , would be:

$$
𝑦\_𝑖 = 𝑌 \cdot \frac{𝑤\_𝑖}{\sum𝑤\_𝑗}
$$

The generalized shape of the reward function is shown in the graph below. The two lines, one\
dark orange and one light orange, show the shape of the yield curves for the expected rewards on\
one’s sBTC holdings only as a result of dual stacking rewards, and the shape of the yield curve\
for one’s combined sBTC and STX as a result of the combination of dual stacking rewards on\
one’s sBTC and the standard stacking rewards for one’s STX.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-2848b170669461943322c6998a08151d6678b47c%2Fimage.png?alt=media" alt=""><figcaption><p>Staking STX alongside BTC amplifies rewards based on a yield curve, up to 10x.</p></figcaption></figure></div>

***

For more detail on the Reward Function parameters and models, refer to the [Dual Stacking litepaper](https://github.com/stx-labs/papers/blob/main/Dual%20Stacking%20Litepaper.pdf).


# Dual Stacking Smart Contract

## Overview

The Dual Stacking contract enables participants to earn boosted sBTC rewards by holding sBTC and optionally stacking STX. It operates in cycles with periodic snapshots to calculate rewards based on holdings and stacking participation.

{% hint style="info" %}
For the live dual stacking contract on mainnet, check out the contract page [here](https://explorer.hiro.so/txid/SP1HFCRKEJ8BYW4D0E3FAWHFDX8A25PPAA83HWWZ9.dual-stacking-v1?chain=mainnet).
{% endhint %}

### Decentralized Architecture

* Permissionless operations: Anyone can execute critical cycle operations including snapshot capturing, ratio proposal/validation, weight calculation, and reward distribution.
* On-chain data only: All participant data (sBTC balances, STX stacking amounts) is read directly from the blockchain — no off-chain oracles or trusted data sources required.
* Competitive ratio discovery: Multiple participants can propose different golden ratios; the system validates based on mathematical criteria (95th percentile), not admin approval.
* Transparent execution: All operations are executed on-chain with verifiable results and public event logs.
* Self-service enrollment: Users can enroll, opt-out, and manage their participation independently.

### Main Operations

{% stepper %}
{% step %}
**Initialization**

The contract is initialized once with a Stacks block height parameter that is the first one in the Bitcoin block specified, or after it, in case there aren't any STX blocks anchored to it.
{% endstep %}

{% step %}
**Enrollment**

Users can self-enroll for participation with custom reward addresses. DeFi protocols can be enrolled by admin with custom tracking, stacking, and reward addresses. All participants can opt-out or change their addresses at any time.
{% endstep %}

{% step %}
**Snapshots and Cycles**

Anyone can trigger periodic snapshots that capture participant sBTC balances and STX stacking amounts from on-chain data based on predefined block intervals.
{% endstep %}

{% step %}
**Ratio Computation**

After snapshots are complete, anyone can propose a golden ratio (optimal STX/sBTC ratio), tally participant distributions, and validate if their proposal meets the 95th percentile criteria to determine the benchmark for maximum rewards.
{% endstep %}

{% step %}
**Weight Calculation**

Anyone can trigger participant weight calculations using the validated dual stacking formula that provides up to 10x boost (configurable) for those who meet or exceed the golden ratio.
{% endstep %}

{% step %}
**Rewards**

Anyone can trigger reward distribution every cycle based on calculated weights. Administrators can update configurations like APR, yield boost multiplier, snapshot length, and number of snapshots per cycle.
{% endstep %}

{% step %}
**Administrative Controls**

Admins maintain protocol parameters, enroll/opt-out DeFi protocols with special address configurations, manage whitelists and blacklists, and can perform emergency operations if needed.
{% endstep %}
{% endstepper %}

***

## Cycle Structure

* Each cycle consists of a fixed number of snapshots (default 14).
* Each snapshot occurs after a set number of Bitcoin blocks (default 150).
* The total cycle length is thus 2100 Bitcoin blocks by default (14 snapshots × 150 blocks).
* These defaults can be adjusted for production environments (e.g., 1 snapshot per day with appropriate block counts).

## Dual Stacking Formula

Weight Calculation:

$$
w\_i = \cfrac{\[B\_i \cdot (1 + M \cdot \sqrt{r\_i})]}{n}
$$

Where:

* *w*<sub>*i*</sub>*&#x20;= weight for user i*
* *B*<sub>*i*</sub>*&#x20;= sBTC balance of user i (sum across all snapshots)*
* *M = yield boost multiplier (default 9, meaning max boost of 10x)*
* *r*<sub>*i*</sub>*&#x20;= min(d*<sub>*i*</sub>*/D, 1), the ratio adjustment factor*
* *d*<sub>*i*</sub>*&#x20;= S*<sub>*i*</sub>*/B*<sub>*i*</sub>*, user's personal STX/sBTC ratio*
* *S*<sub>*i*</sub>*&#x20;= STX stacked by user i (sum across all snapshots)*
* *D = golden ratio (95th percentile STX/sBTC ratio across all participants)*
* *n = number of snapshots per cycle (default 14)*

Rewards Distribution:

$$
R\_i = (\frac{w\_i}{Σw}) \cdot Total Rewards
$$

Where:

* *R*<sub>*i*</sub>*&#x20;= reward for user i*
* *Σw = sum of all participant weights*
* *Total Rewards = min(pool balance, APR-based cap)*

Key Properties:

* *Participants with d*<sub>*i*</sub>*&#x20;≥ D receive maximum boost of (M+1) x (default 10x).*
* *Participants with d*<sub>*i*</sub>*&#x20;= 0 (no STX stacked) receive base rewards (1x).*
* *Boost scales with the square root of the ratio for intermediate values.*
* *Whitelisted DeFi tracking addresses automatically receive maximum boost without needing to stack STX.*
* *Weights are divided by the number of snapshots per cycle to normalize across the cycle duration.*

***

## Cycle Workflow

The Dual Stacking smart contract operates in cycles, each divided into snapshots. The process ensures accurate reward distribution through a series of permissionless operations that anyone can execute.

{% stepper %}
{% step %}
**Snapshot Phase (Anyone Can Execute)**

* capture-snapshot-balances: Anyone can capture balances for enrolled users after each snapshot.
* advance-to-next-snapshot: Anyone can transition to the next snapshot.
* finalize-snapshots: Anyone can conclude all snapshot data after the final snapshot.
  {% endstep %}

{% step %}
**Ratio Validation Phase (Competitive & Permissionless)**

* propose-golden-ratio: Anyone can propose a golden ratio.
* tally-participant-ratios: The proposer tallies participant ratios relative to their proposed ratio.
* validate-ratio: The proposer validates their proposal — succeeds only if it represents the 95th percentile.
* Multiple proposals can be submitted; the first valid one locks in for the cycle.
  {% endstep %}

{% step %}
**Weight Computation Phase (Anyone Can Execute)**

* calculate-participant-weights: Anyone can calculate participant weights using the dual stacking formula.
* finalize-weight-computation: Anyone can finalize weight computation.
  {% endstep %}

{% step %}
**Reward Distribution Phase (Anyone Can Execute)**

* set-is-distribution-enabled: Anyone can enable reward distribution by determining the available reward pool.
* distribute-rewards: Anyone can distribute rewards to enrolled users based on their weights.
* finalize-reward-distribution: Anyone can finalize reward distribution after all participants are rewarded.
  {% endstep %}

{% step %}
**Cycle Transition (Anyone Can Execute)**

* advance-to-next-cycle: Anyone can advance to the next cycle after all rewards are distributed.
  {% endstep %}
  {% endstepper %}

Note: All operations read data directly from the blockchain (sBTC balances from the sBTC token contract, STX stacking from native Stacks protocol). No off-chain data sources or trusted intermediaries are required.

***

## Public Functions

### 1. Contract Initialization

#### initialize-contract

Activates the contract with an initial cycle.

* Parameters: stx-block-height (uint)
* Assertions:
  * Current Bitcoin block height must be >= the configured cycle start Bitcoin block height.
  * The contract must not be active.
  * The Stacks block height must bracket the configured Bitcoin block height.
* Effect:
  * Initializes state variables for the first cycle and marks the contract as active.
  * Records cycle data and the first snapshot.

#### update-initialize-block

Updates the initialization Bitcoin block height before the contract is activated.

* Parameters: new-bitcoin-block-height (uint)
* Assertions:
  * Contract must not be active.
  * Caller must be the admin.
* Effect:
  * Updates the starting Bitcoin block height for the first cycle.

#### update-cycle-data-before-initialized

Updates both the snapshots per cycle and blocks per snapshot for the first cycle before initialization.

* Parameters: updated-snapshots-per-cycle (uint), updated-blocks-per-snapshot (uint)
* Assertions:
  * Contract must not be active.
  * Caller must be the admin.
* Effect:
  * Sets the cycle structure for the first cycle.

***

### 2. Enrollment

#### enroll

Enrolls the caller for rewards in future cycles.

* Parameters: rewarded-address (optional principal)
* Assertions:
  * Caller must not already be enrolled.
  * Caller must not be blacklisted.
  * Caller must hold at least the minimum required sBTC amount.
* Effect:
  * Adds the caller to the participants map with tracking, stacking, and rewarded addresses set appropriately.
  * Increments the next cycle participant count.

#### enroll-defi

Enrolls a DeFi protocol for rewards with custom addresses (admin only).

* Parameters:
  * defi-contract (principal)
  * tracking-address (principal)
  * rewarded-address (principal)
  * stacking-address (optional principal)
* Assertions:
  * Caller must be the admin.
  * DeFi contract must not already be enrolled.
  * DeFi contract must not be blacklisted.
* Effect:
  * Adds the DeFi protocol to the participants map with custom addresses.
  * Increments the next cycle participant count.

#### enroll-defi-batch

Batch enroll multiple DeFi protocols (admin only).

* Parameters: defi-contracts (list 900 {...})
* Assertions:
  * Caller must be the admin.
* Effect:
  * Enrolls multiple DeFi protocols in a single transaction.

#### opt-out

Allows the caller to opt out of participation in future cycles.

* Assertions:
  * Caller must be enrolled.
* Effect:
  * Removes the caller from the participants map.
  * Decrements the next cycle participant count.

#### opt-out-defi

Opts out a DeFi protocol from participation (admin only).

* Parameters: defi-contract (principal)
* Assertions:
  * Caller must be the admin.
  * DeFi contract must be enrolled.
* Effect:
  * Removes the DeFi protocol from the participants map.

#### opt-out-defi-batch

Batch opt out multiple DeFi protocols (admin only).

* Parameters: defi-contracts (list 200 principal)
* Assertions:
  * Caller must be the admin.
* Effect:
  * Opts out multiple DeFi protocols in a single transaction.

***

### 3. Participant Address Management

* change-reward-address
* change-reward-address-defi
* change-stacking-address-defi
* change-tracking-address-defi
* change-addresses-defi
* change-addresses-defi-batch

(Each function has parameters, admin assertions where applicable, and updates participant/DeFi addresses as described in the original spec.)

***

### 4. Snapshots and Cycles

#### capture-snapshot-balances

Captures snapshot balances for a list of participants at the current snapshot block height. Permissionless.

* Parameters: principals (list of up to 900 principals)
* Assertions:
  * The contract must be active.
  * The current snapshot Stacks block height must be available.
* Effect:
  * Reads sBTC balance from the sBTC token contract for each participant.
  * Reads STX stacked amount from native Stacks protocol (including liquid stacking if enabled).
  * Updates snapshot totals and participant holdings.
  * Tracks stacking and tracking addresses.

#### advance-to-next-snapshot

Advances the contract to the next snapshot within the current cycle. Permissionless.

* Parameters: new-stx-block-height (uint)
* Assertions:
  * The contract must be active.
  * All participants must be snapshotted.
  * Current Bitcoin block height must have reached the next snapshot block.
  * The cycle must not have ended.
  * The Stacks block height must bracket the next snapshot Bitcoin block height.
* Effect:
  * Increments snapshot index.
  * Aggregates snapshot totals into cycle totals.
  * Resets snapshot counters.
  * Records the new snapshot block heights.

#### finalize-snapshots

Finalizes all snapshots for the current cycle after the last snapshot is complete. Permissionless.

* Assertions:
  * The contract must be active.
  * Snapshots must not already be finalized.
  * Must be on the last snapshot of the cycle.
  * All participants must be snapshotted in the final snapshot.
* Effect:
  * Aggregates the final snapshot totals into cycle totals.
  * Marks snapshots as finalized.
  * Sets last operation state to "concluded".
  * Enables the ratio proposal phase.

#### advance-to-next-cycle

Advances the contract to the next cycle after all rewards are distributed. Permissionless.

* Parameters: stx-block-height (uint)
* Assertions:
  * The contract must be active.
  * Current Bitcoin block height must have reached the next cycle.
  * All participants must be rewarded.
  * Reward distribution must be finalized.
  * The Stacks block height must bracket the next cycle Bitcoin block height.
* Effect:
  * Increments cycle ID.
  * Resets state variables for the new cycle.
  * Updates cycle configuration from next-cycle settings.
  * Initializes the first snapshot of the new cycle.

***

### 5. Ratio Computation and Validation

#### propose-golden-ratio

Proposes a golden ratio for the current cycle. Permissionless.

* Parameters: ratio (uint) — proposed ratio scaled by 10^8
* Assertions:
  * Snapshots must be finalized.
  * A ratio must not already be validated for this cycle.
  * The caller must not have already proposed a ratio for this cycle.
* Effect:
  * Records the proposed ratio for the caller.
  * Initializes tracking for participant tallying.
  * Sets last operation state to "proposed-ratio".

#### change-proposed-golden-ratio

Change a previously proposed golden ratio before validation.

* Parameters: ratio (uint)
* Assertions:
  * The caller must have already proposed a ratio.
  * The ratio must not yet be validated.
* Effect:
  * Updates the proposed ratio and resets tally data.

#### tally-participant-ratios

Tallies how many participants have ratios above, below, or equal to the proposed golden ratio.

* Parameters: principals (list of up to 900 principals)
* Assertions:
  * The caller must have proposed a ratio.
  * The ratio must not yet be validated.
  * Must not have already tallied all participants.
* Effect:
  * Computes each participant's STX/sBTC ratio.
  * Tracks sBTC amounts above, below, and equal to the proposed ratio.
  * Increments participants counted.

#### validate-ratio

Validates that the proposed ratio represents the 95th percentile of participant ratios.

* Assertions:
  * The caller must have proposed a ratio.
  * All participants must be tallied.
  * The ratio must not already be validated.
  * If no STX is stacked by anyone, ratio must equal 1.0 (baseline).
  * sBTC above the ratio must be ≤ 5% of total sBTC.
  * sBTC at or above the ratio must be ≥ 5% of total sBTC.
* Effect:
  * Marks the ratio as validated.
  * Records the validated ratio for the cycle.
  * Sets last operation state to "ratio-validated".

#### set-max-percentage-above-ratio

Updates the percentage threshold for validation (admin only).

* Parameters: new-max-percentage-above-ratio (uint) — default 500 = 5%
* Assertions:
  * Caller must be the admin.
* Effect:
  * Updates the validation threshold.

***

### 6. Weight Computation

#### calculate-participant-weights

Calculates participant weights using the dual stacking formula. Permissionless.

* Parameters: principals (list of up to 900 principals)
* Assertions:
  * The ratio must be validated.
  * The current cycle Stacks block height must be available.
* Effect:
  * Retrieves validated golden ratio D.
  * Applies minimum threshold to D to prevent division by zero $$D = max(D, 10^-8)$$.
  * For each participant, computes weight using: $$w\_i = \cfrac{\[B\_i \cdot (1 + M \cdot √r\_i)]}{n}$$
  * Accumulates total weights in total-weights-sum.
  * Records individual weights per tracking address (not per enrolled address).

Notes:

* Multiple enrolled addresses sharing the same tracking address will share the same weight.
* Can be called in batches of up to 900 participants.

#### finalize-weight-computation

Finalizes the weight computation phase. Permissionless.

* Assertions:
  * The ratio must be validated.
  * Weights must not already be finalized.
  * All participants must have weights computed.
* Effect:
  * Marks weights as computed.
  * Sets last operation state to "weights-finalized".
  * Enables the reward distribution phase.

***

### 7. Reward Distribution

#### set-is-distribution-enabled

Prepares the contract to distribute rewards by determining the available reward pool. Permissionless.

* Assertions:
  * The contract must be active.
  * Distribution must not already be enabled.
  * Weights must be computed.
* Effect:
  * Reads the contract's sBTC balance.
  * Calculates rewards to distribute: min(pool balance, APR-based cap).
  * The cap is: $$(CPR × total-weights-sum) / (M + 1)$$
  * Marks rewards as ready for distribution.
  * Sets last operation state to "set-can-distribute".

#### distribute-rewards

Distributes rewards to participants based on their computed weights. Permissionless.

* Parameters: principals (list of up to 900 principals)
* Assertions:
  * Distribution must be enabled.
* Effect:
  * Calculates reward for each participant: (weight / total-weights) × total-rewards
  * Transfers sBTC rewards to rewarded addresses.
  * Marks participants as rewarded.
  * Aggregates rewards per rewarded address.

Notes:

* Can be called in batches of up to 900 participants.
* Multiple enrolled addresses sharing the same rewarded address aggregate rewards and only trigger one transfer per tracking address.

#### finalize-reward-distribution

Marks reward distribution as finalized for the current cycle. Permissionless.

* Assertions:
  * The contract must be active.
  * All participants must be rewarded.
  * Distribution must be enabled.
  * Must not already be finalized.
* Effect:
  * Records the finalization block height.
  * Sets last operation state to "finalized".
  * Enables cycle advancement.
  * Triggers external DeFi protocols to distribute their internal rewards (they monitor this finalization event).

***

### 8. Administrative Controls

* update-admin
* update-min-sbtc-hold-required-for-enrollment
* update-snapshot-length
* update-snapshots-per-cycle
* update-cycle-data
* update-bitcoin-blocks-per-year
* update-APR
* update-yield-boost-multiplier
* set-liquid-stacking
* emergency-withdraw-sbtc

(Each of the above has parameters, admin-only assertions where applicable, and effects described in the original spec. Notable constraints include APR bounds and multiplier bounds.)

***

### 9. Blacklist Management

* add-blacklisted
* add-blacklisted-batch
* remove-blacklisted
* remove-blacklisted-batch

(Admin-only operations to manage blacklist; adding an enrolled address auto opts it out.)

***

### 10. DeFi Whitelist Management

#### whitelist-defi-tracking

Adds a DeFi tracking address to the whitelist (gives maximum weight boost automatically).

* Parameters: defi-rewards-contract (principal)
* Assertions:
  * Caller must be the admin.
  * Address must not already be whitelisted.
* Effect:
  * Adds the tracking address to the whitelist.
  * Whitelisted addresses receive maximum boost (r<sub>i</sub> = 1.0) in weight calculations.
  * During snapshots, whitelisted addresses have their STX stacking recorded as 0 (they don't need to stack STX to receive max boost).

#### remove-whitelisted-defi-tracking

Removes a DeFi tracking address from the whitelist (admin only).

* Parameters: defi-rewards-contract (principal)
* Assertions:
  * Caller must be the admin.
  * Address must be whitelisted.
* Effect:
  * Removes the tracking address from the whitelist.

#### remove-whitelisted-defi-tracking-batch

Batch removes DeFi tracking addresses from the whitelist (admin only).

* Parameters: defi-rewards-contract (list 200 principal)
* Assertions:
  * Caller must be the admin.
* Effect:
  * Removes multiple tracking addresses from the whitelist.

***

## Private Functions

* update-snapshot-for-new-cycle: Resets snapshot counters and sets initial snapshot block heights.
* reset-state-for-cycle: Applies next-cycle configuration, resets flags and totals, records cycle data, updates participant count.
* capture-participant-balances: Reads sBTC and STX stacked at snapshot height, updates holdings and aggregates totals.
* calculate-participant-weight: Computes weight per tracking address using the dual stacking formula (integer math details in original spec).
* tally-user-ratio: Classifies a user's ratio relative to a proposed ratio and accumulates sBTC totals.
* distribute-reward-user: Transfers reward per tracking address and updates rewarded status.
* remove-participant: Deletes participant and decrements counts.
* enroll-defi-one / change-addresses-defi-one: helpers for batch operations.
* is-blacklisted: checks blacklist membership.

(Private functions implement the described effects and integer scaling considerations; refer to function details above for math/scaling behavior.)

***

## Read-Only Functions

### Cycle Information

* get-current-cycle-id
* cycle-data
* get-cycle-current-state
* current-overview-data
* get-yield-cycle-data
* nr-cycles-year
* cycle-percentage-rate

### Snapshot Information

* snapshot-data
* get-stacks-block-height-for-cycle-snapshot
* get-bitcoin-block-height-for-cycle-snapshot

### Reward Information

* get-reward-distribution-status
* is-distribution-ready
* reward-amount-for-cycle-and-address
* reward-amount-for-cycle-and-reward-address
* is-distribution-finalized-for-current-cycle
* get-distribution-finalized-at-height

### Ratio and Weight Information

* get-ratio-data
* get-weight-computation-status
* get-participant-weight

### Participant Information

* is-enrolled-in-next-cycle
* is-enrolled-this-cycle
* get-is-blacklisted
* get-is-blacklisted-list
* get-is-whitelisted-defi
* get-latest-reward-address
* get-participant-cycle-info

### State and Configuration

* get-last-operation-state
* get-admin
* get-is-contract-active
* get-current-bitcoin-block-height
* get-minimum-enrollment-amount
* get-next-action-bitcoin-height
* get-contract-sbtc-balance
* get-apr-data

### STX Stacking Queries

* get-amount-stx-stacked
* get-amount-stx-stacked-at-block-height
* get-amount-stacked-at-block-height
* get-amount-stacked-now


# FAQ

Clarifying some common questions and sharing external resources for Dual Stacking

#### General Dual Stacking Questions

<details>

<summary>Why can't other chains do this?</summary>

Other blockchains pay rewards in what they can mint (ETH, SOL, etc.). They have no mechanism to channel real Bitcoin.

Stacks has Proof of Transfer (PoX): Consensus mechanism that channels Bitcoin from miners to network participants. Operational since 2021. Over 4,000 BTC moved through PoX to date. This architectural difference makes Bitcoin earning Bitcoin rewards possible.

</details>

<details>

<summary>How is this different from wrapped BTC?</summary>

Rewards are paid in sBTC, redeemable for Bitcoin at any time and actual Bitcoin through PoX consensus, not platform tokens.

{% hint style="info" %}
**What is sBTC?**

sBTC is a [SIP-010](https://github.com/stacksgov/sips/blob/main/sips/sip-010/sip-010-fungible-token-standard.md) token on Stacks that can be converted back to BTC on Bitcoin. The key property of sBTC is its 1:1 peg to Bitcoin, meaning 1 sBTC is always equivalent to 1 BTC.
{% endhint %}

</details>

<details>

<summary>When is this live?</summary>

sBTC has been operational since December 2024. Dual Stacking launches November 2025.

{% hint style="info" %}
Coinciding with the Dual Stacking launch, the existing sBTC Rewards Program will sunset on October 31, 2024.
{% endhint %}

</details>

<details>

<summary>What will happen to the sBTC Rewards Program?</summary>

Coinciding with the Dual Stacking launch, the existing sBTC Rewards Program will sunset on October 31, 2024. But don’t worry, you can earn even more sBTC with Dual Stacking - a new way to stack both STX and sBTC to create stronger alignment between Bitcoin capital and the Stacks network.

**Key Dates to be aware of:**

Oct 30: Dual Stacking launches and you can enroll to start earning

Nov 4: sBTC Rewards Program ends and final rewards distributed

Nov 5: First Dual Stacking rewards cycle begins

Nov 20 (estimated): First Dual Stacking rewards cycle ends, rewards distributed\\

</details>

#### Dual Stacking Rewards

<details>

<summary>What are the minimum requirements?</summary>

The minimum to mint sBTC via the sBTC Bridge app is currently at 0.001 BTC (100,000 sats).

The minimum to enroll in Dual Stacking with your minted sBTC will be 0.0001 sBTC (10,000 sats).

Stacking STX is done normally through stacking pools, so no minimum. The Dual Stacking web app will auto-detect if a user is currently stacking STX.

</details>

<details>

<summary>Can I just stack BTC?</summary>

Yes, if you lock BTC only, you still earn base rewards. No STX required to participate.

</details>

<details>

<summary>Where does the yield come from?</summary>

Stacks is the only blockchain with Proof of Transfer—a consensus mechanism that channels BTC from miners to participants who secure the network by Stacking STX. At launch, Dual Stacking rewards will come from Stacks entities who volunteer their Stacking rewards (earned via Proof of Transfer) to Dual Stacking participants as sBTC.

</details>

<details>

<summary>How often are rewards paid out?</summary>

Rewards are paid out roughly every 2 weeks in line with PoX stacking cycles, with the first cycle beginning on November 5, 2025.

</details>

<details>

<summary>How are rewards calculated?</summary>

A Dual Stacking calculator is available in-app to help estimate your annual rewards based on the ratio of BTC/STX you are stacking. The system uses a square-root reward curve that creates diminishing returns, meaning your first STX paired with BTC has the biggest impact on your rewards, while additional STX continues to help at a decreasing rate. Review the [Dual Stacking Litepaper](https://github.com/stx-labs/papers/blob/main/Dual%20Stacking%20Litepaper.pdf) for more details.

</details>

<details>

<summary>How will this impact my existing Stacking rewards?</summary>

Dual Stacking does not modify PoX consensus, meaning there is no direct change to native Stacking rewards. No action is required to continue natively Stacking. Dual Stacking may indirectly impact stacking rewards by increasing more stacking participation overall.

</details>

#### Concerning Dual Stacking Security

<details>

<summary>What are the trust assumptions?</summary>

Dual Stacking operates as a transparent smart contract on the Stacks network. sBTC bridge operations are secured by a federation of [reputable signers](https://www.stacks.co/sbtc), with a 70% threshold of signer approval required for any transaction. No single entity can move funds unilaterally.

</details>

#### External Resources

* [\[Twitter\]](https://x.com/andrerserrano/status/1977845457226178757) Dual Stacking Litepaper Announcement from Andre Serrano
* [\[Github\]](https://github.com/stx-labs/papers/blob/main/Dual%20Stacking%20Litepaper.pdf) Official Dual Stacking Litepaper
* [\[Stacks Forum\]](https://forum.stacks.org/t/stacks-economic-model-unlocking-bitcoin-capital-long-term-growth/18035#dual-stacking-aligning-btc-and-stx-incentives-3) Initial Dual Stacking Announcement
* [\[Stacks Official\]](https://www.stacks.co/dual-stacking) Dual Stacking landing page on stacks.co
* \[[Stacks Blog](https://www.stacks.co/blog/dual-stacking-launches-on-stacks)] Official blog announcement
* \[[Stacks Twitter](https://x.com/Stacks/status/1983900168954286342)] Official twitter announcement
* \[[Dual Stacking App](https://app.stacks.co/)] Official Dual Stacking App

#### Related Technical Resources

* [\[Explorer\]](https://explorer.hiro.so/txid/SP1HFCRKEJ8BYW4D0E3FAWHFDX8A25PPAA83HWWZ9.dual-stacking-v1?chain=mainnet) `dual-stacking-v1` : Main Dual Stacking Contract


# Introduction

Build powerful apps, secured by Bitcoin.

<div data-with-frame="true"><figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2FGdHL7viBPTUy5YMx9dxN%2Fbuild-intro.png?alt=media&#x26;token=77008faf-011e-4e21-90f0-f4b108a11598" alt=""><figcaption></figcaption></figure></div>

<details>

<summary><strong>New to building with Stacks? Check out these weekly virtual meets!</strong></summary>

* **Stacks DevRel office hours**: Follow and enable notifications for [@StacksDevs](https://x.com/StacksDevs) on Twitter to catch alerts for our weekly livestreams every Thursday at 10am EST. Office Hours are the easiest way to stay in the loop on product drops, live demos, community builder spotlights, and more. Stay up-to-date with release discussions, real-time walkthroughs, and builder highlights that matter.
* **Clarity Working Group**: An open, developer-focused initiative dedicated to supporting builders across the Stacks ecosystem. The group brings together experienced Clarity engineers (“Clarity giga chads”), auditors, educators, grant project teams, and new developers to collaborate, learn, and advance smart contract development on Bitcoin. Check out the calendar [link](https://www.addevent.com/event/yc0x95fky8y4) to join every other Tuesday.
* **AI BTC Working Group:** Join the **AI BTC Working Group**'s (WG) weekly meeting on AIBTC's twitter account, where they delve into the exciting intersection of AI and Bitcoin. Check out the calendar [link](https://www.addevent.com/event/c3qjy462xr82) to join every Thursday.
* **Runes Capsule Webinars:** Join a weekly deep-dive into Runes Capsule architecture, Bitcoin bridging, and trust minimized design patterns on Stacks. Check out this [link](https://calendar.google.com/calendar/u/0/r?cid=b247d75eb1a11dc3ebbf0c62eb4a1c83b4a53d4d2f903eaa19d685f28f087f92%40group.calendar.google.com) to join every Sundays.

</details>

{% hint style="info" %}
Stacks ranks #5 among all crypto ecosystems for new developers in 2025! \[source: Electric Capital]
{% endhint %}

### Hello, Builders 👋

Stacks is a fast, low-cost, builder-friendly layer 2 network on Bitcoin. It’s built on Bitcoin, inheriting Bitcoin’s battle-tested security. By jumping into our docs, you’re joining the Stacks builder community that’s bringing a global onchain economy to Bitcoin.

If you're here on this page, hopefully you've already gotten a good sense of *what* Stacks' purpose is, if not, head to the [Learn](https://app.gitbook.com/o/hoh4mQXTl8NvI3cETroY/s/H74xqoobupBWwBsVMJhK/) section. Or if you're still on the edge of *why* you should build with Stacks, head to [Why Build with Stacks](https://docs.stacks.co/build/get-started/introduction/why-build-with-stacks).

***

### Pick your learning path

We all have different styles of learning. If you've already got a good concept of web3 fundamentals and want to get a quick taste of what the DevEx is like on Stacks, then check out the [Developer Quickstart](https://docs.stacks.co/build/get-started/developer-quickstart). Or find the path that clicks for you — and if bandwidth allows, tackle them all!

<table data-view="cards"><thead><tr><th></th><th data-hidden data-card-target data-type="content-ref"></th></tr></thead><tbody><tr><td><strong>Try the Developer Quickstart</strong></td><td><a href="developer-quickstart">developer-quickstart</a></td></tr><tr><td><strong>Start Learning Clarity</strong></td><td><a href="clarity-crash-course">clarity-crash-course</a></td></tr><tr><td><strong>Bitcoin Primer Tutorial</strong></td><td><a href="https://app.gitbook.com/s/skGYu79qDNfITOqDNU3s/bitcoin-primer">Bitcoin Primer</a></td></tr><tr><td><strong>Earn a Stacks Developer Degree</strong></td><td><a href="https://learnweb3.io/degrees/stacks-developer-degree/">https://learnweb3.io/degrees/stacks-developer-degree/</a></td></tr><tr><td><strong>Watch Our Hands-On Videos</strong></td><td><a href="https://www.youtube.com/@stacks-developers">https://www.youtube.com/@stacks-developers</a></td></tr><tr><td><strong>Clarity Development Using Clarinet</strong></td><td><a href="../clarinet">clarinet</a></td></tr></tbody></table>

***

### Who should use what

| If you are…                                                                               | First check out...                                                                                                                                            |
| ----------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Completely new to building with Stacks                                                    | [Developer Quickstart](https://docs.stacks.co/build/get-started/developer-quickstart)                                                                         |
| Learning smart contract development                                                       | [Clarity Crash Course](https://docs.stacks.co/build/get-started/clarity-crash-course), [Learn Clarinet](https://docs.stacks.co/build/clarinet)                |
| Preferring a structured, guided course that shows you every step to build full-stack apps | [Stacks Developer Degree](https://learnweb3.io/degrees/stacks-developer-degree/), [Bitcoin Primer](https://docs.stacks.co/build/get-started/broken-reference) |
| Wanting to integrate sBTC in your app                                                     | [sBTC guides](https://docs.stacks.co/build/more-guides/sbtc)                                                                                                  |
| Launching a token                                                                         | [Create Tokens](https://docs.stacks.co/build/get-started/create-a-token)                                                                                      |
| Interested in security / auditing                                                         | [Stacks Bug Bounties](https://immunefi.com/bug-bounty/stacks/information/)                                                                                    |

***

### Still got questions?

We know, it's a lot. But we, along with our large community, are always more than welcome to help you throughout your journey with Stacks.

* [**Stacks Discord**](https://discord.gg/stacks): Connect with other developers and our team
* [**Stacks Forum**](https://forum.stacks.org/): Ask questions and share projects
* [**Stacks Twitter**](https://x.com/StacksDevs)**:** Follow us on Twitter and ask us questions there&#x20;


# Why Build with Stacks

Diving into the question of why we're all here

{% embed url="<https://youtu.be/eqFFX4Sx9mY?si=XcH6Bo3nTQusW0Tp>" %}

### Why build with Stacks

Build on Bitcoin with Stacks because builders don’t need a new base layer — they need a better app layer. Stacks anchors to Bitcoin finality while enabling clear, auditable contracts and expressive logic, making BTC useful beyond holding. With production-ready tooling and one of the most active Bitcoin L2 developer communities, you get momentum, collaboration, and Bitcoin-aligned product-market fit from day one. If you want Bitcoin capital with real applications, Stacks is the path of least resistance and greatest leverage.

### What does it mean to build with Stacks

Building with Stacks means creating applications and smart contracts that ***extend*** the power of Bitcoin without altering Bitcoin itself. It’s about inheriting Bitcoin’s security, finality, and economic gravity, while gaining the expressiveness needed for decentralized apps, ownership-first systems, and programmable digital assets.&#x20;

Developers use easy, LISP-like contracts written in the Clarity language, interact with the chain using familiar tooling like Stacks.js, automate on-chain responsiveness with Chainhooks, enable Bitcoin programmability via sBTC, and tap into indexed on-chain data through reliable APIs.&#x20;

Ultimately, **building with Stacks is a mindset**: leverage Bitcoin as the base layer, but experiment boldly at the application layer—where users keep custody of their bitcoin via sBTC, transactions enforce intent, and decentralized systems become useful enough for everyday life.

### Benefits of building with Stacks

<details>

<summary>🌐 Global Community</summary>

***Diverse and Vibrant:*** Stacks has a massive global builder community where collaboration happens at internet speed, not conference speed. You plug into shared momentum, talent, diversity, and distribution across a network anchored by Bitcoin.

* \[[Hiro YT](https://youtu.be/jjSbIKRb8Z8?si=JRzdbiBWq9mLKVaz)] Meeting Rockstar Web3 Builders at the EasyA x Stacks Hackathon
* \[[StacksDevs](https://x.com/StacksDevs/status/1991506865394774371)] Photos from the Stacks Hacker House in Buenos Aires
* \[[Stacks YT](https://youtu.be/UB6pkG58wYo?si=ITiW7xhz8odfa59T)] How Stacks Took Over Miami

</details>

<details>

<summary>🎨 Creator Tools</summary>

***The Bitcoin-Backed Creator Economy:*** From artists to influencers, creators are seeking smarter ways to capture value. With Stacks, you can push the boundaries of monetization, powered by Bitcoin capital and programmable Clarity contracts.

* \[[Hiro Blog](https://www.hiro.so/blog/what-is-bitcoin-culture-see-it-through-bitcoin-nfts)] What is “Bitcoin Culture?” See it through Bitcoin NFTs
* \[[Hiro Blog](https://www.hiro.so/blog/building-an-accelerator-for-african-creators-with-osinachi-africas-foremost-nft-artist)] Building an Accelerator for African Creators With Osinachi, Africa’s Foremost NFT Artist&#x20;
* \[[Hiro Blog](https://www.hiro.so/blog/a-look-inside-gammas-create-portal-and-how-it-empowers-nft-creators)] A Look Inside Gamma’s Create Portal and How It Empowers NFT Creators

</details>

<details>

<summary>🛠️ Developer Experience</summary>

***Built for Builders:*** Stacks offers everything you need — tooling, infra, and hands-on support. Backed by one of the largest on-chain dev communities, it’s a place to collaborate, level up, and build the future together.

* \[[Hiro YT](https://youtu.be/gPG6ZFGpYo0?si=hMxIxGJjuoggfD8Q)] Exploring Web3 Developer Tooling With the Clarinet Team
* \[[Bitcoin Builders YT](https://youtu.be/RCHbqfaUbHQ?si=j5BLw6lCIYAq52RI)] What is the Dev Experience for Bitcoin Layers?

</details>

<details>

<summary>🏗️ Builder Programs</summary>

***Support at Every Step:*** Stacks runs specialized builder programs that give you capital, feedback, and community validation, not just swag and tweets. You get structured support that compounds long after demo day.

* \[[Stacks Ascent](https://stacks.org/ascent)] From Code to Company
* \[[Stacks Foundation](https://stacks.org/grants)] Grants & Bounty Programs&#x20;

</details>


# Developer Quickstart

Your 0→1 guide for building a Clarity contract and app on Stacks.

<figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2Fgit-blob-8964e1069c12ec8e68a70911dbfc7c0ba0434fc5%2FFrame%20316125324.jpg?alt=media" alt=""><figcaption></figcaption></figure>

**Welcome to the Stacks Developer Quickstart Guide!**\
This is your fast-track path for understanding what you'll need to become a Stacks developer. In this guide, you’ll build a real Clarity smart contract, wire up a functioning Stacks app, and pick up about 75% of the practical knowledge every Stacks builder needs. Whether you’re shipping your first project or leveling up your skills, this guide takes you from zero to deployed—quickly and confidently.

### What you'll achieve

By the end of this quickstart, you’ll have built an onchain app by:

* Building a Clarity smart contract with Clarinet
* Utilize the 1:1 Bitcoin backed token, sBTC
* Deploying your smart contract to Stacks' testnet
* Interacting with your deployed contract from a frontend app

{% hint style="success" %}
**Why Stacks?**

Stacks is a fast, low-cost, builder-friendly layer 2 network on Bitcoin. It’s built on Bitcoin, inheriting Bitcoin’s battle-tested security. By jumping into this guide, you’re joining the Stacks community that’s bringing a global onchain economy to Bitcoin.
{% endhint %}

### What You'll Build

The app you'll build will be a message board contract. Users can add a new message to store on-chain for a fee of 1 satoshi in sBTC. Other functionality to read data from the contract will also be handled. Besides sBTC, there will be other things that'll be introduced to you such as post-conditions, Bitcoin read access, unit testing, wallet connectivity, BNS, Hiro, and more. Hopefully all this will give you a good flavor of what you can expect in the Stacks builder ecosystem.

Let's start building on Bitcoin! :orange\_square:

{% hint style="info" %}
**Prerequisites**

* Basic familiarity with web development
* Basic familiarity with web3 concepts
* A modern web browser
* Node.js
* Visual Studio Code or any other popular IDE
  {% endhint %}

### Set Up Your Developer Environment

{% stepper %}
{% step %}
**Install Clarinet**

Clarinet is the popular CLI tool to build, test, and deploy smart contracts on the Stacks blockchain.

Below are a few different ways to install Clarinet on your machine using your terminal. Refer to the dedicated [installation](https://docs.stacks.co/build/clarinet/overview) guide in the 'Learn Clarinet' section for more information.

{% tabs %}
{% tab title="Homebrew" %}

```bash
brew install clarinet
```

{% endtab %}

{% tab title="Winget" %}

```bash
winget install clarinet
```

{% endtab %}

{% tab title="Source" %}

```bash
sudo apt install build-essential pkg-config libssl-dev
git clone https://github.com/stx-labs/clarinet
cd clarinet
cargo clarinet-install
```

{% endtab %}

{% tab title="Binary" %}

```bash
wget -nv https://github.com/stx-labs/clarinet/releases/latest/download/clarinet-linux-x64-glibc.tar.gz -O clarinet-linux-x64.tar.gz
tar -xf clarinet-linux-x64.tar.gz
chmod +x ./clarinet
mv ./clarinet /usr/local/bin
```

{% endtab %}
{% endtabs %}
{% endstep %}

{% step %}
**Install Clarity Extension**

You'll also want to install the Clarity Extension for your code editor. The official one is '[Clarity - Stacks Labs](https://marketplace.visualstudio.com/items?itemName=StacksLabs.clarity-stacks)' which is maintained by [Stacks Labs](https://stackslabs.com/).

<details>

<summary>What is Clarity?</summary>

Clarity is Stacks' smart contract language, designed for safety and predictability.

Clarity is inspired by LISP and uses a functional programming approach. Everything in Clarity is an expression wrapped in parentheses. This can be a bit overwhelming at first if you are used to languages like JavaScript or Solidity, but the learning curve is short and Clarity is a simple language to understand once you dive in and start using it.

Check out the [Clarity Crash Course](https://docs.stacks.co/build/get-started/clarity-crash-course) for a quick primer.

</details>

<div data-with-frame="true"><figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2Fgit-blob-905e73353b0556c91fdaeb15a3a02bdc7e2aa789%2Fclarity-extension.png?alt=media" alt=""><figcaption><p>The 'Clarity - Stacks Labs' extension as it appears in Visual Studio Code.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Install a Stacks wallet**

There are many Stacks supported wallets in the market. For this guide, we'll be using the [Leather](https://leather.io/) wallet. Leather supports Stacks, Bitcoin, and other Bitcoin related meta-protocols. Download and install its browser extension so you can interact with your smart contract later on in this guide. Make sure to switch to the **Testnet** network in your wallet settings. Later on, we'll show you how to get testnet STX and sBTC tokens that you'll use for contract interaction.
{% endstep %}
{% endstepper %}

### Create a Clarity smart contract

{% stepper %}
{% step %}
**Create a new Clarinet project**

Let's start by creating a new Clarinet project which will house our smart contract. The `clarinet new` command sets up everything you need for smart contract development, including a testing framework, deployment configurations, and a local development environment.

{% code title="terminal" %}

```
clarinet new my-stacks-contracts
```

{% endcode %}

A Clarinet project will be scaffolded with the below:

{% code title="terminal" expandable="true" %}

```
Created directory my-stacks-contracts
Created directory contracts
Created directory settings
Created directory tests
Created file Clarinet.toml
Created file settings/Mainnet.toml
Created file settings/Testnet.toml
Created file settings/Devnet.toml
Created directory .vscode
Created file .vscode/settings.json
Created file .vscode/tasks.json
Created file .gitignore
Created file .gitattributes
Created file package.json
Created file tsconfig.json
Created file vitest.config.ts

----------------------------
Hint: what's next?
Switch to the newly created directory with:

  $ cd my-stacks-contracts

Once you are ready to write your contracts, run the following commands:

  $ clarinet contract new <contract-name>
    Create new contract scaffolding, including test files.

  $ clarinet check
    Check contract syntax for all files in ./contracts.
```

{% endcode %}
{% endstep %}

{% step %}
**Generate your contract**

Now that we have our project structure, let's create a smart contract. Navigate into your project directory and use Clarinet's contract generator:

```sh
$ cd my-stacks-contracts
$ clarinet contract new message-board
Created file contracts/message-board.clar
Created file tests/message-board.test.ts
Updated Clarinet.toml with contract message-board
```

Clarinet automatically creates both your contract file and a corresponding test file.
{% endstep %}
{% endstepper %}

### Write your Clarity smart contract

{% stepper %}
{% step %}
**Define constants**

Open `contracts/message-board.clar` and remove its existing content. This is where we'll start writing our own Clarity smart contract.

Let's first define some constants:

* contract owner to establish control access
* custom error codes to handle errors in functions

<pre class="language-clarity" data-title="message-board.clar"><code class="lang-clarity">;; Simple Message Board Contract
;; This contract allows users to read and post messages for a fee in sBTC.

;; Define contract owner
<strong>(define-constant CONTRACT_OWNER tx-sender)
</strong>
;; Define error codes
<strong>(define-constant ERR_NOT_ENOUGH_SBTC (err u1004))
</strong><strong>(define-constant ERR_NOT_CONTRACT_OWNER (err u1005))
</strong><strong>(define-constant ERR_BLOCK_NOT_FOUND (err u1003))
</strong></code></pre>

You'll notice in the `CONTRACT_OWNER` constant that `tx-sender` is set in place as the value. When this contract is deployed, the Clarity VM will determine who the `tx-sender` is based on who deployed the contract. This allows the hardcoded `tx-sender` to always point to the principal that deployed the contract.
{% endstep %}

{% step %}
**Define data storage**

We'll then need to define some data storage:

* A map to store key-value pairs of the message id and it's related metadata
* A data variable to count the total number of messages added

<pre class="language-clarity" data-title="message-board.clar"><code class="lang-clarity">;; Define a map to store messages
;; Each message has an ID, content, author, and Bitcoin block height timestamp
<strong>(define-map messages
</strong>  uint
  {
    message: (string-utf8 280),
    author: principal,
    time: uint,
  }
)

;; Counter for total messages
<strong>(define-data-var message-count uint u0)
</strong></code></pre>

{% endstep %}

{% step %}
**Define an add message function**

Next up is our main function of the contract. This function allows users to add a new message to the contract for a fee of 1 satoshi in sBTC. Invoking this function will change the state of our contract and update the data storage pieces we setup before.

<pre class="language-clarity" data-title="message-board.clar" data-expandable="true"><code class="lang-clarity">;; Public function to add a new message for 1 satoshi of sBTC
;; @format-ignore
<strong>(define-public (add-message (content (string-utf8 280)))
</strong>  (let ((id (+ (var-get message-count) u1)))
    (try! (restrict-assets? contract-caller 
      ((with-ft 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token "sbtc-token" u1))
      (unwrap!
        ;; Charge 1 satoshi of sBTC from the caller
        (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token
          transfer u1 contract-caller current-contract none
        )
        ERR_NOT_ENOUGH_SBTC
      )
    ))
    ;; Store the message with current Bitcoin block height
    (map-set messages id {
      message: content,
      author: contract-caller,
      time: burn-block-height,
    })
    ;; Update message count
    (var-set message-count id)
    ;; Emit event for the new message
    (print {
      event: "[Stacks Dev Quickstart] New Message",
      message: content,
      id: id,
      author: contract-caller,
      time: burn-block-height,
    })
    ;; Return the message ID
    (ok id)
  )
)
</code></pre>

There's quite a lot going on in this function above that covers in-contract post-conditions, calling the official sBTC token contract, reading Bitcoin state, emitting events, and etc. We'll break it down for you:

<details>

<summary>Define public function and params</summary>

```clarity
(define-public (add-message (content (string-utf8 280)))
    ;; function body
)
```

By using the `define-public` function, we can literally create a public function where anyone can invoke.

* `(add-message ... )` : the custom name of the public function
* `(content (string-utf8 280))` : the custom paramater name and type

</details>

<details>

<summary>Create let variable binding for next message id</summary>

```clarity
(let ((id (+ (var-get message-count) u1)))
    ;; body expressions
)
```

Creates a "local" variable that can be used inside the function body only. This `id` variable will be used to represent the new message id being added.

</details>

<details>

<summary>Transfer 1 satoshi of sBTC from user to the contract</summary>

<pre class="language-clarity"><code class="lang-clarity">(try! (restrict-assets? contract-caller 
  ((with-ft 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token "sbtc-token" u1))
  (unwrap!
    ;; Charge 1 satoshi of sBTC from the caller
<strong>    (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token
</strong>      transfer u1 contract-caller current-contract none
    )
    ERR_NOT_ENOUGH_SBTC
  )
))
</code></pre>

This snippet calls the external .`sbtc-token` contract to transfer sBTC.

The `restrict-assets?` acts as an in-contract post-condition to protect user and contract funds when calling external contracts to transfer assets.

</details>

<details>

<summary>Store message data in mapping</summary>

```clarity
(map-set messages id {
  message: content,
  author: contract-caller,
  time: burn-block-height,
})
```

The function `map-set` will allow the existing mapping of `messages` to add a new key-value pair consiting of the metadata of the new message.

We'll be using the current Bitcoin block height (via `burn-block-height`) as a way to capture the time of when this new message was added. Through `burn-block-height` , Clarity allows us to have read access into the Bitcoin state at anytime.

</details>

<details>

<summary>Update the message-count variable</summary>

```clarity
(var-set message-count id)
```

Increments the existing data variable of `message-count` with the `let` id variable.

</details>

<details>

<summary>Emit an event to the network</summary>

```clarity
(print {
  event: "[Stacks Dev Quickstart] New Message",
  message: content,
  id: id,
  author: contract-caller,
  time: burn-block-height,
})
```

The `print` function will allow us to emit a custom event to the Stacks network.

Emitting events on Stacks serves several critical purposes:

1. **Transparency**: Events provide an on-chain record of actions and transactions, ensuring transparency.
2. **Notification**: They serve as a signal mechanism for users and external applications, notifying them of specific occurrences on Stacks.
3. **State Tracking**: Developers can use events to track changes in the state of smart contracts without querying the chain continuously.
4. **Efficient Data Handling**: By emitting events, webhook services, such as Hiro's [Chainhooks](https://docs.hiro.so/en/tools/chainhooks), can filter and handle relevant data efficiently, reducing the on-chain computation load.

</details>

<details>

<summary>Return final response</summary>

<pre class="language-clarity"><code class="lang-clarity">;; Return the message ID
<strong>(ok id)
</strong></code></pre>

Public functions *must* return a ResponseType (using either `ok` or `err`). In this case, we'll return a response type with an inner value of the new message id.

</details>
{% endstep %}

{% step %}
**Add sBTC contract requirements**

Since we're working with sBTC in our local developer environment, we'll need to make sure Clarinet can recognize this. Clarinet can automatically wire up the official sBTC contracts so you can build and test sBTC flows locally.

In our case, all we'll need to do is add the [`.sbtc-deposit`](https://explorer.hiro.so/txid/SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-deposit?chain=mainnet) contract as a project requirement.

{% code title="terminal" %}

```
clarinet requirements add SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-deposit
```

{% endcode %}

You'll notice in the `add-message` public function, we're making an external contract call to the [`.sbtc-token`](https://explorer.hiro.so/txid/0xead2080826685a98886891cbd9b288d367ae19b357353c71fff4a3330da582c8?chain=mainnet) contract. This is the official sBTC token contract that contains the [SIP-010](https://github.com/stacksgov/sips/blob/main/sips/sip-010/sip-010-fungible-token-standard.md) standard `transfer` function that we are invoking.

Check out the dedicated [sBTC integration](https://docs.stacks.co/build/clarinet/integrations/sbtc) page to learn more.
{% endstep %}

{% step %}
**Allow contract owner to withdraw funds**

In the beginning of our contract, we defined a constant to store the Stacks principal of the contract owner. Having a contract owner allows for specific access control of the contract that is entitled to the owner. Let's allow the owner to be able to withdraw the accumulated sBTC fees that were sent by anyone who created a new message in the contract.

<pre class="language-clarity" data-expandable="true"><code class="lang-clarity">;; Withdraw function for contract owner to withdraw accumulated sBTC
(define-public (withdraw-funds)
  (begin
<strong>    (asserts! (is-eq tx-sender CONTRACT_OWNER) (err u1005))
</strong>    (let ((balance (unwrap-panic (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token
        get-balance current-contract
      ))))
      (if (> balance u0)
        (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token
          transfer balance current-contract CONTRACT_OWNER none
        )
        (ok false)
      )
    )
  )
)
</code></pre>

You'll notice in the highlighted line that the function performs an `asserts!` check to confirm that the `tx-sender` calling the contract is in fact the `CONTRACT_OWNER` . If it is in fact the owner of the contract, the function body proceeds with transferring the balance of sBTC to the owner or else it'll throw an error that we defined earlier.

{% hint style="info" %}
The usage of `tx-sender` versus another Clarity keyword, `contract-caller` , is always a tricky concept because it determines who actually initiated the transaction versus who invoked the current function. Both of them can have certain implications on security based on the context of your code. Check out the dedicated [blog](https://www.setzeus.com/public-blog-post/clarity-carefully-tx-sender), written by community dev Setzeus, to learn when you should use either or.
{% endhint %}
{% endstep %}

{% step %}
**Implement read only functions**

We'll round out our contract with important read only functions that will return us needed data from the contract.

<pre class="language-clarity" data-expandable="true"><code class="lang-clarity">;; Read-only function to get a message by ID
(define-read-only (get-message (id uint))
  (map-get? messages id)
)

;; Read-only function to get message author
(define-read-only (get-message-author (id uint))
  (get author (map-get? messages id))
)

;; Read-only function to get message count at a specific Stacks block height
(define-read-only (get-message-count-at-block (block uint))
<strong>  (ok (at-block
</strong>    (unwrap! (get-stacks-block-info? id-header-hash block) ERR_BLOCK_NOT_FOUND)
    (var-get message-count)
  ))
)
</code></pre>

You'll notice the usage of a `at-block` function in the highlighted line of code. The `at-block` function evaluates the inner expression *as if* it were evaluated at the end of a specific Stacks block.
{% endstep %}

{% step %}
**Test your contract**

Now with the actual writing of your contract complete, we now need to test its functionality. There's a few different ways we can go about iterating and testing the functionality of your contract.

* Contract interaction in the [Clarinet REPL](https://docs.stacks.co/build/clarinet/contract-interaction)
* Running your contract in a [local blockchain environment](https://docs.stacks.co/build/clarinet/local-blockchain-development)
* Fuzz testing with [Rendezvous](https://stacks-network.github.io/rendezvous/)
* Writing unit tests with the [Clarinet JS SDK](https://docs.stacks.co/build/clarinet-js-sdk/overview)

We'll go with unit testing for now. In your `tests` folder, open up the related `message-board.test.ts` file and let's use the unit test written below.

<pre class="language-typescript" data-title="tests/message-board.test.ts" data-line-numbers data-expandable="true"><code class="lang-typescript">import { Cl, ClarityType } from "@stacks/transactions";
import { describe, expect, it } from "vitest";

const accounts = simnet.getAccounts();
const deployer = accounts.get("deployer")!;
const address1 = accounts.get("wallet_1")!;

describe("example tests", () => {
  let content = "Hello Stacks Devs!"

<strong>  it("allows user to add a new message", () => {
</strong>    let currentBurnBlockHeight = simnet.burnBlockHeight;

    let confirmation = simnet.callPublicFn(
      "stacks-dev-quickstart-message-board",
      "add-message",
      [Cl.stringUtf8(content)],
      address1
    )

    const messageCount = simnet.getDataVar("stacks-dev-quickstart-message-board", "message-count");
    
    expect(confirmation.result).toHaveClarityType(ClarityType.ResponseOk);
    expect(confirmation.result).toBeOk(messageCount);    
    expect(confirmation.events[1].data.value).toBeTuple({
      author: Cl.standardPrincipal(address1),
      event: Cl.stringAscii("[Stacks Dev Quickstart] New Message"),
      id: messageCount,
      message: Cl.stringUtf8(content),
      time: Cl.uint(currentBurnBlockHeight),
    });
  });

<strong>  it("allows contract owner to withdraw funds", () => {
</strong>    simnet.callPublicFn(
      "stacks-dev-quickstart-message-board",
      "add-message",
      [Cl.stringUtf8(content)],
      address1
    )
    
    simnet.mineEmptyBurnBlocks(2);

    let confirmation = simnet.callPublicFn(
      "stacks-dev-quickstart-message-board",
      "withdraw-funds",
      [],
      deployer
    )
    
    expect(confirmation.result).toBeOk(Cl.bool(true));
    expect(confirmation.events[0].event).toBe("ft_transfer_event")
    expect(confirmation.events[0].data).toMatchObject({
      amount: '1',
      asset_identifier: 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token::sbtc-token',
      recipient: deployer,
      sender: `${deployer}${".stacks-dev-quickstart-message-board"}`,
    })
  })
});

</code></pre>

You'll notice we have two `it` blocks setup to test out 2 different scenarios:

1. Allows user to add a new message
2. Allows owner to withdraw sBTC funds

Run the test via `npm run test` to confirm that the two scenarios are functioning as intended.

{% code title="terminal" %}

```bash
$ npm run test

 ✓ tests/message-board.test.ts (2 tests) 46ms
   ✓ message board tests (2)
     ✓ allows user to add a new message 26ms
     ✓ allows contract owner to withdraw funds 19ms

 Test Files  1 passed (1)
      Tests  2 passed (2)
   Start at  14:05:07
   Duration  886ms (transform 40ms, setup 42ms, collect 8ms, tests 46ms, environment 699ms, prepare 4ms)
```

{% endcode %}

Great! Now that your contract is working as intended, let's deploy the contract to testnet.
{% endstep %}
{% endstepper %}

### Get testnet faucet tokens

{% stepper %}
{% step %}
**Navigate to the Hiro Platform faucet**

[Hiro](https://www.hiro.so/platform) is a platform to build and scale Bitcoin apps, including custom data streams, onchain alerts, API key management, and more. Create an account and navigate to the top tab of 'Faucet'. On the Faucet page, you can request testnet STX and/or sBTC. We'll be needing both so fund your Leather wallet account with both.

<div data-with-frame="true"><figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2Fgit-blob-00b9cf6339cbd1350ca6644d3a8c37af5b2967c3%2Fsbtc-faucet.png?alt=media" alt=""><figcaption></figcaption></figure></div>

Grab the testnet Stacks address from your Leather wallet and paste it in the recipient field.

{% hint style="warning" %}
**Important**: Switch to the **Testnet** network in your wallet settings
{% endhint %}
{% endstep %}

{% step %}
**Confirm testnet tokens in your wallet**

Open up your Leather extension to confirm that you've received testnet STX and sBTC. You might need to enable the viewing of the sBTC token in your wallet under 'Manage tokens'.

<div data-with-frame="true"><figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2Fgit-blob-1ef8ebf4e70270b22d4c7a35901626b19f811d92%2Fenable-sbtc-view.png?alt=media" alt=""><figcaption></figcaption></figure></div>

With both testnet STX and sBTC, you're ready to deploy your contract and interact with it from a front-end client.
{% endstep %}
{% endstepper %}

### Deploy your Clarity smart contract

{% stepper %}
{% step %}
**Generate testnet deployment plan**

You'll first want to input a mnemonic seed phrase in the `settings/Testnet.toml` file and specify the account derivation path that you want to use for deploying the contract. The account should be the same one you used to request testnet STX to. This will be the account that actually deploys the contract and becomes the contract owner.

<pre data-title="settings/Testnet.toml"><code>[network]
name = "testnet"
stacks_node_rpc_address = "https://api.testnet.hiro.so"
deployment_fee_rate = 10

[accounts.deployer]
<strong>mnemonic = "&#x3C;YOUR TESTNET MNEMONIC>"
</strong>derivation = "m/44'/5757'/0'/0/0"
</code></pre>

Then generate a deployment plan for the testnet network. Deployment plans are YAML files that describe how contracts are published or called.

{% hint style="warning" %}
For more information on configuring deployment plans, check out the specific guide [here](https://docs.stacks.co/build/clarinet/contract-deployment).
{% endhint %}

{% code title="terminal" %}

```bash
$ clarinet deployments generate --testnet --medium-cost
Analyzing contracts...
Calculating deployment costs...
Generating deployment plan
Created file deployments/default.testnet-plan.yaml
```

{% endcode %}
{% endstep %}

{% step %}
**Deploy contract to testnet**

Once your deployment plan is generated and configured properly, go ahead and deploy the contract to testnet.

{% code title="terminal" %}

```bash
clarinet deployments apply --testnet
```

{% endcode %}

If the contract was successfully deployed, you should see the below confirmation:

```
Broadcasting transactions to https://api.testnet.hiro.so
Publish ST11V9ZN6E6VG72SHMAVM9GDE30VD3VGW5Q1W9WX3.message-board Transaction confirmed
```

{% hint style="info" %}
A sample of the contract we just created above is already deployed to testnet [here](https://explorer.hiro.so/txid/ST11V9ZN6E6VG72SHMAVM9GDE30VD3VGW5Q1W9WX3.stacks-dev-quickstart-message-board?chain=testnet). Check out its contract page on the Stacks Explorer and directly interact with its functions.
{% endhint %}
{% endstep %}
{% endstepper %}

### Use stacks.js on the frontend

{% stepper %}
{% step %}
**Connect wallet**

Using [stacks.js](https://docs.stacks.co/build/stacks.js/overview) packages on the frontend will allow our frontend app to authenticate wallets, call our contract functions, and interact with the Stacks network.

We'll first want to connect and authenticate our Leather wallet extension with our frontend app. The stacks.js monorepo contains several underlying packages specific to different use cases. The package `@stacks/connect` is the main connectivity package used in Stacks.

In the snippet below, you'll notice we have 3 functions setup to handle `connectWallet` , `disconnectWallet`, and for `getBns` . All 3 functions will be integral in how we want to display the 'Connect' and 'Disconnect' button in the UI.

{% hint style="info" %}
Retrieving a wallet account's associated [BNS](https://app.gitbook.com/s/H74xqoobupBWwBsVMJhK/network-fundamentals/bitcoin-name-system) is a staple of Stacks and for web3 identity. Check out [BNSv2](https://www.bnsv2.com/) for more information and for availably public API endpoints you could use.
{% endhint %}

<pre class="language-typescript" data-title="src/App.tsx" data-expandable="true"><code class="lang-typescript">import { connect, disconnect } from '@stacks/connect'
import type { GetAddressesResult } from '@stacks/connect/dist/types/methods'
import { useState } from 'react'

function App() {
  let [isConnected, setIsConnected] = useState&#x3C;boolean>(false)
  let [walletInfo, setWalletInfo] = useState&#x3C;any>(null)
  let [bns, setBns] = useState&#x3C;string>('')

<strong>  async function connectWallet() {
</strong>    let connectionResponse: GetAddressesResult = await connect()
    let bnsName = await getBns(connectionResponse.addresses[2].address)

    setIsConnected(true)
    setWalletInfo(connectionResponse)
    setBns(bnsName)
  }

<strong>  async function disconnectWallet() {
</strong>    disconnect();
  }
  
<strong>  async function getBns(stxAddress: string) {
</strong>    let response = await fetch(`https://api.bnsv2.com/testnet/names/address/${stxAddress}/valid`)
    let data = await response.json()

    return data.names[0].full_name
  }
  
  return (
    &#x3C;>
      &#x3C;h3>Stacks Dev Quickstart Message Board&#x3C;/h3>
      {isConnected ? (
        &#x3C;button onClick={disconnectWallet}>{
<strong>          bns ? bns : walletInfo.addresses[2].address
</strong>        }&#x3C;/button>
      ) : (
        &#x3C;button onClick={connectWallet}>connect wallet&#x3C;/button>
      )}
    &#x3C;/>
  )
}
</code></pre>

The `connect()` method comes with ability to configure how you want the wallet selector modal to appear for your app. You can decide which wallets to have only appear as an option or allow any wallet that follows the SIP-030 standard to appear as an available Stacks wallet.

<div data-with-frame="true"><figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2Fgit-blob-78474940add075c89330f112d59413d7acc3221e%2Fstacks-connect-modal.png?alt=media" alt=""><figcaption><p>The Stacks Connect wallet selector modal</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Call \`add-message\` public function**

Next, we'll setup a `stx_callContract` to invoke the `add-message` public function of our contract. This function will accept a string content to be passed into our contract call.

<pre class="language-typescript" data-expandable="true"><code class="lang-typescript">import { request } from '@stacks/connect'
import type { TransactionResult } from '@stacks/connect/dist/types/methods'
import { Cl, Pc } from '@stacks/transactions'
import { useState } from 'react'

function App() {
  // ...
  let [content, setContent] = useState&#x3C;string>('')

  async function addMessage() {
    let postCond_1 = Pc.principal('ST11V9ZN6E6VG72SHMAVM9GDE30VD3VGW5Q1W9WX3')
      .willSendEq(1)
      .ft('ST1F7QA2MDF17S807EPA36TSS8AMEFY4KA9TVGWXT.sbtc-token', 'sbtc-token')
  
<strong>    let result: TransactionResult = await request('stx_callContract', {
</strong>      contract: 'ST11V9ZN6E6VG72SHMAVM9GDE30VD3VGW5Q1W9WX3.stacks-dev-quickstart-message-board',
      functionName: 'add-message',
      functionArgs: [Cl.stringUtf8(content)],
      network: 'testnet',
      postConditions: [postCond_1],
      postConditionMode: 'deny',
      sponsored: false
    })
  
    setContent('')
  }

  return (
    &#x3C;>
      // ...
      &#x3C;span className='input-container'>
        &#x3C;button onClick={addMessage}>add-message&#x3C;/button>
        &#x3C;input type="text" onChange={e => setContent(e.target.value)}/>
      &#x3C;/span>
    &#x3C;/>
  )
}
</code></pre>

You'll notice in the transaction data object that we pass into our string literal method of `stx_callContract`, that we're setting up post-conditions. [Post-Conditions](https://docs.stacks.co/build/post-conditions/overview) for the frontend are declared to protect user assets. The `Pc` helper from `@stacks/transactions` helps us to declare post-condition statements for any type of asset and equality operator.

Invoking our `addMessage` function will prompt the user's connected wallet to prompt a transaction confirmation popup. This popup will display all of the relevant information of the transaction as well as the post-condition statements that we've declared.

<div data-with-frame="true"><figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2Fgit-blob-e934e83ff3f29b17b2b2c0c9b3c143c9e3240b51%2Ftx-confirmation-popup.png?alt=media" alt=""><figcaption></figcaption></figure></div>
{% endstep %}

{% step %}
**Call read-only function**

As how we've created a few read-only functions in our contract, we'll also want to call these from the frontend to retrieve certain contract data.

Let's setup a `fetchCallReadOnlyFunction` to invoke our contract's `get-message-count-at-block` read-only function. For this, we'll fetch the current Stacks block height from the Hiro API endpoint and pass that returned value into our read-only function.

<pre class="language-typescript" data-expandable="true"><code class="lang-typescript">// ...
import type { ClarityValue } from '@stacks/connect/dist/types/methods'
import { Cl, fetchCallReadOnlyFunction } from '@stacks/transactions'

function App() {
  // ...  
  async function getMessageCountAtBlock() {
<strong>    let response = await fetch('https://api.testnet.hiro.so/v2/info', {
</strong>      headers: {
        "x-api-key": "&#x3C;HIRO_API_KEY>"
      }
    })
    let data = await response.json()
    let stacksBlockHeight = data.stacks_tip_height

    let result: ClarityValue = await fetchCallReadOnlyFunction({
      contractAddress: 'ST11V9ZN6E6VG72SHMAVM9GDE30VD3VGW5Q1W9WX3',
      contractName: 'stacks-dev-quickstart-message-board',
      functionName: 'get-message-count-at-block',
<strong>      functionArgs: [Cl.uint(stacksBlockHeight)],
</strong>      network: 'testnet',
      senderAddress: 'ST11V9ZN6E6VG72SHMAVM9GDE30VD3VGW5Q1W9WX3',
    })
  }
  
  // ...
</code></pre>

{% hint style="info" %}
For the complete set of available API endpoints for the Stacks network, check out the [Hiro docs](https://docs.hiro.so/). But first create an API key from the [Hiro Platform](https://platform.hiro.so/) to determine your API rate plan.
{% endhint %}
{% endstep %}
{% endstepper %}

And that's it, you've successfully created an sBTC powered Clarity smart contract which can be interacted with from a frontend app. There's obviously much more you can do to complete this but you've got some of the basics down pat now. Go ahead and finish creating the frontend functions to call on the other contract functions we have.

***

### Further Improvements

This is just the beginning. There are many ways we can improve upon this app. Here are some suggestions for you to extend the functionality of this app:

* Deploy to mainnet and share your project with the community
* Use [Chainhooks](https://docs.hiro.so/en/tools/chainhooks) to index emitted events from the contract
* Integrate the [`sbtc`](https://docs.stacks.co/build/more-guides/sbtc/how-to-use-the-sbtc-js-library-for-bridging) library so users can directly bridge their BTC to sBTC in-app
* Utilize SIP-009 NFTs to uniquely identify each message for each author

***

### Next Steps

Now that you have the basics down, here are some ways to continue your Stacks development journey:

**Learn More About Clarity**

* [**Clarity Crash Course**](https://docs.stacks.co/docs/clarity-crash-course): Quick introduction to Clarity concepts
* [**Clarity Book**](https://book.clarity-lang.org/): Comprehensive guide to Clarity development
* [**Clarity Reference**](https://docs.stacks.co/docs/clarity): Complete documentation of Clarity functions

**Development Tools**

* [**Clarinet**](https://github.com/stx-labs/clarinet): Local development environment for Clarity
* [**Hiro Platform**](https://platform.hiro.so/): Hosted development environment
* [**Stacks Explorer**](https://explorer.stacks.co/): View transactions and contracts

**Community Resources**

* [**Stacks Discord**](https://discord.gg/stacks): Connect with other developers
* [**Stacks Forum**](https://forum.stacks.org/): Ask questions and share projects


# Clarity Crash Course

The Stacks ecosystem has its own smart contract programming language called Clarity.

<figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2FvnYwEweWgc92psOwXSv0%2Fclarity.jpg?alt=media&#x26;token=caac4d31-2af6-4fa7-b9df-f42b24a3bbcd" alt=""><figcaption><p>source: <a href="https://www.hiro.so/blog/write-better-smart-contracts-with-the-programming-language-clarity">Hiro Blog</a></p></figcaption></figure>

### Intro

This is designed for people with some programming experience who are new to Clarity. You don't need prior smart contract development experience, but if you have experience with languages like Solidity, you'll pick this up quickly.

Once you've briefly familiarized yourself with the language, consider the [Clarity Book](https://book.clarity-lang.org/) or the course [Clarity Universe](https://clarity-lang.org/universe) to continue your learning.

{% hint style="info" %}
Clarity is developed as a joint effort of [Hiro PBC](https://hiro.so/), [Algorand](http://algorand.com/), and various other stakeholders, that originally targets the Stacks blockchain.
{% endhint %}

### Your First Clarity Smart Contract

We're going to walkthrough a basic Clarity smart contract using the [Clarity Playground](https://play.hiro.so/), an online REPL environment where you can write and run Clarity code in the browser. Visit that link and it will open up a new example contract for you on the left view, with an interactive REPL on the right view.

<div data-with-frame="true"><figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2Fh0rd2pM6E7QCbbabCIZx%2Fclarity-playground.png?alt=media&#x26;token=3472e055-d669-4964-9ec8-4330af93e922" alt=""><figcaption><p>The example counter contract provided when visiting the Clarity Playground</p></figcaption></figure></div>

{% hint style="info" %}
Clarity Playground is a new tool to write and run Clarity code directly in the browser. With Clarity Playground, developers can test out concepts, try new ideas, or just, well…play around. Learn more [here](https://www.hiro.so/blog/meet-clarity-playground).
{% endhint %}

The example contract you'll see is a simple counter contract that will store the value of a `count` in a data variable and `increment` the count value by invoking a defined public function.

{% code title="counter.clar" %}

```clarity
(define-data-var count uint u0)
(define-data-var contract-owner principal tx-sender)
(define-data-var cost uint u10)

(define-read-only (get-count)
  (var-get count)
)

(define-public (increment)
  (begin
    (print u"incrementing count")
    (ok (var-set count (+ (var-get count) u1)))
  )
)
```

{% endcode %}

Clarity's syntax is inspired by LISP: everything is an expression wrapped in parentheses. Function definitions, variable declarations, and parameters are lists inside lists. This makes Clarity concise and readable once you get used to it. Here are some characteristics of Clarity you'll notice:

{% stepper %}
{% step %}

#### Everything in parentheses is an expression

Clarity treats everything as expressions inside parentheses. Function definitions are calls to built-in functions; the function body is an expression. This uniformity helps reasoning about programs in Clarity.
{% endstep %}

{% step %}

#### Uses LISP-like nesting

Expect nested parentheses and expressions. You’ll often read code as lists inside lists, where each parentheses-enclosed group represents a call or expression.
{% endstep %}
{% endstepper %}

{% hint style="info" %}
In Clarity, there are public, private, and read-only functions:

* public: can modify chain state and be called externally.
* private: can modify state but only be called within the contract.
* read-only: will fail if they attempt to modify state.
  {% endhint %}

Let's expand on these ideas by walking through that example counter contract line by line.

#### Defining data variables

The built-in Clarity function of `define-data-var` allows you to define a new persisted variable for the contract. Only modifiable by the contract.

```clarity
;; defining a `count` variable to store a variable unsigned integer value
(define-data-var count uint u0)

;; defining a `contract-owner` for a specific `principal` value
(define-data-var contract-owner principal tx-sender)

;; defining a `cost` variable with an initial unsigned integer value of 10
(define-data-var cost uint u10)
```

#### Defining a read-only function to read the current count value

The built-in Clarity function of `define-read-only` defines a public read-only function. Cannot modify data maps or call mutating functions. May return any type.

```clarity
;; allows anyone to read the current `count` value in the contract
(define-read-only (get-count)
  (var-get count)
)
```

#### Defining a public function to increment the count value

This function prints a log event saying it's incrementing a counter, then reads the current counter, adds 1, saves it back on-chain, and returns success.

```clarity
;; Defines a public function named increment that anyone can call
(define-public (increment)
  ;; Starts a begin block, which allows multiple expressions to run in order.
  (begin
    ;; Logs/prints the text "incrementing count" (as a Unicode string) to 
    ;; the transaction output or event stream.
    (print u"incrementing count")
    ;; adds u1 to the current count and wraps the resulting value in a response type
    (ok (var-set count (+ (var-get count) u1)))
  )
)
```

### Interact With Your Contract

The Clarity Playground allows you to call your functions on the right side view via a REPL console that runs a simnet environment.

<details>

<summary><strong>What is Simnet?</strong></summary>

Simnet is optimized for providing fast feedback loops at the cost of correctness. Simnet does not provide a full simulated blockchain environment, so there are no concepts of transaction fees, new blocks, or consensus mechanisms.

Instead, simnet focuses on letting you quickly iterate on your code and test the code of the contract locally through unit testing and integration testing. It’s a good preliminary debugging step before introducing the additional variables that come with a fully-fledged blockchain environment.

Simnet is a local environment spun up on your machine and is a private instance—you cannot share a simnet environment with other devs and collaborate with them—and further, simnet has no persistent state. It resets with each run.

</details>

On page load of the Clarity Playground, the example counter contract is automatically deployed to the REPL console on the right side. If you made any changes to the contract in the code editor on the left view, be sure to click on Deploy.

Calling contracts in the console or calling any externally deployed contracts will need to be passed into the built-in Clarity function called `contract-call?` .

Follow the steps below to interact with your counter contract:

{% stepper %}
{% step %}

#### Call the read-only \`get-count\` function

In the bottom right Clarity command console, paste in the below command to call your `get-count` function to see the current `count` value.

{% code title="clarity command console" %}

```clarity
(contract-call? .contract-0 get-count)
```

{% endcode %}

The console should return an initial value of `u0` since we haven't incremented the `count` yet.
{% endstep %}

{% step %}

#### Call the public \`increment\` function

Now let's finally increment our count value. In the bottom right Clarity command console, paste in the below command to call your `increment` function, which will increment the `count` value by 1.

The console should return a value of `(ok true)` . This means the public function executed successfully and the count should have incremented.

{% code title="clarity command console" %}

```clarity
(contract-call? .contract-0 increment)
```

{% endcode %}
{% endstep %}

{% step %}

#### Call our \`get-count\` function again

To see if our count value was really incremented, let's call our read-only `get-count` function once again.

{% code title="clarity command console" %}

```clarity
(contract-call? .contract-0 get-count)
```

{% endcode %}

The console should now returns a value of `u1` which is exactly what we'd expect.

<div data-with-frame="true"><figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2FfFO1IviDxtHu8sBXeKgW%2Fclarity-playground-console.png?alt=media&#x26;token=9ef08bf1-94ef-407a-b557-62bdac0a17ea" alt=""><figcaption></figcaption></figure></div>
{% endstep %}
{% endstepper %}

Great! You just interacted with your first Clarity smart contract. Hopefully this gives you a good introduction to how the Clarity smart contract language looks and feels.

***

### Read Access into Bitcoin

Clarity smart contracts on the Stacks layer can also read Bitcoin state and can be triggered by standard Bitcoin transactions. This is because Stacks nodes also run Bitcoin nodes as part of consensus, and they read and index Bitcoin state.

Reading Bitcoin state in Clarity is made by possible by the built-in function: `get-burn-block-info?`  and the keyword `burn-block-height` .

* `burn-block-height` : This keyword returns the current block height of the underlying burnchain: Bitcoin. Check out the example snippet below:

```clarity
(> burn-block-height u1000) 
;; returns true if the current height of the underlying burn blockchain has passed 1000 blocks.
```

* `get-burn-block-info?` : This function fetches block data of the burnchain: Bitcoin. Check out the example snippet below:

```clarity
(get-burn-block-info? header-hash u677050)
;; Returns (some 0xe671...)
```

<details>

<summary>Verifying bitcoin transactions in Clarity</summary>

One of the most popular Clarity contracts that leverages read access into Bitcoin is the `clarity-bitcoin-lib` contract, maintained by Friedger. This contract intakes data of a bitcoin transaction and will verify that it was indeed mined in a Bitcoin block.

For more info: <https://github.com/friedger/clarity-bitcoin>

</details>

***

### Flexible and secure modularization

Many DAOs of the major Stacks apps implement a familiar contract design and architecture. This familiarity is inspired by the [ExecutorDAO](https://github.com/MarvinJanssen/executor-dao) framework, written by Marvin Janssen. This ExecutorDAO framework leverages the flexibility of having modularization in your smart contracts by compartmentalizing duties.

The core tenets of the ExecutorDAO framework that make this possible are:

1. Proposals are smart contracts.
2. The core executes, the extensions give form.
3. Ownership control happens via sending context.

{% tabs %}
{% tab title="Main DAO contract" %}
The main DAO contract acts as the core contract where its sole purpose is to execute proposals and to keep a list of authorised extensions.

{% code title="dao.clar" expandable="true" %}

```clarity
(use-trait proposal-trait .proposal-trait.proposal-trait)
(use-trait extension-trait .extension-trait.extension-trait)

;; ...

;; --- Authorisation check
(define-private (is-self-or-extension)
	(ok (asserts! (or (is-eq tx-sender (as-contract tx-sender)) (is-extension contract-caller)) err-unauthorised))
)

;; ...

;; --- Admin function to execute proposals
(define-public (execute (proposal <proposal-trait>) (sender principal))
	(begin
		(try! (is-self-or-extension))
		(asserts! (map-insert executed-proposals (contract-of proposal) block-height) err-already-executed)
		(print {event: "execute", proposal: proposal})
		(as-contract (contract-call? proposal execute sender))
	)
)
```

{% endcode %}
{% endtab %}

{% tab title="A proposal extension contract" %}
This proposal contract updates the whitelist of an example `.nft-escrow` contract that is owned by the main DAO contract. This proposal contract implements the `proposal-trait` and is passed into the main DAO contract's `execute` function for final approved execution.

{% code title="proposal.clar" %}

```clarity
(impl-trait .proposal-trait.proposal-trait)

(define-public (execute (sender principal))
	(contract-call? .nft-escrow set-whitelisted .some-nft true)
)
```

{% endcode %}
{% endtab %}
{% endtabs %}

***

### Testing Clarity Smart Contracts

Once you get to writing more advanced smart contracts, properly testing them is paramount to protecting anyone who interacts with your contract.&#x20;

{% hint style="danger" %}
Smart contracts are immutable once deployed. Bugs are permanent. Test them thoroughly.
{% endhint %}

* [Rendezvous Fuzz Testing](https://docs.stacks.co/build/rendezvous/overview): Use Rendezvous to hammer your contract with random inputs. It helps expose edge cases and vulnerabilities.
* [Unit Testing in Clarinet](https://docs.stacks.co/build/clarinet-js-sdk): Unit testing verifies that individual contract functions behave as expected.&#x20;

***

### Auditing Clarity Smart Contracts

Auditors provide an independent, expert review of your smart contracts to identify vulnerabilities, logic flaws, edge cases, or design risks that might be missed during development. Here are a few Clarity smart contract auditors that are part of the Stacks community.

* [Clarity Alliance](https://x.com/ClarAllianceSec)
* [SetDev](https://x.com/setdevbtc)

***

### Additional Resources

This brief overview should get your feet wet with Clarity. For deeper learning, we recommend:

* [Clarity Book](https://book.clarity-lang.org/title-page.html)
* [Clarity Universe](https://clarity-lang.org/universe)
* [Clarity Playground](https://play.hiro.so/)
* [Clarity Camp](https://learn.stacks.org/course/clarity-camp)
* \[[StacksGov](https://github.com/stacksgov/sips/blob/main/sips/sip-002/sip-002-smart-contract-language.md)] SIP-002 The Clarity Smart Contract Language
* \[[Hiro Blog](https://www.hiro.so/blog/web3-programming-languages-clarity-vs-solidity)] Web3 Programming Languages: Clarity vs. Solidity
* \[[Stacks YT](https://youtu.be/hFqH1bJEvnw?si=yQADCvRNNjotuAga)] How Stacks' Language Clarity Enables Next Gen Smart Contracts
* \[[StacksDevs YT](https://www.youtube.com/watch?v=WZe1DgJ1w-E)] How Stacks’ Smart Contract Language Prevents Exploitation
* \[[Chainlink YT](https://youtu.be/OAVwd6SNJVU?si=UgfjmisBRbIYv27U)] Marvin Janssen: Clarity Smart Contracts for Stacks&#x20;
* [100+ Days of Clarity video series by Setzeus](https://youtube.com/playlist?list=PLFHm9eE6H5uhNQ4cUXRE-4HkXF1ekS0ZG\&si=q0NmD-e9_QBomK3a)
* \[[waits.dev](https://waits.dev/writing/clarity-vs-solidity)] Clarity vs Solidity

If you prefer jumping into Clarity's reference materials for definitions on all its types, functions, and keywords, head to [Clarity's Reference section](https://app.gitbook.com/s/GVj1Z9vMuEOMe7oH7Wnq/clarity/functions) of the docs.


# Create a Token

Many Stacks projects need tokens to establish membership or as an incentive for building a thriving Web3 community. When building a project, you need to not only think about whether your project needs a token (and if so, what type), but also what other Stacks tokens your app will need to interact with.

Rather than needing to work with external libraries, Clarity has built-in functions that make working with fungible and non-fungible tokens a breeze. Below are the 3 different types of tokens available on Stacks. Click into any one of them to learn what they are and the different ways to have them launched for your project.

### Fungible Tokens

Fungible tokens on Stacks are digital assets that are interchangeable and identical in value, much like traditional currencies such as the dollar or bitcoin. They are typically used for utilities like payments, rewards, and participation rights within decentralized applications on the Stacks blockchain.

[**Launch a fungible token**](https://docs.stacks.co/build/get-started/create-a-token/fungible-tokens)

### Non-Fungible Tokens

Non-fungible tokens (NFTs) on Stacks are unique digital assets that cannot be exchanged on a one-to-one basis, as each token holds distinct information and value. They are often used for representing ownership of digital art, collectibles, and other unique items within decentralized applications on the Stacks network. NFTs provide a way to authenticate and trade the unique characteristics of digital goods securely.

[**Launch a non-fungible token**](https://docs.stacks.co/build/get-started/create-a-token/non-fungible-tokens)

### Semi-Fungible Tokens

Semi-fungible tokens (SFTs) are a type of digital asset that possess qualities of both fungible and non-fungible tokens. Initially, SFTs can be exchanged on a one-to-one basis like fungible tokens because they represent identical assets or goods, often in specific series or batches. However, once redeemed or utilized, they transform into non-fungible tokens, acquiring unique attributes or identification. This makes SFTs versatile for applications such as event tickets, vouchers, or gaming items where controlled fungibility is beneficial.

[**Launch a semi-fungible token**](https://docs.stacks.co/build/get-started/create-a-token/semi-fungible-tokens)


# Fungible Tokens

A guide to help you create your own fungible tokens

<figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2Fgit-blob-1c637648c315552097de9ce9a37266d6226f4304%2Fimage.png?alt=media" alt=""><figcaption><p>source: <a href="https://www.hiro.so/blog/an-overview-of-8-types-of-tokens-in-web3">Hiro blog</a></p></figcaption></figure>

Creating a fungible token on Stacks can happen a few different ways — using no-code launchpads or writing your own Clarity smart contract. This guide helps you pick the best path for your goals and gives you the implementation details to ship confidently, whether you’re deploying with clicks or code.

### Custom Development

For developers who want full control over their token implementation, here’s how to create a custom SIP-010 token on Stacks using Clarity. But before you deploy the token contract, you must have your token contract conform to the SIP-010 trait standard.

{% stepper %}
{% step %}

#### Define SIP-010 fungible token trait

<details>

<summary><strong>What is SIP-010?</strong></summary>

[SIP-010](https://github.com/stacksgov/sips/blob/main/sips/sip-010/sip-010-fungible-token-standard.md) is the standard for defining fungible tokens on Stacks. Defining a common interface (known in Clarity as a "trait") allows different smart contracts, apps, and wallets to interoperate with fungible token contracts in a reusable way.

</details>

Below is an implementation of the SIP-010 trait standard for fungible tokens. You can use the existing minimal standard SIP-010 trait or extend it by adding in your own custom traits. But the requirements of the SIP-010 traits are necessary to have at the minimum.

{% code title="SIP-010 trait implementation" expandable="true" %}

```clarity
(define-trait sip-010-trait
  (
    ;; Transfer from the caller to a new principal
    (transfer (uint principal principal (optional (buff 34))) (response bool uint))

    ;; the human readable name of the token
    (get-name () (response (string-ascii 32) uint))

    ;; the ticker symbol, or empty if none
    (get-symbol () (response (string-ascii 32) uint))

    ;; the number of decimals used, e.g. 6 would mean 1_000_000 represents 1 token
    (get-decimals () (response uint uint))

    ;; the balance of the passed principal
    (get-balance (principal) (response uint uint))

    ;; the current total supply (which does not need to be a constant)
    (get-total-supply () (response uint uint))

    ;; an optional URI that represents metadata of this token
    (get-token-uri () (response (optional (string-utf8 256)) uint))
  )
)
```

{% endcode %}

All we are doing here is defining the function signatures for functions we'll need to implement in our token contract, which we can see a simple version of below.
{% endstep %}

{% step %}

#### Implement SIP-010 trait in token contract

Any token contract that wants to conform to the SIP-010 fungible token standard for Stacks needs to have this trait "implemented" in their token contract. See the below minimal token contract example of how this is done.

{% code title="token-contract-clar" expandable="true" %}

```clarity
;; This contract implements the SIP-010 community-standard Fungible Token trait.
(impl-trait 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)

;; Define the FT, with no maximum supply
(define-fungible-token clarity-coin)

;; Define errors
(define-constant ERR_OWNER_ONLY (err u100))
(define-constant ERR_NOT_TOKEN_OWNER (err u101))

;; Define constants for contract
(define-constant CONTRACT_OWNER tx-sender)
(define-constant TOKEN_NAME "Clarity Coin")
(define-constant TOKEN_SYMBOL "CC")
(define-constant TOKEN_DECIMALS u6) ;; 6 units displayed past decimal, e.g. 1.000_000 = 1 token

(define-data-var token_uri (string-utf8 256) u"https://hiro.so") ;; utf-8 string with token metadata host

;; SIP-010 function: Get the token balance of a specified principal
(define-read-only (get-balance (who principal))
  (ok (ft-get-balance clarity-coin who))
)

;; SIP-010 function: Returns the total supply of fungible token
(define-read-only (get-total-supply)
  (ok (ft-get-supply clarity-coin))
)

;; SIP-010 function: Returns the human-readable token name
(define-read-only (get-name)
  (ok TOKEN_NAME)
)

;; SIP-010 function: Returns the symbol or "ticker" for this token
(define-read-only (get-symbol)
  (ok TOKEN_SYMBOL)
)

;; SIP-010 function: Returns number of decimals to display
(define-read-only (get-decimals)
  (ok TOKEN_DECIMALS)
)

;; SIP-010 function: Returns the URI containing token metadata
(define-read-only (get-token-uri)
  (ok (some (var-get token_uri)))
)

;; Properly updates token URI by emitting a SIP-019 token metadata update notification
(define-public (set-token-uri (value (string-utf8 256)))
    (begin
        (asserts! (is-eq tx-sender CONTRACT_OWNER) ERR_OWNER_ONLY)
        (var-set token-uri value)
        (ok (print {
              notification: "token-metadata-update",
              payload: {
                contract-id: current-contract,
                token-class: "ft"
              }
            })
        )
    )
)

;; Mint new tokens and send them to a recipient.
;; Only the contract deployer can perform this operation.
(define-public (mint (amount uint) (recipient principal))
  (begin
    (asserts! (is-eq tx-sender CONTRACT_OWNER) ERR_OWNER_ONLY)
    (ft-mint? clarity-coin amount recipient)
  )
)

;; SIP-010 function: Transfers tokens to a recipient
;; Sender must be the same as the caller to prevent principals from transferring tokens they do not own.
(define-public (transfer
  (amount uint)
  (sender principal)
  (recipient principal)
  (memo (optional (buff 34)))
)
  (begin
    ;; #[filter(amount, recipient)]
    (asserts! (or (is-eq tx-sender sender) (is-eq contract-caller sender)) ERR_NOT_TOKEN_OWNER)
    (try! (ft-transfer? clarity-coin amount sender recipient))
    (match memo to-print (print to-print) 0x)
    (ok true)
  )
)
```

{% endcode %}

This is the Clarity code we need in order to create an fungible token, with one additional function, `mint` that allows us to actually create a new fungible tokens. This `mint` function is not needed to adhere to the trait.

The token contract example above is passing in an already deployed trait on mainnet into the `impl-trait` function. You can use this same deployed trait for your own token contract as well.

{% hint style="success" %}
Deployed SIP-010 trait contracts you can directly implement in your custom token contract:

* \[mainnet] [SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait](https://explorer.hiro.so/txid/SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard?chain=mainnet)
* \[testnet] [ST1NXBK3K5YYMD6FD41MVNP3JS1GABZ8TRVX023PT.sip-010-trait-ft-standard.sip-010-trait](https://explorer.hiro.so/txid/ST1NXBK3K5YYMD6FD41MVNP3JS1GABZ8TRVX023PT.sip-010-trait-ft-standard?chain=testnet)

Reminder: when implementing these deployed traits in your contract, be sure to also add them as a contract requirement in Clarinet.
{% endhint %}
{% endstep %}
{% endstepper %}

### No-code Platforms

Use community built no-code platforms that can quickly help you deploy tokens.

<details>

<summary>STX.City</summary>

[STX.CITY](https://stx.city/) is a one-click platform for launching tokens on Stacks. The platform is a comprehensive toolkit for memecoin creators, enabling them to grow their communities through features like AMM listing support (such as on [Alex](https://alexgo.io/), [Velar](https://velar.com/), and [Stackswap](https://app.stackswap.org/)), airdrops, token donations, and burn mechanisms.

Check out [this](https://www.hiro.so/blog/building-stx-city-as-a-solo-dev-on-stacks) blog post by the founder of STX.City for more information.

</details>

### Best Practices

Here are some things to consider when creating your token and after your token is launched.

<details>

<summary>How to format the token metadata?</summary>

Example token metadata taken from the sBTC token:

```json
// https://ipfs.io/ipfs/bafkreibqnozdui4ntgoh3oo437lvhg7qrsccmbzhgumwwjf2smb3eegyqu

{
  "sip": 16,
  "name": "sBTC",
  "description": "BTC is a 1:1 Bitcoin-backed asset on the Stacks Bitcoin L2 that will allow developers to leverage the security, network effects, and .5T in latent capital of the Bitcoin network.",
  "image": "https://ipfs.io/ipfs/bafkreiffe46h5voimvulxm2s4ddszdm4uli4rwcvx34cgzz3xkfcc2hiwi",
  "properties": {
    "decimals": 8,
    "external_url": "https://sbtc.tech"
  }
}
```

Check out the [SIP-016](https://github.com/stacksgov/sips/blob/main/sips/sip-016/sip-016-token-metadata.md) standard for how you should define the schema of your metadata.

</details>

<details>

<summary>How would I properly update my token metadata?</summary>

If you plan on updating your token's metadata in the future, you should definitely implement a [SIP-019](https://github.com/stacksgov/sips/blob/main/sips/sip-019/sip-019-token-metadata-update-notifications.md) compliant token metadata update notification. Take a look at the example token contract above and you'll notice the `set-token-uri` function emits a SIP-019 compliant print event.

```clarity
;; ...
(define-public (set-token-uri (value (string-utf8 256)))
    (begin
        (asserts! (is-eq tx-sender CONTRACT_OWNER) ERR_OWNER_ONLY)
        (var-set token-uri value)
        (ok (print {
              notification: "token-metadata-update",
              payload: {
                contract-id: current-contract,
                token-class: "ft"
              }
            })
        )
    )
)
;; ...
```

Hiro’s [Token Metadata API](https://www.hiro.so/token-metadata-api) watches for that specific print event (specifically the notification of "token-metadata-update") on the network and auto-updates the API’s database to reflect a change in the existing token’s metadata.

If your token contract did not implement this print event, you could use the helper contract below to invoke a function that'll emit the same print event notification. Just invoke the `ft-metadata-update-notify` function of this contract below:

[SP1H6HY2ZPSFPZF6HBNADAYKQ2FJN75GHVV95YZQ.token-metadata-update-notify](https://explorer.hiro.so/txid/SP1H6HY2ZPSFPZF6HBNADAYKQ2FJN75GHVV95YZQ.token-metadata-update-notify?chain=mainnet)

</details>

### Additional Resources

* \[[dev.to](https://dev.to/kamalthedev/ethereum-vs-bitcoin-a-deep-dive-into-token-standards-erc-20-vs-sip-10-vs-brc20-vs-stx20-12na)] A Deep Dive into Token Standards: ERC-20 vs. SIP-10 vs. BRC20 vs. STX20
* \[[StacksGov](https://github.com/stacksgov/sips/blob/main/sips/sip-010/sip-010-fungible-token-standard.md)] SIP-010 Standard Trait Definition for Fungible Tokens
* \[[StacksGov](https://github.com/stacksgov/sips/blob/main/sips/sip-016/sip-016-token-metadata.md)] SIP-016 Schema Definition for Metadata for Digital Assets
* \[[StacksGov](https://github.com/stacksgov/sips/blob/main/sips/sip-019/sip-019-token-metadata-update-notifications.md)] SIP-019 Notifications for Token Metadata Updates
* \[[contract](https://explorer.hiro.so/txid/SP1H6HY2ZPSFPZF6HBNADAYKQ2FJN75GHVV95YZQ.token-metadata-update-notify?chain=mainnet)] SP1H6HY2ZPSFPZF6HBNADAYKQ2FJN75GHVV95YZQ.token-metadata-update-notify
* \[[StacksDevs YT](https://youtu.be/v0_Mexz3KJ8?si=iGMyxQX2lSktOTWp)] Fungible Token Standard (SIP-10) Tutorial For Bitcoin L2 Stacks
* \[[LearnWeb3](https://learnweb3.io/lessons/sip-010-fungible-tokens-and-traits/)] SIP-010 Fungible Tokens & Traits
* \[[Medium @n.campos.rojas](https://medium.com/@n.campos.rojas/learn-how-to-create-fungible-tokens-on-stacks-versus-on-ethereum-a6dae4986863)] Learn how to create fungible tokens on Stacks (versus on Ethereum)


# Non-Fungible Tokens

A guide to help you create your own non-fungible tokens

<figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2Fgit-blob-90ba3f571bd0fa2b90a5e1ea06bab97333e27ca5%2Fimage.png?alt=media" alt=""><figcaption><p>source: <a href="https://www.hiro.so/blog/breaking-down-an-order-book-contract-for-nft-marketplaces">Hiro blog</a></p></figcaption></figure>

Create an NFT with Stacks because it builds **on Bitcoin** — inheriting the security and permanence of the most durable chain via Proof-of-Transfer. Clarity smart contracts make logic easy to audit, reducing the guessing and attack surface common in NFT projects. Plus, Stacks NFTs tap into a Bitcoin-aligned community that values ownership, longevity, and real on-chain utility.

### Custom Development

For developers who want full control over their token implementation, here’s how to create a custom SIP-009 NFT on Stacks using Clarity. But before you deploy the NFT contract, you must have your NFT contract conform to the SIP-009 trait standard.

{% stepper %}
{% step %}

#### Define SIP-009 non-fungible token trait

<details>

<summary><strong>What is SIP-009?</strong></summary>

[SIP-009](https://github.com/stacksgov/sips/blob/main/sips/sip-009/sip-009-nft-standard.md) is the standard for defining fungible tokens on Stacks. Defining a common interface (known in Clarity as a "trait") allows different smart contracts, apps, and wallets to interoperate with non-fungible token contracts in a reusable way. Its primary purpose is to ensure that NFTs are composable and different tools know how to interact with them.

</details>

Below is an implementation of the SIP-009 trait standard for non-fungible tokens. You can use the existing minimal standard SIP-009 trait or extend it by adding in your own custom traits. But the requirements of the SIP-009 traits are necessary to have at the minimum.

{% code title="NFT trait standard" expandable="true" %}

```clarity
(define-trait nft-trait
  (
    ;; Last token ID, limited to uint range
    (get-last-token-id () (response uint uint))

    ;; URI for metadata associated with the token
    (get-token-uri (uint) (response (optional (string-ascii 256)) uint))

     ;; Owner of a given token identifier
    (get-owner (uint) (response (optional principal) uint))

    ;; Transfer from the sender to a new principal
    (transfer (uint principal principal) (response bool uint))
  )
)
```

{% endcode %}

All we are doing here is defining the function signatures for functions we'll need to implement in our NFT contract, which we can see a simple version of below.
{% endstep %}

{% step %}

#### Implement SIP-009 trait in NFT contract

Any NFT contract that wants to conform to the SIP-009 non-fungible token standard for Stacks needs to have this trait "implemented" in their NFT contract. See the below minimal NFT contract example of how this is done.

{% code title="non-fungible-token.clar" expandable="true" %}

```clarity
;; This contract implements the SIP-009 community-standard Non-Fungible Token trait
(impl-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)

;; Define the NFT's name
(define-non-fungible-token Your-NFT-Name uint)

;; Keep track of the last minted token ID
(define-data-var last-token-id uint u0)

;; Define constants
(define-constant CONTRACT_OWNER tx-sender)
(define-constant COLLECTION_LIMIT u1000) ;; Limit to series of 1000

(define-constant ERR_OWNER_ONLY (err u100))
(define-constant ERR_NOT_TOKEN_OWNER (err u101))
(define-constant ERR_SOLD_OUT (err u300))

(define-data-var base-uri (string-ascii 256) "https://your.api.com/path/to/collection/{id}")

;; SIP-009 function: Get the last minted token ID.
(define-read-only (get-last-token-id)
  (ok (var-get last-token-id))
)

;; SIP-009 function: Get link where token metadata is hosted
(define-read-only (get-base-uri (token-id uint))
  (ok (some (var-get base-uri)))
)

;; SIP-009 function: Get the owner of a given token
(define-read-only (get-owner (token-id uint))
  (ok (nft-get-owner? Your-NFT-Name token-id))
)

;; SIP-019 compliant token metadata update notification
(define-public (set-base-uri (value (string-ascii 256)))
    (begin
        (asserts! (is-eq tx-sender CONTRACT_OWNER) ERR_OWNER_ONLY)
        (var-set base-uri value)
        (ok (print {
              notification: "token-metadata-update",
              payload: {
                token-class: "nft",
                contract-id: current-contract,
              }
            })
        )
    )
)

;; SIP-009 function: Transfer NFT token to another owner.
(define-public (transfer (token-id uint) (sender principal) (recipient principal))
  (begin
    ;; #[filter(sender)]
    (asserts! (is-eq tx-sender sender) ERR_NOT_TOKEN_OWNER)
    (nft-transfer? Your-NFT-Name token-id sender recipient)
  )
)

;; Mint a new NFT.
(define-public (mint (recipient principal))
  ;; Create the new token ID by incrementing the last minted ID.
  (let ((token-id (+ (var-get last-token-id) u1)))
    ;; Ensure the collection stays within the limit.
    (asserts! (< (var-get last-token-id) COLLECTION_LIMIT) ERR_SOLD_OUT)
    ;; Only the contract owner can mint.
    (asserts! (is-eq tx-sender CONTRACT_OWNER) ERR_OWNER_ONLY)
    ;; Mint the NFT and send it to the given recipient.
    (try! (nft-mint? Your-NFT-Name token-id recipient))

    ;; Update the last minted token ID.
    (var-set last-token-id token-id)
    ;; Return a success status and the newly minted NFT ID.
    (ok token-id)
  )
)
```

{% endcode %}

This is the Clarity code we need in order to create an NFT, with one additional function, `mint` that allows us to actually create a new NFT. This `mint` function is not needed to adhere to the trait.

The token contract example above is passing in an already deployed trait on mainnet into the `impl-trait` function. You can use this same deployed trait for your own NFT contract as well.

{% hint style="success" %}
Deployed SIP-010 trait contracts you can directly implement in your custom token contract:

* \[mainnet] SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait
* \[testnet] ST1NXBK3K5YYMD6FD41MVNP3JS1GABZ8TRVX023PT.nft-trait

Reminder: when implementing these deployed traits in your contract, be sure to also add them as a contract requirement in Clarinet.
{% endhint %}
{% endstep %}
{% endstepper %}

### Best Practices

Here are some things to consider when creating your NFT and after your NFT is launched.

<details>

<summary>How to format the NFT metadata?</summary>

Check out the [SIP-016](https://github.com/stacksgov/sips/blob/main/sips/sip-016/sip-016-token-metadata.md) standard for how you should define the schema of your metadata.

</details>

<details>

<summary>How would I properly update my NFT metadata?</summary>

If you plan on updating your NFT's metadata in the future, you should definitely implement a function that emits a [SIP-019](https://github.com/stacksgov/sips/blob/main/sips/sip-019/sip-019-token-metadata-update-notifications.md) compliant token metadata update notification. Take a look at the example NFT contract above and you'll notice the `set-base-uri` function emits a SIP-019 compliant print event.

<pre class="language-clarity"><code class="lang-clarity">;; ...
(define-public (set-base-uri (value (string-ascii 256)))
    (begin
        (asserts! (is-eq tx-sender CONTRACT_OWNER) ERR_OWNER_ONLY)
        (var-set base-uri value)
        (ok (print {
              notification: "token-metadata-update",
              payload: {
<strong>                token-class: "nft",
</strong>                contract-id: current-contract,
              }
            })
        )
    )
)
;; ...
</code></pre>

Hiro’s [Token Metadata API](https://www.hiro.so/token-metadata-api) watches for that specific print event (specifically the notification of "token-metadata-update") on the network and auto-updates the API’s database to reflect a change in the existing NFT’s metadata.

If your NFT contract did not implement this print event, you could use the helper contract below to invoke a function that'll emit the same print event notification. Just invoke the `nft-metadata-update-notify` function of this contract below:

[SP1H6HY2ZPSFPZF6HBNADAYKQ2FJN75GHVV95YZQ.token-metadata-update-notify](https://explorer.hiro.so/txid/SP1H6HY2ZPSFPZF6HBNADAYKQ2FJN75GHVV95YZQ.token-metadata-update-notify?chain=mainnet)

</details>

### Additional Resources

* \[[Stacks](https://www.stacks.co/explore/nfts)] Explore NFTs on Stacks
* \[[Clarity Book](https://book.clarity-lang.org/ch10-01-sip009-nft-standard.html)] SIP009: the NFT standard
* \[[StacksGov](https://github.com/stacksgov/sips/blob/main/sips/sip-010/sip-010-fungible-token-standard.md)] SIP-009 Standard Trait Definition for Non-Fungible Tokens
* \[[StacksGov](https://github.com/stacksgov/sips/blob/main/sips/sip-016/sip-016-token-metadata.md)] SIP-016 Schema Definition for Metadata for Digital Assets
* \[[StacksGov](https://github.com/stacksgov/sips/blob/main/sips/sip-019/sip-019-token-metadata-update-notifications.md)] SIP-019 Notifications for Token Metadata Updates
* \[[contract](https://explorer.hiro.so/txid/SP1H6HY2ZPSFPZF6HBNADAYKQ2FJN75GHVV95YZQ.token-metadata-update-notify?chain=mainnet)] SP1H6HY2ZPSFPZF6HBNADAYKQ2FJN75GHVV95YZQ.token-metadata-update-notify
* \[[Hiro YT](https://youtu.be/Hejsz-pivM4?si=SrOlgC9KK6YQvEy7)] How to Display NFTs in a Wallet Using the Token Metadata API
* \[[Hiro YT](https://youtu.be/xwbXNgSvMkk?si=Dl8KEL2KsmPy1kON)] A Beginner's Overview of the Megapont Ape NFT Clarity Smart Contract
* \[[Hiro YT](https://youtu.be/Ajuq6j2NXM8?si=Gj-Z5sxJ28FRyPmN)] Stacker Chat with Muneeb Ali: Diving Deeper into Bitcoin NFTs
* \[[Hiro Blog](https://www.hiro.so/blog/breaking-down-nft-code-snippets-in-clarity)] Breaking Down NFT Code Snippets in Clarity
* \[[Hiro Blog](https://www.hiro.so/blog/how-sigle-built-nft-gated-features-in-their-app)] How Sigle Built NFT-Gated Features in Their App


# Semi-Fungible Tokens

A guide to help you create your own semi-fungible tokens

Semi-fungible tokens (SFTs) are a hybrid token structure that embraces parts of both FTs (fungible tokens) and NFTs. SFTs are interchangeable (like FTs) and can be traded between users like cash—1 SFT has the same value as another SFT in the same collection. But each SFT also has a unique identifier (like NFTs).

SFTs are also particularly well suited for Web3 gaming and applications that need to issue lots of different tokens because SFTs enable different asset classes to be managed by a single smart contract (which as a developer is easier to manage and as a user results in cheaper transaction fees).

### Custom Development

For developers who want full control over their SFT implementation, here’s how to create a custom SIP-013 SFT on Stacks using Clarity. But before you deploy the SFT contract, you must have your SFT contract conform to the SIP-013 trait standard.

{% stepper %}
{% step %}

#### Define SIP-013 semi-fungible token trait

<details>

<summary><strong>What is SIP-013?</strong></summary>

[SIP-013](https://github.com/stacksgov/sips/blob/main/sips/sip-013/sip-013-semi-fungible-token-standard.md) is the standard for defining semi-fungible tokens on Stacks. Defining a common interface (known in Clarity as a "trait") allows different smart contracts, apps, and wallets to interoperate with semi-fungible token contracts in a reusable, standard way.

</details>

Below is an implementation of the SIP-013 trait standard for semi-fungible tokens. You can use the existing minimal standard SIP-013 trait or extend it by adding in your own custom traits. But the requirements of the SIP-013 traits are necessary to have at the minimum.

{% code title="SFT trait standard" expandable="true" %}

```clarity
(define-trait sip013-semi-fungible-token-trait
	(
		;; Get a token type balance of the passed principal.
		(get-balance (uint principal) (response uint uint))

		;; Get the total SFT balance of the passed principal.
		(get-overall-balance (principal) (response uint uint))

		;; Get the current total supply of a token type.
		(get-total-supply (uint) (response uint uint))

		;; Get the overall SFT supply.
		(get-overall-supply () (response uint uint))

		;; Get the number of decimal places of a token type.
		(get-decimals (uint) (response uint uint))

		;; Get an optional token URI that represents metadata for a specific token.
		(get-token-uri (uint) (response (optional (string-ascii 256)) uint))

		;; Transfer from one principal to another.
		(transfer (uint uint principal principal) (response bool uint))

		;; Transfer from one principal to another with a memo.
		(transfer-memo (uint uint principal principal (buff 34)) (response bool uint))
	)
)

```

{% endcode %}

All we are doing here is defining the function signatures for functions we'll need to implement in our SFT contract, which we can see a simple version of below.

**\[optional] transfer-many specification**\
SIP013 Semi-fungible tokens can also optionally implement the trait `sip013-transfer-many-trait` to offer a built-in "transfer-many" features for bulk token transfers.

{% code title="SFT transfer many trait" %}

```clarity
(define-trait sip013-transfer-many-trait
	(
		;; Transfer many tokens at once.
		(transfer-many ((list 200 {token-id: uint, amount: uint, sender: principal, recipient: principal})) (response bool uint))

		;; Transfer many tokens at once with memos.
		(transfer-many-memo ((list 200 {token-id: uint, amount: uint, sender: principal, recipient: principal, memo: (buff 34)})) (response bool uint))
	)
)
```

{% endcode %}
{% endstep %}

{% step %}

#### Implement SIP-013 trait in SFT contract

Any SFT contract that wants to conform to the SIP-013 semi-fungible token standard for Stacks needs to have this trait "implemented" in their SFT contract. See the below minimal SFT contract example of how this is done.

{% code title="semi-fungible-token.clar" expandable="true" %}

```clarity
(impl-trait 'SPDBEG5X8XD50SPM1JJH0E5CTXGDV5NJTKAKKR5V.sip013-semi-fungible-token-trait.sip013-semi-fungible-token-trait)
(impl-trait 'SPDBEG5X8XD50SPM1JJH0E5CTXGDV5NJTKAKKR5V.sip013-transfer-many-trait.sip013-transfer-many-trait)

(define-fungible-token semi-fungible-token)
(define-non-fungible-token semi-fungible-token-id {token-id: uint, owner: principal})
(define-map token-balances {token-id: uint, owner: principal} uint)
(define-map token-supplies uint uint)

(define-constant contract-owner tx-sender)

(define-constant err-owner-only (err u100))
(define-constant err-insufficient-balance (err u1))
(define-constant err-invalid-sender (err u4))

(define-private (set-balance (token-id uint) (balance uint) (owner principal))
	(map-set token-balances {token-id: token-id, owner: owner} balance)
)

(define-private (get-balance-uint (token-id uint) (who principal))
	(default-to u0 (map-get? token-balances {token-id: token-id, owner: who}))
)

(define-read-only (get-balance (token-id uint) (who principal))
	(ok (get-balance-uint token-id who))
)

(define-read-only (get-overall-balance (who principal))
	(ok (ft-get-balance semi-fungible-token who))
)

(define-read-only (get-total-supply (token-id uint))
	(ok (default-to u0 (map-get? token-supplies token-id)))
)

(define-read-only (get-overall-supply)
	(ok (ft-get-supply semi-fungible-token))
)

(define-read-only (get-decimals (token-id uint))
	(ok u0)
)

(define-read-only (get-token-uri (token-id uint))
	(ok none)
)

;; #[allow(unchecked_params)]
(define-public (transfer (token-id uint) (amount uint) (sender principal) (recipient principal))
	(let
		(
			(sender-balance (get-balance-uint token-id sender))
		)
		(asserts! (or (is-eq sender tx-sender) (is-eq sender contract-caller)) err-invalid-sender)
		(asserts! (<= amount sender-balance) err-insufficient-balance)
		(try! (ft-transfer? semi-fungible-token amount sender recipient))
		(try! (tag-nft-token-id {token-id: token-id, owner: sender}))
		(try! (tag-nft-token-id {token-id: token-id, owner: recipient}))
		(set-balance token-id (- sender-balance amount) sender)
		(set-balance token-id (+ (get-balance-uint token-id recipient) amount) recipient)
		(print {type: "sft_transfer", token-id: token-id, amount: amount, sender: sender, recipient: recipient})
		(ok true)
	)
)

(define-public (transfer-memo (token-id uint) (amount uint) (sender principal) (recipient principal) (memo (buff 34)))
	(begin
		(try! (transfer token-id amount sender recipient))
		(print memo)
		(ok true)
	)
)

(define-private (transfer-many-iter (item {token-id: uint, amount: uint, sender: principal, recipient: principal}) (previous-response (response bool uint)))
	(match previous-response prev-ok (transfer (get token-id item) (get amount item) (get sender item) (get recipient item)) prev-err previous-response)
)

(define-public (transfer-many (transfers (list 200 {token-id: uint, amount: uint, sender: principal, recipient: principal})))
	(fold transfer-many-iter transfers (ok true))
)

(define-private (transfer-many-memo-iter (item {token-id: uint, amount: uint, sender: principal, recipient: principal, memo: (buff 34)}) (previous-response (response bool uint)))
	(match previous-response prev-ok (transfer-memo (get token-id item) (get amount item) (get sender item) (get recipient item) (get memo item)) prev-err previous-response)
)

(define-public (transfer-many-memo (transfers (list 200 {token-id: uint, amount: uint, sender: principal, recipient: principal, memo: (buff 34)})))
	(fold transfer-many-memo-iter transfers (ok true))
)

(define-public (mint (token-id uint) (amount uint) (recipient principal))
	(begin
		(asserts! (is-eq tx-sender contract-owner) err-owner-only)
		(try! (ft-mint? semi-fungible-token amount recipient))
		(try! (tag-nft-token-id {token-id: token-id, owner: recipient}))
		(set-balance token-id (+ (get-balance-uint token-id recipient) amount) recipient)
		(map-set token-supplies token-id (+ (unwrap-panic (get-total-supply token-id)) amount))
		(print {type: "sft_mint", token-id: token-id, amount: amount, recipient: recipient})
		(ok true)
	)
)

(define-private (tag-nft-token-id (nft-token-id {token-id: uint, owner: principal}))
	(begin
		(and
			(is-some (nft-get-owner? semi-fungible-token-id nft-token-id))
			(try! (nft-burn? semi-fungible-token-id nft-token-id (get owner nft-token-id)))
		)
		(nft-mint? semi-fungible-token-id nft-token-id (get owner nft-token-id))
	)
)
```

{% endcode %}

This is the Clarity code we need in order to create a SFT, with an additional function, `mint` that allows us to actually create a new SFT. This `mint` function is not needed to adhere to the trait.

The token contract example above is passing in already deployed traits on mainnet into the `impl-trait` function. You can use these same deployed traits for your own SFT contract as well.

{% hint style="success" %}
Deployed SIP-013 trait contracts you can directly implement in your custom token contract:

* \[mainnet] SPDBEG5X8XD50SPM1JJH0E5CTXGDV5NJTKAKKR5V.sip013-semi-fungible-token-trait
* \[mainnet] SPDBEG5X8XD50SPM1JJH0E5CTXGDV5NJTKAKKR5V.sip013-transfer-many-trait

Reminder: when implementing these deployed traits in your contract, be sure to also add them as contract requirements in Clarinet.
{% endhint %}
{% endstep %}
{% endstepper %}

### Best Practices

<details>

<summary>How to deal with post-conditions on SFTs?</summary>

Check out the SIP-013 standard for more info on dealing with post-conditions for SFTs.

</details>

### Additional Resources

* \[[StacksGov](https://github.com/stacksgov/sips/blob/main/sips/sip-013/sip-013-semi-fungible-token-standard.md)] SIP-013 Standard Trait Definition for Semi-Fungible Tokens
* \[[Hiro YT](https://youtu.be/a7c8aBiIkD4?si=k4cUS5DHrUsnm7Q9)] A Walkthrough of a SIP013 Implementation of SFTs on Stacks
* \[[DegenLab](https://docs.degenlab.io/gamefistacks/sfts/general-idea-and-base-sfts-static-deployments)] Example of SFT implementation with DegenLab&#x20;


# Build a Frontend

Interact with your contracts with a proper frontend app

<figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2FrfjDyteJnuvkHu2kJuBG%2Fbuild-a-frontend.jpg?alt=media&#x26;token=06626a33-8dfe-4522-9e63-5b641c2c8301" alt=""><figcaption><p>source: <a href="https://www.hiro.so/blog/3-reasons-the-future-of-apps-will-be-decentralized">Hiro Blog</a></p></figcaption></figure>

A major part of building full-stack Stacks applications is creating a well designed UI with a solid UX. One of your primary tools for this is stacks.js, a JavaScript/Typescript library that simplifies working with contracts, wallets, and the Stacks network.

{% hint style="info" %}
This section assumes you have basic knowledge in front-end development and bootstrapping frontend frameworks.
{% endhint %}

### Components to your Stacks frontend app

* [Authentication](https://docs.stacks.co/build/get-started/build-a-frontend/authentication)
* [Post-Conditions](https://docs.stacks.co/build/get-started/build-a-frontend/post-conditions)
* [Sending Transactions](https://docs.stacks.co/build/get-started/build-a-frontend/sending-transactions)

### Additional Resources

* \[[Hiro Blog](https://www.hiro.so/blog/rich-app-templates-in-the-hiro-platform)] Rich App Templates in the Hiro Platform: Accelerating Web3 Development
* \[[Hiro Blog](https://www.hiro.so/blog/lean-devops-strategies-for-your-web3-project)] Lean DevOps Strategies for Your Web3 Project
* \[[Hiro Blog](https://www.hiro.so/blog/introducing-stacks-js-starters-launch-a-frontend-in-just-a-few-clicks)] Introducing Stacks.js Starters: Launch a Frontend in Just a Few Clicks


# Authentication

<figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2FZEqTKjHson1bcg9Dnb5J%2Fauthentication.jpg?alt=media&#x26;token=e364c6e6-7f74-4e1f-aaeb-76d99bde7eba" alt=""><figcaption><p>source: <a href="https://www.hiro.so/blog/navigating-the-tension-between-web3-privacy-and-data-transparency">Hiro Blog</a></p></figcaption></figure>

Authenticating (connecting wallets) with a Stacks-supported wallet is a common task when building Stacks apps. On a web2 app, authentication usually means sending credentials to a central provider, which then verifies you and controls access. In web3, authentication uses a wallet and cryptographic signatures with libraries like stacks.js, letting users prove identity without a central party holding the keys.

{% hint style="info" %}
To learn more about how wallets and accounts work with Stacks, check out this [section](https://app.gitbook.com/s/H74xqoobupBWwBsVMJhK/network-fundamentals/accounts) in Learn.
{% endhint %}

Below is a simple example showing how to set up front-end authentication with `@stacks/connect` and access user data in the UI. The stacks.js monorepo contains several underlying packages specific to different use cases. The package `@stacks/connect` is the main connectivity package used in Stacks.

## Authentication on the frontend

Using `@stacks/connect` on the frontend will allow our frontend app to authenticate wallets, call our contract functions, and interact with the Stacks network.

In the snippet below, you'll notice we have 3 functions setup to handle `connectWallet` , `disconnectWallet`, and for `getBns` . All 3 functions will be integral in how we want to display the 'Connect' and 'Disconnect' button in the UI.

{% hint style="info" %}
Retrieving a wallet account's associated [BNS](https://app.gitbook.com/s/H74xqoobupBWwBsVMJhK/network-fundamentals/bitcoin-name-system) is a staple of Stacks and for web3 identity. Check out [BNSv2](https://www.bnsv2.com/) for more information and for availably public API endpoints you could use.
{% endhint %}

<pre class="language-typescript" data-title="src/App.tsx" data-expandable="true"><code class="lang-typescript">import { connect, disconnect } from '@stacks/connect'
import type { GetAddressesResult } from '@stacks/connect/dist/types/methods'
import { useState } from 'react'

function App() {
  let [isConnected, setIsConnected] = useState&#x3C;boolean>(false)
  let [walletInfo, setWalletInfo] = useState&#x3C;any>(null)
  let [bns, setBns] = useState&#x3C;string>('')

<strong>  async function connectWallet() {
</strong>    let connectionResponse: GetAddressesResult = await connect()
    let bnsName = await getBns(connectionResponse.addresses[2].address)

    setIsConnected(true)
    setWalletInfo(connectionResponse)
    setBns(bnsName)
  }

<strong>  async function disconnectWallet() {
</strong>    disconnect();
  }
  
<strong>  async function getBns(stxAddress: string) {
</strong>    let response = await fetch(`https://api.bnsv2.com/testnet/names/address/${stxAddress}/valid`)
    let data = await response.json()

    return data.names[0].full_name
  }
  
  return (
    &#x3C;>
      &#x3C;h3>Stacks Dev Quickstart Message Board&#x3C;/h3>
      {isConnected ? (
        &#x3C;button onClick={disconnectWallet}>{
<strong>          bns ? bns : walletInfo.addresses[2].address
</strong>        }&#x3C;/button>
      ) : (
        &#x3C;button onClick={connectWallet}>connect wallet&#x3C;/button>
      )}
    &#x3C;/>
  )
}
</code></pre>

The `connect()` method comes with the ability to configure how you want the wallet selector modal to appear for your app. You can decide which wallets to have only appear as an option or allow any wallet that follows the SIP-030 standard to appear as an available Stacks wallet.

For the complete guides check out the [Stacks Connect](https://docs.stacks.co/build/stacks-connect) section.


# Post-Conditions

A unique security mechanism on Stacks to protect user funds

### What are post-conditions?

Post-conditions are assertions about an on-chain transaction that must be met; otherwise, the transaction will abort during execution. In other words, post-conditions act as a safety net, allowing you to specify what state changes can occur in a transaction. This logic helps limit the amount of damage that can be done to a user and their assets, whether due to a bug or malicious behavior.

Post conditions are an additional safety feature built into the Stacks chain itself that help to protect end users. Rather than being a function of Clarity smart contracts, they are implemented on the client side and meant to be an additional failsafe against malicious contracts.

Put simply, post conditions are a set of conditions that must be met before a user's transaction will execute. The primary goal behind post conditions is to limit the amount of damage that can be done to a user's assets due to a bug, intentional or otherwise.

They are sent as part of the transaction when the user initiates it, meaning we need to implement post-conditions on the frontend. Whenever you are transferring an asset (fungible or non-fungible) from one address to another, you should take advantage of post conditions.

{% hint style="info" %}
Head to the dedicated section on [post-conditions](https://docs.stacks.co/build/post-conditions) for more in-depth information.
{% endhint %}

We're going to use [stacks.js](https://github.com/stx-labs/stacks.js/tree/master/packages/transactions#post-conditions) to familiarize ourselves with constructing post-conditions on the frontend. And there are several different ways to construct post-conditions based on asset type.

### Simple example

In this example, we are attached a post-condition statement to a contract call transaction to protect the user's assets in the event the contract is malicious.

<pre class="language-typescript"><code class="lang-typescript">import { request } from '@stacks/connect'
import type { TransactionResult } from '@stacks/connect/dist/types/methods'
import { Pc } from '@stacks/transactions'

let postCond_1 = Pc.principal('ST11V9ZN6E6VG72SHMAVM9GDE30VD3VGW5Q1W9WX3')
  .willSendEq(1)
  .ft('ST1F7QA2MDF17S807EPA36TSS8AMEFY4KA9TVGWXT.sbtc-token', 'sbtc-token')

let result: TransactionResult = await request('stx_callContract', {
  // ...
<strong>  postConditions: [postCond_1],
</strong>  postConditionMode: 'deny',
  // ...
})
</code></pre>

Let's walkthrough the example above line-by-line to see what's happening when you attach a post-condition statement to a transaction.

{% stepper %}
{% step %}

#### Declare post-condition statement

```typescript
let postCond_1 = Pc
  // Specify who the sender of the expected sBTC transfer will originate from
  .principal('ST11V9ZN6E6VG72SHMAVM9GDE30VD3VGW5Q1W9WX3')
  // Specify the equality operator of the amount expected to be sent
  .willSendEq(1)
  // Specify the fungible token’s contract principal and asset name
  .ft('ST1F7QA2MDF17S807EPA36TSS8AMEFY4KA9TVGWXT.sbtc-token', 'sbtc-token')
```

In this statement, you are declaring that the principal (usually the user that'll call this function) `ST11V9ZN6E6VG72SHMAVM9GDE30VD3VGW5Q1W9WX3` should only expect to send out *exactly* 1 satoshi of sBTC during the execution of this contract call transaction.&#x20;
{% endstep %}

{% step %}

#### Include post-condition statement to transaction params

<pre class="language-typescript"><code class="lang-typescript">let result: TransactionResult = await request('stx_callContract', {
  // ...
<strong>  postConditions: [postCond_1],
</strong>  // ...
})
</code></pre>

The transaction param of `postConditions` accepts an array of different post-condition statements. This means you can declare many post-condition statements of what the user should expect to happen during the execution of the transaction. This include any asset transfers coming from the user or from a contract.
{% endstep %}

{% step %}

#### Determine post-condition mode

The other related transaction param of `postConditionMode` is a special setting that is useful when you want to deal with other unexpected/unforeseen asset transfer events that the developer or user may not be aware of.&#x20;

<pre class="language-typescript"><code class="lang-typescript">let result: TransactionResult = await request('stx_callContract', {
  // ...
  postConditions: [postCond_1],
<strong>  postConditionMode: 'deny',
</strong>  // ...
})
</code></pre>

By setting the `postConditionMode` to `deny` we are stating that if any other asset transfers, besides the ones we've declared, happen during the execution of the transaction, then force the entire transaction to fail.
{% endstep %}
{% endstepper %}

### How post-conditions appear to the user

Since post-conditions are declared on your frontend code, they also need to be visually displayed to users. Stacks-supported wallets handle that by displaying post-conditions on the transaction confirmation modals that popup when a user needs to confirm/approve a transaction.

<div data-with-frame="true"><figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2FflyarkGxrtWJErCd2H38%2Fexample-post-condition-leather.png?alt=media&#x26;token=e910e87f-0566-4dbc-aeb6-0a18e4203f61" alt=""><figcaption><p>Post-conditions when appeared in a wallet's transaction confirmation modal</p></figcaption></figure></div>

After transaction confirmation and broadcasting, users are also able to see what post-conditions were set in their transaction on the transaction page of the Stacks Explorer. This gives users and developers more confidence in analyzing transactions.

<div data-with-frame="true"><figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2FBVxwJKkmC1qdeitSktWu%2Fpost-conditions-explorer.png?alt=media&#x26;token=8e5aba16-7333-47b6-a402-b30f9e4cfd51" alt=""><figcaption><p>Analyze post-conditions set in transactions on the transactions page of the Stacks Explorer</p></figcaption></figure></div>

***

### Additional Resources

* \[[Post-Conditions](https://docs.stacks.co/build/post-conditions)] Dedicated section on post-conditions in these docs
* \[[Hiro YT](https://youtu.be/xXgQB8NfdEY?si=eSZp4tlLOCkkqGRS)] ELI5: Post-Conditions on Stacks


# Sending Transactions

<figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2Fs3rLRQQsrTebJkfsL6WR%2Fsend-transactions.jpg?alt=media&#x26;token=1d14700b-41bd-4d53-b022-259c417ce4f6" alt=""><figcaption></figcaption></figure>

Any Stacks app is going to require sending transactions at some point, so how do we do that?

{% hint style="warning" %}
When you send Stacks transactions, don't forget to utilize post-conditions.
{% endhint %}

### Invoking contract call transactions

In our example below, we're going to be showing how to invoke a contract function from the frontend which will prompt a user's wallet to confirm transaction. For this, we'll setup a `stx_callContract` to invoke the `add-message` public function of our contract taken from the [Developer Quickstart](https://docs.stacks.co/build/get-started/developer-quickstart). This function will accept a string content to be passed into our contract call.

<pre class="language-typescript" data-expandable="true"><code class="lang-typescript">import { request } from '@stacks/connect'
import type { TransactionResult } from '@stacks/connect/dist/types/methods'
import { Cl, Pc } from '@stacks/transactions'
import { useState } from 'react'

function App() {
  // ...
  let [content, setContent] = useState&#x3C;string>('')

  async function addMessage() {
    let postCond_1 = Pc.principal('ST11V9ZN6E6VG72SHMAVM9GDE30VD3VGW5Q1W9WX3')
      .willSendEq(1)
      .ft('ST1F7QA2MDF17S807EPA36TSS8AMEFY4KA9TVGWXT.sbtc-token', 'sbtc-token')
  
<strong>    let result: TransactionResult = await request('stx_callContract', {
</strong>      contract: 'ST11V9ZN6E6VG72SHMAVM9GDE30VD3VGW5Q1W9WX3.stacks-dev-quickstart-message-board',
      functionName: 'add-message',
      functionArgs: [Cl.stringUtf8(content)],
      network: 'testnet',
      postConditions: [postCond_1],
      postConditionMode: 'deny',
      sponsored: false
    })
  
    setContent('')
  }

  return (
    &#x3C;>
      // ...
      &#x3C;span className='input-container'>
        &#x3C;button onClick={addMessage}>add-message&#x3C;/button>
        &#x3C;input type="text" onChange={e => setContent(e.target.value)}/>
      &#x3C;/span>
    &#x3C;/>
  )
}
</code></pre>

Let's breakdown some of the transaction params we specified in our string literal method of `stx_callContract`&#x20;

* `contract` : this requires the full contract principal of the target contract.
* `functionName` : the name of the public function in the contract.
* `functionArgs` : an array of the required function arguments in the same order as coded in the actual function of the Clarity contract. The `Cl` namespace has type converter methods that help with converting your argument into the required Clarity type.
* `network` : the target network the contract is deployed on.
* `postConditions` & `postConditionMode` : [Post-Conditions](https://docs.stacks.co/build/post-conditions/overview) for the frontend are declared to protect user assets. The `Pc` helper from `@stacks/transactions` helps us to declare post-condition statements for any type of asset and equality operator.
* `sponsored` : if the transaction fees will be sponsored or not.

Invoking our `addMessage` function will prompt the user's connected wallet to prompt a transaction confirmation popup. This popup will display all of the relevant information of the transaction as well as the post-condition statements that we've declared.

Invoking a contract function is just one example of sending transactions from the frontend. There is also calling read-only functions, initiating asset transfer transactions, and etc.

### Invoking asset transfer transactions

The `request` object also supports native asset transfers for both STX, fungible tokens, and non-fungible tokens. Here is an example of creating an sBTC transfer transaction on the frontend.

Since sBTC is a SIP-010 fungible token, we'll invoke the `stx_transferSip10Ft` method.

```typescript
import { request } from '@stacks/connect';

let response = await request('stx_transferSip10Ft', {
    asset: 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token',
    amount: 1,
    recipient: 'SP202X1VHZMN5S90T44N7SSQ496PYQD66XCPA7BNK',
    network: 'mainnet',
});
```

***

### Additional Resources

* \[[Learn Stacks.js](https://docs.stacks.co/build/stacks.js)] Head to the Learn Stacks.js section to see more examples&#x20;


# Clarity 4 is now LIVE!

Making Bitcoin Smart Contracts More Powerful

SIP-033 and SIP-034 have officially activated at Bitcoin block 923222 – bringing Clarity 4 live on Stacks, the smart contract layer secured by Bitcoin.

This upgrade introduces Version 4 of the Clarity smart contract language, marking a major step forward for the Stacks ecosystem. For users, it delivers safer, smarter contracts with enhanced built-in protections.

For builders, it unlocks five powerful new functions that make developing secure, flexible, and Bitcoin-native DeFi applications easier than ever.

### What Clarity 4 Means for Bitcoin Builders

#### 1. On-chain Contract Verification

Developers can now fetch the hash of another contract’s code body.

[`contract-hash?`](https://docs.stacks.co/reference/clarity/functions#contract-hash)

This makes it possible for one contract to verify that another follows a specific template before interacting with it – a major step toward safer, more trustless bridges and marketplaces that can support a wider range of assets.

#### 2. Allowing Contracts to Set Post-Conditions

New functions allow contracts to set post-conditions that protect their assets.

[`restrict-assets?`](https://docs.stacks.co/reference/clarity/functions#restrict-assets)

This means a contract can safely call external contracts (such as traits) and automatically roll back any changes if the executed code moves assets beyond what’s allowed.

#### 3. Convert Simple Values into ASCII Strings

Clarity 4 adds a function to convert simple values like booleans or principals into ASCII strings.

[`to-ascii?`](https://docs.stacks.co/reference/clarity/functions#to-ascii)

This makes it easier to generate readable, string-based messages – a useful tool for developers building cross-chain features and integrations.

#### 4. Get the Timestamp of the Current Block

A new keyword lets developers retrieve the timestamp of the current block.

[`stacks-block-time`](https://docs.stacks.co/reference/clarity/keywords#stacks-block-time)

This addition enables time-based logic in smart contracts – an essential capability for building features like yield schedules, lockups, or expiration conditions in DeFi applications.

#### 5. Native Passkey Integration

Clarity 4 introduces a new function enabling on-chain verification of secp256r1 signatures.

[`secp256r1-verify`](https://docs.stacks.co/reference/clarity/functions#secp256r1-verify)

This lays the groundwork for passkey-based authentication, opening the door to features like hardware-secured wallets and biometric transaction signing.

#### 6. Dimension-specific Tenure Extensions

The SIP-033 vote also included technical rider SIP-034, which introduces dimension-specific tenure extensions. Signers can approve resets to one budget dimension (e.g., read-count) without resetting the others, allowing high-throughput workloads even when the cost model is pessimistic.

### Why This Matters for Bitcoin

Clarity 4 strengthens Stacks' position as Bitcoin's liquidity layer by giving developers the tools to build more sophisticated Bitcoin DeFi applications – all secured by Bitcoin through Stacks' Proof of Transfer mechanism.

Whether you're building Bitcoin lending protocols, yield products with sBTC, or the next generation of BTCFi applications, Clarity 4 delivers the security and functionality Bitcoin capital markets demand.

Check out [the full SIP-033](https://github.com/stacksgov/sips/pull/218) & [SIP-034](https://github.com/314159265359879/sips/blob/9b45bf07b6d284c40ea3454b4b1bfcaeb0438683/sips/sip-034/sip-034.md) specifications.

***

#### Additional Resources

* \[[Hiro Youtube](https://youtu.be/oJgacfc7YVk?si=b72bNicdS8NjUpml)] A Dev N' Tell with Brice on new Clarity 4 features


# Overview

Clarinet is everything you need to write, test, and deploy Clarity smart contracts on Stacks.

Clarinet is the fastest way to build, test, and deploy smart contracts on the Stacks blockchain. It gives you a local devnet, REPL, testing framework, and debugging tools to ship high-quality Clarity code with confidence.

{% hint style="success" %}
For the latest releases and versions of Clarinet, check out the open-source repo [here](https://github.com/stx-labs/clarinet).
{% endhint %}

<div data-with-frame="true"><figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2Fgit-blob-3ce68c0c166844533a353a3b15c699590defd5e7%2Fclarinet-diagram.png?alt=media" alt=""><figcaption></figcaption></figure></div>

{% updates format="full" %}
{% update date="2025-11-05" %}

## Clarinet was migrated to Stacks Labs

* The Clarinet repository now belongs to the stx-labs organization.
* The NPM packages are now published under the `@stacks` organization.
* The VSCode extension is now published under the Stacks Labs organization.
* Check out the [discussion](https://github.com/stx-labs/clarinet/discussions/2055) to see how to migrate older projects.
  {% endupdate %}
  {% endupdates %}

## Key features

* [**Leverage a powerful CLI**](https://app.gitbook.com/s/GVj1Z9vMuEOMe7oH7Wnq/clarinet/cli-reference) - Create new projects, manage your smart contracts and their dependencies using clarinet requirements, and interact with your code through the built-in REPL.
* [**Write unit tests with the SDK**](https://docs.stacks.co/build/clarinet-js-sdk/unit-testing) - Use the Clarinet SDK to write unit tests in a familiar JS environment and validate contract behavior.
* [**Run a private blockchain environment**](https://docs.stacks.co/build/clarinet/local-blockchain-development) - Spin up a local devnet with nodes, miners, and APIs so you can test and integrate your code.
* [**VSCode extension**](https://docs.stacks.co/build/clarinet/integrations/clarity-vscode-extension) - Linter, step by step debugger, helps writing smart contracts (autocompletion, documentation etc).

## Installation

{% tabs %}
{% tab title="Homebrew" %}

```bash
brew install clarinet
```

{% endtab %}

{% tab title="Winget" %}

```bash
winget install clarinet
```

{% endtab %}

{% tab title="Source" %}

```bash
sudo apt install build-essential pkg-config libssl-dev
git clone https://github.com/stx-labs/clarinet
cd clarinet
cargo clarinet-install
```

{% endtab %}

{% tab title="Binary" %}

```bash
wget -nv https://github.com/stx-labs/clarinet/releases/latest/download/clarinet-linux-x64-glibc.tar.gz -O clarinet-linux-x64.tar.gz
tar -xf clarinet-linux-x64.tar.gz
chmod +x ./clarinet
mv ./clarinet /usr/local/bin
```

{% endtab %}
{% endtabs %}

## Networks

Clarinet supports different network types to cater to various development and testing needs.

| Network   | Description                                                                 | Use case                                                           |
| --------- | --------------------------------------------------------------------------- | ------------------------------------------------------------------ |
| `simnet`  | Optimized for fast feedback loops, introspection, and portability.          | Ideal for initial development and unit-testing.                    |
| `devnet`  | Local Stacks and Bitcoin nodes running on Docker for faster feedback loops. | Use for integration tests or local frontend development.           |
| `testnet` | A pre-production network that offers a realistic environment for testing.   | Ideal for final testing before deploying to Mainnet.               |
| `mainnet` | The production network where real transactions occur.                       | Use when you're ready to deploy your smart contract to production. |

For a deeper understanding of when to use these networks, check out the dedicated blog post by Hiro [here](https://www.hiro.so/blog/devnet-vs-testnet-vs-mainnet-what-do-they-mean-for-web3-developers).

***

### Additional Resources

* \[[Hiro Blog](https://www.hiro.so/blog/clarinet-roadmap-looking-to-the-future)] The Humble Beginning of Clarinet

***

{% hint style="info" %}
Help: Need help building with Clarinet?

Reach out to us on the **#clarinet** channel on [Discord](https://stacks.chat/) under the Developer Tools section.
{% endhint %}


# Quickstart

In this guide, you'll build a simple counter smart contract and interact with it in a local environment.

## What you'll learn

* Create a Clarity smart contract project
* Write Clarity code with maps and public functions
* Test and validate your contracts using Clarinet's console

## Prerequisites

* Clarinet installed on your machine. Follow the [installation guide](https://docs.stacks.co/build/overview#installation) if needed.
* A code editor like VS Code for editing Clarity files.

{% stepper %}
{% step %}
**Create your project**

Let's start by creating a new Clarinet project. The `clarinet new` command sets up everything you need for smart contract development, including a testing framework, deployment configurations, and a local development environment:

```bash
clarinet new counter
```

Clarinet creates a complete project structure for you. Each folder serves a specific purpose in your development workflow:

```
- counter/
  - contracts/
  - settings/
    - Devnet.toml
    - Mainnet.toml
    - Testnet.toml
  - tests/
    - Clarinet.toml
    - package.json
    - vitest.config.js
```

{% endstep %}

{% step %}
**Generate your contract**

Now that we have our project structure, let's create a smart contract. Navigate into your project directory and use Clarinet's contract generator:

```bash
$ cd counter
$ clarinet contract new counter
Created file contracts/counter.clar
Created file tests/counter.test.ts
Updated Clarinet.toml with contract counter
```

Clarinet automatically creates both your contract file and a corresponding test file. This follows the best practice of writing tests alongside your contract code:

| File                     | Purpose                     |
| ------------------------ | --------------------------- |
| `contracts/counter.clar` | Your smart contract code    |
| `tests/counter.test.ts`  | Test file for your contract |

{% hint style="info" %}
Notice that Clarinet also updated your `Clarinet.toml` file. This configuration file tracks all contracts in your project and their deployment settings.
{% endhint %}
{% endstep %}

{% step %}
**Write your contract code**

Open `contracts/counter.clar` and replace its contents with our counter implementation. This contract will maintain a separate count for each user who interacts with it:

{% code title="contracts/counter.clar" %}

```lisp
;; Define a map to store counts for each user
(define-map counters principal uint)

;; Increment the count for the caller
(define-public (count-up)
  (ok (map-set counters tx-sender (+ (get-count tx-sender) u1)))
)

;; Get the current count for a user
(define-read-only (get-count (who principal))
  (default-to u0 (map-get? counters who))
)
```

{% endcode %}

Let's understand what each part does:

* `define-map` creates a persistent storage map that associates each user (principal) with their count
* `tx-sender` is a built-in variable that contains the address of whoever calls the function
* `define-public` declares functions that can modify contract state
* `define-read-only` declares functions that only read data without modifying it
  {% endstep %}

{% step %}
**Validate your contract**

Before we can test our contract, let's make sure it's syntactically correct and type-safe. Clarinet's check command analyzes your contract without deploying it:

```bash
clarinet check
```

If you see errors instead, here are the most common issues and how to fix them:

| Error                 | Fix                                                                           |
| --------------------- | ----------------------------------------------------------------------------- |
| `Unknown keyword`     | Check spelling of Clarity functions                                           |
| `Type mismatch`       | Ensure you're using correct types (uint, principal, etc.)                     |
| `Unresolved contract` | Verify contract name in `Clarinet.toml` matches the contract name in the file |
| {% endstep %}         |                                                                               |

{% step %}
**Test in the console**

Now for the exciting part—let's interact with our contract! Clarinet provides an interactive console where you can call functions and see results immediately. Start the console with:

```bash
clarinet console
```

Once the console loads, you can call your contract functions directly. Here are a few examples you can try:

```lisp
$ (contract-call? .counter count-up)
(ok true)
$ (contract-call? .counter get-count tx-sender)
u1
$ (contract-call? .counter count-up)
(ok true)
$ (contract-call? .counter get-count tx-sender)
u2
```

{% endstep %}
{% endstepper %}


# Project Structure

Understand the complete structure and configuration of a Clarinet project.

A Clarinet project follows a carefully designed structure that separates contracts, tests, and configuration. Understanding this structure helps you organize code effectively and configure tools for an efficient development workflow.

## Core project layout

Every Clarinet project contains these essential directories and files:

```
- my-project/
  - .vscode/
  - contracts/
    - main.clar
    - trait.clar
  - deployments/
  - settings/
    - Devnet.toml
    - Mainnet.toml
    - Testnet.toml
  - tests/
    - main.test.ts
  - .gitignore
  - Clarinet.toml
  - package.json
  - tsconfig.json
  - vitest.config.js
```

Each component serves a specific purpose in your development workflow. The sections below explain how they work together to create a complete development environment.

## The project manifest

### Clarinet.toml

The **Clarinet.toml** file is the heart of your project. It defines project metadata and tracks all contracts:

```toml
[project]
name = "counter"
description = "A counter smart contract"

[contracts.traits]
path = "contracts/traits.clar"
clarity_version = 4
epoch = "latest"

[contracts.counter]
path = "contracts/counter.clar"
clarity_version = 4
epoch = "latest"
```

The manifest handles several critical functions:

* **Contract registration**: Every contract must be listed here
* **Stacks epoch and Clarity version**: Specifies Clarity version and epoch for each contract
* **Boot sequence**: Lists contracts to deploy on `clarinet devnet start`

### Epoch configuration

You can specify the epoch in two ways:

```toml
# Use a specific epoch version
epoch = 3.1
```

```toml
# Use the latest available epoch (default)
epoch = "latest"
```

Using `"latest"` ensures your contracts always use the newest Clarity features and optimizations available in your version of Clarinet.

## Testing infrastructure

### Package configuration

The **package.json** defines your testing environment and dependencies:

```json
{
  "name": "counter-tests",
  "version": "1.0.0",
  "description": "Run unit tests on this project.",
  "type": "module",
  "private": true,
  "scripts": {
    "test": "vitest run",
    "test:report": "vitest run -- --coverage --costs",
    "test:watch": "chokidar \"tests/**/*.ts\" \"contracts/**/*.clar\" -c \"npm run test:report\""
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@stacks/clarinet-sdk": "^3.9.1",
    "@stacks/transactions": "^7.2.0",
    "@types/node": "^24.4.0",
    "chokidar-cli": "^3.0.0",
    "vitest": "^4.0.7",
    "vitest-environment-clarinet": "^3.0.0"
  }
}
```

| Package                       | Purpose                                                 |
| ----------------------------- | ------------------------------------------------------- |
| `@stacks/clarinet-sdk`        | WebAssembly-compiled Clarinet for Node.js               |
| `@stacks/transactions`        | Clarity value manipulation in TypeScript                |
| `vitest`                      | Modern testing framework with native TypeScript support |
| `vitest-environment-clarinet` | Simnet bootstrapping for tests                          |

### Vitest configuration

The **vitest.config.js** configures the testing framework:

```js

/// <reference types="vitest" />

import { defineConfig } from "vite";
import { vitestSetupFilePath, getClarinetVitestsArgv } from "@stacks/clarinet-sdk/vitest";

export default defineConfig({
  test: {
    environment: "clarinet", // use vitest-environment-clarinet
    pool: "forks",
    poolOptions: {
      threads: { singleThread: true },
      forks: { singleFork: true },
    },
    setupFiles: [
      vitestSetupFilePath,
      // custom setup files can be added here
    ],
    environmentOptions: {
      clarinet: {
        ...getClarinetVitestsArgv(),
        // add or override options
      },
    },
  },
});
```

This configuration enables:

* **Clarinet environment**: Automatic `simnet` setup for each test
* **Single fork mode**: Efficient test execution with proper isolation
* **Coverage tracking**: Generate reports in multiple formats
* **Custom setup**: Add project-specific test utilities

### TypeScript configuration

The **tsconfig.json** provides TypeScript support:

```json
{
  "compilerOptions": {
    "target": "ESNext",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ESNext"],
    "skipLibCheck": true,

    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,

    "strict": true,
    "noImplicitAny": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": [
    "node_modules/@stacks/clarinet-sdk/vitest-helpers/src",
    "tests"
  ]
}
```

Properly setting the `include` property ensures TypeScript picks up the helpers defined in the Clarinet SDK package along with your tests.

## Network configurations

### Environment settings

Each network has its own configuration file in the **settings** directory:

```toml
[network]
name = "devnet"
deployment_fee_rate = 10

[accounts.deployer]
mnemonic = "twice kind fence tip hidden..."
balance = 100_000_000_000_000

[accounts.wallet_1]
mnemonic = "sell invite acquire kitten..."
balance = 10_000_000_000_000
```

These settings control:

* **Network ports**: API, RPC, and explorer endpoints
* **Account configuration**: Test wallets with STX balances
* **Chain parameters**: Network-specific blockchain settings

{% hint style="warning" %}
Never commit mainnet private keys or mnemonics. Use environment variables for production credentials.
{% endhint %}

## Common issues

<details>

<summary>Imports failing in tests</summary>

If you're encountering import errors in your tests, update your TypeScript configuration to use Vite's bundler resolution:

```json
{
  "compilerOptions": {
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true
  }
}
```

This configuration ensures TypeScript understands Vite's module resolution strategy and allows importing `.ts` files directly.

</details>


# Project Development

Clarinet streamlines the entire lifecycle of Clarity smart contract development. From project initialization to contract management and code formatting, you'll have the tools needed for professional workflows.

## Creating a new project

The `clarinet new` command creates a complete project structure with all necessary configuration files:

```bash
$ clarinet new my-defi-app
```

| Option                | Description                     | Example                                   |
| --------------------- | ------------------------------- | ----------------------------------------- |
| `--disable-telemetry` | Opt out of telemetry collection | `clarinet new my-app --disable-telemetry` |

For a deeper look at what Clarinet generates, see the [project structure](https://docs.stacks.co/build/clarinet/project-structure) guide.

## Managing contracts

### Creating new contracts

The `clarinet contract new` command generates both a contract file and a matching test file:

```bash
$ clarinet contract new token
Created file contracts/token.clar
Created file tests/token.test.ts
Updated Clarinet.toml
```

The generated contract includes a minimal template:

```clarity
;; token
;; <add a description here>

;; constants
;;

;; data vars
;;

;; data maps
;;

;; public functions
;;

;; read only functions
;;

;; private functions
;;
```

### Removing contracts

Clean up unused contracts with the `rm` command:

```bash
$ clarinet contract rm old-token
Removed file contracts/old-token.clar
Removed file tests/old-token.test.ts
Updated Clarinet.toml
```

## Checking project contract syntax

Validate your entire project setup:

```bash
$ clarinet check
✔ 3 contracts checked
```

Check specific contracts:

```bash
$ clarinet check contracts/token.clar
✔ contracts/token.clar Syntax of contract successfully checked
```

## Code formatting

Clarinet includes a formatter to maintain consistent style across your project.

Format all contracts in your project:

```bash
$ clarinet format --in-place
Formatted 5 contracts
```

### Formatting options

Customize formatting to match your team's style guide:

| Option              | Description                                            | Example                                 |
| ------------------- | ------------------------------------------------------ | --------------------------------------- |
| `--dry-run`         | Preview changes without modifying files                | `clarinet format --dry-run`             |
| `--in-place`        | Replace file contents (required for actual formatting) | `clarinet format --in-place`            |
| `--max-line-length` | Set maximum line length                                | `clarinet format --max-line-length 100` |
| `--indent`          | Set indentation size                                   | `clarinet format --indent 2`            |
| `--tabs`            | Use tabs instead of spaces                             | `clarinet format --tabs`                |

### Format single files

```bash
$ clarinet format contracts/messy-contract.clar --in-place
```

Format specific contracts with glob patterns:

```bash
$ clarinet format contracts/token*.clar --in-place
```

## Project configuration

### Working with requirements

Add mainnet contracts as dependencies:

```bash
$ clarinet requirements add SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait
Added requirement SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait
Updated Clarinet.toml
```

Clarinet adds the dependency to `Clarinet.toml`:

```toml
[project]
requirements = [
  { contract_id = "SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait" }
]
```

You can now implement traits from mainnet contracts:

```clarity
(impl-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)

(define-non-fungible-token my-nft uint)
;; ... implement required functions
```

##


# Contract Interaction

Clarinet provides powerful tools for interacting with your contracts during development. The console gives you an interactive REPL where you can call functions, inspect state, and debug issues in real time.

## Starting the console

Use `clarinet console` to launch an interactive session with your contracts deployed to a local simulated blockchain:

```bash
clarinet console
```

Sample startup output:

```
clarity-repl v3.3.0
Enter "::help" for usage hints.
Connected to a transient in-memory database.
```

The console supports several useful flags for different development scenarios:

| Option                                  | Description                                           |
| --------------------------------------- | ----------------------------------------------------- |
| `--enable-remote-data`                  | Connect to mainnet or testnet to query real contracts |
| `--deployment-plan-path <path>`         | Use a specific deployment plan                        |
| `--manifest-path <path>`                | Use an alternate `Clarinet.toml` location             |
| `--remote-data-api-url <url>`           | Specify a custom Stacks API endpoint                  |
| `--remote-data-initial-height <height>` | Set the starting block height for remote data         |

## Working with remote data

One of the most powerful features is the ability to interact with real mainnet or testnet contracts from your local console. This lets you test against actual deployed contracts:

```bash
clarinet console --enable-remote-data
```

Example contract calls:

```clarity
(contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token get-decimals)
;; (ok u8)

(contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token get-name)
;; (ok "Arkadiko Token")
```

These capabilities help you:

* Test integrations with existing protocols
* Verify contract behavior against live chain state
* Develop contracts that depend on mainnet deployments

> **Warning: Remote data requirements**
>
> Before using remote data, add the target contract to `Clarinet.toml` with `clarinet requirements add SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token`.

### Using the Hiro API key

Avoid rate limits by setting the `HIRO_API_KEY` environment variable before launching the console. Clarinet forwards this key in the `x-api-key` header for all requests:

```bash
export HIRO_API_KEY=your_api_key_here
clarinet console --enable-remote-data
```

You can request a free API key from the Hiro Platform.

### Working with contracts

List all available contracts in the session:

```clarity
::get_contracts
;; +---------------------------------------------------------+----------------------+
;; | Contract identifier                                    | Public functions    |
;; |---------------------------------------------------------+----------------------|
;; | ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.counter      | (count-up)          |
;; |                                                         | (get-count (who ...))|
;; +---------------------------------------------------------+----------------------+

(contract-call? .counter count-up)
;; (ok true)

(contract-call? .counter get-count tx-sender)
;; u1
```

### Working with different principals

Switch between the provided test wallets to validate multi-user flows:

```clarity
::get_assets_maps
;; +-------------------------------------------+-----------------+
;; | Address                                   | uSTX            |
;; |-------------------------------------------+-----------------|
;; | ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM | 100000000000000 |
;; | ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5 | 100000000000000 |
;; ...

::set_tx_sender ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5
;; tx-sender switched to ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5
```

### Working with block heights

Advance the chain to test time-dependent logic:

```clarity
::get_block_height
;; Current block height: 4

::advance_chain_tip 100
;; new burn height: 3
;; new stacks height: 104

::get_block_height
;; Current block height: 104
```

> **Tip: Console reference**
>
> For a complete list of console commands, see the [CLI reference](https://github.com/stacks-network/docs/blob/master/docs/reference/clarinet/cli-reference.md).

## Common issues

<details>

<summary>Contract not found errors</summary>

If you see `use of unresolved contract` errors, the contract may not be deployed or the name might be incorrect:

```clarity
(contract-call? .missing-contract get-value)
;; error: use of unresolved contract
```

Solutions:

* Check for typos in the contract identifier
* Confirm the contract is deployed in the current session with `::get_contracts`
* Use the correct prefix (`.` for local contracts)

</details>

<details>

<summary>Remote data connection issues</summary>

When you enable remote data, rate limits or connectivity problems can occur:

```clarity
(contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token get-name)
;; error: API rate limit exceeded
```

**Solutions:**

1. Set your Hiro API key: `export HIRO_API_KEY=your_key_here`
2. Use a custom API endpoint: `--remote-data-api-url https://your-node.com`
3. Wait for rate limit to reset (usually 1 minute)

</details>

##


# Validation and Analysis

Clarinet provides powerful tools for validating, analyzing, and debugging your smart contracts. From static type checking to real-time cost analysis, you can ensure your contracts are correct and efficient before deployment.

Contract validation spans static analysis, runtime debugging, and cost optimization. Each discipline helps you gain confidence in contract behavior.

## Understanding contract validation

**Static analysis vs. runtime debugging**

| Static analysis                         | Runtime debugging                      |
| --------------------------------------- | -------------------------------------- |
| Catches issues before deployment        | Reveals behavior during execution      |
| Flags type mismatches and syntax errors | Shows actual execution costs           |
| Ensures trait compliance                | Exposes state changes and side effects |
| Detects undefined variables             | Highlights transaction flow            |
| Validates function signatures           | Surfaces performance bottlenecks       |

## Static analysis

Run comprehensive validation with `clarinet check`:

```bash
clarinet check
```

Successful output resembles:

```
✔ 3 contracts checked
```

When validation fails, Clarinet provides detailed diagnostics:

```
✖ 1 error detected

Error in contracts/token.clar:15:10
  |
15|  (ok (+ balance amount))
  |         ^^^^^^^
  |
  = Type error: expected uint, found (response uint uint)
```

{% stepper %}
{% step %}
**Run basic checks**

Use `clarinet check` to validate your contracts and catch type/syntax errors before deployment.

```bash
clarinet check
```

{% endstep %}

{% step %}
**Check a specific contract**

Focus validation during development on a single contract file:

```bash
clarinet check contracts/nft.clar
```

{% endstep %}

{% step %}
**Integrate into CI**

Automate validation in continuous integration pipelines. Example GitHub Actions workflow:

```yaml
name: Contract Validation
on: [push, pull_request]

jobs:
  sanity-checks:
    runs-on: ubuntu-latest
    container: ghcr.io/stx-labs/clarinet:latest
    steps:
      - uses: actions/checkout@v4
      - name: Check Clarity contracts check
        run: clarinet check --use-on-disk-deployment-plan
      - name: Check Clarity contracts format
        run: clarinet fmt --check
```

{% endstep %}
{% endstepper %}

**Validation scope**

Clarinet validates multiple aspects of your contracts:

| Validation type          | What it checks                                     |
| ------------------------ | -------------------------------------------------- |
| **Type safety**          | Function parameters, return values, variable types |
| **Trait compliance**     | Implementation matches trait definitions           |
| **Response consistency** | `ok`/`err` branches return the same types          |
| **Variable scope**       | Variables defined before use                       |
| **Function visibility**  | Proper use of public, private, and read-only       |

## Runtime analysis

The Clarinet console offers runtime tools that help you inspect behavior during execution.

### Cost analysis with `::toggle_costs`

Enable automatic cost display after every expression:

```clarity
::toggle_costs
;; Always show costs: true

(contract-call? .counter count-up)
;; +----------------------+----------+------------+------------+
;; |                      | Consumed | Limit      | Percentage |
;; |----------------------+----------+------------+------------|
;; | Runtime              | 4775     | 5000000000 | 0.00 %     |
;; | Read count           | 5        | 15000      | 0.03 %     |
;; | Read length (bytes)  | 268      | 100000000  | 0.00 %     |
;; | Write count          | 1        | 15000      | 0.01 %     |
;; | Write length (bytes) | 41       | 15000000   | 0.00 %     |
;; +----------------------+----------+------------+------------+
;; (ok true)
```

### Execution tracing with `::trace`

Trace function calls to understand execution flow:

```clarity
::trace (contract-call? .defi-pool swap u100 'token-a 'token-b)
;; (contract-call? .defi-pool swap u100 'token-a 'token-b) <console>
;; ( get-pool-balance 'token-a ) defi-pool:15:8
;;   ↳ args: 'token-a
;;     u50000
;; ( get-pool-balance 'token-b ) defi-pool:16:8
;;   ↳ args: 'token-b
;;     u75000
;; ( calculate-output u100 u50000 u75000 ) defi-pool:18:12
;;   ↳ args: u100, u50000, u75000
;;     u149
;; (ok u149)
```

### Interactive debugging with `::debug`

Set breakpoints and step through execution:

```clarity
::debug (contract-call? .complex-contract process-batch)
break validate-input
;; Breakpoint set at validate-input
continue
;; Hit breakpoint at validate-input:23
```

Common navigation commands:

{% hint style="info" %}

* `step` or `s` – step into subexpressions
* `finish` or `f` – complete the current expression
* `next` or `n` – step over subexpressions
* `continue` or `c` – resume execution
  {% endhint %}

### Using `::get_costs` for targeted analysis

```clarity
::get_costs (contract-call? .defi-pool add-liquidity u1000 u1000)
;; +----------------------+----------+------------+------------+
;; |                      | Consumed | Limit      | Percentage |
;; |----------------------+----------+------------+------------|
;; | Runtime              | 12250    | 5000000000 | 0.00 %     |
;; | Read count           | 6        | 15000      | 0.04 %     |
;; | Read length (bytes)  | 192      | 100000000  | 0.00 %     |
;; | Write count          | 3        | 15000      | 0.02 %     |
;; | Write length (bytes) | 96       | 15000000   | 0.00 %     |
;; +----------------------+----------+------------+------------+
;; (ok {lp-tokens: u1000})
```

### Spotting costly operations with `::trace`

```clarity
::trace (contract-call? .complex-algo process-large-dataset)
```

Review the trace for loops with high iteration counts, nested map/filter operations, repeated contract calls, and large data structure manipulations.

## Debugging workflows

Master interactive debugging to identify issues quickly:

```clarity
::debug (contract-call? .counter count-up)
;; ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.counter:9:3
;;   6
;;   7      ;; Increment the count for the caller
;;   8      (define-public (count-up)
;; ->9        (ok (map-set counters tx-sender (+ (get-count tx-sender) u1)))
;;             ^
;;  10     )
```

### Analyzing failed transactions with `::trace`

```clarity
::trace (contract-call? .marketplace purchase u999)
;; (contract-call? .marketplace purchase u999) <console>
;; ( get-listing u999 ) marketplace:45:12
;;   ↳ args: u999
;;     none
;; (err u404)  # Listing not found
```

### Using `::encode` and `::decode` for inspection

```clarity
::encode { id: u1, active: true }
;; 0c0000000206616374697665030269640100000000000000000000000000000001

::decode 0d0000000b48656c6c6f20776f726c64
;; "Hello world"
```

### Testing time-dependent logic

```clarity
::get_block_height
;; Current block height: 4

::advance_chain_tip 100
;; new burn height: 3
;; new stacks height: 104

(contract-call? .vesting claim)
;; (ok {claimed: u2500, remaining: u7500})
```

##


# Clarity Formatter

The Clarity formatter automatically shapes your smart contract code to follow standardized style rules. Consistent formatting improves readability and makes collaboration easier across teams.

## Formatting philosophy

The formatter applies an opinionated standard designed to make Clarity code more readable:

* **Line length** – wraps lines at 80 characters by default
* **Indentation** – uses two spaces for consistency
* **Structure** – enforces consistent patterns for functions, let bindings, and control flow

You can customize these defaults to match your preferences.

### Integration points

{% stepper %}
{% step %}
**Clarity VS Code Extension**

Format directly in the editor.
{% endstep %}

{% step %}
**Clarinet CLI**

Format via command line, including entire projects.
{% endstep %}
{% endstepper %}

## Comparison table

| Aspect            | Manual formatting      | Clarity formatter           |
| ----------------- | ---------------------- | --------------------------- |
| Consistency       | Varies by developer    | Uniform across the codebase |
| Speed             | Time-consuming         | Instant                     |
| Error-prone       | Yes                    | No                          |
| Team coordination | Requires a style guide | Automatic enforcement       |

## Best practices

* **Format on save** – enable automatic formatting in VS Code
* **Pre-commit hooks** – ensure code is formatted before commits
* **Team adoption** – share consistent settings with your team

## Formatting rules in detail

### Function definitions

Functions span multiple lines with consistent indentation:

```clarity
(define-public (my-func
    (amount uint)
    (sender principal)
  )
  (ok true)
)
```

Single arguments can remain on the first line:

```clarity
(define-read-only (get-balance (who principal))
  (ok u0)
)
```

### Let expressions

Bindings are placed on separate lines with consistent indentation:

```clarity
(let (
  (a u1)
  (b u2)
)
  (body-expression)
)
```

### Control flow (if, match)

Each branch receives its own line:

```clarity
(if condition
  (then-expression)
  (else-expression)
)

(match optional-value
  value (handle-some value)
  (handle-none)
)
```

### Tuples and maps

The formatter automatically converts to sugared syntax with proper formatting:

```clarity
;; Input: (tuple (n1 u1) (n2 u2))
;; Output:
{
  n1: u1,
  n2: u2,
}
```

## Usage examples

### VS Code integration

```json
// settings.json
"[clarity]": {
  "editor.formatOnSave": true
}
```

### CLI usage

```bash
clarinet format --in-place
```

Format with custom settings:

```bash
clarinet format -i 4 -l 120 --in-place
```

Check formatting in CI/CD pipelines:

```bash
clarinet format --check
```

The `--check` flag validates that all Clarity files are properly formatted without changing them, which is ideal for continuous integration workflows.

## Ignoring blocks of code

Prevent formatting for specific code blocks:

```clarity
;; @format-ignore
(define-constant something (list
  1     2  3  ;; Preserves custom spacing
  4 5 ))
```


# Local Blockchain Development

Clarinet ships with a complete local blockchain environment so you can build, test, and debug smart contracts without deploying to a public network.

## Starting your local blockchain

Launch devnet with all required services:

```bash
clarinet devnet start
```

Useful flags:

| Option                           | Description                                       |
| -------------------------------- | ------------------------------------------------- |
| `--manifest-path <path>`         | Use an alternate `Clarinet.toml`                  |
| `--no-dashboard`                 | Stream logs instead of showing the interactive UI |
| `--deployment-plan-path <path>`  | Apply a specific deployment plan                  |
| `--use-on-disk-deployment-plan`  | Use an existing plan without recomputing          |
| `--use-computed-deployment-plan` | Recompute and overwrite the plan                  |
| `--package <path>`               | Load a packaged devnet configuration              |

{% hint style="info" %}
Prerequisites

Devnet requires Docker. If you see “clarinet was unable to create network,” ensure Docker Desktop is running or the Docker daemon is started.
{% endhint %}

By default the dashboard displays service health, recent transactions, block production, contract deployments, and resource usage. Use `--no-dashboard` in CI or when you prefer streaming logs.

## Core services and features

Devnet starts these services for you:

| Service          | Port  | Purpose                                  |
| ---------------- | ----- | ---------------------------------------- |
| Stacks node      | 20443 | Processes transactions and mines blocks  |
| Bitcoin node     | 18443 | Provides block anchoring in regtest mode |
| Stacks API       | 3999  | REST API for blockchain data             |
| Postgres         | 5432  | Indexes blockchain data                  |
| Stacks Explorer  | 8000  | Browse transactions in a web UI          |
| Bitcoin Explorer | 8001  | View the Bitcoin regtest chain           |

Devnet includes pre-funded accounts:

```clarity
::get_assets_maps
;; +-------------------------------------------+-----------------+
;; | Address                                   | STX Balance     |
;; |-------------------------------------------+-----------------|
;; | ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM | 100000000000000 |
;; | ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5 | 100000000000000 |
;; | ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG | 100000000000000 |
;; | ST2JHG361ZXG51QTKY2NQCVBPPRRE2KZB1HR05NNC | 100000000000000 |
;; | ST2NEB84ASENDXKYGJPQW86YXQCEFEX2ZQPG87ND  | 100000000000000 |
;; +-------------------------------------------+-----------------+
```

When devnet starts it automatically deploys your project contracts so you can interact immediately.

```
$ clarinet devnet start
Deploying contracts...
Deploying counter.clar        ✓  ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.counter
Deploying token.clar         ✓  ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.token
Deploying marketplace.clar   ✓  ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.marketplace

All contracts deployed successfully
```

## Configuration and customization

Devnet behavior is controlled by configuration files in your project.

### Basic configuration

`settings/Devnet.toml` defines network settings:

```toml
[network]
name = "devnet"

# Service ports
stacks_node_rpc_port = 20443
stacks_api_port = 3999
stacks_explorer_port = 8000
bitcoin_node_rpc_port = 18443

[network.devnet]
bitcoin_controller_block_time = 30_000  # 30 seconds

disable_bitcoin_explorer = false
disable_stacks_explorer = false
disable_stacks_api = false
```

### Port configuration

Avoid local conflicts by customizing ports:

```toml
stacks_node_rpc_port = 30443
stacks_api_port = 4999
postgres_port = 6432
stacks_explorer_port = 4020
```

### Mining intervals

Control block production speed:

```toml
bitcoin_controller_block_time = 1_000     # Fast development (1 second)
bitcoin_controller_block_time = 30_000    # Standard testing (30 seconds)
bitcoin_controller_block_time = 120_000   # Realistic timing (2 minutes)
```

### Custom accounts

Add accounts with specific balances:

```toml
[accounts.treasury]
mnemonic = "twice kind fence tip hidden tilt action fragile skin nothing glory cousin"
balance = 10_000_000_000_000

[accounts.alice]
mnemonic = "female adjust gallery certain visit token during great side clown fitness like"
balance = 5_000_000_000_000
```

## Accessing services

Devnet exposes several ways to interact with the blockchain.

### Stacks Explorer

Visit the explorer to browse transactions, blocks, contract state, and account balances:

```
http://localhost:8000
```

### API endpoints

Query blockchain data with the Stacks API:

```bash
curl http://localhost:3999/v2/info
```

Common endpoints:

* `/v2/info` – network information
* `/v2/accounts/{address}` – account details
* `/v2/contracts/source/{address}/{name}` – contract source code
* `/extended/v1/tx/{txid}` – transaction details

### Direct RPC

Submit transactions directly to the Stacks node:

```bash
curl -X POST http://localhost:20443/v2/transactions \
  -H "Content-Type: application/json" \
  -d @transaction.json
```

Useful RPC endpoints:

* `/v2/transactions` – broadcast transactions
* `/v2/contracts/call-read` – read-only contract calls
* `/v2/fees/transfer` – fee estimates for STX transfers

## Advanced configuration

### Performance optimization

For faster development cycles:

{% code title="settings/Devnet.toml" %}

```toml
[network.devnet]
bitcoin_controller_block_time = 1_000

disable_bitcoin_explorer = true
disable_stacks_explorer = true
disable_stacks_api = false
```

{% endcode %}

### Epoch configuration

Test different Stacks versions:

```toml
[epochs]
epoch_2_0 = 0     # Stacks 2.0 from genesis
epoch_2_05 = 0    # Stacks 2.05 from genesis  
epoch_2_1 = 0     # Stacks 2.1 from genesis
epoch_2_2 = 0     # Pox-2 from genesis
epoch_2_3 = 0     # Pox-3 from genesis
epoch_2_4 = 0     # Pox-4 from genesis
epoch_3_0 = 101   # Nakamoto activation at block 101
```

### Custom node/signer images

Clarinet runs Devnet with specific tags for each Docker image. For example, Clarinet v3.10.0 uses the following images:

* stacks node: `blockstack/stacks-blockchain:3.3.0.0.1-alpine`
* stacks signer: `blockstack/stacks-signer:3.3.0.0.1.0-alpine`

We recommend Devnet users let Clarinet handle it and use the default version. This ensures that your Clarinet version can handle and properly configure the images it uses.

In some cases, you may need to use other images. Clarinet lets you do this by configuring it in `settings/Devnet.toml`. For example, if you don't want to run the `alpine` images:

```toml
# setting/Devnet.toml
[network]
name = "devnet"
deployment_fee_rate = 10

# ...

[devnet]
stacks_node_image_url = "blockstack/stacks-blockchain:3.3.0.0.1"
stacks_signer_image_url = "blockstack/stacks-signer:3.3.0.0.1.0"
```

<details>

<summary>Build an image locally and use it</summary>

* Clone the stacks-core repository (or a fork) and checkout the desired branch.

```
git clone git@github.com:stacks-network/stacks-core.git
cd stacks-core
git checkout develop
```

* Build the Docker image `stacks-node:local`:

```
docker build -t stacks-node:local -f ./Dockerfile ./
```

* Clarinet needs the image to be available in a registry. You can host a local one and push the image to it.

```
docker run -d -e REGISTRY_HTTP_ADDR=0.0.0.0:5001 -p 5001:5001 --name registry registry:2
docker tag stacks-node:local localhost:5001/stacks-node:local
docker push localhost:5001/stacks-node:local
```

* Set the image to be used:

```
# setting/Devnet.toml
[network]
name = "devnet"
deployment_fee_rate = 10

# ...

[devnet]
stacks_node_image_url = "localhost:5001/stacks-node:local"
```

* Then start Devnet:

```
clarinet devnet sta
```

</details>

### Package deployment

Create reusable devnet configurations:

```bash
$ clarinet devnet package --name demo-env
Packaging devnet configuration...
Created demo-env.json
```

Use a packaged configuration:

```bash
$ clarinet devnet start --package demo-env.json
```

## Common issues

<details>

<summary>Docker connection errors — “clarinet was unable to create network”</summary>

Follow these steps to fix Docker connection issues:

Ensure Docker Desktop is running (macOS/Windows).Start the Docker daemon (sudo systemctl start docker) on Linux.Confirm permissions with docker ps.Reset Docker to factory defaults if problems persist.

Verify Docker status:

```bash
docker --version
docker ps
```

</details>

<details>

<summary>Port already in use — “bind: address already in use”</summary>

Find and stop the conflicting process (macOS/Linux):

```bash
lsof -i :3999
kill -9 $(lsof -t -i:3999)
```

Windows equivalent:

```bash
netstat -ano | findstr :3999
taskkill /PID <PID> /F
```

Or update ports in `settings/Devnet.toml`:

```toml
stacks_api_port = 4999
stacks_explorer_port = 4020
postgres_port = 6432
```

</details>

<details>

<summary>High resource usage (slow performance, high CPU or memory)</summary>

Optimizations:

```toml
disable_bitcoin_explorer = true
disable_stacks_explorer = true
bitcoin_controller_block_time = 60_000
```

Set Docker resource limits:

```bash
docker update --memory="2g" --cpus="1" <container_id>
```

Clean up old data:

```bash
clarinet devnet stop
docker system prune -a
rm -rf tmp/devnet
```

</details>

<details>

<summary>Network already exists — “network with name `.devnet` already exists”</summary>

Remove the orphaned network:

```bash
docker network rm <project>.devnet
```

If you're unsure of the name:

```bash
docker network ls | grep devnet
docker network rm <network-name>
```

Prevent the issue by stopping devnet with `Ctrl+C` and pruning orphaned networks:

```bash
docker network prune
```

</details>

<details>

<summary>Docker stream error during startup — “Fatal: unable to create image: Docker stream error”</summary>

**Error**: "Fatal: unable to create image: Docker stream error"

This error often occurs when Docker images are corrupted or when explorers fail to start properly.

**Solution 1 - Disable explorers**:

If you don't need the web explorers, disable them in `settings/Devnet.toml`:

```
disable_bitcoin_explorer = true
disable_stacks_explorer = true
```

**Solution 2 - Clean Docker environment**:

Remove all containers and images, then restart:

Terminal

```
docker stop $(docker ps -a -q)
docker system prune -a
docker volume prune
```

**Solution 3 - Full cleanup and restart**:

Terminal

```
docker stop $(docker ps -a -q)
docker network rm <project-name>.devnet
docker system prune --all --volumes
clarinet devnet start
```

This ensures a clean Docker environment for devnet to start fresh.

</details>

<details>

<summary>Contract deployment failures</summary>

Ensure dependencies deploy first in `Clarinet.toml`:

```toml
[contracts.sip-010-trait]
path = "contracts/sip-010-trait.clar"

[contracts.token]
path = "contracts/token.clar"
```

Validate contracts before deployment:

```bash
clarinet check
```

Check logs:

```bash
clarinet devnet start --no-dashboard
```

Deploy manually if needed:

```bash
clarinet deployments generate --devnet
clarinet deployments apply --devnet
```

</details>

***

### Additional Resources

* \[[Hiro Blog](https://www.hiro.so/blog/5-ways-to-interact-with-devnet-in-the-hiro-platform)] 5 Ways to Interact With Devnet in the Hiro Platform&#x20;


# Contract Deployment

Clarinet provides deployment tooling that helps you move from local development to production networks. Whether you're testing on devnet, staging on testnet, or launching on mainnet, Clarinet streamlines the process.

## Generating deployment plans

Deployment plans are YAML files that describe how contracts are published or called. Be sure to have a valid 24 word mnemonic seed phrase specified in the target network's `.toml` file in `settings/` and then generate a plan for any network:

```bash
$ clarinet deployments generate --testnet --medium-cost
Analyzing contracts...
Calculating deployment costs...
Generating deployment plan
Created file deployments/default.testnet-plan.yaml
```

Example output structure:

{% code title="deployments/default.devnet-plan.yaml" %}

```yaml
---
id: 0
name: Devnet deployment
network: devnet
stacks-node: "http://localhost:20443"
bitcoin-node: "http://devnet:devnet@localhost:18443"
plan:
  batches:
    - id: 0
      transactions:
        - contract-publish:
            contract-name: counter
            expected-sender: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM
            cost: 6940
            path: contracts/counter.clar
            anchor-block-only: true
            clarity-version: 2
      epoch: "2.5"
```

{% endcode %}

### Deployment plan structure

| Field          | Description                                  |
| -------------- | -------------------------------------------- |
| `id`           | Unique identifier for the deployment         |
| `name`         | Human-readable deployment name               |
| `network`      | Target network (devnet, testnet, or mainnet) |
| `stacks-node`  | RPC endpoint for the Stacks node             |
| `bitcoin-node` | RPC endpoint for the Bitcoin node            |
| `plan.batches` | Array of deployment batches                  |

### Deployment specifications

Deployment behavior is configured in two places:

* **Project configuration (`Clarinet.toml`)** – Clarity versions, dependencies, epoch requirements
* **Network configuration (`settings/<network>.toml`)** – Account details, balances, endpoints

Example network configuration:

{% code title="settings/Testnet.toml" %}

```toml
[network]
name = "testnet"
deployment_fee_rate = 10

[accounts.deployer]
mnemonic = "<YOUR TESTNET MNEMONIC>"
balance = 100_000_000_000_000
derivation = "m/44'/5757'/0'/0/0"
```

{% endcode %}

## Working with contract requirements

Reference contracts that already exist on-chain—useful for standardized traits.

### Adding requirements

```bash
clarinet requirements add SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait
```

Clarinet updates your configuration automatically:

```toml
[project]
name = "my-nft-project"
requirements = [
  { contract_id = "SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait" }
]
```

During deployment Clarinet downloads the contract, remaps the principal for devnet, and ensures the requirement is available before your contracts deploy.

## Deploying to different networks

### Devnet

Devnet deploys contracts automatically when it starts:

```bash
clarinet devnet start
```

To deploy manually against a running devnet:

```bash
clarinet deployments apply --devnet
```

See [local development](https://docs.stacks.co/build/clarinet/local-blockchain-development) for more devnet configuration tips.

### Testnet

{% hint style="info" %}
Prerequisites:

* Request testnet STX from the faucet
* Configure your account in `settings/Testnet.toml`
* Validate contracts with `clarinet check`
  {% endhint %}

Generate a deployment plan with cost estimation:

```bash
clarinet deployments generate --testnet --medium-cost
```

Deploy to testnet:

```bash
clarinet deployments apply --testnet
```

### Mainnet

{% hint style="warning" %}
Mainnet checklist
{% endhint %}

{% stepper %}
{% step %}
Finish thorough testing on testnet
{% endstep %}

{% step %}
Audit contracts for security
{% endstep %}

{% step %}
Ensure sufficient STX for fees
{% endstep %}

{% step %}
Back up deployment keys securely
{% endstep %}

{% step %}
Prefer a hardware wallet for deployment
{% endstep %}
{% endstepper %}

Create a mainnet plan:

```bash
clarinet deployments generate --mainnet --high-cost
```

Deploy with confirmation:

```bash
clarinet deployments apply --mainnet
```

## Cost estimation and optimization

Choose the right fee level for your deployment:

```bash
clarinet deployments generate --testnet --manual-cost
```

Fee options:

* `--low-cost` – minimize fees, slower confirmation
* `--medium-cost` – balanced approach
* `--high-cost` – priority inclusion
* `--manual-cost` – interactive selection

Analyze costs before deploying:

```bash
clarinet deployments generate --testnet --medium-cost
```

## Advanced deployment configurations

### Multi-batch deployments

Deploy complex systems with batches:

{% code title="" %}

```yaml
plan:
  batches:
    - id: 0
      transactions:
        - contract-publish:
            contract-name: trait-definitions
            path: contracts/traits.clar
            clarity-version: 2
    - id: 1
      transactions:
        - contract-publish:
            contract-name: token
            path: contracts/token.clar
        - contract-publish:
            contract-name: oracle
            path: contracts/oracle.clar
    - id: 2
      transactions:
        - contract-publish:
            contract-name: defi-pool
            path: contracts/defi-pool.clar
```

{% endcode %}

Batches guarantee that dependencies deploy first, allow parallel transactions within a batch, and run batches sequentially.

### Transaction types

Deployment plans support different transaction types:

| Transaction type    | Description                                                         |
| ------------------- | ------------------------------------------------------------------- |
| Contract operations | Publish or call contracts, specifying sender, cost, and source path |
| Asset transfers     | Transfer STX or BTC by setting sender, recipient, and amounts       |

**Contract operations**

```yaml
- contract-publish:
    contract-name: my-contract
    expected-sender: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM
    cost: 5960
    path: contracts/my-contract.clar
    clarity-version: 2

- contract-call:
    contract-id: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.my-contract
    expected-sender: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM
    method: initialize
    parameters:
      - u1000000
      - "Token Name"
    cost: 5960
```

**Asset transfers**

```yaml
- stx-transfer:
    expected-sender: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM
    recipient: ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG
    mstx-amount: 1000000
    memo: '0x48656c6c6f'

- btc-transfer:
    expected-sender: mjSrB3wS4xab3kYqFktwBzfTdPg367ZJ2d
    recipient: bcrt1qnxknq3wqtphv7sfwy07m7e4sr6ut9yt6ed99jg
    sats-amount: 100000000
    sats-per-byte: 10
```

### Manual customization

You can edit deployment plans for complex scenarios.

{% hint style="info" %}
Manual edits

When Clarinet prompts to overwrite your plan, answer `no` to keep custom changes.
{% endhint %}

Example contract initialization batch:

```yaml
- id: 3
  transactions:
    - contract-call:
        contract-id: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.token
        method: initialize
        parameters:
          - u1000000
          - { name: "My Token", symbol: "MTK", decimals: u6 }
        expected-sender: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM
```

## Common issues

### Insufficient STX balance

**Error**: “Insufficient STX balance for deployment”

Solutions:

{% stepper %}
{% step %}
Request testnet STX from the faucet
{% endstep %}

{% step %}
Reduce the fee rate with `--low-cost`
{% endstep %}

{% step %}
Check your balance:

```bash
clarinet console --testnet
stx-account 'ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG
```

{% endstep %}
{% endstepper %}

### Contract already exists

**Error**: “Contract `token` already deployed at this address”

Solutions:

{% stepper %}
{% step %}
Use a different contract name
{% endstep %}

{% step %}
Deploy from another address
{% endstep %}

{% step %}
On testnet, switch to a fresh account
{% endstep %}
{% endstepper %}

### Network connection failures

**Error**: “Failed to connect to testnet node”

Check your network settings:

```toml
[network]
name = "testnet"
node_rpc_address = "https://stacks-node-api.testnet.stacks.co"
```

Alternative endpoints:

* Hiro: `https://api.testnet.hiro.so`
* Your own node

Debug the connection:

```bash
curl -I https://api.testnet.hiro.so/v2/info
```

### Invalid deployment plan

**Common YAML errors**

* Incorrect indentation
* Missing required fields
* Invalid contract paths

Validate and regenerate as needed:

```bash
clarinet deployments check
clarinet deployments generate --testnet
ls contracts/
```


# FAQ

Common questions and solutions for Clarinet development.

This page addresses common issues encountered when building with Clarinet, based on community feedback and support interactions.

<details>

<summary><strong>How do I test with sBTC tokens in my development environment?</strong></summary>

To test with sBTC tokens, add the mainnet sBTC contract as a requirement and mint tokens using the deployer address.

* Add sBTC as a requirement:\
  `clarinet requirements add SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token`
* Mint sBTC in your tests\
  // The sBTC multisig address that can mint\
  `const sbtcDeployer = "SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4";`\
  // Mint sBTC to your test wallet\
  `const mintTx = simnet.callPublicFn( "SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token", "mint", [Cl.uint(1000000), Cl.principal(wallet1)], sbtcDeployer);`\
  \
  This approach lets you work with sBTC in unit tests without complex Bitcoin transaction simulation.

</details>

<details>

<summary><strong>Why am I getting an error when using mainnet addresses during mainnet simulation?</strong></summary>

When you run mainnet execution simulation, the target contract may expect mainnet addresses instead of the default testnet wallets. As of Clarinet v3.4.0, you can enable mainnet wallets in simnet with `use_mainnet_wallets = true`:

```toml
[repl.remote_data]
enabled = true
initial_height = 522000
use_mainnet_wallets = true
```

If you prefer to manage addresses manually, skip `simnet.getAccounts()` and use the specific mainnet principals you need:

```ts
// Instead of using simnet.getAccounts()
const mainnetAddress = "SP3R4F6C1J3JQWWCVZ3S7FRRYPMYG6ZW6RZK31FXY";

// Mint STX to any mainnet address
simnet.mintSTX(mainnetAddress, 1000000n);

// Call functions with a mainnet address
const result = simnet.callReadOnlyFn(
  "SP3R4F6C1J3JQWWCVZ3S7FRRYPMYG6ZW6RZK31FXY.pyth-storage-v3",
  "get-price",
  [priceFeed],
  mainnetAddress
);
```

The simnet accepts any valid Stacks address when mainnet simulation is enabled.

</details>

<details>

<summary><strong>How do I migrate from expectSTXTransferEvent to the new SDK?</strong></summary>

Clarinet v2 relies on standard Vitest matchers instead of the legacy event helpers.

Old approach (Clarinet v1):

```ts
block.receipts[0].events.expectSTXTransferEvent(
  amount,
  sender,
  recipient
);
```

New approach (Clarinet v2):

```ts
// Check for an exact event match
expect(events).toContainEqual({
  event: "stx_transfer_event",
  data: {
    amount: "1000000",
    memo: "",
    recipient: "ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM",
    sender: "ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5",
  },
});

// Or assert specific properties only
expect(events).toContainEqual({
  event: "stx_transfer_event",
  data: expect.objectContaining({
    sender: address1,
    recipient: contractAddress,
  }),
});
```

For Clarity value assertions, use the built-in matchers:

```ts
expect(result).toBeOk(Cl.bool(true));
expect(result).toBeErr(Cl.uint(500));
```

</details>

<details>

<summary><strong>Why am I getting "bip39 error" when generating deployment plans?</strong></summary>

Starting with Clarinet 2.15.0, deployment configurations require 24-word mnemonics. Twelve-word mnemonics are no longer supported.

Update your configuration with a full 24-word phrase:

```toml
[accounts.deployer]

# Use a 24-word mnemonic
mnemonic = "twice kind fence tip hidden tilt action fragile skin nothing glory cousin green tomorrow spring wrist shed math olympic multiply hip blue scout claw"
```

Generate a new 24-word mnemonic using a BIP39 generator if needed. The longer phrase improves security for production deployments.

</details>

<details>

<summary><strong>Can I test Bitcoin transaction verification in Clarinet?</strong></summary>

Testing contracts that use `clarity-bitcoin-lib` for Bitcoin transaction verification has limitations in simnet and devnet environments.

Current limitations:

* No real Bitcoin blocks or transactions in simnet
* Mock blocks do not contain verifiable Bitcoin transactions
* `get-burn-block-info?` returns mock data unsuitable for verification

Workarounds:

* Test Bitcoin verification logic on mainnet or with mainnet execution simulation
* Write unit tests that mock expected behavior instead of full verification
* Consider separating Bitcoin verification logic so it can be tested independently

The Clarinet team continues to investigate better support for Bitcoin-focused testing.

</details>

<details>

<summary><strong>Why does my devnet freeze at the epoch 3.0 transition?</strong></summary>

The epoch 3.0 transition in devnet can be unstable, with success rates between 50–80% depending on your setup.

Temporary workarounds:

* Restart devnet if it freezes around blocks 139–140
* Try Clarinet 2.14.0, which some users report as more stable
* Watch for the upcoming feature to start devnet directly in epoch 3.0

You can also monitor the transition manually:

```
# Watch for the transition around these blocks
Block 139: Epoch 2.5
Block 140: Should transition to 3.0
```

The Clarinet team is working on improving epoch transition stability and plans to allow starting devnet in epoch 3.0.

</details>


# Integrations

Explore powerful external tools and resources you can integrate into your Clarity smart contract workflow with Clarinet to level up your development experience.

<table data-view="cards"><thead><tr><th></th><th data-hidden data-card-target data-type="content-ref"></th></tr></thead><tbody><tr><td><h4>Clarity VSC Extension</h4></td><td><a href="integrations/clarity-vscode-extension">clarity-vscode-extension</a></td></tr><tr><td><h4>Chainhooks</h4></td><td><a href="integrations/chainhook">chainhook</a></td></tr><tr><td><h4>Stacks.js</h4></td><td><a href="integrations/stacks.js">stacks.js</a></td></tr><tr><td><h4>sBTC</h4></td><td><a href="integrations/sbtc">sbtc</a></td></tr></tbody></table>


# Clarity VSCode Extension

{% hint style="info" %}
The [VSCode extension](https://marketplace.visualstudio.com/items?itemName=StacksLabs.clarity-stacks) for Clarity is now published under the Stacks Labs organization.
{% endhint %}

## Features

### Smart auto-completion

The extension provides intelligent code completion that understands Clarity's context. When you start typing any Clarity function, you get instant suggestions with documentation:

```clarity
;; Type "stx-tr" and get:
(stx-transfer? amount sender recipient)
;;             ^      ^      ^
;;             Placeholders for easy navigation
```

Use `Tab` to jump between placeholders and `Escape` to exit placeholder mode.

### Documentation on hover

Access comprehensive documentation without leaving your editor. Hover over any Clarity function or keyword to see:

```clarity
;; Hover over 'map-set' to see:
;; - Function signature
;; - Parameter descriptions
;; - Return type
;; - Usage examples
(map-set my-map {key: "value"} "data")
```

### Go-to definition

Navigate your codebase efficiently with jump-to-definition features:

* `F12` or `Ctrl+Click` - Go to definition
* `Alt+F12` - Peek definition without leaving current file
* Works across contract files and contract calls

### Real-time error checking

The extension validates your code continuously, providing immediate feedback:

* **Red squiggles** - Syntax errors, unknown keywords
* **Yellow squiggles** - Warnings for potentially unsafe code
* **Error list** - All issues in the Problems panel (`Ctrl+Shift+M`)

Common errors caught include undefined variables, type mismatches, missing trait implementations, and invalid function signatures.

### Local contract resolution

Auto-completion works across your entire project. Reference functions from other contracts in your workspace:

```clarity
;; Auto-complete local contract calls
(contract-call? .my-token transfer amount sender recipient)
;;               ^
;;               Suggests contracts in your project
```

### Trait support

When implementing traits (like SIP-009 NFTs or SIP-010 tokens), the extension verifies:

* All required functions are implemented
* Function signatures match trait definitions
* Return types are correct

```clarity
;; Extension warns if missing required trait functions
(impl-trait .sip-010-trait.sip-010-trait)

;; ⚠️ Warning: Missing required function 'get-balance'
```

### Visual debugging

{% stepper %}
{% step %}
**Set breakpoints**

Set breakpoints by clicking line numbers in the editor.
{% endstep %}

{% step %}
**Start debugging**

Press `F5` or use Run → Start Debugging to begin a debugging session.
{% endstep %}

{% step %}
**Step through code**

Step through code line-by-line to follow execution.
{% endstep %}

{% step %}
**Inspect state**

Inspect variables and stack state while paused at breakpoints.
{% endstep %}
{% endstepper %}

{% hint style="warning" %}
Visual debugging requires VS Code Desktop and Clarinet installed locally.
{% endhint %}

## Comparison table

| Feature               | Basic Editor    | VS Code Extension       |
| --------------------- | --------------- | ----------------------- |
| Syntax highlighting   | Limited         | Full Clarity support    |
| Auto-completion       | None            | Context-aware with docs |
| Error checking        | On deploy only  | Real-time validation    |
| Documentation         | External lookup | Inline hover docs       |
| Debugging             | Console only    | Visual debugger         |
| Cross-file navigation | Manual          | Jump to definition      |

***

### Additional Resources

* \[[zed.dev](https://zed.dev/extensions?query=clarity)] Zed extension for Clarity


# Chainhook Integration

Learn how to register Chainhooks on Clarinet devnet so you can monitor smart contract events during local development.

## What you'll learn

* Create Chainhook predicate files for event monitoring
* Register Chainhooks with Clarinet devnet
* Monitor contract calls and blockchain events
* Set up webhooks for real-time notifications

{% hint style="info" %}
Prerequisites

* Clarinet `2.1.0` or later (`clarinet --version`)
* Node.js `16` or later (`node --version`)
  {% endhint %}

## Quickstart

{% stepper %}
{% step %}
**Create your Chainhook predicates**

Create predicate files in a `chainhooks/` directory alongside your contracts:

* contracts/
  * counter.clar
* chainhooks/
  * increment.json
  * decrement.json
* tests/
  * counter.test.ts
* Clarinet.toml

Example predicate for monitoring increment events:

{% code title="chainhooks/increment.json" %}

```json
{
  "chain": "stacks",
  "uuid": "increment-hook",
  "name": "Increment Counter Hook",
  "version": 1,
  "networks": {
    "devnet": {
      "if_this": {
        "scope": "contract_call",
        "contract_identifier": "ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.counter",
        "method": "increment"
      },
      "then_that": {
        "http_post": {
          "url": "http://localhost:3000/api/increment",
          "authorization_header": "Bearer my-secret"
        }
      }
    }
  }
}
```

{% endcode %}
{% endstep %}

{% step %}
**Start devnet with Chainhooks**

From your project root, start devnet. Clarinet registers every predicate automatically:

{% code title="Start devnet" %}

```bash
clarinet devnet start
```

{% endcode %}

Check the logs for a confirmation message such as:

{% code title="Clarinet log" %}

```
INFO Feb  5 15:20:07.233382 2 chainhooks registered
```

{% endcode %}
{% endstep %}

{% step %}
**Monitor Chainhook activity**

Trigger contract actions and watch for Chainhook alerts:

{% code title="Clarinet log" %}

```
INFO Feb  5 15:21:07.233382 1 hooks triggered
```

{% endcode %}

Verify the payload based on your `then_that` configuration:

* `http_post` – confirm your endpoint received the POST request
* `file_append` – ensure the file was created or updated
  {% endstep %}
  {% endstepper %}

## Common patterns

### Contract deployment hook

Monitor when specific contracts are deployed:

{% code title="chainhooks/deploy.json" %}

```json
{
  "chain": "stacks",
  "uuid": "deploy-hook",
  "name": "Contract Deploy Monitor",
  "version": 1,
  "networks": {
    "devnet": {
      "if_this": {
        "scope": "contract_deployment",
        "deployer": "ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM"
      },
      "then_that": {
        "file_append": {
          "path": "./deployments.log"
        }
      }
    }
  }
}
```

{% endcode %}

### STX transfer monitoring

Track STX transfers above a certain threshold:

{% code title="chainhooks/stx-transfer.json" %}

```json
{
  "chain": "stacks",
  "uuid": "stx-transfer-hook",
  "name": "Large STX Transfer Monitor",
  "version": 1,
  "networks": {
    "devnet": {
      "if_this": {
        "scope": "stx_event",
        "actions": ["transfer"],
        "amount_upper_bound": "1000000000000"
      },
      "then_that": {
        "http_post": {
          "url": "http://localhost:3000/api/large-transfer"
        }
      }
    }
  }
}
```

{% endcode %}


# Stacks.js Integration

Use Stacks.js to interact with your Clarinet devnet from JavaScript applications.

## What you'll learn

* Configure Stacks.js for a local devnet connection
* Make STX transfers between devnet accounts
* Call smart contract functions from JavaScript
* Deploy contracts programmatically

## Quickstart

{% stepper %}
{% step %}
**Install Stacks.js packages**

Add the required libraries to your frontend project:

```bash
npm install @stacks/transactions @stacks/network
```

{% endstep %}

{% step %}
**Configure for devnet**

Create a network helper:

```ts
import { StacksDevnet } from '@stacks/network';

export const devnet = new StacksDevnet({
  url: 'http://localhost:3999'
});

export const accounts = {
  deployer: {
    address: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',
    key: 'cb3df38053d132895220b9ce471f6b676db5b9bf0b4adefb55f2118ece2478df01'
  },
  wallet1: {
    address: 'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5',
    key: '7287ba251d44a4d3fd9276c88ce34c5c52a038955511cccaf77e61068649c17801'
  }
};
```

{% endstep %}

{% step %}
**Test STX transfers**

Send a transfer between devnet accounts:

```ts
import { makeSTXTokenTransfer, broadcastTransaction, AnchorMode } from '@stacks/transactions';
import { devnet, accounts } from './devnet-config';

async function transferSTX() {
  const tx = await makeSTXTokenTransfer({
    amount: 1_000_000n,
    recipient: accounts.wallet1.address,
    senderKey: accounts.deployer.key,
    network: devnet,
    anchorMode: AnchorMode.Any,
  });

  const result = await broadcastTransaction(tx, devnet);
  console.log('Transaction ID:', result.txid);
}

transferSTX().catch(console.error);
```

Run the transfer with `ts-node stx-transfer.ts`.
{% endstep %}

{% step %}
**Call smart contracts**

Interact with contracts deployed on devnet:

```ts
import { makeContractCall, broadcastTransaction, AnchorMode } from '@stacks/transactions';
import { devnet, accounts } from './devnet-config';

async function callContract() {
  const tx = await makeContractCall({
    contractAddress: accounts.deployer.address,
    contractName: 'counter',
    functionName: 'increment',
    functionArgs: [],
    senderKey: accounts.wallet1.key,
    network: devnet,
    anchorMode: AnchorMode.Any,
  });

  await broadcastTransaction(tx, devnet);
}

async function readCount() {
  const response = await fetch(
    `${devnet.coreApiUrl}/v2/contracts/call-read/${accounts.deployer.address}/counter/get-count`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        sender: accounts.wallet1.address,
        arguments: []
      })
    }
  );
  const data = await response.json();
  console.log(data);
}

callContract().catch(console.error);
readCount().catch(console.error);
```

{% endstep %}

{% step %}
**Deploy contracts programmatically**

Deploy a contract from your application code:

```ts
import { makeContractDeploy, broadcastTransaction, AnchorMode } from '@stacks/transactions';
import { devnet, accounts } from './devnet-config';
import counterContract from './contracts/counter.clar?raw';

async function deployCounter() {
  const tx = await makeContractDeploy({
    contractName: 'counter',
    codeBody: counterContract,
    senderKey: accounts.deployer.key,
    network: devnet,
    anchorMode: AnchorMode.Any,
  });

  return broadcastTransaction(tx, devnet);
}

deployCounter().catch(console.error);
```

{% endstep %}
{% endstepper %}

## Common patterns

### Watching for transaction confirmation

Monitor when transactions are confirmed on devnet:

```ts
async function waitForTransaction(txid: string) {
  let attempts = 0;
  const maxAttempts = 10;

  while (attempts < maxAttempts) {
    const response = await fetch(
      `${devnet.coreApiUrl}/extended/v1/tx/${txid}`
    );

    const tx = await response.json();

    if (tx.tx_status === 'success') {
      console.log('Transaction confirmed!');
      return tx;
    }

    if (tx.tx_status === 'abort_by_response') {
      throw new Error(`Transaction failed: ${tx.tx_result.repr}`);
    }

    // Wait for next block
    await new Promise(resolve => setTimeout(resolve, 5000));
    attempts++;
  }

  throw new Error('Transaction timeout');
}
```

### Post conditions for safety

Add post conditions to ensure contract calls behave as expected:

```ts
import { Pc } from '@stacks/transactions';

const postConditions = [
  // Ensure sender's balance decreases by exactly the amount
  Pc.principal(accounts.wallet1.address)
    .willSendEq(1000000n)
    .ustx(),

  // Ensure recipient receives the amount
  Pc.principal(accounts.deployer.address)
    .willReceiveEq(1000000n)
    .ustx()
];

const tx = await makeSTXTokenTransfer({
  amount: 1000000n,
  recipient: accounts.deployer.address,
  senderKey: accounts.wallet1.key,
  network: devnet,
  postConditions,
  anchorMode: AnchorMode.Any,
});
```


# sBTC Integration

<figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2Fgit-blob-02201cb8efabaf4d44886bc37cd308fd65241d12%2Fsbtc-clarinet-testing.jpg?alt=media" alt=""><figcaption><p>source: <a href="https://www.hiro.so/blog/expanded-sbtc-testing-support-is-live-in-clarinet-and-the-hiro-platform">Hiro blog</a></p></figcaption></figure>

Clarinet can automatically wire up the official sBTC contracts so you can build and test SIP-010 flows locally.

## What you'll learn

* Add sBTC smart contracts to your Clarinet project
* Test contracts with automatic sBTC funding in devnet
* Work with sBTC as a SIP-010 fungible token
* Deploy sBTC contracts to testnet and mainnet

## Prerequisites

* Clarinet 2.15.0 or later required for automatic sBTC integration.

## Quickstart

{% stepper %}
{% step %}
**Add sBTC to your project**

Add the sBTC contracts to your project requirements:

```bash
clarinet requirements add SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-deposit
```

This pulls in:

* `sbtc-token` – SIP-010 fungible token contract
* `sbtc-registry` – configuration registry
* `sbtc-deposit` – deposit and withdrawal logic

Clarinet auto-funds devnet wallets with sBTC when these are present.
{% endstep %}

{% step %}
**Create an sBTC-enabled contract**

Example NFT marketplace that accepts sBTC payments:

```clarity
(define-non-fungible-token marketplace-nft uint)
(define-data-var mint-price uint u100)
(define-data-var next-id uint u0)

(define-public (mint-with-sbtc)
  (begin
    (try! (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token transfer
      (var-get mint-price)
      tx-sender
      (as-contract tx-sender)
      none))
    (try! (nft-mint? marketplace-nft (var-get next-id) tx-sender))
    (ok (var-set next-id (+ (var-get next-id) u1)))
  )
)

(define-read-only (get-sbtc-balance (owner principal))
  (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token get-balance owner)
)
```

{% endstep %}

{% step %}
**Test in the Clarinet console**

Launch the console and try the contract using auto-funded wallets:

```bash
clarinet console
```

```clarity
(contract-call? .nft-marketplace get-sbtc-balance tx-sender)
(contract-call? .nft-marketplace mint-with-sbtc)
(nft-get-owner? .nft-marketplace marketplace-nft u0)
```

{% endstep %}

{% step %}
**Write unit tests**

Sample Vitest test for sBTC payments:

```ts
import { describe, expect, it } from 'vitest';
import { Cl } from '@stacks/transactions';

describe('NFT Marketplace', () => {
  it('mints NFT with sBTC payment', () => {
    const accounts = simnet.getAccounts();
    const wallet1 = accounts.get('wallet_1')!;

    const initial = simnet.callReadOnlyFn(
      'nft-marketplace',
      'get-sbtc-balance',
      [Cl.standardPrincipal(wallet1.address)],
      wallet1.address
    );

    const mint = simnet.callPublicFn(
      'nft-marketplace',
      'mint-with-sbtc',
      [],
      wallet1
    );

    expect(mint.result).toBeOk();

    const final = simnet.callReadOnlyFn(
      'nft-marketplace',
      'get-sbtc-balance',
      [Cl.standardPrincipal(wallet1.address)],
      wallet1.address
    );

    expect(Number(Cl.parse(final.result))).toBeLessThan(
      Number(Cl.parse(initial.result))
    );
  });
});
```

{% endstep %}

{% step %}
**Deploy to testnet**

Generate a plan to confirm remapped addresses for official sBTC contracts:

```bash
clarinet deployments generate --testnet
```

Deploy when ready:

```bash
clarinet deployments apply --testnet
```

{% endstep %}
{% endstepper %}

## Common patterns

### Working with sBTC addresses

Clarinet handles sBTC contract address mapping across networks:

| Network       | sBTC Contract Address                                  |
| ------------- | ------------------------------------------------------ |
| Simnet/Devnet | `SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token` |
| Testnet       | `ST1F7QA2MDF17S807EPA36TSS8AMEFY4KA9TVGWXT.sbtc-token` |
| Mainnet       | Contract address remains unchanged                     |

Your contract code always references the simnet address. Clarinet automatically remaps during deployment.

## Manual sBTC minting in unit tests

While Clarinet 2.15.0+ automatically funds wallets with sBTC in devnet, you may need to manually mint sBTC in unit tests for specific scenarios.

### Minting sBTC using the deployer address

The sBTC token contract allows the deployer (multisig) address to mint tokens. Use this approach in your tests:

```ts
import { describe, expect, it } from "vitest";
import { Cl } from "@stacks/transactions";

describe("Manual sBTC minting", () => {
  it("mints sBTC to custom addresses", () => {
    // The sBTC multisig address that can mint
    const sbtcDeployer = "SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4";
    const customWallet = "ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM";

    // Mint 1000 sats to custom wallet
    const mintResult = simnet.callPublicFn(
      "SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token",
      "mint",
      [
        Cl.uint(1000),              // amount in sats
        Cl.principal(customWallet)   // recipient
      ],
      sbtcDeployer                   // sender must be deployer
    );

    expect(mintResult.result).toBeOk(Cl.bool(true));

    // Verify balance
    const balance = simnet.callReadOnlyFn(
      "SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token",
      "get-balance",
      [Cl.principal(customWallet)],
      customWallet
    );

    expect(balance.result).toBeOk(Cl.uint(1000));
  });
});
```

### Testing with mainnet execution simulation

When using mainnet execution simulation, you can mint sBTC using the actual mainnet multisig:

```ts
const mainnetMultisig = "SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4";
const mainnetWallet = "SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR";

// Mint sBTC to any mainnet address
simnet.callPublicFn(
  "SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token",
  "mint",
  [Cl.uint(100000), Cl.principal(mainnetWallet)],
  mainnetMultisig
);
```

This approach is useful for:

* Testing specific sBTC amounts
* Simulating different wallet balances
* Testing edge cases with precise token amounts
* Integration testing with mainnet contracts


# Overview

Practical guide to testing smart contracts with the Clarinet JS SDK.

<figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2Fgit-blob-cbae820d7a026aefc4fc12d70d9dc1426dc943ba%2Fclarinet-sdk.png?alt=media" alt=""><figcaption><p>source: <a href="https://www.hiro.so/blog/announcing-the-clarinet-sdk-a-javascript-programming-model-for-easy-smart-contract-testing">Hiro blog</a></p></figcaption></figure>

The Clarinet JS SDK provides a powerful testing framework for Clarity smart contracts. It integrates with Vitest to let you run comprehensive tests against a simulated blockchain environment.

{% hint style="success" %}
For the latest releases and versions of `@stacks/clarinet-sdk`, check out its npm page [here](https://www.npmjs.com/package/@stacks/clarinet-sdk).
{% endhint %}

## Initial setup

Create a new Node.js project (or reuse an existing one):

```bash
npm init -y
```

Install the Clarinet JS SDK and its dependencies:

```bash
npm install @stacks/clarinet-sdk vitest @stacks/transactions
```

## Project structure

Organize your project so contracts and tests live together:

```
- my-project/
  - contracts/
    - counter.clar
  - tests/
    - counter.test.ts
  - Clarinet.toml
  - package.json
  - tsconfig.json
  - vitest.config.js
```

## Simple test

Create `tests/counter.test.ts` to verify the contract:

{% code title="tests/counter.test.ts" %}

```ts
import { describe, expect, it } from "vitest";
import { Cl } from "@stacks/transactions";

const accounts = simnet.getAccounts();
const wallet = accounts.get("wallet_1")!;

describe("counter contract", () => {
  it("increments the count", () => {
    const countUpCall = simnet.callPublicFn("counter", "count-up", [], wallet);
    expect(countUpCall.result).toBeOk(Cl.bool(true));
  });
});
```

{% endcode %}

The `simnet` object is automatically available and exposes a simulated Stacks blockchain.

## Configuration options

### Clarinet configuration

Define your contracts in `Clarinet.toml`:

```toml
[project]
name = "my-project"

[contracts.counter]
path = "contracts/counter.clar"
```

### TypeScript setup

Configure TypeScript for the SDK:

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "node",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "types": ["vitest/globals"]
  },
  "include": ["tests/**/*.ts"],
  "exclude": ["node_modules"]
}
```

### Vitest configuration

Set up Vitest so the SDK can bootstrap the testing environment:

```js
import { defineConfig } from "vitest/config";
import { vitestSetupFilePath } from "@stacks/clarinet-sdk/vitest";

export default defineConfig({
  test: {
    environment: "node",
    globals: true,
    setupFiles: [vitestSetupFilePath],
  },
});
```

{% hint style="info" %}
Include `vitestSetupFilePath` in `setupFiles` so the SDK can prepare the `simnet` instance before tests run.
{% endhint %}

### Package scripts

Add convenient test scripts to `package.json`:

```json
"scripts": {
  "test": "vitest run",
  "test:watch": "vitest",
  "test:coverage": "vitest run --coverage"
}
```

## Common patterns

### Testing read-only functions

Use `callReadOnlyFn` for functions that do not modify state:

```ts
const getCountCall = simnet.callReadOnlyFn(
  "counter",
  "get-count",
  [Cl.principal(wallet)],
  wallet
);
expect(getCountCall.result).toBeUint(1);
```

### Testing public functions with parameters

Pass parameters with the appropriate Clarity helpers:

```ts
const depositCall = simnet.callPublicFn(
  "defi",
  "deposit",
  [Cl.uint(1000)],
  wallet
);
expect(depositCall.result).toBeOk(Cl.bool(true));
```

### Accessing contract state

Inspect data variables and maps directly:

```ts
const totalDeposits = simnet.getDataVar("defi", "total-deposits");
expect(totalDeposits).toBeUint(1000);

const balance = simnet.getMapEntry("defi", "balances", Cl.principal(wallet));
expect(balance).toBeUint(1000);
```

## Examples

### Testing contract deployment

Ensure the contract was deployed:

```ts
it("ensures the contract is deployed", () => {
  const contractSource = simnet.getContractSource("counter");
  expect(contractSource).toBeDefined();
});
```

### Testing error conditions

Verify error handling logic:

```ts
it("fails when borrowing too much", () => {
  const borrowCall = simnet.callPublicFn(
    "defi",
    "borrow",
    [Cl.uint(10000)], // Amount exceeds allowed
    wallet
  );
  expect(borrowCall.result).toBeErr(Cl.uint(300)); // err-overborrow
});
```

### Testing with multiple accounts

Simulate cross-account interactions:

```ts
const wallet1 = accounts.get("wallet_1")!;
const wallet2 = accounts.get("wallet_2")!;

// Wallet 1 deposits
simnet.callPublicFn("defi", "deposit", [Cl.uint(1000)], wallet1);

// Wallet 2 tries to withdraw wallet 1's funds (should fail)
const withdrawCall = simnet.callPublicFn(
  "defi",
  "withdraw",
  [Cl.uint(1000)],
  wallet2
);
expect(withdrawCall.result).toBeErr(Cl.uint(401)); // err-unauthorized
```

## Running tests

Execute the full suite:

```bash
npm run test
```

Generate coverage reports:

```bash
npm run test:report
```

This command produces:

* `lcov.info` – code coverage data
* `costs-reports.json` – gas cost analysis

View the HTML report (macOS example):

```bash
brew install lcov
genhtml lcov.info --branch-coverage -o coverage
open coverage/index.html
```

## Advanced usage

### Using the SDK in existing projects

If your project has a custom structure, keep contracts and tests together and point the SDK to the manifest:

```
- my-app/
  - blockchain/
    - contracts/
      - token.clar
    - tests/
      - token.test.ts
    - Clarinet.toml
  - frontend/
    - App.tsx
  - package.json
  - vitest.config.js
```

Update `vitest.config.js` to reference the correct manifest path:

```js
export default defineConfig({
  test: {
    environment: "node",
    globals: true,
    setupFiles: [vitestSetupFilePath],
    env: {
      CLARINET_MANIFEST_PATH: "./blockchain/Clarinet.toml"
    }
  },
});
```

##


# Unit Testing

Unit testing verifies that individual contract functions behave as expected. The Clarinet JS SDK pairs with Vitest to help you catch bugs early in development.

## What you'll learn

* Set up a Clarinet project for unit testing
* Write tests for public and read-only functions
* Handle error conditions and edge cases
* Run tests and generate coverage reports

{% stepper %}
{% step %}
**Set up your project**

Create a new Clarinet project and install dependencies:

```bash
clarinet new stx-defi
cd stx-defi
npm install
```

{% endstep %}

{% step %}
**Create the contract**

Generate a contract stub:

```bash
clarinet contract new defi
```

Replace `contracts/defi.clar` with the following implementation:

```clarity
;; Holds the total amount of deposits in the contract
(define-data-var total-deposits uint u0)

;; Maps a user's principal address to their deposited amount
(define-map deposits { owner: principal } { amount: uint })

;; Public function for users to deposit STX into the contract
(define-public (deposit (amount uint))
  (let
    (
      ;; Fetch the current balance or default to 0 if none exists
      (current-balance (default-to u0 (get amount (map-get? deposits { owner: tx-sender }))))
    )
    ;; Transfer the STX from sender to contract
    (try! (stx-transfer? amount tx-sender (as-contract tx-sender)))
    ;; Update the user's deposit amount in the map
    (map-set deposits { owner: tx-sender } { amount: (+ current-balance amount) })
    ;; Update the total deposits variable
    (var-set total-deposits (+ (var-get total-deposits) amount))
    ;; Return success
    (ok true)
  )
)

;; Read-only function to get the balance by tx-sender
(define-read-only (get-balance-by-sender)
  (ok (map-get? deposits { owner: tx-sender }))
)
```

Validate the contract:

```bash
clarinet check
```

{% endstep %}

{% step %}
**Write your unit test**

Create `tests/defi.test.ts` with a basic happy-path test:

```ts
import { describe, it, expect } from 'vitest';
import { Cl } from '@stacks/transactions';

const accounts = simnet.getAccounts();
const wallet1 = accounts.get('wallet_1')!;

describe('stx-defi', () => {
  it('allows users to deposit STX', () => {
    // Define the amount to deposit
    const amount = 1000;

    // Call the deposit function
    const deposit = simnet.callPublicFn('defi', 'deposit', [Cl.uint(amount)], wallet1);

    // Assert the deposit was successful
    expect(deposit.result).toBeOk(Cl.bool(true));

    // Verify the contract's total deposits
    const totalDeposits = simnet.getDataVar('defi', 'total-deposits');
    expect(totalDeposits).toBeUint(amount);

    // Check the user's balance
    const balance = simnet.callReadOnlyFn('defi', 'get-balance-by-sender', [], wallet1);
    expect(balance.result).toBeOk(
      Cl.some(
        Cl.tuple({
          amount: Cl.uint(amount),
        })
      )
    );
  });
});
```

{% hint style="info" %}
Key calls:

* `simnet.callPublicFn` – executes public functions
* `expect(...).toBeOk()` – asserts a Clarity `ok` response
* `simnet.getDataVar` – reads a contract data variable
* `Cl.*` helpers – build Clarity values in JavaScript
  {% endhint %}
  {% endstep %}

{% step %}
**Try it out**

Run the tests:

```bash
$ npm run test
 PASS  tests/defi.test.ts
  stx-defi
    allows users to deposit STX (5 ms)

Test Files  1 passed (1)
     Tests  1 passed (1)
```

{% endstep %}

{% step %}
**Generate coverage reports**

```bash
npm run test:report
```

This command produces:

* `lcov.info` – code coverage data
* `costs-reports.json` – gas cost analysis

View the HTML report (macOS example):

```bash
$ brew install lcov
$ genhtml lcov.info --branch-coverage -o coverage
$ open coverage/index.html
```

{% endstep %}
{% endstepper %}

## Common issues

| Issue                      | Solution                                                              |
| -------------------------- | --------------------------------------------------------------------- |
| `toBeOk is not a function` | Ensure the Clarinet SDK matchers are loaded via `vitestSetupFilePath` |
| `Contract not found`       | Re-run `clarinet check` to compile and register contracts             |
| Type errors                | Use the `Cl` helpers to construct Clarity values                      |

## Advanced testing patterns

Test error conditions:

```ts
it('fails when depositing zero', () => {
  const deposit = simnet.callPublicFn('defi', 'deposit', [Cl.uint(0)], wallet1);
  expect(deposit.result).toBeErr(Cl.uint(100)); // err-invalid-amount
});
```

Test with multiple accounts:

```ts
const wallet2 = accounts.get('wallet_2')!;

it('tracks deposits from multiple users', () => {
  simnet.callPublicFn('defi', 'deposit', [Cl.uint(1000)], wallet1);
  simnet.callPublicFn('defi', 'deposit', [Cl.uint(2000)], wallet2);

  const total = simnet.getDataVar('defi', 'total-deposits');
  expect(total).toBeUint(3000);
});
```

##


# Integration Testing

Integration testing connects multiple contracts and workflows to ensure the entire system behaves correctly. The Clarinet JS SDK lets you simulate complex scenarios and interactions across contracts.

## What you'll learn

* Set up integration tests for multi-step workflows
* Test contract interactions and dependencies
* Simulate real-world scenarios
* Verify system-wide state changes

## Set up your project

Create a new Clarinet project and install dependencies:

```bash
clarinet new stx-defi
cd stx-defi
npm install
```

## Create the enhanced contract

We'll use an enhanced DeFi contract that supports both deposits and borrowing. Create the contract:

```bash
clarinet contract new defi
```

Replace `contracts/defi.clar` with this enhanced version:

```clarity
;; Error constants
(define-constant err-overborrow (err u300))

;; Interest rate (10%)
(define-data-var loan-interest-rate uint u10)

;; Total deposits in the contract
(define-data-var total-deposits uint u0)

;; User deposits
(define-map deposits { owner: principal } { amount: uint })

;; User loans
(define-map loans principal { amount: uint, last-interaction-block: uint })

;; Deposit STX into the contract
(define-public (deposit (amount uint))
  (let
    (
      (current-balance (default-to u0 (get amount (map-get? deposits { owner: tx-sender }))))
    )
    (try! (stx-transfer? amount tx-sender (as-contract tx-sender)))
    (map-set deposits { owner: tx-sender } { amount: (+ current-balance amount) })
    (var-set total-deposits (+ (var-get total-deposits) amount))
    (ok true)
  )
)

;; Borrow STX based on deposits (up to 50% of deposit)
(define-public (borrow (amount uint))
  (let
    (
      (user-deposit (default-to u0 (get amount (map-get? deposits { owner: tx-sender }))))
      (allowed-borrow (/ user-deposit u2))
      (current-loan-details (default-to { amount: u0, last-interaction-block: u0 }
                            (map-get? loans tx-sender)))
      (accrued-interest (calculate-accrued-interest
                         (get amount current-loan-details)
                         (get last-interaction-block current-loan-details)))
      (total-due (+ (get amount current-loan-details) (unwrap-panic accrued-interest)))
      (new-loan (+ amount))
    )
    (asserts! (<= new-loan allowed-borrow) err-overborrow)
    (try! (as-contract (stx-transfer? amount tx-sender tx-sender)))
    (map-set loans tx-sender { amount: new-loan, last-interaction-block: block-height })
    (ok true)
  )
)

;; Get user's balance
(define-read-only (get-balance-by-sender)
  (ok (map-get? deposits { owner: tx-sender }))
)

;; Get amount owed including interest
(define-read-only (get-amount-owed)
  (let
    (
      (current-loan-details (default-to { amount: u0, last-interaction-block: u0 }
                            (map-get? loans tx-sender)))
      (accrued-interest (calculate-accrued-interest
                         (get amount current-loan-details)
                         (get last-interaction-block current-loan-details)))
      (total-due (+ (get amount current-loan-details) (unwrap-panic accrued-interest)))
    )
    (ok total-due)
  )
)

;; Calculate interest
(define-private (calculate-accrued-interest (principal uint) (start-block uint))
  (let
    (
      (elapsed-blocks (- block-height start-block))
      (interest (/ (* principal (var-get loan-interest-rate) elapsed-blocks) u10000))
    )
    (asserts! (not (is-eq start-block u0)) (ok u0))
    (ok interest)
  )
)
```

Run `clarinet check` to ensure your contract is valid:

```bash
clarinet check
```

## Write integration tests

Create a test that simulates a complete user workflow - depositing and then borrowing:

```ts
import { describe, it, expect } from 'vitest';
import { Cl } from '@stacks/transactions';

const accounts = simnet.getAccounts();
const wallet1 = accounts.get('wallet_1')!;

describe('stx-defi integration', () => {
  it('allows deposit and borrow workflow', () => {
    // Step 1: User deposits STX
    const depositResult = simnet.callPublicFn(
      'defi',
      'deposit',
      [Cl.uint(1000)],
      wallet1
    );
    expect(depositResult.result).toBeOk(Cl.bool(true));

    // Verify deposit was recorded
    const totalDeposits = simnet.getDataVar('defi', 'total-deposits');
    expect(totalDeposits).toBeUint(1000);

    // Step 2: User borrows against deposit
    const borrowResult = simnet.callPublicFn(
      'defi',
      'borrow',
      [Cl.uint(400)], // Borrowing 40% of deposit
      wallet1
    );
    expect(borrowResult.result).toBeOk(Cl.bool(true));

    // Step 3: Check amount owed
    const { result } = simnet.callReadOnlyFn(
      'defi',
      'get-amount-owed',
      [],
      wallet1
    );
    expect(result).toBeOk(Cl.uint(400)); // No interest yet at same block
  });

  it('prevents over-borrowing', () => {
    // Setup: deposit first
    simnet.callPublicFn('defi', 'deposit', [Cl.uint(1000)], wallet1);

    // Attempt to borrow more than allowed (>50%)
    const borrowResult = simnet.callPublicFn(
      'defi',
      'borrow',
      [Cl.uint(600)],
      wallet1
    );

    // Should fail with err-overborrow
    expect(borrowResult.result).toBeErr(Cl.uint(300));
  });
});
```

Key aspects used in the test:

* callPublicFn - Simulates calling public functions just as on the actual blockchain
* getDataVar - Retrieves the value of contract data variables
* callReadOnlyFn - Calls read-only functions without modifying state
* Custom matchers - toBeOk() and toBeErr() validate Clarity response types

## Try it out

Run your integration tests:

```bash
npm run test
```

## Common issues

| Issue                         | Solution                                               |
| ----------------------------- | ------------------------------------------------------ |
| State pollution between tests | Each test runs in isolation - state doesn't carry over |
| Timing issues                 | Use `simnet.mineEmptyBlocks()` to advance block height |
| Complex assertions            | Break down into smaller, focused tests                 |

##


# Mainnet Execution Simulation

Mainnet execution simulation (MXS) lets you test your Clarity contracts against real mainnet data without deploying experimental code. You can reproduce historical state, validate complex integrations, and debug edge cases while keeping the speed of local development.

## What you'll learn

* Set up MXS in a Clarinet project
* Write tests that interact with mainnet contracts
* Simulate historical transactions
* Understand MXS limitations

## What is Mainnet execution simulation?

Testing smart contracts in realistic conditions is essential. Simnet offers an isolated environment but lacks the live Stacks mainnet's complexity and history.

MXS fills this gap by enabling unit tests with the Clarinet JS SDK and Vitest to simulate the Stacks mainnet state at a specific block height. This allows you to:

* **Validate contract logic with real data:** Directly test mainnet contracts or data within your tests.
* **(Re)simulate transactions:** Analyze mainnet transactions' results, execution, or costs without deploying or using actual STX.

## Enable MXS in your project

Add the following configuration to your `Clarinet.toml` file:

```toml
[repl.remote_data]

# Enable mainnet execution simulation
enabled = true

# Specify the Stacks block height to fork from
initial_height = 522000

# API URL (optional, defaults to https://api.hiro.so)
api_url = 'https://api.hiro.so'
```

{% hint style="info" %}
Pro tip

Set a specific `initial_height` to keep tests reproducible.
{% endhint %}

## Using mainnet addresses

When testing contracts that check or require mainnet addresses, set `use_mainnet_wallets = true`. This enables your simnet tests to use mainnet addresses (SP/SM) instead of testnet addresses (ST).

```toml
[repl.remote_data]
enabled = true
initial_height = 522000
use_mainnet_wallets = true  # !mark
```

This is particularly useful when:

* Testing against mainnet-only contracts like DEX protocols
* Your contract includes [`(is-standard standard-or-contract-principal)`](https://docs.stacks.co/build/clarinet-js-sdk/mainnet-execution-simulation) validation
* Simulating transactions that require mainnet address formats

## Configure API access

While MXS works without an API key, you may encounter rate limits. Set up an API key for reliable access:

```bash
export HIRO_API_KEY="<your-api-key>"
```

## Write tests with mainnet data

Once MXS is enabled, your tests automatically operate against the mainnet state snapshot. Here's an example testing against the mainnet `pox-4` contract:

```ts
import { describe, it, expect } from "vitest";
import { Cl } from "@stacks/transactions";

const accounts = simnet.getAccounts();
const deployer = accounts.get("deployer")!;

describe("pox-4 mainnet interaction", () => {
  it("reads current reward cycle from mainnet", () => {
    // Call the mainnet pox-4 contract
    const call = simnet.callReadOnlyFn(
      "SP000000000000000000002Q6VF78.pox-4", // Mainnet contract
      "current-pox-reward-cycle",
      [],
      deployer
    );

    // Assert the result (adjust based on your initial_height)
    expect(call.result).toBeUint(109);

    console.log("Current POX reward cycle:", Cl.prettyPrint(call.result));
  });
});
```

The test uses `simnet.callReadOnlyFn` just like in standard unit tests, but because MXS is enabled, it targets the actual `pox-4` contract state at the specified block height.

## Try it out

Run your test to see MXS in action:

```bash
npm run test
```

## Common issues

<details>

<summary>Rate limit errors</summary>

Solution: Set up the `HIRO_API_KEY` environment variable.

```bash
export HIRO_API_KEY="<your-api-key>"
```

</details>

<details>

<summary>Inconsistent results</summary>

Solution: Fix `initial_height` in configuration so tests are run against a reproducible block snapshot.

</details>

<details>

<summary>Function not found</summary>

Solution: Check the contract exists at your block height.

</details>

## Testing in the playground

{% stepper %}
{% step %}
**Visit the playground**

Go to: <https://play.hiro.so/?remote_data=true>
{% endstep %}

{% step %}
**Run a mainnet contract call**

Example Clarity call:

```clarity
> contract-call? 'SP000000000000000000002Q6VF78.pox-4 current-pox-reward-cycle
```

{% endstep %}
{% endstepper %}


# Overview

Rendezvous is a fuzzer for Clarity smart contracts that finds vulnerabilities through stateful, randomized testing, all in Clarity.

{% hint style="danger" %}
Smart contracts on Stacks are immutable. Bugs are forever. Test early. Test often. Fuzzing finds edge cases that unit tests often miss.
{% endhint %}

## What is Fuzz Testing?

Fuzzing hits your code with random inputs. It helps uncover unexpected behavior and subtle bugs. Unlike unit tests, it explores paths you didn't think of.

## What is Rendezvous?

Rendezvous (`rv`) is a Clarity fuzzer. It supports:

### Property-Based Testing

You extract properties about your smart contract using Clarity. Rendezvous checks them multiple times with random inputs, in a stateful manner (the smart contract's state is not refreshed during the run).

**What is a property?**

A property is a universal truth about your smart contract's state, functions, etc.

**How to extract a property?**

Say that your smart contract has a function that reverses a list of `uint`s. In this case, one property can be that "reversing a list twice returns the original list". The property will look like this:

```clarity
(define-public (test-reverse-list (seq (list 127 uint)))
  (begin
    (asserts!
      (is-eq seq
        (reverse-uint
          (reverse-uint seq)
        )
      )
      (err u999)
    )
    (ok true)
  )
)
```

**Making your property valid for Rendezvous**

> For a property to be cosidered valid by Rendezvous, it has to comply with the following rules:
>
> * Function name starts with `test-`
> * Function is declared as `public`
> * Test passes when it returns `(ok true)`
> * Test would be discarded if it returned `(ok false)`
> * Test fails if it returns an error or throws an exception

***

### Invariant Testing

You define read-only conditions in Clarity that must always hold true. Rendezvous attempts to create state transitions in your smart contract and continuously checks the conditions you defined to hold.

**What is an invariant?**

An invariant is a general truth regarding your smart contract's internal state. It will not be able to mutate the state, its role being solely to check the integrity of the state.

**How to extract an invariant?**

Say that you have a counter contract, having functions to `increment` and `decrement`. In this case, you could use the Rendezvous [`context`](https://stacks-network.github.io/rendezvous/chapter_6.html?#the-rendezvous-context) to extract an invariant regarding your smart contract's internal state:

```clarity
(define-read-only (invariant-counter-gt-zero)
  (let
    (
      (increment-num-calls
        (default-to u0 (get called (map-get? context "increment")))
      )
      (decrement-num-calls
        (default-to u0 (get called (map-get? context "decrement")))
      )
    )
    (if
      (<= increment-num-calls decrement-num-calls)
      true
      (> (var-get counter) u0)
    )
  )
)
```

**Making your invariant valid for Rendezvous**

> For an invariant to be cosidered valid by Rendezvous, it has to complain to the following ruleset:
>
> * Function name starts with invariant-
> * Function is declared as read-only (not public)
> * Function returns a boolean value (true if the invariant holds, false if violated)
> * The test can use the special context map to access execution history

## Why Test in Clarity?

{% stepper %}
{% step %}

#### Same constraints as production

Tests operate under the exact same constraints as production code.
{% endstep %}

{% step %}

#### Better understanding of Clarity

Writing tests in Clarity improves your familiarity with the language and its semantics.
{% endstep %}

{% step %}

#### No need to expose internals

You don't have to expose internal functions as public solely for testing.
{% endstep %}

{% step %}

#### Fewer tools to manage

Running tests in Clarity reduces the number of external tools and integrations you need to maintain.
{% endstep %}
{% endstepper %}

## Getting Started

Put tests next to contracts. Rendezvous will find them.

```
my-project/
├── Clarinet.toml
├── contracts/
│   ├── my-contract.clar       # Contract
│   ├── my-contract.tests.clar # Tests
└── settings/
    └── Devnet.toml
```

### Installation

To install Rendezvous as a dependency in your project, use `npm`:

```
npm install @stacks/rendezvous
```

This will add Rendezvous to your project's `node_modules` and update your `package.json`.

***

### Additional Resources

* \[[Github](https://stacks-network.github.io/rendezvous/)] Rendezvous repo
* \[[Youtube @jofawole](https://youtu.be/deWQxCEy9_M?si=bBpUoKGpJvFLFu_9)] How to Use Rendezvous to Fuzz Clarity Contracts


# Quickstart

Learn how to test your Clarity smart contracts thoroughly using Rendezvous  property-based testing.

This tutorial walks you through testing a DeFi lending contract with Rendezvous. You’ll see how Rendezvous uncovers subtle vulnerabilities that traditional unit tests might miss, and learn how to design property-based tests that help expose real bugs.

## What You'll Learn

You will test a simplified DeFi lending contract that allows users to deposit STX and borrow against those deposits. This contract hides a subtle bug that passes all example-based tests, but fails when running Rendezvous property-based testing.

You’ll learn to:

* Write property-based tests directly in Clarity
* Catch real vulnerabilities using randomized, stateful test runs
* Replay and fix failing test sequences deterministically

> Note: This example is adapted from the [stx-defi](https://github.com/hirosystems/clarity-examples/blob/ccd9ecf0bf136d7f28ef116706ed2936f6d8781a/examples/stx-defi/contracts/stx-defi.clar) contract in the [hirosystems/clarity-examples](https://github.com/hirosystems/clarity-examples) repository.

## Prerequisites

Before you begin, make sure you have:

* Node.js (version >= 20)
* Clarinet installed ([installation guide](https://github.com/stx-labs/clarinet))

## Step 1: Create a New Clarinet Project

Open your terminal and create a new Clarinet project:

```bash
clarinet new rendezvous-tutorial
cd rendezvous-tutorial
```

This creates a new directory with the basic Clarinet structure:

```
rendezvous-tutorial/
├── Clarinet.toml
├── contracts/
├── settings/
│   └── Devnet.toml
└── tests/
```

## Step 2: Add Rendezvous

Add Rendezvous to your project:

```bash
npm install @stacks/rendezvous
```

Verify the installation:

```bash
npx rv --help
```

## Step 3: Add the Lending Contract

Add a new contract to the Clarinet project:

```bash
clarinet contract new stx-defi
```

Open `contracts/stx-defi.clar` and add this Clarity code:

```clarity
;; stx-defi.clar
;; A simplified DeFi lending protocol.

(define-map deposits
  { owner: principal }
  { amount: uint }
)

(define-map loans
  principal
  { amount: uint }
)

(define-constant err-overborrow (err u300))

(define-public (deposit (amount uint))
  (let
    (
      (current-balance
        (default-to u0 (get amount (map-get? deposits { owner: tx-sender })))
      )
    )
    (try! (stx-transfer? amount tx-sender (as-contract tx-sender)))
    (map-set deposits
      { owner: tx-sender }
      { amount: (+ current-balance amount) }
    )
    (ok true)
  )
)

(define-public (borrow (amount uint))
  (let
    (
      (user-deposit
        (default-to u0 (get amount (map-get? deposits { owner: tx-sender })))
      )
      (allowed-borrow (/ user-deposit u2))
      (current-loan
        (default-to u0 (get amount (map-get? loans tx-sender)))
      )
      (new-loan (+ amount))
    )
    (asserts! (<= new-loan allowed-borrow) err-overborrow)
    (let
      ((recipient tx-sender))
      (try! (as-contract (stx-transfer? amount tx-sender recipient)))
    )
    (map-set loans tx-sender { amount: new-loan })
    (ok true)
  )
)

(define-read-only (get-loan-amount)
  (ok (default-to u0 (get amount (map-get? loans tx-sender))))
)
```

**What this contract does:**

* Users can `deposit` STX into the protocol
* Users can `borrow` up to 50% of their deposit value
* The contract tracks deposits and loans for each user

## Step 4: Write Some Unit Tests

Let's first write some example-based unit tests.

Open `tests/stx-defi.test.ts` and add these example-based unit tests:

```typescript
describe("stx-defi unit tests", () => {
  it("can deposit", () => {
    const amountToDeposit = 1000;

    const { result } = simnet.callPublicFn(
      "stx-defi",
      "deposit",
      [Cl.uint(amountToDeposit)],
      address1
    );

    expect(result).toBeOk(Cl.bool(true));
  });

  it("can borrow half of deposit", () => {
    const amountToDeposit = 1000;
    const amountToBorrow = 500;

    const { result: depositResult } = simnet.callPublicFn(
      "stx-defi",
      "deposit",
      [Cl.uint(amountToDeposit)],
      address1
    );
    expect(depositResult).toBeOk(Cl.bool(true));

    const { result } = simnet.callPublicFn(
      "stx-defi",
      "borrow",
      [Cl.uint(amountToBorrow)],
      address1
    );

    expect(result).toBeOk(Cl.bool(true));
  });

  it("loan amount is correct", () => {
    const amountToDeposit = 1000;
    const amountToBorrow = 500;

    simnet.callPublicFn(
      "stx-defi",
      "deposit",
      [Cl.uint(amountToDeposit)],
      address1
    );

    simnet.callPublicFn(
      "stx-defi",
      "borrow",
      [Cl.uint(amountToBorrow)],
      address1
    );

    const { result } = simnet.callReadOnlyFn(
      "stx-defi",
      "get-loan-amount",
      [],
      address1
    );

    expect(result).toBeOk(Cl.uint(amountToBorrow));
  });

  it("cannot borrow more than half of deposit", () => {
    const amountToDeposit = 1000;
    const amountToBorrow = 501;

    simnet.callPublicFn(
      "stx-defi",
      "deposit",
      [Cl.uint(amountToDeposit)],
      address1
    );

    const { result } = simnet.callPublicFn(
      "stx-defi",
      "borrow",
      [Cl.uint(amountToBorrow)],
      address1
    );

    // err-overborrow
    expect(result).toBeErr(Cl.uint(300));
  });
});
```

Install dependencies and run the tests:

```bash
npm install
npm test
```

**Looking good!** ✅ (or so it seems...)

The main functions and state of the contract are now covered by tests. Line coverage is probably high as well. Looks great, right? But here's the thing: example-based tests only verify the examples you thought of. Let's see if the contract holds up under **Rendezvous property-based testing**.

## Step 5: Add Rendezvous Property-Based Tests

Rendezvous lets you test a broader range of inputs, not just specific examples. Let's see how to write your first property-based test and why it matters.

### Create the Test File

Create the Rendezvous test file:

```bash
touch contracts/stx-defi.tests.clar
```

### Add an Ice-Breaker Test

Before writing any meaningful properties, it's a good idea to check that Rendezvous can run. Add a simple "always-true" test to verify your setup. Open `contracts/stx-defi.tests.clar` and add an always-true test:

```clarity
(define-public (test-always-true)
  (ok true)
)
```

Check if Rendezvous can execute the test:

```bash
npx rv . stx-defi test
```

Expected output:

```
$ npx rv . stx-defi test
Using manifest path: Clarinet.toml
Target contract: stx-defi

Starting property testing type for the stx-defi contract...

₿        1 Ӿ        3   deployer [PASS] stx-defi test-always-true  (ok true)
₿        1 Ӿ        4   wallet_5 [PASS] stx-defi test-always-true  (ok true)
₿       11 Ӿ       15   wallet_1 [PASS] stx-defi test-always-true  (ok true)
₿      690 Ӿ      695   wallet_1 [PASS] stx-defi test-always-true  (ok true)
...
₿    12348 Ӿ    12447   wallet_3 [PASS] stx-defi test-always-true  (ok true)
₿    12348 Ӿ    12448   wallet_3 [PASS] stx-defi test-always-true  (ok true)
₿    12357 Ӿ    12458   wallet_5 [PASS] stx-defi test-always-true  (ok true)

OK, properties passed after 100 runs.


EXECUTION STATISTICS

│ PROPERTY TEST CALLS
│
├─ + PASSED
│    └─ test-always-true: x100
│
├─ ! DISCARDED
│    └─ test-always-true: x0
│
└─ - FAILED
     └─ test-always-true: x0

LEGEND:

  PASSED    properties verified for given inputs
  DISCARDED skipped due to invalid preconditions
  FAILED    property violations or unexpected behavior
```

If you see similar output, your setup works. You're ready to write a **real property-based test**.

### Define a Borrowing Property

You want to test that **borrowing always updates the loan amount correctly**:

```clarity
;; stx-defi.tests.clar

;; Property: Borrowing should always update the loan amount correctly.
;; The new loan amount should equal the old loan amount plus the borrowed
;; amount.
(define-public (test-borrow (amount uint))
  (let (
      ;; Record the loan amount before performing any action that would end up
      ;; changing the internal state of the smart contract. Query the loans map
      ;; for the selected tx-sender and store the result in the initial-loan
      ;; local variable.
      (initial-loan (default-to u0 (get amount (map-get? loans tx-sender))))
    )
    ;; Since the initial-loan is recorded before the borrow call, you can now
    ;; call the borrow function to allow checking the effects after the call.
    (try! (borrow amount))
    ;; Verify the property: updated loan = initial loan + borrowed amount
    (asserts!
      (is-eq (default-to u0 (get amount (map-get? loans tx-sender)))
        (+ initial-loan amount)
      )
      (err u999) ;; any error code to identify the test failure.
    )
    (ok true)
  )
)
```

> At this stage, **the test will likely fail**. This is an important learning moment: Rendezvous runs your tests in a **stateful, randomized environment** that simulates real contract interactions.

### How Rendezvous Executes Property Tests

Rendezvous:

1. Injects all property-based tests directly into the deployed contract.
2. Detects all public `test-*` functions automatically.
3. Generates a random sequence to call each test.
4. Produces random argument values for each function parameter.
5. Randomly selects senders from settings/Devnet.toml.
6. Randomly advances Bitcoin and Stacks block heights during testing.
7. Accumulates state across test calls instead of resetting each time.
8. Discards test cases where preconditions fail, returning (ok false).

This design allows you to test your contract in **realistic, varied scenarios** that a simple/example-based unit test could never reach.

### Why the First Test Fails

The test likely failed because the `borrow` call failed—the contract wasn't in a suitable state. Rendezvous allows you to discard test cases when preconditions aren't met (wrong state, invalid arguments, caller, height, etc.). In our case, `borrow` will fail for one of these reasons:

* no deposits were made
* the generated amount argument is non-positive (u0)
* the generated amount argument is more than the allowed borrow value

To fix this, you need to **simulate deposits** and add **discard logic**.

Let's address them one by one.

### Handle Preconditions

**First, you need deposits.** You can create a helper function that Rendezvous will pick up during property-based testing runs. This helper will allow deposits to be created so other tests can check properties that require deposits:

```clarity
;; This is a helper function that will eventually be picked up during
;; property-based-testing runs. It allows creating deposits in the smart
;; contract so other tests can check properties requiring a deposit.
(define-public (test-deposit-helper (amount uint))
  (let (
      ;; Call the deposit function and ignore the result.
      (deposit-result (deposit amount))
    )
    (ok true)
  )
)
```

**Next, add discard logic to the borrow test.** A test is discarded when it returns `(ok false)`. Wrap the core test logic in a conditional that checks for invalid preconditions (the three cases listed above) and returns `(ok false)` to discard those cases:

```clarity
;; Property: Borrowing should always update the loan amount correctly.
;; The new loan amount should equal the old loan amount plus the borrowed
;; amount.
(define-public (test-borrow (amount uint))
  (if (or
      ;; If amount is 0, the STX transfer performed in the borrow operation
      ;; would fail, resulting in a false negative.
      (is-eq amount u0)
      ;; If the amount to borrow would exceed the allowed limit defined in the
      ;; borrow function, the borrow operation would fail, resulting in a false
      ;; negative.
      (> (+ (default-to u0 (get amount (map-get? loans tx-sender))) amount)
        (/ (default-to u0 (get amount (map-get? deposits { owner: tx-sender })))
          u2
        ))
    )
    ;; Discard the test if preconditions aren't met.
    (ok false)
    ;; Run the test.
    (let ((initial-loan (default-to u0 (get amount (map-get? loans tx-sender)))))
      (unwrap! (borrow amount) (err "Borrow call failed"))
      (let ((updated-loan (default-to u0 (get amount (map-get? loans tx-sender)))))
        ;; Verify the property: new loan = old loan + borrowed amount
        (asserts! (is-eq updated-loan (+ initial-loan amount))
          (err "Loan amount not updated correctly")
        )
        (ok true)
      )
    )
  )
)
```

The test discards invalid cases: when `amount` is `u0`, or when the new total loan would exceed half the deposit (which also covers cases with no deposits).

> Now the test only runs when valid preconditions are met.

### Run Rendezvous and Catch the Bug

Start a new property-based testing run:

```bash
npx rv . stx-defi test
```

Rendezvous will probably catch the bug in the very first run, showing output like this:

```
$ npx rv . stx-defi test
Using manifest path: Clarinet.toml
Target contract: stx-defi

Starting property testing type for the stx-defi contract...

₿        1 Ӿ        3   wallet_7 [PASS] stx-defi test-deposit-helper 2 (ok true)
₿     1001 Ӿ     1004   wallet_7 [WARN] stx-defi test-borrow 2015589496 (ok false)
₿     1001 Ӿ     1005   wallet_8 [PASS] stx-defi test-deposit-helper 2147483636 (ok true)
₿     1898 Ӿ     1903   wallet_6 [WARN] stx-defi test-borrow 1984339073 (ok false)
₿     1898 Ӿ     1904   deployer [PASS] stx-defi test-deposit-helper 195930186 (ok true)
₿     1898 Ӿ     1905   wallet_2 [PASS] stx-defi test-deposit-helper 13 (ok true)
...
₿     3464 Ӿ     3485   deployer [PASS] stx-defi test-borrow 28 (ok true)
₿     3468 Ӿ     3490   wallet_1 [WARN] stx-defi test-borrow 25 (ok false)
₿     3468 Ӿ     3491   wallet_8 [FAIL] stx-defi test-borrow 11 (err "Loan amount not updated correctly")
₿     3468 Ӿ     3492   wallet_1 [PASS] stx-defi test-deposit-helper 1653600941 (ok true)
₿     4058 Ӿ     4083   wallet_8 [PASS] stx-defi test-deposit-helper 1653600941 (ok true)
₿     4058 Ӿ     4084   wallet_8 [WARN] stx-defi test-borrow 1653600941 (ok false)
₿     4058 Ӿ     4085   wallet_8 [WARN] stx-defi test-borrow 0 (ok false)
₿     4058 Ӿ     4086   wallet_8 [FAIL] stx-defi test-borrow 6 (err "Loan amount not updated correctly")
₿     4058 Ӿ     4087   wallet_8 [FAIL] stx-defi test-borrow 3 (err "Loan amount not updated correctly")
₿     4058 Ӿ     4088   wallet_8 [FAIL] stx-defi test-borrow 2 (err "Loan amount not updated correctly")
₿     4058 Ӿ     4089   wallet_8 [FAIL] stx-defi test-borrow 1 (err "Loan amount not updated correctly")
₿     4058 Ӿ     4090   wallet_8 [WARN] stx-defi test-borrow 0 (ok false)
₿     4058 Ӿ     4091   wallet_8 [FAIL] stx-defi test-borrow 1 (err "Loan amount not updated correctly")
₿     4058 Ӿ     4092   wallet_8 [WARN] stx-defi test-borrow 0 (ok false)
₿     4058 Ӿ     4093   wallet_8 [FAIL] stx-defi test-borrow 1 (err "Loan amount not updated correctly")

Error: Property failed after 22 tests.
Seed : 1880056597

Counterexample:
- Test Contract : stx-defi
- Test Function : test-borrow (public)
- Arguments     : [1]
- Caller        : wallet_8
- Outputs       : {"type":{"response":{"ok":"bool","error":{"string-ascii":{"length":33}}}}}

What happened? Rendezvous went on a rampage and found a weak spot:

The test function "test-borrow" returned:

(err "Loan amount not updated correctly")

EXECUTION STATISTICS

│ PROPERTY TEST CALLS
│
├─ + PASSED
│    ├─ test-borrow: x2
│    └─ test-deposit-helper: x13
│
├─ ! DISCARDED
│    ├─ test-borrow: x12
│    └─ test-deposit-helper: x0
│
└─ - FAILED
     ├─ test-borrow: x7
     └─ test-deposit-helper: x0

LEGEND:

  PASSED    properties verified for given inputs
  DISCARDED skipped due to invalid preconditions
  FAILED    property violations or unexpected behavior

! FAILED tests indicate that your function properties don't hold for all inputs. Review the counterexamples above for debugging.
```

The output shows a failure: `(err "Loan amount not updated correctly")`. The contract isn't tracking loan amounts correctly.

> **Note:** The output includes a seed (`1880056597`) you can use to reproduce this exact sequence.

You can also stop at the first failure:

```bash
npx rv . stx-defi test --bail
```

## Step 6: Identify and Fix the Borrow Bug

After taking a closer look at the lending contract, the bug is in this line of the `borrow` function:

```clarity
(new-loan (+ amount))
```

Change the line to correctly accumulate loans:

```clarity
(new-loan (+ current-loan amount))
```

### Re-run Rendezvous with the Same Seed

Re-run with the same seed, to find out if you completely fixed the bug for that random sequence of events:

```clarity
npx rv . stx-defi test --seed=1880056597
```

Output:

```
$ npx rv . stx-defi test --seed=1880056597
Using manifest path: Clarinet.toml
Target contract: stx-defi
Using seed: 1880056597

Starting property testing type for the stx-defi contract...

₿        1 Ӿ        3   wallet_7 [PASS] stx-defi test-deposit-helper 2 (ok true)
₿     1001 Ӿ     1004   wallet_7 [WARN] stx-defi test-borrow 2015589496 (ok false)
₿     1001 Ӿ     1005   wallet_8 [PASS] stx-defi test-deposit-helper 2147483636 (ok true)
₿     1898 Ӿ     1903   wallet_6 [WARN] stx-defi test-borrow 1984339073 (ok false)
₿     1898 Ӿ     1904   deployer [PASS] stx-defi test-deposit-helper 195930186 (ok true)
₿     1898 Ӿ     1905   wallet_2 [PASS] stx-defi test-deposit-helper 13 (ok true)
...
₿    17291 Ӿ    17388   wallet_4 [PASS] stx-defi test-borrow 708340522 (ok true)
₿    17291 Ӿ    17389   wallet_4 [PASS] stx-defi test-deposit-helper 589199221 (ok true)
₿    17565 Ӿ    17664   wallet_2 [PASS] stx-defi test-deposit-helper 2147483627 (ok true)
₿    18559 Ӿ    18659   wallet_8 [PASS] stx-defi test-borrow 1622181282 (ok true)
₿    18559 Ӿ    18660   wallet_3 [PASS] stx-defi test-deposit-helper 2147483630 (ok true)

OK, properties passed after 100 runs.
```

> The bug is fixed! The contract now correctly tracks cumulative loans.

### Run Multiple Random Sequences

Test additional random sequences (each run generates a new random sequence):

```bash
npx rv . stx-defi test
```

Run more tests to increase confidence (default is 100 runs):

```bash
npx rv . stx-defi test --runs=1000
```

**Rendezvous caught the bug and you successfully fixed it!** 🎯

## Step 7: Understand the Bug

**What was the bug?**

Rendezvous discovered that when a user borrows multiple times, only the most recent borrow amount is recorded.

The bug means the contract doesn't track cumulative borrows correctly. When a user borrows multiple times, only the most recent borrow amount is recorded, not the total. The existing loan amount (`current-loan`) is completely ignored!

**Why did example-based unit tests miss this?**

The unit tests passed because they only tested single borrow scenarios. Look back at the unit test:

```typescript
it("loan amount is correct after single borrow", () => {
  // Only ONE borrow call - bug not triggered!
  simnet.callPublicFn(
    "stx-defi",
    "borrow",
    [Cl.uint(amountToBorrow)],
    address1
  );
  // ...
});
```

When there's only one borrow, `(+ amount)` and `(+ current-loan amount)` produce the same result because the initial loan is `u0`.

**Rendezvous caught the bug by:**

1. Randomly generating test sequences
2. Calling `borrow` multiple times with different amounts
3. Verifying the property holds for ALL sequences

This is the power of using Rendezvous!

## What You Learned

You've successfully:

✅ Created a simple DeFi lending contract

✅ Wrote traditional unit tests that passed but missed a critical bug

✅ Wrote your first Rendezvous property-based test

✅ Discovered how Rendezvous catches bugs through random stateful testing

✅ Fixed the bug and verified the fix

✅ Understood the difference between stateless example-based and stateful property-based testing

## The Key Insight

**Example-based tests check specific examples. Property-based tests check a much broader range of inputs.**

Example-based tests ask:

* "Does this work for input A?"
* "Does this work for input B?"

Property-based tests ask:

* "Does this ALWAYS work?"
* "Can I find ANY input that breaks this?"

Rendezvous explores your contract's state space automatically, finding edge cases you might never think to test manually.

## Real-World Impact

This bug in a production DeFi protocol would allow users to:

1. Deposit 1000 STX
2. Borrow 500 STX (maximum allowed)
3. Borrow another 500 STX (should fail, but succeeds due to bug)
4. Total borrowed: 1000 STX with only 500 STX recorded
5. User only needs to repay 500 STX despite borrowing 1000 STX

This would drain the protocol's funds — a critical vulnerability caught by Rendezvous in seconds.

## Example Implementation

You can see a complete step-by-step implementation of this tutorial with commit-by-commit progress in the [rendezvous-tutorial repository](https://github.com/BowTiedRadone/rendezvous-tutorial) ([view commits](https://github.com/BowTiedRadone/rendezvous-tutorial/commits/master/)).

## Next Steps

Now that you understand the power of Rendezvous, explore:

* **More examples**: Study other smart contracts in the [Examples Chapter](https://stacks-network.github.io/rendezvous/chapter_8.html) of the [Rendezvous Docs](https://stacks-network.github.io/rendezvous/)
* **Your own contracts**: Apply Rendezvous to your projects and find bugs before they reach production

***

## Get Involved

**Found this tutorial useful?** Star the [Rendezvous repository on GitHub](https://github.com/stacks-network/rendezvous) to show your support!

Have questions, found a bug, or want to contribute? We'd love to hear from you:

* **Open an issue** on [GitHub](https://github.com/stacks-network/rendezvous/issues)
* **Reach out** with questions or feedback
* **Share your findings** — contribute examples of bugs you've caught to show others how powerful advanced testing techniques can be


# Overview

<figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2Fgit-blob-62cf4ac9cd02135ce49684f743cb8d0cd885f409%2Fstacksjs-learn.png?alt=media" alt=""><figcaption><p>source: <a href="https://www.hiro.so/blog/taking-a-look-at-recent-stacks-js-improvements">Hiro blog</a></p></figcaption></figure>

## Overview

Stacks.js is a collection of JavaScript libraries that enable you to build web applications on the Stacks blockchain. From wallet authentication to smart contract interactions.

{% hint style="success" %}
For the latest releases and versions of Stacks.js packages, check out its open-source repo [here](https://github.com/stx-labs/stacks.js).
{% endhint %}

## Key features

* **Transaction construction** - Build and broadcast all transaction types with type-safe APIs
* **Smart contract interaction** - Deploy contracts and call functions with automatic encoding
* **Wallet integration** - Connect to Leather, Xverse, and other Stacks wallets seamlessly
* **Post-conditions** - Protect users with built-in asset transfer validations

## Installation

Stacks.js is separated into focused packages published under the `@stacks` scope. Install only what you need:

{% tabs %}
{% tab title="Transactions" %}
{% code title="terminal" %}

```bash
npm install @stacks/transactions
```

{% endcode %}
{% endtab %}

{% tab title="Wallet Connections" %}
{% code title="terminal" %}

```bash
npm install @stacks/connect
```

{% endcode %}
{% endtab %}

{% tab title="Network Config" %}
{% code title="terminal" %}

```bash
npm install @stacks/network
```

{% endcode %}
{% endtab %}

{% tab title="Common Utils" %}
{% code title="terminal" %}

```bash
npm install @stacks/common
```

{% endcode %}
{% endtab %}
{% endtabs %}

Other available packages include:

* `@stacks/api`
* `@stacks/auth`
* `@stacks/encryption`
* `@stacks/network`
* `@stacks/stacking`
* `@stacks/transactions`
* `@stacks/bns`
* `@stacks/common`
* `@stacks/profile`
* `@stacks/storage`
* `@stacks/wallet-sdk`

***

{% hint style="info" %}
Need help building with Stacks.js?

Reach out to us on the **#stacks-js** channel on [Discord](https://stacks.chat/) under the Developer Tools section.
{% endhint %}

***

### Additional Resources

* \[[stacks.js.org](https://stacks.js.org/)] For a complete list of definitions on types, methods, classes, & etc.


# Accounts & Addresses

Stacks uses the concept of an "account" to represent a user's identity on the blockchain. An account is identified by a unique address derived from the account's public key.

## Address formats

Stacks addresses use different prefixes to indicate the network they belong to, making it easy to distinguish between mainnet and testnet addresses.

```ts
// Mainnet address starts with 'SP'
const mainnetAddress = 'SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159';

// Testnet address starts with 'ST'
const testnetAddress = 'ST2F4BK4GZH6YFBNHYDDGN4T1RKBA7DA1BJZPJEJJ';
```

The address format ensures that tokens on testnet cannot be accidentally sent to mainnet addresses and vice versa.

## Getting an address

There are several ways to obtain a Stacks address depending on your use case and what cryptographic material you have available.

{% stepper %}
{% step %}
**Using Stacks Connect**

When building user-facing applications, you'll typically get addresses from users who connect their wallets through Stacks Connect.

```ts
import { connect, getLocalStorage, request } from '@stacks/connect';

async function handleWalletConnection() {
  // Connect to wallet
  const response = await connect();
  
  // Get stored addresses
  const data = getLocalStorage();
  const stxAddresses = data.addresses.stx;
  
  if (stxAddresses && stxAddresses.length > 0) {
    const address = stxAddresses[0].address;
    console.log('STX Address:', address);
    // 'SP1MXSZF4NFC8JQ1TTYGEC2WADMC7Y3GHVZYRX6RF'
  }
  
  // Get detailed account info if needed
  const accounts = await request('stx_getAccounts');
  console.log('Account details:', accounts.addresses[0]);
}
```

Stacks Connect stores the connected addresses in local storage, allowing your app to persist the connection across page reloads.
{% endstep %}

{% step %}
**Using a seed phrase**

For programmatic wallet generation or when restoring accounts from backup, you can derive addresses from a seed phrase (also known as a mnemonic).

```ts
import { generateWallet, generateSecretKey } from '@stacks/wallet-sdk';

async function createWalletFromSeed() {
  // Generate a new 24-word seed phrase
  const secretKey = generateSecretKey();
  
  // Or use an existing seed phrase
  // const secretKey = 'already owned seed phrase ...';
  
  const wallet = await generateWallet({
    secretKey,
    password: 'optional-encryption-password',
  });
  
  // Get the first account's address
  const account = wallet.accounts[0];
  const mainnetAddress = account.address;
  
  console.log('Address:', mainnetAddress);
  console.log('Private key:', account.stxPrivateKey);
}
```

Each wallet can contain multiple accounts, all derived from the same seed phrase using different derivation paths.
{% endstep %}

{% step %}
**Using a private key**

If you already have a private key, you can directly derive the corresponding address without going through the wallet generation process.

```ts
import { privateKeyToAddress, TransactionVersion } from '@stacks/transactions';

function getAddressFromPrivateKey() {
  // Compressed private key (64 or 66 characters)
  const privateKey = 'your-private-key-here';
  
  // For mainnet
  const mainnetAddress = privateKeyToAddress(
    privateKey, 
    TransactionVersion.Mainnet
  );
  
  // For testnet
  const testnetAddress = privateKeyToAddress(
    privateKey, 
    TransactionVersion.Testnet
  );
  
  console.log('Mainnet:', mainnetAddress);
  console.log('Testnet:', testnetAddress);
}
```

The same private key will generate different addresses for mainnet and testnet due to the network-specific version bytes.
{% endstep %}

{% step %}
**Using a public key**

When you only have access to a public key (for example, in a watch-only wallet scenario), you can still derive the corresponding address.

```ts
import { publicKeyToAddress, TransactionVersion } from '@stacks/transactions';

function getAddressFromPublicKey() {
  // Compressed public key (66 characters starting with 02 or 03)
  const publicKey = '03b3e0a76b292b2c83fc0ac14ae6160d0438ebe94e14bbb7d0ded3c217f3d29ba7';
  
  // For mainnet
  const mainnetAddress = publicKeyToAddress(
    publicKey,
    TransactionVersion.Mainnet
  );
  
  // For testnet  
  const testnetAddress = publicKeyToAddress(
    publicKey,
    TransactionVersion.Testnet
  );
  
  console.log('Mainnet:', mainnetAddress);
  // 'SP1MXSZF4NFC8JQ1TTYGEC2WADMC7Y3GHVZYRX6RF'
}
```

This is useful for creating watch-only wallets or verifying addresses without access to private keys.
{% endstep %}
{% endstepper %}

## Address validation

Before sending transactions, it's important to validate that addresses are properly formatted.

```ts
import { validateStacksAddress } from '@stacks/transactions';

function isValidAddress(address: string): boolean {
  try {
    // Check if it's a valid mainnet address
    if (address.startsWith('SP')) {
      return validateStacksAddress(address);
    }
    
    // Check if it's a valid testnet address
    if (address.startsWith('ST')) {
      return validateStacksAddress(address);
    }
    
    return false;
  } catch (error) {
    return false;
  }
}

// Examples
console.log(isValidAddress('SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159')); // true
console.log(isValidAddress('invalid-address')); // false
```

Always validate addresses before using them in transactions to prevent loss of funds due to typos or formatting errors.


# Private Keys

Stacks applications can work with two different account types: web wallets (like Hiro Wallet or Xverse) that users control, or local accounts you manage the private keys directly.

## Web wallets (user-controlled)

Most users interact with Stacks apps through web wallets, where the wallet handles all private key management and transaction signing.

```ts
import { connect } from '@stacks/connect';

// Users connect their wallet
const response = await connect();
console.log('Connected addresses:', response.addresses);

// The wallet handles all cryptographic operations
// when signing transactions or messages
```

Use web wallets when building user-facing applications where users should maintain control of their keys.

## Local accounts (application-controlled)

Local accounts give your application direct control over private keys, enabling programmatic transaction signing without user interaction.

```ts
import { makeSTXTokenTransfer } from '@stacks/transactions';

// Your application controls the private key
const privateKey = 'your-private-key-here';

const txOptions = {
  recipient: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',
  amount: 1000000n,
  senderKey: privateKey, // Direct private key usage
  network: 'testnet',
};

const transaction = await makeSTXTokenTransfer(txOptions);
// Transaction is signed programmatically
```

Use local accounts for backend services, automated systems, or development tools that need to sign transactions without user interaction.

## Working with private keys

When building applications that use local accounts, you'll need to generate and manage private keys securely.

### Generating random private keys

Create a new private key for one-time use or testing purposes.

```ts
import { randomPrivateKey } from '@stacks/transactions';

function generateNewAccount() {
  const privateKey = randomPrivateKey();
  console.log('Private key:', privateKey);
  // 'f5a31c1268a1e37d4edaa05c7d11183c5fbf...'
  
  // IMPORTANT: Store this securely!
  // Anyone with this key can control the account
  return privateKey;
}
```

{% hint style="warning" %}
Private keys in Stacks are 256-bit numbers, typically represented as 64-character hexadecimal strings. Anyone with the private key can control the account—store keys securely.
{% endhint %}

## Private key formats

Stacks.js supports multiple private key formats for different use cases.

```ts
import { PrivateKey } from '@stacks/transactions';

// Hex string format (most common)
const hexKey = 'f5a31c1268a1e37d4edaa05c7d11183c5fbf...';

// Compressed format with suffix
const compressedKey = 'f5a31c1268a1e37d4edaa05c7d11183c5fbf...01';

// Create from raw bytes
const bytes = new Uint8Array(32); // 32 bytes = 256 bits
crypto.getRandomValues(bytes);
const privateKeyFromBytes = PrivateKey.fromBytes(bytes);
```

The compressed format includes a suffix byte (01) that indicates the key should use compressed public key encoding.

## Wallet generation with seed phrases

For better security and recoverability, use hierarchical deterministic (HD) wallets based on seed phrases.

{% stepper %}
{% step %}
**Generate a seed phrase**

Create a new 24-word mnemonic seed phrase that can regenerate all wallet accounts.

```ts
import { generateSecretKey } from '@stacks/wallet-sdk';

function createNewWallet() {
  const secretKey = generateSecretKey();
  console.log('Seed phrase:', secretKey);
  // "warrior volume sport ... figure cake since"
  
  // Users should write this down and store it securely
  // This phrase can regenerate all accounts in the wallet
  return secretKey;
}
```

{% hint style="warning" %}
Seed phrases provide a human-readable backup that can restore an entire wallet hierarchy. Users should write this down and store it securely.
{% endhint %}
{% endstep %}

{% step %}
**Create wallet from seed phrase**

Generate a complete wallet structure from a seed phrase, including multiple accounts.

```ts
import { generateWallet, generateSecretKey } from '@stacks/wallet-sdk';

async function setupWallet() {
  // Use existing seed phrase or generate new one
  const seedPhrase = generateSecretKey();
  
  const wallet = await generateWallet({
    secretKey: seedPhrase,
    password: 'optional-encryption-password',
  });
  
  // Access the first account
  const account = wallet.accounts[0];
  console.log('STX address:', account.address);
  console.log('STX private key:', account.stxPrivateKey);
  console.log('Data private key:', account.dataPrivateKey);
  
  return wallet;
}
```

Each wallet can contain multiple accounts, all derived from the same seed phrase but with different private keys.
{% endstep %}

{% step %}
**Managing multiple accounts**

HD wallets support multiple accounts from a single seed phrase, useful for organizing funds or separating concerns.

```ts
import { generateNewAccount, generateWallet, generateSecretKey } from '@stacks/wallet-sdk';

async function createMultipleAccounts() {
  const seedPhrase = generateSecretKey();
  
  let wallet = await generateWallet({
    secretKey: seedPhrase,
    password: 'my-password',
  });
  
  console.log('Accounts:', wallet.accounts.length); // 1 (default)
  
  // Add more accounts
  wallet = generateNewAccount(wallet);
  wallet = generateNewAccount(wallet);
  
  console.log('Accounts:', wallet.accounts.length); // 3
  
  // Each account has its own keys and address
  wallet.accounts.forEach((account, index) => {
    console.log(`Account ${index}:`, account.address);
  });
}
```

All accounts can be regenerated from the original seed phrase, making backup simple while maintaining separate addresses.
{% endstep %}
{% endstepper %}


# Networks

Typically, we speak of `mainnet` and `testnet` as the networks of Stacks. Most wallets are configured to `mainnet` by default—this is the production environment, the actual blockchain that holds real STX tokens.

As the name suggests, `testnet` is a public network for testing. It's a separate blockchain state that holds test tokens, which have no value.

For completeness we also mention `devnet`. This isn't "one" network, but how developers refer to ephemeral local networks used for testing. It is the same as `testnet`, but for local development. [Learn more](https://docs.stacks.co/build/clarinet/local-blockchain-development).

## Setting the network

Most Stacks.js functions accept a `network` parameter or an optional last argument.

The `network` type is a string, and can be one of:

* `'mainnet'` (default)
* `'testnet'`
* `'devnet'`
* `'mocknet'` (alias of `devnet`)

### Examples

Network in transaction signing:

{% code title="transaction.ts" %}

```ts
const tx = makeSTXTokenTransfer({
  // ...
  network: 'testnet',
});
```

{% endcode %}

Network in address derivation:

{% code title="address.ts" %}

```ts
const address = privateKeyToAddress(privateKey, 'devnet');
// ST3NBRSFKX28FQ2ZJ1MAKX58HKHSDGNV5N7R21XCP
```

{% endcode %}

{% hint style="info" %}
For more advanced workflows, pass a custom network configuration object. See the `@stacks/network` package for details.
{% endhint %}


# Read Only Calls

Read-only function calls allow you to query data from smart contracts without creating a transaction. These calls are free, instant, and don't require wallet interaction.

## Basic read-only call

Call a read-only function to get contract data without any transaction fees:

```ts
import { fetchCallReadOnlyFunction, cvToValue } from '@stacks/transactions';

const contractAddress = 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM';
const contractName = 'my-contract';
const functionName = 'get-balance';

const response = await fetchCallReadOnlyFunction({
  contractAddress,
  contractName,
  functionName,
  functionArgs: [],
  senderAddress: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',
});

const balance = cvToValue(response);
console.log('Balance:', balance);
```

## Passing function arguments

Most read-only functions require arguments. Use Clarity value builders to construct the appropriate types:

```ts
import {
  fetchCallReadOnlyFunction,
  principalCV,
  uintCV,
  stringUtf8CV
} from '@stacks/transactions';

const functionArgs = [
  principalCV('ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM'),
  stringUtf8CV('admin')
];

const response = await fetchCallReadOnlyFunction({
  contractAddress: 'ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG',
  contractName: 'access-control',
  functionName: 'has-role',
  functionArgs,
  senderAddress: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',
});

const hasRole = cvToValue(response);
console.log('Has admin role:', hasRole);
```

## Handling response types

Read-only functions can return response types (ok/err). Check the response type to handle both success and error cases:

```ts
import {
  fetchCallReadOnlyFunction,
  cvToJSON,
  ResponseOkCV,
  ResponseErrorCV
} from '@stacks/transactions';

const response = await fetchCallReadOnlyFunction({
  contractAddress: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',
  contractName: 'sip-010-token',
  functionName: 'get-token-info',
  functionArgs: [],
  senderAddress: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',
});

if (response.type === 'ok') {
  const tokenInfo = cvToJSON(response.value);
  console.log('Token info:', tokenInfo);
  // {
  //   name: "My Token",
  //   symbol: "MTK",
  //   decimals: 6,
  //   totalSupply: "1000000000000"
  // }
} else {
  console.error('Error:', cvToValue(response.value));
}
```

## Using custom network

Specify a custom network URL for testnet or custom node connections:

```ts
import { fetchCallReadOnlyFunction } from '@stacks/transactions';

const response = await fetchCallReadOnlyFunction({
  contractAddress: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',
  contractName: 'my-contract',
  functionName: 'get-data',
  functionArgs: [],
  senderAddress: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',
  network: 'testnet', // or custom URL like 'http://localhost:3999'
});
```


# Build Transactions

Learn how to build transactions programmatically for complete control over blockchain interactions.

## Objectives

* Build signed transactions for immediate broadcast
* Create unsigned transactions for multi-signature workflows
* Implement sponsored transactions to pay fees for users

## Transaction types

Stacks supports five primary transaction types, each serving a specific purpose.

```ts
// STX Transfer - Send native tokens
const stxTransfer = await makeSTXTokenTransfer(options);

// Contract Deployment - Deploy Clarity contracts  
const deployment = await makeContractDeploy(options);

// Contract Call - Execute contract functions
const contractCall = await makeContractCall(options);

// Each transaction type accepts similar base options:
interface TransactionOptions {
  senderKey: string;        // Private key for signing
  network: string;          // 'mainnet' or 'testnet'
  fee?: bigint;            // Manual fee in microSTX
  nonce?: bigint;          // Manual nonce
  anchorMode?: AnchorMode; // Block anchoring strategy
}
```

## Building signed transactions

Signed transactions are ready to broadcast immediately. The private key signs during creation.

{% stepper %}
{% step %}
**STX token transfer**

```ts
import { makeSTXTokenTransfer, broadcastTransaction } from '@stacks/transactions';

const transaction = await makeSTXTokenTransfer({
  recipient: 'ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG',
  amount: 1000000n, // 1 STX = 1,000,000 microSTX
  senderKey: 'your-private-key-hex',
  network: 'testnet',
  memo: 'Payment for services', // Optional memo (max 34 bytes)
});

const result = await broadcastTransaction({ transaction });
console.log('Transaction ID:', result.txid);
```

{% endstep %}

{% step %}
**Smart contract deployment**

```ts
import { makeContractDeploy, ClarityVersion } from '@stacks/transactions';

const contractCode = `
(define-public (say-hello)
  (ok "Hello, Stacks!"))
`;

const transaction = await makeContractDeploy({
  contractName: 'hello-world',
  codeBody: contractCode,
  senderKey: 'your-private-key-hex',
  network: 'testnet',
  clarityVersion: ClarityVersion.Clarity3,
});

const result = await broadcastTransaction({ transaction });
```

{% endstep %}

{% step %}
**Contract function calls**

```ts
import { makeContractCall, Cl } from '@stacks/transactions';

const transaction = await makeContractCall({
  contractAddress: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',
  contractName: 'counter',
  functionName: 'increment',
  functionArgs: [Cl.uint(1)],
  senderKey: 'your-private-key-hex',
  network: 'testnet',
});
```

{% endstep %}
{% endstepper %}

## Unsigned transactions

Create unsigned transactions for multi-signature workflows or offline signing.

```ts
import { makeUnsignedSTXTokenTransfer, TransactionSigner } from '@stacks/transactions';
import { publicKeyFromPrivate } from '@stacks/encryption';

// Create unsigned transaction
const publicKey = publicKeyFromPrivate('your-private-key');

const unsignedTx = await makeUnsignedSTXTokenTransfer({
  recipient: 'ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG',
  amount: 1000000n,
  publicKey,
  network: 'testnet',
});

// Sign separately
const signer = new TransactionSigner(unsignedTx);
signer.signOrigin('your-private-key');

const signedTx = signer.transaction;
```

## Sponsored transactions

Let one account pay fees for another account's transaction.

```ts
// User creates sponsored transaction
const userTx = await makeContractCall({
  contractAddress: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',
  contractName: 'my-contract',
  functionName: 'transfer',
  functionArgs: [Cl.principal('ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG')],
  senderKey: 'user-private-key',
  sponsored: true,
  fee: 0n, // User doesn't pay
  network: 'testnet',
});

// Sponsor completes and pays
import { sponsorTransaction } from '@stacks/transactions';

const sponsoredTx = await sponsorTransaction({
  transaction: userTx,
  sponsorPrivateKey: 'sponsor-private-key',
  fee: 2000n, // Sponsor pays the fee
  network: 'testnet',
});

const result = await broadcastTransaction({ transaction: sponsoredTx });
```

## Multi-signature transactions

Require multiple signatures for enhanced security.

```ts
// Create multi-sig transaction (2-of-3)
const publicKeys = [publicKey1, publicKey2, publicKey3];

const multiSigTx = await makeUnsignedSTXTokenTransfer({
  recipient: 'ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG',
  amount: 5000000n,
  numSignatures: 2, // Require 2 of 3
  publicKeys,
  network: 'testnet',
});

// Collect signatures
const signer = new TransactionSigner(multiSigTx);
signer.signOrigin(privateKey1); // First signature
signer.appendOrigin(privateKey2); // Second signature

const signedTx = signer.transaction;
```

## Working with Clarity values

Use the `Cl` helper for type-safe contract arguments.

```ts
import { Cl } from '@stacks/transactions';

const functionArgs = [
  // Primitives
  Cl.uint(42),
  Cl.int(-10),
  Cl.bool(true),
  Cl.stringUtf8('Hello 世界'),
  Cl.stringAscii('Hello World'),
  
  // Principals
  Cl.standardPrincipal('ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG'),
  Cl.contractPrincipal('ST123...', 'my-contract'),
  
  // Composites
  Cl.list([Cl.uint(1), Cl.uint(2), Cl.uint(3)]),
  Cl.tuple({ 
    name: Cl.stringUtf8('Alice'),
    age: Cl.uint(30)
  }),
  
  // Optionals and responses
  Cl.some(Cl.uint(42)),
  Cl.none(),
  Cl.ok(Cl.uint(200)),
  Cl.err(Cl.uint(404))
];
```

## Post-conditions

Add safety constraints to protect users from unexpected transfers.

```ts
import { Pc, PostConditionMode } from '@stacks/transactions';

const transaction = await makeContractCall({
  // ... other options
  postConditions: [
    // Sender must send exactly 1 STX
    Pc.principal('ST1ADDRESS...')
      .willSendEq(1000000n)
      .ustx(),
    
    // Contract must transfer tokens
    Pc.principal('ST2CONTRACT...')
      .willSendGte(100n)
      .ft('ST2CONTRACT.token-contract', 'my-token')
  ],
  postConditionMode: PostConditionMode.Deny, // Strict mode
});
```

## Fee estimation

Get accurate fee estimates before broadcasting.

```ts
import { estimateFee } from '@stacks/transactions';

// Build transaction first
const tx = await makeSTXTokenTransfer({
  recipient: 'ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG',
  amount: 1000000n,
  senderKey: privateKey,
  network: 'testnet',
  fee: 1n, // Minimal fee for estimation
});

// Estimate appropriate fee
const feeRate = await estimateFee(tx);
tx.setFee(feeRate);

// Now broadcast with accurate fee
const result = await broadcastTransaction({ transaction: tx });
```


# Contract Calls

Contract calls allow you to execute state-changing functions in smart contracts. Unlike read-only calls, these create transactions that must be signed and broadcast to the network.

## Basic contract call

Execute a simple contract function by creating a transaction with the required parameters.

```ts
import { 
  makeContractCall,
  broadcastTransaction,
  AnchorMode
} from '@stacks/transactions';

async function callContract() {
  const txOptions = {
    contractAddress: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',
    contractName: 'my-contract',
    functionName: 'transfer',
    functionArgs: [],
    senderKey: 'your-private-key',
    network: 'testnet',
    anchorMode: AnchorMode.Any,
  };
  
  const transaction = await makeContractCall(txOptions);
  const broadcastResponse = await broadcastTransaction({ transaction });
  
  console.log('Transaction ID:', broadcastResponse.txid);
}
```

The `makeContractCall` function creates a transaction that will execute the specified function when confirmed on-chain.

## Passing function arguments

Most contract functions require arguments. Use Clarity value constructors to match the expected parameter types.

```ts
import { 
  Cl,
  makeContractCall,
} from '@stacks/transactions';

const functionArgs = [
  Cl.principal('ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG'), // recipient
  Cl.uint(1000000), // amount
  Cl.buffer(Buffer.from('Transfer memo', 'utf-8')), // memo
];

const txOptions = {
  contractAddress: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',
  contractName: 'sip-010-token',
  functionName: 'transfer',
  functionArgs,
  senderKey: 'your-private-key',
  network: "testnet",
};

const transaction = await makeContractCall(txOptions);
const result = await broadcastTransaction({ transaction });
console.log('Transaction ID:', result.txid);
```

Each Clarity type has a corresponding constructor function that ensures proper encoding for the blockchain.

### Complex argument types

```ts
// Tuple arguments
const userInfo = Cl.tuple({
  name: Cl.string('Alice'),
  age: Cl.uint(30),
  active: Cl.bool(true),
});

// List arguments
const addresses = Cl.list([
  Cl.principal('ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM'),
  Cl.principal('ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG'),
]);
```

Optional and response values have dedicated constructors for proper type safety.

```ts
// Optional values
const optionalValue = Cl.some(Cl.uint(42)); // (some 42)
const noValue = Cl.none(); // none

// Response values
const successResponse = Cl.ok(Cl.uint(100));
const errorResponse = Cl.err(Cl.uint(404));
```

## Contract call with STX transfer

Some contracts require STX to be sent along with the function call, such as when minting NFTs or paying for services.

```ts
async function mintNFT() {
  const mintPrice = 1000000; // 1 STX
  
  const txOptions = {
    contractAddress: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',
    contractName: 'nft-collection',
    functionName: 'mint',
    functionArgs: [],
    senderKey: 'your-private-key',
    network: new StacksTestnet(),
    anchorMode: AnchorMode.Any,
    // Attach STX to the contract call
    amount: mintPrice,
  };
  
  const transaction = await makeContractCall(txOptions);
  return broadcastTransaction(transaction, network);
}
```

## Handling contract responses

Process transaction results and contract responses:

```ts
async function executeAndMonitor() {
  // Execute contract call
  const transaction = await makeContractCall({
    contractAddress: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',
    contractName: 'my-contract',
    functionName: 'process',
    functionArgs: [uintCV(100)],
    senderKey: 'your-private-key',
    network: new StacksTestnet(),
    anchorMode: AnchorMode.Any,
  });
  
  const broadcastResponse = await broadcastTransaction(transaction, network);
  const txId = broadcastResponse.txid;
  
  // Wait for confirmation
  const txInfo = await waitForConfirmation(txId, network);
  
  // Check transaction result
  if (txInfo.tx_status === 'success') {
    console.log('Contract returned:', txInfo.tx_result);
    // Parse the result based on expected return type
  } else {
    console.error('Transaction failed:', txInfo.tx_result);
  }
}

async function waitForConfirmation(txId: string, network: StacksNetwork) {
  let attempts = 0;
  const maxAttempts = 30;
  
  while (attempts < maxAttempts) {
    const response = await fetch(
      `${network.coreApiUrl}/extended/v1/tx/${txId}`
    );
    const txInfo = await response.json();
    
    if (txInfo.tx_status === 'success' || txInfo.tx_status === 'abort_by_response') {
      return txInfo;
    }
    
    await new Promise(resolve => setTimeout(resolve, 10000));
    attempts++;
  }
  
  throw new Error('Transaction confirmation timeout');
}
```

## Multi-step contract interactions

{% stepper %}
{% step %}
**Approve spending**

First, create and broadcast an approval transaction.

```ts
const approveTx = await makeContractCall({
  contractAddress: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',
  contractName: 'token',
  functionName: 'approve',
  functionArgs: [
    standardPrincipalCV('ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG'),
    uintCV(1000000),
  ],
  senderKey: 'your-private-key',
  network: new StacksTestnet(),
  anchorMode: AnchorMode.Any,
});

const approveResult = await broadcastTransaction(approveTx, network);
await waitForConfirmation(approveResult.txid, network);
```

This step ensures the spender is authorized before subsequent actions.
{% endstep %}

{% step %}
**Execute swap after approval**

After the approval is confirmed, execute the swap transaction.

```ts
const swapTx = await makeContractCall({
  contractAddress: 'ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG',
  contractName: 'dex',
  functionName: 'swap-tokens',
  functionArgs: [
    standardPrincipalCV('ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM'),
    uintCV(1000000),
  ],
  senderKey: 'your-private-key',
  network: new StacksTestnet(),
  anchorMode: AnchorMode.Any,
});

return broadcastTransaction(swapTx, network);
```

This step performs the token swap that depends on the prior approval.
{% endstep %}
{% endstepper %}


# Contract Deployment

Deploy smart contracts to the Stacks blockchain.

## Overview

Contract deployment creates new smart contracts on the blockchain. Stacks.js provides tools to compile, deploy, and verify Clarity contracts programmatically. Deployments can be simple single contracts or complex multi-contract systems with dependencies.

## Basic contract deployment

Deploy a simple smart contract:

{% code title="deploy.ts" %}

```ts
import { 
  makeContractDeploy,
  broadcastTransaction,
  AnchorMode 
} from '@stacks/transactions';
import { STACKS_TESTNET } from '@stacks/network';
import { readFileSync } from 'fs';

async function deployContract() {
  const network = new StacksTestnet();
  
  // Read contract source code
  const contractSource = readFileSync('./contracts/my-contract.clar', 'utf-8');
  
  const txOptions = {
    contractName: 'my-contract',
    codeBody: contractSource,
    senderKey: 'your-private-key',
    network,
    anchorMode: AnchorMode.Any,
    fee: 10000, // Higher fee for deployment
  };
  
  const transaction = await makeContractDeploy(txOptions);
  const broadcastResponse = await broadcastTransaction(transaction, network);
  
  console.log('Contract deployed!');
  console.log('Transaction ID:', broadcastResponse.txid);
  console.log('Contract address:', `${senderAddress}.${txOptions.contractName}`);
}
```

{% endcode %}


# Address Validation

Validate and format Stacks addresses and principals.

## Overview

Stacks addresses follow specific formats that differ between mainnet and testnet. Proper validation ensures your application handles addresses correctly, preventing loss of funds and improving user experience. This guide covers address validation, formatting, and conversion utilities.

## Basic address validation

Validate Stacks addresses:

{% code title="basic-validation.ts" %}

```ts
import { 
  validateStacksAddress,
  validateContractName
} from '@stacks/transactions';

// Validate standard addresses
const isValidMainnet = validateStacksAddress('SP2J6Y09JMFWWZCT4VJX0BA5W7A9HZP5EX96Y6VZY');
console.log('Valid mainnet:', isValidMainnet); // true

const isValidTestnet = validateStacksAddress('ST2JHG361ZXG51QTKY2NQCVBPPRRE2KZB1HR05NNC');
console.log('Valid testnet:', isValidTestnet); // true

const isInvalid = validateStacksAddress('invalid-address');
console.log('Valid:', isInvalid); // false

// Validate contract names
const validContract = validateContractName('my-contract');
console.log('Valid contract name:', validContract); // true

const invalidContract = validateContractName('My Contract!');
console.log('Valid contract name:', invalidContract); // false
```

{% endcode %}

## Address types and detection

Identify address types and networks:

{% code title="address-info.ts" %}

```ts
import { 
  getAddressFromPrivateKey,
  getAddressFromPublicKey,
  TransactionVersion
} from '@stacks/transactions';

// Detect address type from prefix
function getAddressInfo(address: string): {
  type: 'standard' | 'contract' | 'multisig' | 'invalid';
  network: 'mainnet' | 'testnet' | 'unknown';
} {
  if (!validateStacksAddress(address)) {
    return { type: 'invalid', network: 'unknown' };
  }
  
  // Mainnet prefixes
  if (address.startsWith('SP')) {
    return { type: 'standard', network: 'mainnet' };
  } else if (address.startsWith('SM')) {
    return { type: 'multisig', network: 'mainnet' };
  }
  
  // Testnet prefixes
  else if (address.startsWith('ST')) {
    return { type: 'standard', network: 'testnet' };
  } else if (address.startsWith('SN')) {
    return { type: 'multisig', network: 'testnet' };
  }
  
  // Contract address (contains .)
  if (address.includes('.')) {
    const [principal] = address.split('.');
    const info = getAddressInfo(principal);
    return { ...info, type: 'contract' };
  }
  
  return { type: 'invalid', network: 'unknown' };
}

// Usage
const info = getAddressInfo('SP2J6Y09JMFWWZCT4VJX0BA5W7A9HZP5EX96Y6VZY.my-contract');
console.log(info); // { type: 'contract', network: 'mainnet' }
```

{% endcode %}

## Address generation

Generate addresses from keys:

{% code title="address-generation.ts" %}

```ts
import {
  makeRandomPrivKey,
  getPublicKey,
  getAddressFromPrivateKey,
  getAddressFromPublicKey,
  TransactionVersion,
  AddressHashMode
} from '@stacks/transactions';

// Generate new random address
function generateNewAddress(network: 'mainnet' | 'testnet') {
  const privateKey = makeRandomPrivKey();
  const publicKey = getPublicKey(privateKey);
  
  const version = network === 'mainnet' 
    ? TransactionVersion.Mainnet 
    : TransactionVersion.Testnet;
  
  const address = getAddressFromPrivateKey(privateKey, version);
  
  return {
    privateKey,
    publicKey,
    address,
  };
}

// Generate address from existing private key
function getAddressFromKey(privateKey: string, network: 'mainnet' | 'testnet') {
  const version = network === 'mainnet'
    ? TransactionVersion.Mainnet
    : TransactionVersion.Testnet;
    
  return getAddressFromPrivateKey(privateKey, version);
}

// Generate multisig address
function generateMultisigAddress(
  publicKeys: string[],
  signaturesRequired: number,
  network: 'mainnet' | 'testnet'
) {
  const version = network === 'mainnet'
    ? TransactionVersion.Mainnet
    : TransactionVersion.Testnet;
    
  const hashMode = AddressHashMode.SerializeP2SH;
  
  // Implementation depends on multisig setup
  // This is a simplified example
  return getAddressFromPublicKey(
    publicKeys[0], // Simplified - real implementation needs all keys
    version,
    hashMode
  );
}
```

{% endcode %}

## Contract address handling

Work with contract principals:

{% code title="contract-address.ts" %}

```ts
// Parse contract address components
function parseContractAddress(contractAddress: string): {
  principal: string;
  contractName: string;
  isValid: boolean;
} {
  const parts = contractAddress.split('.');
  
  if (parts.length !== 2) {
    return { principal: '', contractName: '', isValid: false };
  }
  
  const [principal, contractName] = parts;
  
  const isValid = validateStacksAddress(principal) && 
                  validateContractName(contractName);
  
  return { principal, contractName, isValid };
}

// Build contract address
function buildContractAddress(principal: string, contractName: string): string {
  if (!validateStacksAddress(principal)) {
    throw new Error('Invalid principal address');
  }
  
  if (!validateContractName(contractName)) {
    throw new Error('Invalid contract name');
  }
  
  return `${principal}.${contractName}`;
}

// Validate full contract identifier
function validateContractAddress(address: string): boolean {
  const { isValid } = parseContractAddress(address);
  return isValid;
}

// Usage
const parsed = parseContractAddress('SP2J6Y09JMFWWZCT4VJX0BA5W7A9HZP5EX96Y6VZY.my-token');
console.log(parsed); 
// { principal: 'SP2J6...', contractName: 'my-token', isValid: true }
```

{% endcode %}

## Address conversion utilities

Convert between formats and networks:

{% code title="conversion-utils.ts" %}

```ts
import { c32addressDecode, c32address } from 'c32check';

// Convert between testnet and mainnet addresses
function convertAddressNetwork(
  address: string,
  toNetwork: 'mainnet' | 'testnet'
): string {
  try {
    // Decode the address
    const decoded = c32addressDecode(address);
    
    // Determine new version
    let newVersion: number;
    if (toNetwork === 'mainnet') {
      newVersion = decoded[0] === 26 ? 22 : 20; // Multi-sig or standard
    } else {
      newVersion = decoded[0] === 22 ? 26 : 21; // Multi-sig or standard
    }
    
    // Re-encode with new version
    const newAddress = c32address(newVersion, decoded[1]);
    return newAddress;
  } catch (error) {
    throw new Error('Invalid address format');
  }
}

// Extract address hash
function getAddressHash(address: string): string {
  const decoded = c32addressDecode(address);
  return Buffer.from(decoded[1]).toString('hex');
}

// Check if addresses are same (ignoring network)
function isSameAddress(addr1: string, addr2: string): boolean {
  try {
    const hash1 = getAddressHash(addr1);
    const hash2 = getAddressHash(addr2);
    return hash1 === hash2;
  } catch {
    return false;
  }
}
```

{% endcode %}

## Advanced validation patterns

### Comprehensive address validator

Create a robust validation system:

{% code title="address-validator.ts" %}

```ts
class AddressValidator {
  private cache = new Map<string, boolean>();
  
  validate(address: string, options?: {
    network?: 'mainnet' | 'testnet';
    allowContracts?: boolean;
    allowMultisig?: boolean;
  }): { valid: boolean; reason?: string } {
    // Check cache
    const cacheKey = `${address}-${JSON.stringify(options)}`;
    if (this.cache.has(cacheKey)) {
      return { valid: this.cache.get(cacheKey)! };
    }
    
    // Basic validation
    if (!validateStacksAddress(address)) {
      return { valid: false, reason: 'Invalid address format' };
    }
    
    const info = getAddressInfo(address);
    
    // Check network if specified
    if (options?.network && info.network !== options.network) {
      return { 
        valid: false, 
        reason: `Address is for ${info.network}, expected ${options.network}` 
      };
    }
    
    // Check contract addresses
    if (info.type === 'contract' && !options?.allowContracts) {
      return { valid: false, reason: 'Contract addresses not allowed' };
    }
    
    // Check multisig
    if (info.type === 'multisig' && !options?.allowMultisig) {
      return { valid: false, reason: 'Multisig addresses not allowed' };
    }
    
    // Cache result
    this.cache.set(cacheKey, true);
    
    return { valid: true };
  }
  
  validateBatch(addresses: string[], options?: any): Map<string, boolean> {
    const results = new Map<string, boolean>();
    
    for (const address of addresses) {
      const { valid } = this.validate(address, options);
      results.set(address, valid);
    }
    
    return results;
  }
}
```

{% endcode %}

### Address formatting

Format addresses for display:

{% code title="format-address.tsx" %}

```ts
function formatAddress(
  address: string,
  options?: {
    truncate?: boolean;
    length?: number;
    separator?: string;
  }
): string {
  if (!validateStacksAddress(address)) {
    return 'Invalid Address';
  }
  
  if (options?.truncate) {
    const length = options.length || 8;
    const start = address.slice(0, length);
    const end = address.slice(-length);
    const separator = options.separator || '...';
    return `${start}${separator}${end}`;
  }
  
  return address;
}

// Format for display with copy functionality
function AddressDisplay({ address }: { address: string }) {
  const [copied, setCopied] = useState(false);
  
  const formatted = formatAddress(address, { 
    truncate: true, 
    length: 6 
  });
  
  const copyToClipboard = () => {
    navigator.clipboard.writeText(address);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };
  
  return (
    <div className="address-display" onClick={copyToClipboard}>
      <code>{formatted}</code>
      {copied && <span>✓ Copied</span>}
    </div>
  );
}
```

{% endcode %}

## Input validation hooks

React hooks for address inputs:

{% code title="useAddressInput.tsx" %}

```ts
import { useState, useCallback } from 'react';

function useAddressInput(options?: {
  network?: 'mainnet' | 'testnet';
  allowContracts?: boolean;
}) {
  const [value, setValue] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [isValid, setIsValid] = useState(false);
  
  const validate = useCallback((address: string) => {
    if (!address) {
      setError(null);
      setIsValid(false);
      return;
    }
    
    const validator = new AddressValidator();
    const result = validator.validate(address, options);
    
    setError(result.reason || null);
    setIsValid(result.valid);
  }, [options]);
  
  const handleChange = useCallback((newValue: string) => {
    setValue(newValue);
    validate(newValue);
  }, [validate]);
  
  return {
    value,
    error,
    isValid,
    setValue: handleChange,
    validate,
  };
}

// Usage in component
function AddressInput() {
  const address = useAddressInput({ 
    network: 'mainnet',
    allowContracts: false 
  });
  
  return (
    <div>
      <input
        value={address.value}
        onChange={(e) => address.setValue(e.target.value)}
        placeholder="Enter Stacks address"
        className={address.error ? 'error' : ''}
      />
      {address.error && (
        <span className="error-message">{address.error}</span>
      )}
    </div>
  );
}
```

{% endcode %}

## Security considerations

Implement secure address handling:

{% code title="security.ts" %}

```ts
// Sanitize user input
function sanitizeAddress(input: string): string {
  // Remove whitespace and common separators
  return input.trim().replace(/[\s\-_]/g, '');
}

// Verify address ownership
async function verifyAddressOwnership(
  address: string,
  signature: string,
  message: string
): Promise<boolean> {
  try {
    // Verify the signature matches the address
    const verified = verifyMessageSignature({
      message,
      signature,
      publicKey: await getPublicKeyFromAddress(address),
    });
    
    return verified;
  } catch {
    return false;
  }
}

// Validate address for specific use case
function validateRecipientAddress(
  address: string,
  options: {
    blockList?: string[];
    allowList?: string[];
    requireMainnet?: boolean;
  }
): { valid: boolean; reason?: string } {
  // Check blocklist
  if (options.blockList?.includes(address)) {
    return { valid: false, reason: 'Address is blocked' };
  }
  
  // Check allowlist
  if (options.allowList && !options.allowList.includes(address)) {
    return { valid: false, reason: 'Address not in allowlist' };
  }
  
  // Check network
  const info = getAddressInfo(address);
  if (options.requireMainnet && info.network !== 'mainnet') {
    return { valid: false, reason: 'Mainnet address required' };
  }
  
  return { valid: true };
}
```

{% endcode %}

## Testing utilities

Test address validation:

{% code title="address-validation.test.ts" %}

```ts
import { describe, it, expect } from 'vitest';

describe('Address validation', () => {
  const validAddresses = [
    'SP2J6Y09JMFWWZCT4VJX0BA5W7A9HZP5EX96Y6VZY',
    'ST2JHG361ZXG51QTKY2NQCVBPPRRE2KZB1HR05NNC',
    'SP2J6Y09JMFWWZCT4VJX0BA5W7A9HZP5EX96Y6VZY.my-contract',
  ];
  
  const invalidAddresses = [
    'invalid',
    'SP2J6Y09JMFWWZCT4VJX0BA5W7A9HZP5EX96Y6VZ', // Too short
    'XP2J6Y09JMFWWZCT4VJX0BA5W7A9HZP5EX96Y6VZY', // Wrong prefix
    'SP2J6Y09JMFWWZCT4VJX0BA5W7A9HZP5EX96Y6VZY.', // Missing contract
  ];
  
  validAddresses.forEach(address => {
    it(`should validate ${address}`, () => {
      expect(validateStacksAddress(address)).toBe(true);
    });
  });
  
  invalidAddresses.forEach(address => {
    it(`should reject ${address}`, () => {
      expect(validateStacksAddress(address)).toBe(false);
    });
  });
});
```

{% endcode %}

## Best practices

* Always validate user input: Never trust addresses from users
* Check network compatibility: Ensure addresses match your network
* Handle edge cases: Contract addresses, multisig, etc.
* Cache validation results: Avoid redundant validation
* Provide clear error messages: Help users fix invalid inputs

## Common mistakes

Not checking network type:

{% code title="bad-vs-good-network.ts" %}

```ts
// Bad: Accepting any valid address
const isValid = validateStacksAddress(userInput);

// Good: Checking network matches
const info = getAddressInfo(userInput);
if (info.network !== 'mainnet') {
  throw new Error('Please use a mainnet address');
}
```

{% endcode %}

Assuming address format:

{% code title="bad-vs-good-parse.ts" %}

```ts
// Bad: Assuming standard address
const [principal, contract] = address.split('.');

// Good: Proper validation
const parsed = parseContractAddress(address);
if (!parsed.isValid) {
  throw new Error('Invalid contract address');
}
```

{% endcode %}


# Encoding & Decoding

Convert between Clarity values and JavaScript types.

## Overview

Stacks uses Clarity values (CVs) to represent data in smart contracts. When building applications, you'll need to encode JavaScript values into CVs for contract calls and decode CVs back to JavaScript for display. This guide covers all CV types and conversion patterns.

## Basic type conversions

### Integers

Convert between JavaScript numbers and Clarity integers:

{% code title="integers.ts" %}

```ts
import { 
  intCV, 
  uintCV, 
  cvToValue,
  cvToJSON 
} from '@stacks/transactions';

// Encoding
const positiveInt = uintCV(42);        // u42
const negativeInt = intCV(-100);       // -100
const largeUint = uintCV(1000000);     // u1000000

// Decoding
const jsValue = cvToValue(positiveInt); // 42
const jsonValue = cvToJSON(positiveInt); // { type: 'uint', value: '42' }

// Working with BigInt for large numbers
const bigNumber = uintCV(BigInt('123456789012345678901234567890'));
const decoded = cvToValue(bigNumber); // '123456789012345678901234567890'
```

{% endcode %}

### Booleans

Simple true/false values:

{% code title="booleans.ts" %}

```ts
import { trueCV, falseCV, boolCV } from '@stacks/transactions';

// Encoding
const clarityTrue = trueCV();          // true
const clarityFalse = falseCV();        // false
const fromBoolean = boolCV(true);      // true

// Decoding
const jsBoolean = cvToValue(clarityTrue); // true
```

{% endcode %}

### Strings

Handle ASCII and UTF-8 strings:

{% code title="strings.ts" %}

```ts
import { 
  stringAsciiCV, 
  stringUtf8CV,
  cvToString 
} from '@stacks/transactions';

// ASCII strings (limited character set)
const asciiString = stringAsciiCV('Hello World');
const asciiDecoded = cvToValue(asciiString); // 'Hello World'

// UTF-8 strings (full Unicode support)
const utf8String = stringUtf8CV('Hello 世界! 🌍');
const utf8Decoded = cvToValue(utf8String); // 'Hello 世界! 🌍'

// Direct string extraction
const directString = cvToString(utf8String); // 'Hello 世界! 🌍'
```

{% endcode %}

### Principals

Encode Stacks addresses and contract principals:

{% code title="principals.ts" %}

```ts
import { 
  standardPrincipalCV,
  contractPrincipalCV,
  cvToValue 
} from '@stacks/transactions';

// Standard principal (user address)
const userPrincipal = standardPrincipalCV('SP2J6Y09JMFWWZCT4VJX0BA5W7A9HZP5EX96Y6VZY');

// Contract principal
const contractPrincipal = contractPrincipalCV(
  'SP2J6Y09JMFWWZCT4VJX0BA5W7A9HZP5EX96Y6VZY',
  'my-contract'
);

// Decoding
const address = cvToValue(userPrincipal); 
// 'SP2J6Y09JMFWWZCT4VJX0BA5W7A9HZP5EX96Y6VZY'

const contract = cvToValue(contractPrincipal); 
// 'SP2J6Y09JMFWWZCT4VJX0BA5W7A9HZP5EX96Y6VZY.my-contract'
```

{% endcode %}

## Complex type handling

### Buffers

Work with binary data:

{% code title="buffers.ts" %}

```ts
import { 
  bufferCV,
  bufferCVFromString,
  cvToValue 
} from '@stacks/transactions';

// From hex string
const hexBuffer = bufferCV(Buffer.from('deadbeef', 'hex'));

// From UTF-8 string
const stringBuffer = bufferCVFromString('Hello Buffer');

// From byte array
const byteBuffer = bufferCV(new Uint8Array([1, 2, 3, 4]));

// Decoding returns hex string
const decoded = cvToValue(hexBuffer); // '0xdeadbeef'

// Get raw buffer
const rawBuffer = hexBuffer.buffer; // Buffer instance
```

{% endcode %}

### Optional values

Handle Clarity's optional type:

{% code title="optional.ts" %}

```ts
import { 
  someCV, 
  noneCV,
  cvToValue 
} from '@stacks/transactions';

// Some value (contains a value)
const someValue = someCV(uintCV(42));         // (some u42)
const someString = someCV(stringUtf8CV('hi')); // (some u"hi")

// None value (no value)
const noneValue = noneCV();                    // none

// Decoding
const decodedSome = cvToValue(someValue);  // 42
const decodedNone = cvToValue(noneValue);  // null

// Check optional type
if (someValue.type === ClarityType.OptionalSome) {
  const innerValue = cvToValue(someValue.value);
}
```

{% endcode %}

### Response values

Handle contract response types:

{% code title="response.ts" %}

```ts
import { 
  responseOkCV, 
  responseErrorCV,
  cvToValue 
} from '@stacks/transactions';

// Success response
const okResponse = responseOkCV(uintCV(100));      // (ok u100)
const okString = responseOkCV(stringUtf8CV('Success')); // (ok u"Success")

// Error response
const errorResponse = responseErrorCV(uintCV(404)); // (err u404)
const errorMsg = responseErrorCV(stringUtf8CV('Not found')); // (err u"Not found")

// Decoding and checking
const result = okResponse;
if (result.type === ClarityType.ResponseOk) {
  console.log('Success:', cvToValue(result.value));
} else {
  console.log('Error:', cvToValue(result.value));
}
```

{% endcode %}

### Tuples

Create and decode structured data:

{% code title="tuple.ts" %}

```ts
import { 
  tupleCV,
  cvToValue,
  cvToJSON 
} from '@stacks/transactions';

// Create tuple
const userInfo = tupleCV({
  id: uintCV(1),
  name: stringUtf8CV('Alice'),
  balance: uintCV(1000000),
  active: trueCV(),
  metadata: tupleCV({
    created: uintCV(Date.now()),
    tags: listCV([stringAsciiCV('user'), stringAsciiCV('premium')])
  })
});

// Decode to JavaScript object
const decoded = cvToValue(userInfo);
// {
//   id: 1,
//   name: 'Alice',
//   balance: 1000000,
//   active: true,
//   metadata: {
//     created: 1234567890,
//     tags: ['user', 'premium']
//   }
// }

// Access tuple fields
const nameCV = userInfo.data.name;
const name = cvToValue(nameCV); // 'Alice'
```

{% endcode %}

### Lists

Work with arrays of values:

{% code title="lists.ts" %}

```ts
import { 
  listCV,
  cvToValue 
} from '@stacks/transactions';

// List of same type
const numbers = listCV([uintCV(1), uintCV(2), uintCV(3)]);
const strings = listCV([
  stringUtf8CV('apple'),
  stringUtf8CV('banana'),
  stringUtf8CV('cherry')
]);

// List of tuples (common pattern)
const users = listCV([
  tupleCV({ id: uintCV(1), name: stringUtf8CV('Alice') }),
  tupleCV({ id: uintCV(2), name: stringUtf8CV('Bob') }),
]);

// Decoding
const decodedNumbers = cvToValue(numbers); // [1, 2, 3]
const decodedUsers = cvToValue(users); 
// [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }]

// Iterate over list
numbers.list.forEach((cv, index) => {
  console.log(`Item ${index}:`, cvToValue(cv));
});
```

{% endcode %}

## Advanced encoding patterns

### Dynamic type encoding

Build encoders for runtime values:

{% code title="dynamic-encoder.ts" %}

```ts
function encodeValue(value: any): ClarityValue {
  if (typeof value === 'number') {
    return value >= 0 ? uintCV(value) : intCV(value);
  } else if (typeof value === 'string') {
    // Check if valid ASCII
    if (/^[\x00-\x7F]*$/.test(value)) {
      return stringAsciiCV(value);
    }
    return stringUtf8CV(value);
  } else if (typeof value === 'boolean') {
    return boolCV(value);
  } else if (value === null || value === undefined) {
    return noneCV();
  } else if (Array.isArray(value)) {
    return listCV(value.map(encodeValue));
  } else if (typeof value === 'object') {
    const tupleData: { [key: string]: ClarityValue } = {};
    for (const [key, val] of Object.entries(value)) {
      tupleData[key] = encodeValue(val);
    }
    return tupleCV(tupleData);
  }
  
  throw new Error(`Cannot encode value: ${value}`);
}

// Usage
const encoded = encodeValue({
  name: 'Alice',
  age: 30,
  tags: ['user', 'admin'],
  active: true
});
```

{% endcode %}

### Type-safe decoding

Create decoders with type validation:

{% code title="decode-user.ts" %}

```ts
interface UserData {
  id: number;
  name: string;
  balance: number;
  active: boolean;
}

function decodeUser(cv: ClarityValue): UserData {
  if (cv.type !== ClarityType.Tuple) {
    throw new Error('Expected tuple');
  }
  
  const data = cv.data;
  
  // Validate and extract each field
  if (!data.id || data.id.type !== ClarityType.UInt) {
    throw new Error('Invalid id field');
  }
  
  if (!data.name || (
    data.name.type !== ClarityType.StringASCII && 
    data.name.type !== ClarityType.StringUTF8
  )) {
    throw new Error('Invalid name field');
  }
  
  return {
    id: Number(cvToValue(data.id)),
    name: cvToString(data.name),
    balance: Number(cvToValue(data.balance)),
    active: cvToValue(data.active) as boolean,
  };
}
```

{% endcode %}

### Batch encoding utilities

Encode multiple values efficiently:

{% code title="clarity-encoder.ts" %}

```ts
class ClarityEncoder {
  static encodeArray<T>(
    items: T[],
    encoder: (item: T) => ClarityValue
  ): ClarityValue {
    return listCV(items.map(encoder));
  }
  
  static encodeTuple<T extends Record<string, any>>(
    obj: T,
    schema: { [K in keyof T]: (value: T[K]) => ClarityValue }
  ): TupleCV {
    const tupleData: { [key: string]: ClarityValue } = {};
    
    for (const [key, encoder] of Object.entries(schema)) {
      tupleData[key] = encoder(obj[key as keyof T]);
    }
    
    return tupleCV(tupleData);
  }
  
  static encodeOptional<T>(
    value: T | null | undefined,
    encoder: (value: T) => ClarityValue
  ): OptionalCV {
    if (value === null || value === undefined) {
      return noneCV();
    }
    return someCV(encoder(value));
  }
}

// Usage
const users = [
  { id: 1, name: 'Alice', balance: 1000 },
  { id: 2, name: 'Bob', balance: 2000 },
];

const encoded = ClarityEncoder.encodeArray(users, user =>
  ClarityEncoder.encodeTuple(user, {
    id: (id) => uintCV(id),
    name: (name) => stringUtf8CV(name),
    balance: (balance) => uintCV(balance),
  })
);
```

{% endcode %}

## Serialization and deserialization

Work with serialized Clarity values:

{% code title="serialization.ts" %}

```ts
import { 
  serializeCV,
  deserializeCV,
  cvToHex,
  hexToCV 
} from '@stacks/transactions';

// Serialize to buffer
const cv = tupleCV({ amount: uintCV(1000), memo: stringUtf8CV('Payment') });
const serialized = serializeCV(cv); // Buffer

// Convert to hex for storage/transport
const hex = cvToHex(cv); // '0x0c00000002046d656d6f...'

// Deserialize from hex
const deserialized = hexToCV(hex);
const value = cvToValue(deserialized); // { amount: 1000, memo: 'Payment' }

// Work with raw buffers
const buffer = Buffer.from(hex, 'hex');
const fromBuffer = deserializeCV(buffer);
```

{% endcode %}

## Common conversion patterns

### Contract call arguments

Prepare arguments for contract calls:

{% code title="prepare-args.ts" %}

```ts
function prepareTransferArgs(
  recipient: string,
  amount: number,
  memo?: string
): ClarityValue[] {
  const args = [
    standardPrincipalCV(recipient),
    uintCV(amount),
  ];
  
  if (memo) {
    args.push(someCV(stringUtf8CV(memo)));
  } else {
    args.push(noneCV());
  }
  
  return args;
}

// Usage in contract call
const functionArgs = prepareTransferArgs(
  'SP2J6Y09JMFWWZCT4VJX0BA5W7A9HZP5EX96Y6VZY',
  1000000,
  'Monthly payment'
);
```

{% endcode %}

### Response handling

Process contract responses:

{% code title="handle-response.ts" %}

```ts
function handleContractResponse(response: ClarityValue): {
  success: boolean;
  data: any;
  error?: string;
} {
  if (response.type === ClarityType.ResponseOk) {
    return {
      success: true,
      data: cvToValue(response.value),
    };
  } else if (response.type === ClarityType.ResponseErr) {
    const errorValue = cvToValue(response.value);
    return {
      success: false,
      data: null,
      error: typeof errorValue === 'string' ? errorValue : `Error: ${errorValue}`,
    };
  }
  
  throw new Error('Invalid response type');
}
```

{% endcode %}

## Best practices

{% hint style="info" %}

* Validate types: Always check CV types before decoding
* Handle edge cases: Consider null, undefined, and empty values
* Use appropriate string types: ASCII for simple text, UTF-8 for international
* Preserve precision: Use BigInt for large numbers
* Type narrowing: Use TypeScript type guards for safety
  {% endhint %}

## Common mistakes

<details>

<summary>String type confusion</summary>

```ts
// Bad: Using ASCII for Unicode
const bad = stringAsciiCV('Hello 世界'); // Will throw error

// Good: Use UTF-8 for Unicode
const good = stringUtf8CV('Hello 世界');
```

</details>

<details>

<summary>Number overflow</summary>

```ts
// Bad: JavaScript number too large
const bad = uintCV(Number.MAX_SAFE_INTEGER + 1); // Precision loss

// Good: Use BigInt
const good = uintCV(BigInt('9007199254740992'));
```

</details>


# Network Configuration

Configure and customize Stacks network connections.

## Overview

Stacks.js supports multiple networks—mainnet for production, testnet for development, and custom networks for local testing. Proper network configuration ensures your app connects to the right blockchain instance with optimal settings.

## Basic network setup

Configure standard networks:

```ts
import {
  StacksMainnet,
  StacksTestnet,
  StacksMocknet
} from '@stacks/network';

// Production network
const mainnet = new StacksMainnet();
console.log('Mainnet API:', mainnet.coreApiUrl);
// https://api.hiro.so

// Test network
const testnet = new StacksTestnet();
console.log('Testnet API:', testnet.coreApiUrl);
// https://api.testnet.hiro.so

// Local development network
const mocknet = new StacksMocknet();
console.log('Mocknet API:', mocknet.coreApiUrl);
// http://localhost:3999
```

## Custom network configuration

Create networks with custom endpoints:

```ts
import { StacksNetwork } from '@stacks/network';

// Custom mainnet configuration
const customMainnet = new StacksMainnet({
  url: 'https://my-custom-node.com',
  fetchFn: fetch, // Custom fetch implementation
});

// Custom testnet with specific endpoints
const customTestnet = new StacksTestnet({
  url: 'https://my-testnet-node.com:3999',
});

// Fully custom network
class CustomNetwork extends StacksNetwork {
  constructor() {
    super({
      url: 'https://custom-stacks-node.com',
      networkType: 'mainnet', // or 'testnet', 'mocknet'
    });
  }

  // Override methods as needed
  getBroadcastApiUrl() {
    return `${this.coreApiUrl}/custom/broadcast`;
  }
}
```

## Environment-based configuration

Manage networks across environments:

```ts
// config/network.ts
import {
  StacksNetwork,
  StacksMainnet,
  StacksTestnet,
  StacksMocknet
} from '@stacks/network';

interface NetworkConfig {
  network: StacksNetwork;
  apiUrl: string;
  wsUrl?: string;
  explorerUrl: string;
  faucetUrl?: string;
}

const configs: Record<string, NetworkConfig> = {
  production: {
    network: new StacksMainnet(),
    apiUrl: 'https://api.hiro.so',
    wsUrl: 'wss://api.hiro.so',
    explorerUrl: 'https://explorer.hiro.so',
  },
  staging: {
    network: new StacksTestnet(),
    apiUrl: 'https://api.testnet.hiro.so',
    wsUrl: 'wss://api.testnet.hiro.so',
    explorerUrl: 'https://explorer.hiro.so/?chain=testnet',
    faucetUrl: 'https://api.testnet.hiro.so/extended/v1/faucets/stx',
  },
  development: {
    network: new StacksMocknet(),
    apiUrl: 'http://localhost:3999',
    explorerUrl: 'http://localhost:8000',
  },
};

export function getNetworkConfig(): NetworkConfig {
  const env = process.env.NODE_ENV || 'development';
  return configs[env];
}

// Usage
const { network, apiUrl } = getNetworkConfig();
```

## Network detection and validation

Detect and validate network connections:

```ts
async function detectNetwork(url: string): Promise<'mainnet' | 'testnet' | 'unknown'> {
  try {
    const response = await fetch(`${url}/v2/info`);
    const info = await response.json();

    // Check network ID
    if (info.network_id === 1) {
      return 'mainnet';
    } else if (info.network_id === 2147483648) {
      return 'testnet';
    }

    return 'unknown';
  } catch (error) {
    console.error('Failed to detect network:', error);
    return 'unknown';
  }
}

// Validate network matches expectation
async function validateNetwork(
  network: StacksNetwork,
  expected: 'mainnet' | 'testnet'
): Promise<boolean> {
  const detected = await detectNetwork(network.coreApiUrl);

  if (detected !== expected) {
    console.warn(`Network mismatch! Expected ${expected}, got ${detected}`);
    return false;
  }

  return true;
}
```

## Advanced network features

### Custom headers and authentication

Add authentication or custom headers:

```ts
class AuthenticatedNetwork extends StacksMainnet {
  private apiKey: string;

  constructor(apiKey: string) {
    super();
    this.apiKey = apiKey;
  }

  createFetchFn(): FetchFn {
    return (url: string, init?: RequestInit) => {
      const headers = {
        ...init?.headers,
        'x-api-key': this.apiKey,
        'x-client-version': '1.0.0',
      };

      return fetch(url, { ...init, headers });
    };
  }
}

// Usage
const network = new AuthenticatedNetwork(process.env.API_KEY!);
```

### Request retry and timeout

Implement resilient network requests:

```ts
class ResilientNetwork extends StacksTestnet {
  private maxRetries = 3;
  private timeout = 30000; // 30 seconds

  createFetchFn(): FetchFn {
    return async (url: string, init?: RequestInit) => {
      for (let attempt = 0; attempt < this.maxRetries; attempt++) {
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), this.timeout);

          const response = await fetch(url, {
            ...init,
            signal: controller.signal,
          });

          clearTimeout(timeoutId);

          if (!response.ok && attempt < this.maxRetries - 1) {
            // Retry on server errors
            if (response.status >= 500) {
              await this.delay(1000 * Math.pow(2, attempt));
              continue;
            }
          }

          return response;
        } catch (error) {
          if (attempt === this.maxRetries - 1) throw error;
          await this.delay(1000 * Math.pow(2, attempt));
        }
      }

      throw new Error('Max retries exceeded');
    };
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

## Network-specific configurations

### Configure by chain ID

Set up network based on chain identifier:

```ts
function getNetworkByChainId(chainId: number): StacksNetwork {
  switch (chainId) {
    case 1: // Mainnet
      return new StacksMainnet();
    case 2147483648: // Testnet
      return new StacksTestnet();
    default:
      throw new Error(`Unknown chain ID: ${chainId}`);
  }
}

// Dynamic network from wallet
async function getNetworkFromWallet(): Promise<StacksNetwork> {
  const userData = userSession.loadUserData();
  const address = userData.profile.stxAddress.testnet;

  // Determine network from address prefix
  if (address.startsWith('SP') || address.startsWith('SM')) {
    return new StacksMainnet();
  } else if (address.startsWith('ST') || address.startsWith('SN')) {
    return new StacksTestnet();
  }

  throw new Error('Unable to determine network from address');
}
```

### Multi-network support

Support multiple networks simultaneously:

```ts
class NetworkManager {
  private networks: Map<string, StacksNetwork> = new Map();
  private currentNetwork: string = 'testnet';

  constructor() {
    this.networks.set('mainnet', new StacksMainnet());
    this.networks.set('testnet', new StacksTestnet());
    this.networks.set('devnet', new StacksMocknet());
  }

  getNetwork(name?: string): StacksNetwork {
    const networkName = name || this.currentNetwork;
    const network = this.networks.get(networkName);

    if (!network) {
      throw new Error(`Unknown network: ${networkName}`);
    }

    return network;
  }

  setCurrentNetwork(name: string): void {
    if (!this.networks.has(name)) {
      throw new Error(`Unknown network: ${name}`);
    }
    this.currentNetwork = name;
  }

  addCustomNetwork(name: string, url: string): void {
    const network = new StacksNetwork({ url });
    this.networks.set(name, network);
  }
}

// Usage
const manager = new NetworkManager();
const mainnet = manager.getNetwork('mainnet');
manager.setCurrentNetwork('mainnet');
```

## Network connection monitoring

Monitor network health and status:

```ts
class NetworkMonitor {
  private network: StacksNetwork;
  private isHealthy = true;
  private listeners: Set<(healthy: boolean) => void> = new Set();

  constructor(network: StacksNetwork) {
    this.network = network;
    this.startMonitoring();
  }

  private async startMonitoring() {
    setInterval(async () => {
      try {
        const response = await fetch(
          `${this.network.coreApiUrl}/v2/info`,
          { signal: AbortSignal.timeout(5000) }
        );

        const wasHealthy = this.isHealthy;
        this.isHealthy = response.ok;

        if (wasHealthy !== this.isHealthy) {
          this.notifyListeners();
        }
      } catch (error) {
        const wasHealthy = this.isHealthy;
        this.isHealthy = false;

        if (wasHealthy) {
          this.notifyListeners();
        }
      }
    }, 30000); // Check every 30 seconds
  }

  onHealthChange(callback: (healthy: boolean) => void): () => void {
    this.listeners.add(callback);
    return () => this.listeners.delete(callback);
  }

  private notifyListeners() {
    this.listeners.forEach(callback => callback(this.isHealthy));
  }

  async waitForHealth(timeout = 60000): Promise<void> {
    const start = Date.now();

    while (!this.isHealthy && Date.now() - start < timeout) {
      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    if (!this.isHealthy) {
      throw new Error('Network unhealthy after timeout');
    }
  }
}
```

## WebSocket configuration

Set up real-time connections:

```ts
interface WebSocketConfig {
  url: string;
  reconnectInterval: number;
  maxReconnectAttempts: number;
}

class StacksWebSocketClient {
  private ws: WebSocket | null = null;
  private config: WebSocketConfig;
  private reconnectAttempts = 0;

  constructor(network: StacksNetwork) {
    this.config = {
      url: this.getWebSocketUrl(network),
      reconnectInterval: 5000,
      maxReconnectAttempts: 10,
    };
  }

  private getWebSocketUrl(network: StacksNetwork): string {
    const apiUrl = network.coreApiUrl;
    return apiUrl.replace('https://', 'wss://').replace('http://', 'ws://');
  }

  connect(): void {
    this.ws = new WebSocket(this.config.url);

    this.ws.onopen = () => {
      console.log('WebSocket connected');
      this.reconnectAttempts = 0;
    };

    this.ws.onclose = () => {
      this.handleReconnect();
    };

    this.ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
  }

  private handleReconnect(): void {
    if (this.reconnectAttempts < this.config.maxReconnectAttempts) {
      setTimeout(() => {
        this.reconnectAttempts++;
        this.connect();
      }, this.config.reconnectInterval);
    }
  }

  subscribe(event: string, callback: (data: any) => void): void {
    if (!this.ws) throw new Error('WebSocket not connected');

    this.ws.send(JSON.stringify({
      method: 'subscribe',
      params: { event }
    }));

    this.ws.onmessage = (message) => {
      const data = JSON.parse(message.data);
      if (data.event === event) {
        callback(data);
      }
    };
  }
}
```

## Testing with different networks

Set up tests across networks:

```ts
import { describe, it, beforeEach } from 'vitest';

describe('Cross-network tests', () => {
  const networks = [
    { name: 'mainnet', network: new StacksMainnet() },
    { name: 'testnet', network: new StacksTestnet() },
  ];

  networks.forEach(({ name, network }) => {
    describe(`${name} tests`, () => {
      it('should connect to network', async () => {
        const response = await fetch(`${network.coreApiUrl}/v2/info`);
        expect(response.ok).toBe(true);
      });

      it('should have correct chain ID', async () => {
        const response = await fetch(`${network.coreApiUrl}/v2/info`);
        const info = await response.json();

        if (name === 'mainnet') {
          expect(info.network_id).toBe(1);
        } else {
          expect(info.network_id).toBe(2147483648);
        }
      });
    });
  });
});
```

## Best practices

* Use environment variables: Never hardcode network URLs
* Implement retry logic: Networks can be temporarily unavailable
* Monitor connection health: Detect and handle network issues
* Cache network info: Reduce redundant API calls
* Validate network type: Ensure you're on the expected network

## Common issues

<details>

<summary>CORS errors</summary>

```ts
// Configure proxy for development
const devNetwork = new StacksTestnet({
  url: '/api', // Proxy through your dev server
});

// Or use CORS-enabled endpoints
const corsNetwork = new StacksTestnet({
  url: 'https://api.testnet.hiro.so',
});
```

</details>

<details>

<summary>Timeout handling</summary>

```ts
// Add timeout to all requests
class TimeoutNetwork extends StacksMainnet {
  async fetchWithTimeout(url: string, timeout = 30000): Promise<Response> {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);

    try {
      const response = await fetch(url, {
        signal: controller.signal,
      });
      clearTimeout(id);
      return response;
    } catch (error) {
      clearTimeout(id);
      throw new Error(`Request timeout: ${url}`);
    }
  }
}
```

</details>


# Unit Conversion

Learn how to convert between different unit denominations in Stacks. The blockchain uses microSTX as its base unit, where 1 STX = 1,000,000 microSTX. Proper unit conversion is essential for displaying amounts to users and processing transactions.

## Basic conversions

Convert between STX and microSTX using simple conversion functions.

{% code title="basic-conversions.ts" %}

```ts
// Convert STX to microSTX
function stxToMicroStx(stx: number | string): bigint {
  const stxAmount = typeof stx === 'string' ? parseFloat(stx) : stx;
  return BigInt(Math.floor(stxAmount * 1_000_000));
}

// Convert microSTX to STX
function microStxToStx(microStx: number | bigint | string): string {
  const amount = BigInt(microStx);
  const stx = Number(amount) / 1_000_000;
  return stx.toFixed(6).replace(/\.?0+$/, '');
}

// Usage examples
const microStx = stxToMicroStx(1.5);      // 1500000n
const stx = microStxToStx(1500000);       // "1.5"
```

{% endcode %}

## Precision-safe handling

Handle large numbers without precision loss using BigInt operations.

{% code title="precision-safe.ts" %}

```ts
class StxConverter {
  static readonly MICROSTX_PER_STX = 1_000_000n;
  
  static toMicroStx(amount: string | number, decimals = 6): bigint {
    const amountStr = amount.toString();
    const [whole, decimal = ''] = amountStr.split('.');
    const paddedDecimal = decimal.padEnd(decimals, '0').slice(0, decimals);
    return BigInt(whole + paddedDecimal);
  }
  
  static toStx(microStx: bigint | string | number): string {
    const amount = BigInt(microStx);
    const isNegative = amount < 0n;
    const absoluteAmount = isNegative ? -amount : amount;
    
    const str = absoluteAmount.toString().padStart(7, '0');
    const whole = str.slice(0, -6) || '0';
    const decimal = str.slice(-6);
    
    let result = `${whole}.${decimal}`.replace(/\.?0+$/, '');
    return isNegative ? `-${result}` : result;
  }
}

// Precise conversion examples
const precise1 = StxConverter.toMicroStx('123.456789'); // 123456789n
const precise2 = StxConverter.toStx(123456789n);        // "123.456789"
```

{% endcode %}

## Token conversions

Handle tokens with different decimal places using a flexible converter class.

{% code title="token-converter.ts" %}

```ts
interface TokenInfo {
  decimals: number;
  symbol: string;
  name: string;
}

class TokenConverter {
  constructor(private tokenInfo: TokenInfo) {}
  
  toSmallestUnit(amount: string | number): bigint {
    if (typeof amount === 'string') {
      const [whole, decimal = ''] = amount.split('.');
      const paddedDecimal = decimal
        .padEnd(this.tokenInfo.decimals, '0')
        .slice(0, this.tokenInfo.decimals);
      return BigInt(whole + paddedDecimal);
    }
    
    const multiplier = 10n ** BigInt(this.tokenInfo.decimals);
    return BigInt(Math.floor(amount * Number(multiplier)));
  }
  
  fromSmallestUnit(amount: bigint | string): string {
    const value = BigInt(amount);
    const divisor = 10n ** BigInt(this.tokenInfo.decimals);
    const whole = value / divisor;
    const remainder = value % divisor;
    
    if (remainder === 0n) return whole.toString();
    
    const decimal = remainder
      .toString()
      .padStart(this.tokenInfo.decimals, '0')
      .replace(/0+$/, '');
    
    return `${whole}.${decimal}`;
  }
}

// Different token examples
const usdc = new TokenConverter({ decimals: 6, symbol: 'USDC', name: 'USD Coin' });
const btc = new TokenConverter({ decimals: 8, symbol: 'BTC', name: 'Bitcoin' });

const usdcAmount = usdc.toSmallestUnit('100.50');     // 100500000n
const btcAmount = btc.toSmallestUnit('0.00123456');   // 123456n
```

{% endcode %}

## Display formatting

Format amounts for user interfaces with localization support.

{% code title="stx-formatter.ts" %}

```ts
class StxFormatter {
  static format(microStx: bigint, options?: {
    decimals?: number;
    locale?: string;
    symbol?: boolean;
  }): string {
    const stx = StxConverter.toStx(microStx);
    const number = parseFloat(stx);
    
    const formatted = new Intl.NumberFormat(options?.locale || 'en-US', {
      minimumFractionDigits: 0,
      maximumFractionDigits: options?.decimals ?? 6,
    }).format(number);
    
    return options?.symbol ? `${formatted} STX` : formatted;
  }
  
  static compact(microStx: bigint): string {
    const stx = Number(StxConverter.toStx(microStx));
    
    if (stx >= 1_000_000) {
      return `${(stx / 1_000_000).toFixed(2)}M STX`;
    } else if (stx >= 1_000) {
      return `${(stx / 1_000).toFixed(2)}K STX`;
    }
    
    return this.format(microStx, { decimals: 6, symbol: true });
  }
}

// Formatting examples
const formatted = StxFormatter.format(123456789n, {
  decimals: 2,
  symbol: true
}); // "123.46 STX"

const compact = StxFormatter.compact(1234567890000n); // "1.23K STX"
```

{% endcode %}

## Input validation

Validate and sanitize user input for amount fields.

{% code title="amount-input.ts" %}

```ts
class AmountInput {
  static validate(input: string, options?: {
    decimals?: number;
    min?: string;
    max?: string;
  }): { valid: boolean; error?: string } {
    // Check format
    if (!/^\d*\.?\d*$/.test(input)) {
      return { valid: false, error: 'Invalid number format' };
    }
    
    // Check decimal places
    const parts = input.split('.');
    if (parts[1] && parts[1].length > (options?.decimals || 6)) {
      return { valid: false, error: `Maximum ${options?.decimals || 6} decimal places` };
    }
    
    // Check range
    if (options?.min) {
      const value = parseFloat(input);
      if (value < parseFloat(options.min)) {
        return { valid: false, error: `Minimum amount is ${options.min}` };
      }
    }
    
    return { valid: true };
  }
  
  static sanitize(input: string, decimals = 6): string {
    let sanitized = input.replace(/[^\d.]/g, '');
    const parts = sanitized.split('.');
    
    if (parts.length > 2) {
      sanitized = parts[0] + '.' + parts.slice(1).join('');
    }
    
    if (parts[1] && parts[1].length > decimals) {
      sanitized = parts[0] + '.' + parts[1].slice(0, decimals);
    }
    
    return sanitized;
  }
}

// Validation examples
const result1 = AmountInput.validate('123.456', { 
  decimals: 6, 
  min: '0.000001' 
}); // { valid: true }

const result2 = AmountInput.validate('123.4567890', { 
  decimals: 6 
}); // { valid: false, error: 'Maximum 6 decimal places' }
```

{% endcode %}


# React Native Integration

Stacks.js can be integrated into React Native applications to bring blockchain functionality to mobile devices. This tutorial walks you through setting up a React Native project with Expo and configuring it to work with Stacks.js libraries.

## Objectives

* Set up an Expo project configured for Stacks.js
* Install and configure necessary polyfills for React Native
* Generate wallets and sign transactions in a mobile app
* Handle React Native's JavaScript environment limitations
* Build a working Stacks mobile application

## Prerequisites

* Node.js and npm installed on your development machine
* Basic knowledge of React Native and Expo
* Familiarity with Stacks.js concepts
* iOS or Android device or simulator for testing

## Set up the Expo project

Start by creating a new Expo project. The latest version of Expo provides the best compatibility with Stacks.js polyfills.

```bash
npx create-expo-app@latest my-stacks-app
cd my-stacks-app
```

The boilerplate project includes everything needed to start building. Test the initial setup by running the development server.

```bash
npm start
```

Connect your mobile device using the Expo Go app and scan the QR code to verify the base project works correctly.

## Install necessary dependencies

React Native's JavaScript environment lacks certain Node.js and browser APIs that Stacks.js requires. Install the core Stacks libraries along with necessary polyfills.

```bash
npm install @stacks/transactions @stacks/wallet-sdk
```

Install the polyfill dependencies as dev dependencies to handle missing APIs.

```bash
npm install --save-dev buffer process react-native-get-random-values \
  text-encoding readable-stream crypto-browserify @peculiar/webcrypto
```

These polyfills provide:

* `buffer` and `process` for Node.js globals
* `react-native-get-random-values` for crypto random values
* `text-encoding` for `TextEncoder` and `TextDecoder`
* `crypto-browserify` and `@peculiar/webcrypto` for cryptographic functions

## Configure Metro bundler

Metro bundler needs configuration to properly resolve Node.js modules. Create a custom Metro configuration file.

```bash
npx expo customize metro.config.js
```

Update `metro.config.js` to map Node.js modules to their React Native-compatible versions.

```ts
const { getDefaultConfig } = require('expo/metro-config');

const config = getDefaultConfig(__dirname);

config.resolver.extraNodeModules = {
  stream: require.resolve('readable-stream'),
  crypto: require.resolve('crypto-browserify'),
};

module.exports = config;
```

This configuration ensures that when Stacks.js requests Node.js modules, Metro provides the appropriate polyfills.

## Set up global polyfills

Create a polyfill system to make browser and Node.js APIs available in React Native. This requires modifying the app's entry point.

### Create the polyfill file

Create `polyfill.js` to initialize the required global objects.

```ts
import { Buffer } from 'buffer/';
import process from 'process';
import 'react-native-get-random-values';
import { TextDecoder, TextEncoder } from 'text-encoding';

global.process = process;
global.Buffer = Buffer;
global.TextEncoder = TextEncoder;
global.TextDecoder = TextDecoder;
```

### Create a custom entry point

Create `index.js` so the app loads polyfills before the UI renders.

```ts
import './polyfill';
import { Crypto } from '@peculiar/webcrypto';

Object.assign(global.crypto, new Crypto());

import 'expo-router/entry';
```

{% hint style="warning" %}
Runtime initialization errors: Polyfills must be loaded in separate files as shown. Loading them in the same file can cause runtime initialization errors.
{% endhint %}

### Update package.json

Point the app to use the new entry point.

```json
{
  "main": "index.js"
}
```

## Implement Stacks functionality

With the environment configured, you can now use Stacks.js in your React Native components. Update the main screen to demonstrate wallet generation and transaction signing.

### Import Stacks.js modules

Edit `app/(tabs)/index.tsx` to import the necessary Stacks.js functions.

```ts
import {
  TransactionVersion,
  getAddressFromPrivateKey,
  makeSTXTokenTransfer,
} from '@stacks/transactions';
import { Wallet, generateSecretKey, generateWallet } from '@stacks/wallet-sdk';
import { useState } from 'react';
import { Button } from 'react-native';
```

### Set up component state

Create state variables to manage wallet data and user feedback.

```ts
export default function HomeScreen() {
  const [mnemonic, setMnemonic] = useState('Press button to generate');
  const [wallet, setWallet] = useState<Wallet | null>(null);
  const [log, setLog] = useState('');

  // Component implementation continues...
}
```

### Generate a wallet and sign a transaction

Implement the core functionality to create a wallet and sign a transaction.

```ts
const generate = async () => {
  try {
    const mnemonic = generateSecretKey();
    setMnemonic(mnemonic);

    const wallet = await generateWallet({
      secretKey: mnemonic,
      password: '',
    });
    setWallet(wallet);

    const txOptions = {
      amount: 1000,
      anchorMode: 'any' as const,
      recipient: 'SP3W993D3BRDYB284CY3SBFDEGTC5XEDJPDEA21CN',
      senderKey: wallet.accounts[0].stxPrivateKey,
      fee: 300,
      network: 'testnet' as const,
      nonce: 0,
    };

    const transaction = await makeSTXTokenTransfer(txOptions);
    setLog('Transaction signed successfully');
  } catch (error) {
    setLog(`Error: ${error.message}`);
  }
};
```

### Build the user interface

Show wallet information and trigger wallet generation from the UI.

```ts
return (
  <ThemedView style={{ padding: 20 }}>
    <ThemedText type="title">Stacks Wallet Demo</ThemedText>

    <ThemedView style={{ marginVertical: 20 }}>
      <ThemedText type="subtitle">Seed Phrase</ThemedText>
      <ThemedText style={{ marginBottom: 10 }}>{mnemonic}</ThemedText>
      <Button title="Generate New Wallet" onPress={generate} />
    </ThemedView>

    {wallet && (
      <ThemedView style={{ marginVertical: 20 }}>
        <ThemedText type="subtitle">Wallet Address</ThemedText>
        <ThemedText>
          {getAddressFromPrivateKey(
            wallet.accounts[0].stxPrivateKey,
            TransactionVersion.Testnet
          )}
        </ThemedText>
      </ThemedView>
    )}

    {log && (
      <ThemedView style={{ marginTop: 20 }}>
        <ThemedText type="subtitle">Status</ThemedText>
        <ThemedText>{log}</ThemedText>
      </ThemedView>
    )}
  </ThemedView>
);
```

## Test your implementation

Run the app to verify everything works correctly.

```bash
npm start
```

{% stepper %}
{% step %}
**Generate new wallet**

Press "Generate New Wallet". A new seed phrase appears.
{% endstep %}

{% step %}
**Wallet address**

After generation, the wallet address displays below.
{% endstep %}

{% step %}
**Sign transaction**

A transaction is signed (not broadcast) using the generated wallet.
{% endstep %}

{% step %}
**Confirm success**

A success message confirms signing.
{% endstep %}
{% endstepper %}

{% hint style="info" %}
Secure storage: For production apps, never display seed phrases directly. Use secure storage libraries such as `react-native-keychain` or `expo-secure-store`.
{% endhint %}

## Try it out

Extend the basic implementation with additional features.

```ts
// Challenge: Add a function to check STX balance
const checkBalance = async (address: string) => {
  // Implement balance checking
  // Hint: You'll need to use @stacks/blockchain-api-client
};

// Challenge: Implement transaction broadcasting
const broadcastTransaction = async (transaction: StacksTransaction) => {
  // Implement broadcasting logic
  // Remember to handle network selection
};
```


# Connect Wallet

Learn how to integrate wallet connections into your Stacks application. Connecting a wallet authenticates users and enables blockchain interactions like transfers and contract calls.

<figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2Fgit-blob-521c9e1b18c41dfdbdc4898a1744128bb0586128%2Fstacks-connect.jpg?alt=media" alt=""><figcaption><p>source: <a href="https://www.hiro.so/blog/better-devex-fewer-dependencies-meet-the-new-stacks-connect">Hiro blog</a></p></figcaption></figure>

{% hint style="success" %}
For the latest releases and versions of `@stacks/connect`, check out its npm page [here](https://www.npmjs.com/package/@stacks/connect).
{% endhint %}

## What you'll learn

* Install the `@stacks/connect` package
* Connect to a wallet and authenticate users
* Manage authentication state
* Access user account data

{% hint style="info" %}
Prerequisites:

* Node.js installed on your machine
* A web application setup (React, Vue, or vanilla JS)
* Basic understanding of async/await
  {% endhint %}

## Quickstart

{% stepper %}
{% step %}
**Install package**

Add Stacks Connect to your project:

{% code title="Install" %}

```bash
npm install @stacks/connect
```

{% endcode %}
{% endstep %}

{% step %}
**Connect and authenticate**

Use `connect` to initiate a wallet session and persist user data:

{% code title="connect.ts" %}

```ts
import { connect, isConnected } from '@stacks/connect';

async function connectWallet() {
  if (isConnected()) {
    console.log('Already authenticated');
    return;
  }

  const response = await connect();
  console.log('Connected:', response.addresses);
}
```

{% endcode %}

Manage authentication state in your app:

{% code title="auth.ts" %}

```ts
import { disconnect, isConnected } from '@stacks/connect';

const authenticated = isConnected();

function logout() {
  disconnect();
  console.log('User disconnected');
}
```

{% endcode %}
{% endstep %}

{% step %}
**Access user data**

Read persisted addresses and request full account details:

{% code title="user-data.ts" %}

```ts
import { getLocalStorage, request } from '@stacks/connect';

const userData = getLocalStorage();
if (userData?.addresses) {
  const stxAddress = userData.addresses.stx[0].address;
  const btcAddress = userData.addresses.btc[0].address;
  console.log('STX:', stxAddress);
  console.log('BTC:', btcAddress);
}

const accounts = await request('stx_getAccounts');
const account = accounts.addresses[0];
console.log('Address:', account.address);
console.log('Public key:', account.publicKey);
console.log('Gaia URL:', account.gaiaHubUrl);
```

{% endcode %}
{% endstep %}

{% step %}
**Make your first transaction**

Request the wallet to broadcast a transfer:

{% code title="send-transaction.ts" %}

```ts
import { request } from '@stacks/connect';

async function sendTransaction() {
  const response = await request('stx_transferStx', {
    amount: '1000000',
    recipient: 'SP2MF04VAGYHGAZWGTEDW5VYCPDWWSY08Z1QFNDSN',
    memo: 'First transfer',
  });

  console.log('Transaction ID:', response.txid);
}
```

{% endcode %}
{% endstep %}
{% endstepper %}


# Broadcast Transactions

The process of broadcasting transactions is fundamental for interacting with blockchains, whether you're transferring tokens, deploying contracts, or executing contract functions.

In this guide you will:

* Install the required packages
* Connect to a user's wallet
* Sign and broadcast different transaction types
* Handle transaction results

## Setup and installation

Install the required packages to start building and broadcasting transactions.

{% tabs %}
{% tab title="npm" %}

```bash
npm install @stacks/connect @stacks/transactions
```

{% endtab %}

{% tab title="yarn" %}

```bash
yarn add @stacks/connect @stacks/transactions
```

{% endtab %}

{% tab title="pnpm" %}

```bash
pnpm add @stacks/connect @stacks/transactions
```

{% endtab %}
{% endtabs %}

## Connect to a user's wallet

Before signing transactions, users need to connect their wallet to your application. Use the `connect` function to initiate a wallet connection:

```ts
import { connect, isConnected } from '@stacks/connect';

async function connectWallet() {
  if (!isConnected()) {
    const response = await connect();
    console.log('Connected with addresses:', response);
  }
}
```

## Sign and broadcast transactions

There are three common transaction flows you can build:

{% stepper %}
{% step %}
**STX transfer**

Use `stx_transferStx` to send tokens:

```ts
import { request } from '@stacks/connect';

async function transferStx() {
  const response = await request('stx_transferStx', {
    recipient: 'ST2EB9WEQNR9P0K28D2DC352TM75YG3K0GT7V13CV',
    amount: '100',
    memo: 'Reimbursement',
  });

  console.log('Transaction ID:', response.txId);
}
```

{% endstep %}

{% step %}
**Contract deployment**

Deploy a contract with `stx_deployContract`:

```ts
import { request } from '@stacks/connect';

async function deployContract() {
  const codeBody = '(define-public (say-hi) (ok "hello world"))';

  const response = await request('stx_deployContract', {
    name: 'my-contract',
    code: codeBody,
    clarityVersion: 3,
  });

  console.log('Transaction ID:', response.txId);
}
```

{% hint style="info" %}
Contracts deploy to the Stacks address of the connected wallet.
{% endhint %}
{% endstep %}

{% step %}
**Contract execution**

Call contract functions with `stx_callContract`:

```clarity
(define-public (say-hi)
  (print "hi")
  (ok u0)
)
```

```ts
import { request } from '@stacks/connect';

async function callContract() {
  const response = await request('stx_callContract', {
    contractAddress: 'ST22T6ZS7HVWEMZHHFK77H4GTNDTWNPQAX8WZAKHJ',
    contractName: 'my-contract',
    functionName: 'say-hi',
    functionArgs: [],
  });

  console.log('Transaction ID:', response.txId);
}
```

When passing arguments, construct Clarity values via `Cl`:

```ts
import { Cl } from '@stacks/transactions';

const functionArgs = [
  Cl.uint(123),
  Cl.stringAscii('hello'),
  Cl.standardPrincipalCV('ST1X..'),
];
```

{% endstep %}
{% endstepper %}

## Handle transaction results

When a transaction is signed and broadcast, the `request` method returns a response object containing information about the transaction:

```ts
interface TransactionResponse {
  txId: string;        // The transaction ID
  txRaw: string;       // The raw transaction hex
}
```

You can use the transaction ID to create a link to view the transaction in the explorer:

```ts
import { request } from '@stacks/connect';

async function handleTransaction() {
  const response = await request('stx_transferStx', {
    recipient: 'ST2EB9WEQNR9P0K28D2DC352TM75YG3K0GT7V13CV',
    amount: '100',
  });

  const explorerUrl = `https://explorer.stacks.co/txid/${response.txId}`;
  console.log('View transaction in explorer:', explorerUrl);
}
```


# Message Signing

Learn how to implement message signing in your Stacks application. Message signing allows users to cryptographically prove they control an address without making an on-chain transaction, enabling authentication, authorization, and verifiable statements.

## What you'll learn

* Connect to a user's wallet and request message signatures
* Sign both simple text messages and structured data
* Verify signatures to ensure authenticity

## Prerequisites

* Node.js installed on your machine
* A code editor like VS Code

## Installation

Install the required packages for message signing and verification.

```bash
npm install @stacks/connect @stacks/encryption
```

## Connect to wallet

Before signing messages, establish a connection to the user's wallet. The connection persists across page reloads.

```ts
import { connect, isConnected } from '@stacks/connect';

async function connectWallet() {
  if (!isConnected()) {
    const response = await connect();
    console.log('Connected addresses:', response.addresses);
  }
}
```

Call this function when your app loads or when the user clicks a connect button.

## Sign text messages

Request a signature for a simple text message using the `request` method.

```ts
import { request } from '@stacks/connect';

async function signMessage() {
  const message = 'Hello World';

  const response = await request('stx_signMessage', {
    message,
  });

  console.log('Signature:', response.signature);
  console.log('Public key:', response.publicKey);

  return response;
}
```

The wallet will display the message to the user for approval before signing.

## Sign structured data

For more complex data, use structured message signing with Clarity values.

```ts
import { request } from '@stacks/connect';
import { Cl } from '@stacks/transactions';

async function signStructuredMessage() {
  const message = Cl.tuple({
    action: Cl.stringAscii('transfer'),
    amount: Cl.uint(1000),
    recipient: Cl.stringAscii('alice.btc')
  });

  const domain = Cl.tuple({
    name: Cl.stringAscii('My App'),
    version: Cl.stringAscii('1.0.0'),
    'chain-id': Cl.uint(1) // 1 for mainnet
  });

  const response = await request('stx_signStructuredMessage', {
    message,
    domain
  });

  return response;
}
```

Structured messages provide better type safety and are easier to parse on-chain.

## Verify signatures

Validate signatures to ensure they match the expected message and public key.

```ts
import { verifyMessageSignatureRsv } from '@stacks/encryption';

async function verifySignature(
  message: string,
  signature: string,
  publicKey: string
): Promise<boolean> {
  const isValid = verifyMessageSignatureRsv({
    message,
    signature,
    publicKey
  });

  if (isValid) {
    console.log('✓ Signature verified successfully');
  } else {
    console.log('✗ Invalid signature');
  }

  return isValid;
}
```

Always verify signatures before trusting the signed data.

## Complete verification flow

```ts
async function signAndVerify() {
  // Request signature
  const message = 'Authorize login at ' + new Date().toISOString();
  const signResponse = await request('stx_signMessage', { message });

  // Verify immediately
  const isValid = await verifySignature(
    message,
    signResponse.signature,
    signResponse.publicKey
  );

  if (isValid) {
    // Proceed with authenticated action
    console.log('Authentication successful');
  }
}
```

## Try it out

Create a simple authentication system using message signatures.

```ts
// Generate a unique challenge
function generateChallenge(): string {
  const nonce = Math.random().toString(36).substring(7);
  const timestamp = Date.now();
  return `Sign this message to authenticate:\nNonce: ${nonce}\nTime: ${timestamp}`;
}

// Complete auth flow
async function authenticate() {
  const challenge = generateChallenge();

  try {
    const response = await request('stx_signMessage', {
      message: challenge
    });

    const isValid = verifyMessageSignatureRsv({
      message: challenge,
      signature: response.signature,
      publicKey: response.publicKey
    });

    if (isValid) {
      // Store auth token or session
      localStorage.setItem('auth', JSON.stringify({
        publicKey: response.publicKey,
        timestamp: Date.now()
      }));

      return { success: true };
    }
  } catch (error) {
    console.error('Authentication failed:', error);
  }

  return { success: false };
}
```


# Migration Guide

For a while now, the Stacks community has been working on a new standard for wallet-to-dapp communication. Stacks Connect and related projects now use standards like [WBIPs](https://wbips.netlify.app/) and [SIP-030](https://github.com/janniks/sips/blob/main/sips/sip-030/sip-030-wallet-interface.md) to allow wallets to communicate with dapps in a more simplified and flexible way.

{% hint style="info" %}
Migration status\
Feel free to continue using Stacks Connect `7.x.x` while things stabilize. The `7.x.x` version may still be better supported by some wallets.

Legacy installs:

```bash
npm install @stacks/connect@7.10.1
```

{% endhint %}

## Deprecations

The following classes, methods, and types are deprecated in favor of the new `request` RPC methods:

* `show...` and `open...` methods
* `authenticate` method
* `UserSession` class and related functionality
* `AppConfig` class
* `SessionOptions` interface
* `SessionData` interface
* `UserData` interface
* `SessionDataStore` class
* `InstanceDataStore` class
* `LocalStorageStore` class

{% hint style="info" %}
Backwards compatibility\
`UserSession` and `AppConfig` remain available in `8.x.x` for caching addresses via `loadUserData`, but consider them temporary helpers while you migrate.
{% endhint %}

## Migration steps

{% stepper %}
{% step %}
**Update your @stacks/connect version**

```bash
npm install @stacks/connect@latest
```

{% endstep %}

{% step %}
**Replace legacy methods with `request`**

Switch from `showXyz`, `openXyz`, and `doXyz` helpers to the generic `request(method, params)` API. The `request` function is async, so replace `onFinish`/`onCancel` callbacks with `await` or `.then().catch()` chains.

Examples:

* `showConnect()`, `authenticate()` → `connect()`
* `useConnect().doContractCall({})` → `request('stx_callContract', {})`
* `openContractDeploy()` → `request('stx_deployContract', {})`
  {% endstep %}

{% step %}
**Use `connect` instead of `showConnect` / `authenticate`**

`connect()` is an alias for `request('getAddresses', { forceWalletSelect: true })` and caches the selected address in local storage by default.
{% endstep %}

{% step %}
**Update authentication state management**

* Replace `UserSession.isSignedIn()` with `isConnected()`
* Replace `UserSession.signUserOut()` with `disconnect()`
  {% endstep %}

{% step %}
**Remove legacy code**

* Delete references to deprecated helpers (`AppConfig`, `UserSession`, etc.)
* Remove the `@stacks/connect-react` package
  * Manually reload components if you rely on local storage updates
  * Hooks are no longer required for Stacks Connect
* A new `@stacks/react` package is in development to simplify state tracking (transaction status, network changes, and more)
  {% endstep %}
  {% endstepper %}

## Address Access

Previously, the `UserSession` class was used to access the user's addresses and data, which abstracted away the underlying implementation details. Now, the `request` method is used to directly interact with the wallet, giving developers more explicit control and clarity over what's happening under the hood. This manual approach makes the wallet interaction more transparent and customizable. Developers can manually manage the currently connected user's address in e.g. local storage, jotai, etc. or use the `connect()`/`request()` method to cache the address in local storage.

{% hint style="warning" %}
Security note\
`8.x.x` wallets return only the current network's address (previous versions returned both mainnet and testnet).
{% endhint %}


# Wallet Support

{% hint style="info" %}
Legend:

* 🔴 No support (yet)
* 🟡 Partial support
* 🟢 Supported
* 🔵 Compatibility overrides present (may transform/normalize behavior)
  {% endhint %}

## Wallet Support

This page provides detailed information about which methods and events are supported by different wallet providers in the Stacks ecosystem.

### Method Compatibility

| Method                      | Leather                                 | Xverse-like                                                         |
| --------------------------- | --------------------------------------- | ------------------------------------------------------------------- |
| `getAddresses`              | 🟡 No support for experimental purposes | 🟡 Use `wallet_connect` instead                                     |
| `sendTransfer`              | 🟡 Expects `amount` as string           | 🟡 Expects `amount` as number                                       |
| `signPsbt`                  | 🟡 Uses signing index array only        | 🟡 Uses `signInputs` record instead of array                        |
| `stx_getAddresses`          | 🟢                                      | 🔴                                                                  |
| `stx_getAccounts`           | 🔴                                      | 🟢                                                                  |
| `stx_getNetworks`           | 🔴                                      | 🔴                                                                  |
| `stx_transferStx`           | 🟢                                      | 🟢                                                                  |
| `stx_transferSip10Ft`       | 🟢                                      | 🔴                                                                  |
| `stx_transferSip9Nft`       | 🟢                                      | 🔴                                                                  |
| `stx_callContract`          | 🟡 Hex-encoded Clarity values only      | 🟡 Hex-encoded Clarity values only, no support for `postConditions` |
| `stx_deployContract`        | 🟡 Hex-encoded Clarity values only      | 🟡 Hex-encoded Clarity values only, no support for `postConditions` |
| `stx_signTransaction`       | 🟡 Hex-encoded Clarity values only      | 🟡 Hex-encoded Clarity values only                                  |
| `stx_signMessage`           | 🟡 Hex-encoded Clarity values only      | 🟡 Hex-encoded Clarity values only                                  |
| `stx_signStructuredMessage` | 🟡 Hex-encoded Clarity values only      | 🟡 Hex-encoded Clarity values only                                  |
| `stx_updateProfile`         | 🔴                                      | 🔴                                                                  |

### Event Compatibility

| Event               | Leather | Xverse |
| ------------------- | ------- | ------ |
| `stx_accountChange` | 🔴      | 🔴     |
| `stx_networkChange` | 🔴      | 🔴     |

### Compatibility Layer

The `request` method in `@stacks/connect` adds a layer of auto-compatibility for different wallet providers. This helps unify the interface where wallet providers may implement methods and results differently.

* 🟢 No overrides needed for any wallet
* 🔵 Has compatibility overrides that maintain functionality
* 🟡 Has breaking overrides that may lose some information

| Method                      | Status | Notes                                                                                     |
| --------------------------- | ------ | ----------------------------------------------------------------------------------------- |
| `getAddresses`              | 🔵     | Maps to `wallet_connect` for Xverse-like wallets                                          |
| `sendTransfer`              | 🔵     | Converts `amount` to number for Xverse, string for Leather                                |
| `signPsbt`                  | 🟡     | Transforms PSBT format for Leather (base64 to hex) with lossy restructure of `signInputs` |
| `stx_getAddresses`          | 🔵     | Maps to `wallet_connect` for Xverse-like wallets                                          |
| `stx_callContract`          | 🔵     | Transforms Clarity values to hex-encoded format for compatibility                         |
| `stx_deployContract`        | 🔵     | Transforms Clarity values to hex-encoded format for compatibility                         |
| `stx_signTransaction`       | 🔵     | Transforms Clarity values to hex-encoded format for compatibility                         |
| `stx_signMessage`           | 🔵     | Transforms Clarity values to hex-encoded format for compatibility                         |
| `stx_signStructuredMessage` | 🔵     | Transforms Clarity values to hex-encoded format for compatibility                         |


# Overview

Learn how post-conditions protect users from unexpected transaction outcomes.

<figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2FpWJWOfW50k4PPRaDYC6f%2Fpost-conditions.jpg?alt=media&#x26;token=2a84b1ea-052a-4d6e-93f2-fe4e6653e772" alt=""><figcaption><p>source: <a href="https://www.hiro.so/blog/a-developers-guide-to-post-conditions">Hiro Blog</a></p></figcaption></figure>

### What are post-conditions?

Post-conditions are assertions about an on-chain transaction that must be met; otherwise, the transaction will abort during execution. In other words, post-conditions act as a safety net, allowing you to specify what state changes can occur in a transaction. This logic helps limit the amount of damage that can be done to a user and their assets, whether due to a bug or malicious behavior.

Put simply, post conditions are a set of conditions that must be met before a user's transaction will execute. The primary goal behind post conditions is to limit the amount of damage that can be done to a user's assets due to a bug, intentional or otherwise.

Post conditions are an additional safety feature built into the Stacks chain itself that help to protect end users. Rather than being a function of Clarity smart contracts, they are implemented on the client side and meant to be an additional failsafe against malicious contracts.

They are sent as part of the transaction when the user initiates it, meaning we need to implement post-conditions on the frontend. Whenever you are transferring an asset (fungible or non-fungible) from one address to another, you should take advantage of post conditions.

### The post-condition stack

Post-conditions are enforced by the Stacks protocol itself but do not exist in the smart contracts themselves. Instead, they are programmatically constructed in your front-end application code using Stacks.js, specifically by passing them in as options to the transaction payload construction.

By having post-conditions in the frontend code, Stacks-enabled wallets, such as Leather and Xverse, are able to display the post-conditions in a human-readable format for the user when confirming their transactions. Once a user confirms the transaction, the post-conditions get carried along with the transaction payload where eventually the Stacks protocol will evaluate them together.&#x20;

<div data-with-frame="true"><figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2FxoSWraaxoJz1nvztDde4%2Fpost-condition-stack.png?alt=media&#x26;token=cd646b8e-d193-46eb-865e-fe3875bcd6be" alt=""><figcaption><p><em>A visualization of the “post-conditions stack" and the entities involved</em></p></figcaption></figure></div>

If there were no post-conditions in the front-end application code, a user’s wallet will display an abstract warning message, where it would be up to the user to decide whether they want to blindly proceed with the transaction or not. And whatever the underlying contract code wants to do, it will do without any post-condition restrictions. So if a contract tries to send your STX tokens to a drainer wallet, it will without you knowing.&#x20;

Even with post-conditions set up on the frontend code, a user is still blind to the underlying Clarity smart contract code, but at least they know what to *expect* will happen in the transaction. And if that expectation is not met, the transaction will abort and fail.

### Example of a post-condition

Post-conditions act as safeguards that verify asset transfers match your expectations. They can check STX transfers, fungible tokens, and non-fungible token ownership changes.

```ts
import { Pc } from '@stacks/transactions';

const tx = await makeContractCall({
  // ...
  postConditions: [
    Pc.principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6').willSendEq(1000).ustx(),
  ],
});
```

In the example code snippet below, we are declaring that the user should expect to send exactly 1000 uSTX during the execution of this contract call transaction. If this condition is not met, the transaction will fail.

### Using the Pc helper

The `Pc` helper provides a fluent API for creating post-conditions with better type safety and readability.

```ts
import { Pc } from '@stacks/transactions';

// STX transfer post-condition
const stxCondition = Pc
  .principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6')
  .willSendGte(1000)
  .ustx();

// Fungible token post-condition
const ftCondition = Pc
  .principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6')
  .willSendEq(50)
  .ft('SP3D6PV2ACBPEKYJTCMH7HEN02KP87QSP8KTEH335.my-token', 'my-token');

// NFT post-condition
const nftCondition = Pc
  .principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6')
  .willSendAsset()
  .nft('SP3D6PV2ACBPEKYJTCMH7HEN02KP87QSP8KTEH335.my-nft::my-asset', Cl.uint(1));
```

### Manual creation

Create post-conditions manually using type definitions when building conditions dynamically.

```ts
import {
  StxPostCondition,
  FungiblePostCondition,
  NonFungiblePostCondition
} from '@stacks/transactions';

// STX post-condition
const stxPostCondition: StxPostCondition = {
  type: 'stx-postcondition',
  address: 'SP2JXKMSH007NPYAQHKJPQMAQYAD90NQGTVJVQ02B',
  condition: 'gte', // 'eq' | 'gt' | 'gte' | 'lt' | 'lte'
  amount: '100',
};
```

Available condition types:

* `eq`: Exactly equal to amount
* `gt`: Greater than amount
* `gte`: Greater than or equal to amount
* `lt`: Less than amount
* `lte`: Less than or equal to amount

#### Fungible tokens

```ts
const ftPostCondition: FungiblePostCondition = {
  type: 'ft-postcondition',
  address: 'SP2JXKMSH007NPYAQHKJPQMAQYAD90NQGTVJVQ02B',
  condition: 'eq',
  amount: '100',
  asset: 'SP3D6PV2ACBPEKYJTCMH7HEN02KP87QSP8KTEH335.my-ft-token::my-token',
};
```

#### Non-fungible tokens

```ts
const nftPostCondition: NonFungiblePostCondition = {
  type: 'nft-postcondition',
  address: 'SP2JXKMSH007NPYAQHKJPQMAQYAD90NQGTVJVQ02B',
  condition: 'sent', // 'sent' | 'not-sent'
  asset: 'SP3D6PV2ACBPEKYJTCMH7HEN02KP87QSP8KTEH335.my-nft::my-asset',
  assetId: Cl.uint(602),
};
```

### Post-condition modes

Control how unspecified, unexpected, or unforeseen asset transfers are handled with post-condition mode.

#### **Deny Mode**

Deny mode is the default for post-conditions. Deny is a more-strict setting for post-conditions, and it says that any other asset transfers that do not meet the criteria of the post-condition are denied. In deny mode, any transaction that does not meet the post-condition criteria will fail.

```ts
import { PostConditionMode } from '@stacks/transactions';

const tx = await makeContractCall({
  // ...
  postConditionMode: PostConditionMode.Deny,
  postConditions: [
    // your conditions
  ],
});
```

This setting is useful when you want to limit any transfer events to a specific set of criteria. This setting is ultimately what makes post-conditions powerful, hence the reason why this is defaulted as `deny` if you don’t or forget to pass in a `postConditionMode` option.

{% hint style="warning" %}
Post-condition mode\
Always use `Deny` mode unless you have a specific reason to allow additional transfers. This provides maximum security for users.
{% endhint %}

#### Allow mode

Allow mode is a less-strict setting, in which it “allows” any transaction to execute as long as it meets the criteria of the specified post-conditions. In other words, this `allow` mode enables additional transactions to occur as long as the post-condition is met in that process. This setting is useful when you want to allow other unknown or dynamic transfers to happen. But usually you wouldn’t want to have this happen as this can open up unintended consequences for the user.

### How post-conditions appear to the user

Since post-conditions are declared on your frontend code, they also need to be visually displayed to users. Stacks-supported wallets handle that by displaying post-conditions on the transaction confirmation modals that popup when a user needs to confirm/approve a transaction.

<div data-with-frame="true"><figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2FR2OF2o25z0Vu0HMO21uM%2Fpost-condition-modes.png?alt=media&#x26;token=1fc9ab99-8742-44bb-b3f0-44e84b598c30" alt=""><figcaption><p>How post-conditions appear in wallets under different post-condition modes</p></figcaption></figure></div>

### Things to remember

While powerful, post-conditions have some limitations you should keep in mind. Post-conditions only track who *sends* an asset, and how much. They do not monitor who owns any set of assets when the transaction finishes, nor do they monitor the sequence of owners an asset might have during transaction execution.

Alongside those limitations, it should be obvious, but it’s worth explicitly stating that post-conditions are not a catch-all. Just because you implement post-conditions doesn’t mean your contract or next transaction are guaranteed to be safe. Bugs can still occur, and you still need to build with security in mind. Debugging and extensive tests are still your best friend.

***

### Additional Resources

* \[[Hiro Blog](https://www.hiro.so/blog/a-developers-guide-to-post-conditions)] A Developer’s Guide to Post-Conditions
* \[[dev.to](https://dev.to/stacks/understanding-stacks-post-conditions-e65)] Understanding Stacks Post Conditions
* \[[Hiro YT](https://youtu.be/xXgQB8NfdEY?si=aEY_wrLybfWPMJTt)] ELI5: Post-Condtions on Stacks
* \[[Hiro YT](https://youtu.be/wagcE_IXfME?si=kDqxzPAQ-XsA478l)] Understanding Post-Conditions in a Stacks Blockchain Transaction
* \[[StacksGov](https://github.com/stacksgov/sips/blob/main/sips/sip-005/sip-005-blocks-and-transactions.md#transaction-post-conditions)] Post-conditions section in SIP-005


# Implementing Post-Conditions

Learn how to add post-conditions to protect your Stacks transactions.

Post-conditions are a powerful security feature in Stacks that protect users from unexpected transaction outcomes. This tutorial will walk you through implementing post-conditions in your applications to ensure transactions behave exactly as users expect.

## What you'll learn

* Construct post-conditions using the `Pc` helper API
* Add post-conditions to different transaction types
* Configure post-condition modes for transaction security
* Implement post-conditions for STX, fungible tokens, and NFTs
* Handle semi-fungible tokens (SFTs) with post-conditions

## Prerequisites

* Basic understanding of Stacks transactions
* Stacks.js library installed (`npm install @stacks/transactions`)
* A development environment set up for Stacks

## Constructing post-conditions

The Pc helper in Stacks.js provides a fluent, BDD-inspired API for constructing post-conditions. Start with `Pc.principal()` to specify which address will be verified, then chain methods to define the condition.

```ts
import { Pc } from '@stacks/transactions';

// Basic structure of a post-condition
const postCondition = Pc
  .principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6')
  .willSendEq(1000)
  .ustx();
```

The Pc helper uses method chaining for intuitive condition building. Your IDE will provide auto-completion for available methods at each step.

## Available transfer methods

Post-conditions support different comparison operators and asset types. Choose the appropriate method based on your security requirements.

### STX and fungible token methods

```ts
// Exact amount
Pc.principal(address).willSendEq(1000).ustx();

// Greater than or equal
Pc.principal(address).willSendGte(500).ustx();

// Less than
Pc.principal(address).willSendLt(2000).ustx();
```

Comparison methods available:

* `.willSendEq(amount)` - Exactly equal to amount
* `.willSendGte(amount)` - Greater than or equal to amount
* `.willSendGt(amount)` - Greater than amount
* `.willSendLte(amount)` - Less than or equal to amount
* `.willSendLt(amount)` - Less than amount

### Asset type methods

```ts
// STX transfers
.ustx()

// Fungible token transfers
.ft(contractAddress, tokenName)

// NFT transfers
.nft(assetIdentifier, tokenId)
```

### NFT-specific methods

```ts
// Ensure NFT is sent
Pc.principal(address).willSendAsset().nft(...);

// Ensure NFT is NOT sent
Pc.principal(address).willNotSendAsset().nft(...);
```

## Setting the post-condition mode

The post-condition mode determines how the Stacks blockchain handles asset transfers not explicitly covered by your post-conditions. This is a critical security setting.

```ts
import { PostConditionMode, makeContractCall } from '@stacks/transactions';

const tx = await makeContractCall({
  // ... other transaction properties
  postConditionMode: PostConditionMode.Deny, // Recommended default
  postConditions: [
    // your post-conditions here
  ],
});
```

Mode options:

* PostConditionMode.Deny (default): Transaction fails if any unspecified transfers occur
* PostConditionMode.Allow: Transaction allows transfers beyond specified post-conditions

## Common implementation patterns

### STX transfer post-conditions

Protect STX transfers by specifying exact amounts or ranges.

```ts
import { Pc, makeSTXTokenTransfer } from '@stacks/transactions';

// Exact amount post-condition
const exactAmountCondition = Pc
  .principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6')
  .willSendEq(1000)
  .ustx();

// Use in a transaction
const tx = await makeSTXTokenTransfer({
  recipient: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',
  amount: 1000,
  postConditions: [exactAmountCondition],
  postConditionMode: PostConditionMode.Deny,
  // ... other properties
});
```

### Fungible token post-conditions

Ensure fungible tokens are transferred as expected in contract calls.

```ts
import { Pc, makeContractCall } from '@stacks/transactions';

// Minimum amount condition
const ftCondition = Pc
  .principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6')
  .willSendGte(500)
  .ft('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6.token-ft', 'token');

// Use in a contract call
const tx = await makeContractCall({
  contractAddress: 'STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6',
  contractName: 'token-transfer',
  functionName: 'transfer',
  functionArgs: [
    // ... function arguments
  ],
  postConditions: [ftCondition],
  // ... other properties
});
```

### NFT transfer post-conditions

Control NFT ownership changes with specific post-conditions.

```ts
import { Pc, Cl } from '@stacks/transactions';

// Ensure NFT is sent
const sendNftCondition = Pc
  .principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6')
  .willSendAsset()
  .nft('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6.nft-contract::nft-name', Cl.uint(1));

// Ensure NFT is NOT sent (protection against unwanted transfers)
const keepNftCondition = Pc
  .principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6')
  .willNotSendAsset()
  .nft('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6.nft-contract::nft-name', Cl.uint(1));
```

Use `willNotSendAsset()` to protect valuable NFTs from being transferred unexpectedly.

### Semi-fungible token (SFT) post-conditions

SFTs require special handling as they have both fungible and non-fungible properties.

```ts
import { Cl, Pc } from '@stacks/transactions';

// SFT as NFT (specific token ID)
const sftNftCondition = Pc
  .principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6')
  .willSendAsset()
  .nft(
    'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.sft-contract::sft-id',
    Cl.tuple({
      'token-id': Cl.uint(1),
      owner: Cl.principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6')
    })
  );

// SFT as FT (amount-based)
const sftFtCondition = Pc
  .principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6')
  .willSendEq(500)
  .ft('ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.sft-contract', 'sft-token');
```

## Multiple post-conditions

Complex transactions often require multiple post-conditions to fully protect all asset transfers.

```ts
const tx = await makeContractCall({
  // ... transaction properties
  postConditions: [
    // Sender must send exactly 1000 uSTX
    Pc.principal(senderAddress).willSendEq(1000).ustx(),

    // Contract must send at least 100 tokens to user
    Pc.principal(contractAddress).willSendGte(100)
      .ft(contractAddress + '.my-token', 'my-token'),

    // User must not lose their NFT
    Pc.principal(senderAddress).willNotSendAsset()
      .nft(nftContract + '::my-nft', Cl.uint(1)),
  ],
  postConditionMode: PostConditionMode.Deny,
});
```


# sBTC

The guides in this section provide step-by-step instructions for interacting with sBTC, including operating as a signer and (coming soon) developer guides on how to interact with sBTC as an application developer.

{% hint style="info" %}
In order to run an sBTC signer you must be one of the [approved signers](https://github.com/stacks-network/sbtc/discussions/624) described in [SIP-028](https://github.com/andrerserrano/sips/blob/main/sips/sip-028/sip-028-sbtc_peg.md).
{% endhint %}


# sBTC Builder Quickstart

<figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2Fgit-blob-ecaaf0c5222fda9bc11a86b98a7708295c707484%2FFrame%20316126251.jpg?alt=media" alt=""><figcaption><p>source: Hiro</p></figcaption></figure>

Get up and running with sBTC in 30 minutes or less. This guide covers the essentials for working with sBTC as a SIP-010 token in your smart contracts.

### What is sBTC?

sBTC is Bitcoin on Stacks. It's a SIP-010 fungible token that maintains a 1:1 peg with Bitcoin, enabling you to use Bitcoin in smart contracts and DeFi applications on the Stacks blockchain.

Key points:

* **1:1 Bitcoin peg**: 1 sBTC always equals 1 BTC
* **SIP-010 token**: Works like any other fungible token on Stacks
* **Programmable**: Use Bitcoin in smart contracts, DeFi protocols, and dApps

### Quick Setup

#### Prerequisites

In order to get the most from this quickstart, you should familiarize yourself with Clarity, Clarinet, Stacks.js, and the Hiro Platform. These are the fundamental building blocks of building Stacks applications.

* [Stacks Developer Quickstart](https://app.gitbook.com/o/hoh4mQXTl8NvI3cETroY/s/Zz9BLmTU9oydDpL3qiUh/) - For a quick holistic introduction to the Stacks development process, tools, and fundamentals
* [Clarity Crash Course](https://docs.stacks.co/build/get-started/clarity-crash-course) - For a quick introduction to Clarity
* [Clarinet Docs](https://docs.hiro.so/tools/clarinet)
* [Stacks.js Docs](https://docs.hiro.so/reference/stacks.js)

Choose your preferred development environment:

#### Hiro Platform (Recommended)

The fastest way to start building with sBTC is using the Hiro Platform's hosted devnet. The Platform integrates with your GitHub account. You can either import an existing project from GitHub or start with a Platform template and have it synced with your GitHub account.

After you create the project in the Platform, you can clone it locally and work with the Platform's cloud devnet by connecting your API key as described in the template's README files. This will allow you to work on your code locally but let Platform handle the complexities of actually running the devnet.

{% stepper %}
{% step %}

#### Create an account

Create an account at:\
<https://platform.hiro.so>
{% endstep %}

{% step %}

#### Create or import a project

* Select a template or import your own project from GitHub. There are several templates available to use as a starting point. Some have only smart contracts and some are full-stack dapp templates. Starting with one of these ensures you are building with best practices.
* Navigate to your project dashboard
  {% endstep %}

{% step %}

#### Start devnet

* Click the "Devnet" tab
* Click "Start Devnet"
* Wait for status to show "Active"
  {% endstep %}

{% step %}

#### Connect your wallet

* Your devnet wallets are automatically funded with STX and sBTC
* Use the provided wallet addresses within the templates
* The platform templates are automatically connected to Devnet, and there are instructions in the READMEs of the templates for how to connect your frontend to your Devnet instance
  {% endstep %}
  {% endstepper %}

#### Local with Clarinet

If you would prefer to have your devnet running locally instead of in the Platform cloud, you can run one yourself.

{% stepper %}
{% step %}

#### Install Clarinet (version 3.x)

```bash
brew install clarinet
```

{% endstep %}

{% step %}

#### Create a new project

```bash
clarinet new my-sbtc-project
cd my-sbtc-project
```

{% endstep %}

{% step %}

#### Add sBTC requirements

```bash
clarinet requirements add SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-deposit
```

This automatically includes the sBTC token contract in your Clarinet context so you can reference it within your contracts.
{% endstep %}

{% step %}

#### Start devnet

```bash
clarinet devnet start
```

With either of these options, your Devnet wallets are automatically funded with sBTC. You just need to include the sBTC contract in your contract requirements as shown above.
{% endstep %}
{% endstepper %}

### Working with sBTC in Smart Contracts

sBTC follows the SIP-010 standard, making it easy to integrate into your contracts.

The primary function you'll be using is the `transfer` function. That's because sBTC exists as a 1:1 Bitcoin peg via a SIP-010 token. Minting is handled by the protocol, the main function of writing smart contracts that use sBTC is to move it around, which means using the `transfer` function.

Here's a very basic example of how to transfer sBTC within your contract.

#### Basic Transfer Example

Create a new contract that accepts sBTC payments. You can do this within the Clarinet project folder with `clarinet contract new sbtc-payment`.

{% code title="contracts/sbtc-payment.clar" %}

```clarity
;; contracts/sbtc-payment.clar

;; Define the sBTC token contract reference
(define-constant sbtc-token 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token)

;; Error codes
(define-constant err-insufficient-balance (err u100))
(define-constant err-transfer-failed (err u101))

;; Accept sBTC payment
(define-public (pay-with-sbtc (amount uint) (recipient principal))
  (contract-call? sbtc-token transfer
    amount
    tx-sender
    recipient
    none))
```

{% endcode %}

You can test out this contract by either using the UI within the Platform to call the functions directly if you have devnet running or by opening the console with `clarinet console`.

Once you do that you'll see that your devnet accounts have automatically been funded with sBTC.

<figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2Fgit-blob-35bf7c4f532c5cf2f2efa04674f6a360c4dbbe5a%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>

Once you are ready to deploy to testnet, you can do so by editing your deployment plan as outlined in [this guide](https://docs.hiro.so/tools/clarinet/sbtc-integration).

### Conclusion

You can build pretty much anything you want using this simple foundation, as all of the complexity of sBTC is handled behind the scenes by the protocol.

What's needed now is for builders to take this foundation and build interesting, useful things with it. sBTC unlocks a lot of additional functionality for Bitcoin that previously would have only been possible with either custodied solutions or slow, complex solutions with poor UX.

If you are interested, you can read more about how sBTC works in the [sBTC Concept Guide](https://app.gitbook.com/s/H74xqoobupBWwBsVMJhK/sbtc).


# How to Use the sBTC JS Library for Bridging

A Javascript/Typescript package for integrating your own peg-in/out bridging flow.

Currently, the official [sBTC Bridge app](https://sbtc.stacks.co/) provides users the interface for pegging BTC into sBTC, and vice versa. Building your own sBTC bridging app would consist of working with the construction of bitcoin P2TR transactions, handling user UTXOs, broadcasting transactions, notifying the sBTC Signers' of incoming transactions, and etc. You could check out the complexity of that in the sBTC Bridge app's open-source repo [here](https://github.com/stacks-sbtc/sbtc-bridge). But thankfully there is a library for all of that.

The [`sbtc`](https://www.npmjs.com/package/sbtc) npm library was built to abstract away the complexities of the bridging process of sBTC.

{% hint style="info" %}
Check out the `sbtc` reference [section](https://app.gitbook.com/s/GVj1Z9vMuEOMe7oH7Wnq/stacks.js/sbtc) for definitions, configurations, and more examples.
{% endhint %}

#### **Architecture**

* **Bitcoin:** The original funds are sourced from Bitcoin. A depositor sends these funds to a group of signers, which manage a (rotating) multisignature address formatted for sBTC transactions.
* **sBTC API (Emily):** This API is responsible for tracking deposits and notifying the signers about pending deposits.
* **Stacks:** The network where sBTC is minted. Once the deposit is confirmed, the signers mint the corresponding amount of sBTC to the depositor's specified address on the Stacks network.

#### This guide will provide a walkthrough of using the `sbtc` library for:

* **Depositing**: pegging BTC into sBTC
* **Withdrawing**: pegging sBTC into BTC


# Depositing: Pegging BTC into sBTC

This guides shows how you can integrate the deposit (peg-in) flow from your front-end app to allow users to peg BTC into sBTC on the Stacks network. For more information about sBTC and an explainer of its architecture, check out the general sBTC section [here](https://app.gitbook.com/s/H74xqoobupBWwBsVMJhK/sbtc) in the Learn category.

### Breakdown of the deposit (peg-in) flow

* **Create Deposit (Bitcoin) Transaction:**
  * Structure a Bitcoin transaction to send funds to the group of signers.
  * Use a specialized format that includes:
    * Deposit Script: Identifies which *Stacks address* the sBTC will be minted to and what the *maximum fee* (in satoshis) the signers may take in exchange for minting.
    * Reclaim Script: Allows the sender to reclaim their funds if the transaction is not processed by the signers.
* **Sign and Broadcast the Transaction:**
  * Sign the transaction with the sender's private key.
  * Broadcast the transaction to the Bitcoin network (Bitcoin Regtest for Stacks Testnet).
* **Notify the sBTC API (Emily):**
  * Inform the API about the transaction by submitting its details. This step ensures that the signers are aware of the deposit and can track it.
* **Processing by Signers:** (*no action required*)
  * The signers retrieve and verify the deposit transaction from the Bitcoin blockchain.
  * Once verified, the signers mint the equivalent amount of sBTC on the Stacks network.
* **Receive sBTC (Stacks):** (*no action required*)
  * The minted sBTC is sent to the depositor's designated Stacks address, completing the deposit process.
  * sBTC is SIP-010 compatible and will show up in Stacks wallets and explorers.

In this guide you'll touch on some of the steps above but its much simpler than you'd expect. Using the `sbtc` and `@stacks/connect` libraries, putting together the peg-in process from BTC into sBTC will simply involve the following steps:

1. Building the sBTC deposit address
2. Invoking the user's wallet to sign and broadcast the bitcoin transaction
3. Notifying the sBTC signers
4. Confirm user's sBTC balance

{% hint style="info" %}
This guide assumes you have a front-end bootstrapped with the Stacks Connect library for wallet interactions. Head to the guides for Stacks Connect before continuing with this guide.
{% endhint %}

{% stepper %}
{% step %}

#### Building the sBTC deposit address

You're not directly sending bitcoin to the public sBTC Signers' [bitcoin address](https://mempool.space/address/bc1prcs82tvrz70jk8u79uekwdfjhd0qhs2mva6e526arycu7fu25zsqhyztuy), but rather sending to a custom P2TR address where both the user and sBTC Signers have control over. This custom P2TR address is special because it contains tapscripts that specify which parties are able to unlock the UTXOs via a script path spend.

The construction of these tapscripts is what ultimately generates the custom P2TR address that the user will be sending their UTXOs to. Constructing tapscripts, or bitcoin scripts in general, are complex and tricky. The `sbtc` library provides useful methods for abstracting away the complexities of working with taproot related functions.

```typescript
import { buildSbtcDepositAddress, MAINNET, SbtcApiClientMainnet } from 'sbtc';

// Initialize the sBTC API client based on network
const client = new SbtcApiClientMainnet();

// Build the deposit address with metadata
const deposit = buildSbtcDepositAddress({
  stacksAddress: 'SP14ZYP25NW67XZQWMCDQCGH9S178JT78QJYE6K37', // the address to send/mint the sBTC to
  signersPublicKey: await client.fetchSignersPublicKey(), // the aggregated public key of the signers
  reclaimLockTime: 700, // default value is 950
  reclaimPublicKey: btcPubKey.value, // public key for reclaiming failed deposits
  network: MAINNET,
  maxSignerFee: 4000 // optional property, default value is 80,000 sats
});

// `deposit.address` is the deposit address (send funds here, aka the deposit address as an output)
```

{% hint style="info" %}
The `maxSignerFee` refers to the fee in the bitcoin transaction sweeping funds into, or out of, the consolidated UTXO locked exclusively by sBTC Signers' aggregate address. Depending on network congestion, specify a custom fee your users would be willing to spend. The default value will be 80,000 sats. The user's responsibility of the actual fee spent is actually deducted from the amount of sBTC that will be minted.
{% endhint %}

The `buildSbtcDepositAddress` will return with a schema of:

```
deposit {
    depositScript: string;
    reclaimScript: string;
    trOut: P2TROut;
    address: string; // the custom P2TR address to deposit bitcoin to
}
```

{% endstep %}

{% step %}

#### Sign and broadcast the bitcoin transaction

Invoke the user's Stacks wallet to sign and broadcast the deposit bitcoin transaction.

The string literal `sendTransfer` method will invoke the user's wallet to construct a bitcoin transaction. Be certain that the user's Stacks-supported wallet also supports `sendTransfer` as it is part of [WBIP005](https://wbips.netlify.app/wbips/WBIP005) for default Bitcoin methods.

```typescript
import { request } from '@stacks/connect';
  
const result = await request('sendTransfer', {
  recipients: [
    {
      address: deposit.address,
      amount: 100_000,
    },
  ],
})
```

{% endstep %}

{% step %}

#### Notify the sBTC Signers

Immediately after the deposit bitcoin transaction is broadcasted, fetch the transaction hex and notify the sBTC Signers via the Emily API.

{% hint style="warning" %}
You'll want to wait until the transaction hits the bitcoin mempool before fetching the transaction hex. Usually this is within seconds.
{% endhint %}

```typescript
// below should be delayed until txid appears in the bitcoin mempool
const transaction = await client.fetchTxHex(result.txid);

// 3. NOTIFY THE SIGNERS
let response = await client.notifySbtc({ transaction, ...deposit });
console.log('Notify response:', response);
```

The `notifySbtc` method will return with a schema of:

{% code expandable="true" %}

```
export type SbtcApiNotifyResponse = {
    bitcoinTxid: string;
    bitcoinTxOutputIndex: number;
    recipient: string;
    amount: number;
    lastUpdateHeight: number;
    lastUpdateBlockHash: string;
    status: string;
    statusMessage: string;
    parameters: {
        maxFee: number;
        lockTime: number;
    };
    reclaimScript: string;
    depositScript: string;
};
```

{% endcode %}
{% endstep %}

{% step %}

#### Confirm user's sBTC balance

The user should expect to receive their newly minted sBTC in about 20 minutes, or within 1 to 2 confirmations on the Bitcoin chain. Poll the user's specified `stacksAddress` to check if they've received sBTC and display that to the user on the front-end.

The API client comes with a `fetchSbtcBalance` method that can help with this:

```typescript
const balance = await client.fetchSbtcBalance('SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159');
// 1000000n (in micro-sBTC)
```

You could also fetch the deposit data from the API client. This will return data pertaining to the 3 total transactions that make up the entire deposit (peg-in) flow:

1. \[Bitcoin] Initial bitcoin deposit by the user ([example](https://mempool.space/tx/174bff280dff56d5c1d86d341ddee213d248f375c2552d2d333a59d82a59a35c))
2. \[Bitcoin] Sweep bitcoin transaction by the Signers ([example](https://mempool.space/tx/15029c5cabbd759ae31f58d8a08b50f9e0d9181c128fa61c3bea9c48e8ac8ea7))
3. \[Stacks] Mint sBTC by the Signers ([example](https://explorer.hiro.so/txid/0xe26c60bce407147c6f538805776039b1ed2710b903255a5726d46f4bbe97fc75?chain=mainnet))

{% code expandable="true" %}

```typescript
let depositInfo = await client.fetchDeposit(txid) // txid of initial bitcoin deposit

// example depositInfo result below
{
  "nextToken": null,
  "deposits": [
    {
      "bitcoinTxid": "174bff280dff56d5c1d86d341ddee213d248f375c2552d2d333a59d82a59a35c",
      "bitcoinTxOutputIndex": 0,
      "recipient": "0516a3e1feb8787ea10053bcf8761534112f8057e2af",
      "amount": 300000,
      "lastUpdateHeight": 4512460,
      "lastUpdateBlockHash": "297a564dcbc5a327ceac5674e194bde3218f68d55f40616fd748874e0fcdf838",
      "status": "confirmed",
      "statusMessage": "Included in block 297a564dcbc5a327ceac5674e194bde3218f68d55f40616fd748874e0fcdf838",
      "parameters": {
        "maxFee": 80000,
        "lockTime": 950
      },
      "reclaimScript": "02b603b275203b992a2735a7af6da02cbdfcb723fe5e669765505903db59270b852d0f2d6fe3ac",
      "depositScript": "1e00000000000138800516a3e1feb8787ea10053bcf8761534112f8057e2af7520d8c4344861fc7590fd812c24884a3bfd9374d8ba865a787ff53c9060020aa967ac",
      "fulfillment": {
        "BitcoinTxid": "15029c5cabbd759ae31f58d8a08b50f9e0d9181c128fa61c3bea9c48e8ac8ea7",
        "BitcoinTxIndex": 0,
        "StacksTxid": "e26c60bce407147c6f538805776039b1ed2710b903255a5726d46f4bbe97fc75",
        "BitcoinBlockHash": "00000000000000000001aab771f33914381ad92b3f5cfedf729172f2afd9c65c",
        "BitcoinBlockHeight": 921715,
        "BtcFee": 235
      }
    }
  ]
}
```

{% endcode %}
{% endstep %}
{% endstepper %}

And that's all to it. You've successfully allowed your app to handle incoming BTC to be pegged into sBTC onto the Stacks network.

***

### \[Additional Insights]

### What scripts make up the custom P2TR bitcoin address?

As mentioned above, you're not directly sending bitcoin to the public sBTC Signers' [bitcoin address](https://mempool.space/address/bc1prcs82tvrz70jk8u79uekwdfjhd0qhs2mva6e526arycu7fu25zsqhyztuy), but rather sending to a custom P2TR address where both the user and sBTC Signers have control over. Besides the default key path spend, this custom P2TR address also contains 2 sets of scripts:

<div data-with-frame="true"><figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2Fv9RfcpbXEWwIhMzs0nAr%2Fcustom-taproot-deposit-address.jpeg?alt=media&#x26;token=92489a93-e032-4660-b167-9d31fd01bcc6" alt=""><figcaption></figcaption></figure></div>

#### Deposit script

The deposit script is used by the sBTC Signers to "sweep" the deposited UTXO into their aggregate bitcoin address used to hold the entire balance of deposited bitcoin. So in a way they are consolidating all UTXOs into one single UTXO.

The construction of the deposit script:

{% code expandable="true" %}

```typescript
export function buildSbtcDepositScript(opts: {
  maxSignerFee: number;
  stacksAddress: string;
  signersPublicKey: string;
}) {
  const maxSignerFeeBytes = P.U64BE.encode(BigInt(opts.maxSignerFee));
  const recipientBytes = stacksAddressBytes(opts.stacksAddress);
  const signersPublicKeyBytes = hexToBytes(opts.signersPublicKey);

  if (signersPublicKeyBytes.length !== 32) {
    throw new Error('Signers public key must be 32 bytes (schnorr)');
  }

  return btc.Script.encode([
    P.utils.concatBytes(maxSignerFeeBytes, recipientBytes),
    'DROP',
    signersPublicKeyBytes,
    'CHECKSIG',
  ]);
}
```

{% endcode %}

#### Reclaim script

The reclaim script allows the initial depositor to reclaim their UTXOs.

The construction of the reclaim script:

{% code expandable="true" %}

```typescript
export function buildSbtcReclaimScript(opts: {
  reclaimLockTime: number;
  reclaimPublicKey: string;
}) {
  const reclaimLockTime =
    opts.reclaimLockTime <= 16
      ? opts.reclaimLockTime // number if can be encoded as a OP_<n>
      : btc.ScriptNum().encode(BigInt(opts.reclaimLockTime));
  const publicKeyBytes = hexToBytes(opts.reclaimPublicKey);

  if (publicKeyBytes.length !== 32) throw new Error('Public key must be 32 bytes (schnorr)');

  return btc.Script.encode([
    reclaimLockTime,
    'CHECKSEQUENCEVERIFY',
    'DROP',
    publicKeyBytes,
    'CHECKSIG',
  ]);
}
```

{% endcode %}

Behind the scenes, these two script construction methods are being abstracted away by `buildSbtcDepositAddress` which you've implemented on the front-end.

### How are fees dealt with?

**During deposits**

The `maxSignerFee` refers to the fee in the bitcoin transaction sweeping funds into the consolidated UTXO locked exclusively by sBTC Signers' aggregate address. Depending on network congestion, specify a custom fee your users would be willing to spend. The default value will be 80,000 sats. The user's responsibility of the actual fee spent (for the sweep transaction) is actually deducted from the amount of sBTC that will be minted.

**During withdrawals**

The fees specified in `max-fee` of the function `initiate-withdrawal-request` of the [`.sbtc-withdrawal`](https://explorer.hiro.so/txid/SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-withdrawal?chain=mainnet) contract are referring to the fees paid of the bitcoin withdrawal transaction.

#### How to estimate how much in fees one should spend?

If you want to estimate how much one would expect to be charged in fees, you'd have to estimate the size of the transaction (vbytes) and the current network's fee rate. Below are some estimations you could use as a benchmark:

**For deposits**: \~250 vbytes times the prevailing sats per vbyte fee rate\
**For withdrawals**: \~170 vbtytes times the prevailing sats per vbyte rate

And although many deposits and withdrawals can be combined, these values should be the maximum that a user will be charged regardless of how many other deposits or withdrawals are being serviced in a single transaction by the Signers. Meaning when more than one user's request is included in a sweep transaction on the L1, the users share the fees in proportion to their deposit or withdrawal request's actual weight on the L1.


# Withdrawing: Pegging sBTC into BTC

This guides shows how you can integrate the withdrawal (peg-out) flow from your front-end app to allow users to peg sBTC back into BTC on the Bitcoin network. For more information about sBTC and an explainer of its architecture, check out the general sBTC section [here](https://app.gitbook.com/s/H74xqoobupBWwBsVMJhK/sbtc) in the Learn category.

### Breakdown of the withdrawal (peg-in) flow

* **Validate and deconstruct bitcoin address**
  * Validate user's inputted bitcoin address, to be used to receive BTC, is a valid bitcoin address.
  * Deconstruct the bitcoin address to identify its version type and hashbytes.
* **Construct a Stacks contract call:**
  * Determine amount to withdraw and a reasonable max fee.
  * Construct a contract call to invoke `initiate-withdrawal-request` of `.sbtc-withdrawal` contract.
  * Broadcast the transaction to the Stacks network.
* **Processing by Signers:** (*no action required*)
  * The signers retrieve and verify the withdrawal transaction from the Stacks network.
  * Once verified, the signers burn the sBTC and sends the equivalent amount of BTC back to the user.
* **Receive BTC (Bitcoin):** (*no action required*)
  * The returned BTC is sent to the depositor's designated bitcoin address, completing the withdrawal process.

{% hint style="info" %}
At the moment, the `sbtc` library does not have any direct helper methods, but as you'll see in the guide, it's relatively straightforward to do it without any abstraction methods.
{% endhint %}

In this guide you'll touch on some of the steps above but its much less complex than the deposit flow. Putting together the peg-out process from sBTC into BTC will simply involve the following steps:

1. Validating the withdrawal bitcoin address
2. Contract call to `initiate-withdrawal-request`
3. Confirm BTC withdrawal

{% hint style="info" %}
This guide assumes you have a front-end bootstrapped with the Stacks Connect library for wallet interactions. Head to the guides for Stacks Connect before continuing with this guide.
{% endhint %}

{% stepper %}
{% step %}

#### Validating the withdrawal bitcoin address

Validating a Bitcoin address before using it in code is essential to prevent errors and potential financial losses from incorrect or malicious addresses. It ensures compliance with types like P2PKH, P2SH, or P2TR, and adherence to network protocols. Without proper validation, there's a higher risk of failed transactions and security vulnerabilities, jeopardizing user funds and application reliability.

After validating, you'll want to deconstruct the bitcoin address to identify its version type and hashbytes. The version type is pertaining to the bitcoin address type and how they map to its corresponding Clarity value.

We'll use the `getAddressInfo` method from the [`bitcoin-address-validation`](https://github.com/ruigomeseu/bitcoin-address-validation) library to help us deconstruct the receiving bitcoin address.

<pre class="language-typescript"><code class="lang-typescript">import { AddressType, getAddressInfo } from "bitcoin-address-validation";
import * as bitcoin from "bitcoinjs-lib";

function deconstructBtcAdd(address: string) {
    const typeMapping = {
    [AddressType.p2pkh]: "0x00",
    [AddressType.p2sh]: "0x01",
    [AddressType.p2wpkh]: "0x04",
    [AddressType.p2wsh]: "0x05",
    [AddressType.p2tr]: "0x06",
  };

<strong>  const <a data-footnote-ref href="#user-content-fn-1">addressInfo</a> = getAddressInfo(address);
</strong>  
  const { bech32 } = addressInfo;
  let hashbytes: Uint8Array;
  if (bech32) {
    hashbytes = bitcoin.address.fromBech32(address).data;
  } else {
    hashbytes = bitcoin.address.fromBase58Check(address).hash;
  }

  const type = typeMapping[addressInfo.type];
  if (!type) {
    throw new Error(`Unsupported address type: ${addressInfo.type}`);
  }
  
  return {
    <a data-footnote-ref href="#user-content-fn-2">type</a>,
    <a data-footnote-ref href="#user-content-fn-3">hash</a>bytes,
  };
}
</code></pre>

In the next step, the returned `type` and `hashbytes` are to be passed in as a tuple param of a contract call. The constraints and meaning of the `type` and `hashbytes` param are summarized as:

```
;; version == 0x00 and (len hashbytes) == 20 => P2PKH
;; version == 0x01 and (len hashbytes) == 20 => P2SH
;; version == 0x02 and (len hashbytes) == 20 => P2SH-P2WPKH
;; version == 0x03 and (len hashbytes) == 20 => P2SH-P2WSH
;; version == 0x04 and (len hashbytes) == 20 => P2WPKH
;; version == 0x05 and (len hashbytes) == 32 => P2WSH
;; version == 0x06 and (len hashbytes) == 32 => P2TR
```

{% endstep %}

{% step %}

#### Contract call to `initiate-withdrawal-request`

The function `initiate-withdrawal-request` of the [`.sbtc-withdrawal`](https://explorer.hiro.so/txid/SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-withdrawal?chain=mainnet) contract locks up `amount` + `max-fee` from the sender's account. When the withdrawal request is accepted, the signers will then send BTC `amount` of sats to the recipient and spend the fee `amount` to bitcoin miners (where fee less than or equal to max-fee). If actual fee is less than `max-fee`, then the difference will be minted back to the user when `accept-withdrawal-request` is invoked by the Signers.

The network used, for the bitcoin address, is inherited from the network of the underlying transaction itself (basically, if on Stacks mainnet the Signers will send to mainnet Bitcoin addresses and similarly on Stacks testnet, to Bitcoin testnet addresses).

<pre class="language-typescript"><code class="lang-typescript">import { request } from '@stacks/connect';
import { Cl, Pc } from '@stacks/transactions';

let { type, hashbytes } = deconstructBtcAdd(&#x3C;btcAddress>)

let amount = 100000
let recipient = {
  version: Cl.bufferFromHex(type),
  hashbytes: Cl.buffer(hashbytes)
}
let maxFee = 3000

let postCond_1 = Pc.principal(&#x3C;stxAddress>)
  .willSendEq(amount + maxFee)
  .ft('SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token', 'sbtc-token')

let result = await request('stx_callContract', {
<strong>  contract: 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-withdrawal',
</strong><strong>  functionName: 'initiate-withdrawal-request',
</strong>  functionArgs: [Cl.uint(amount), Cl.tuple(recipient), Cl.uint(maxFee)],
  postConditions: [postCond_1],
  postConditionMode: 'deny',
  network: "mainnet",
})

console.log(result)
// {
//    "transaction": "0000000001040049ff5845af0c7efefca31b764229c84e8968e8bc000000000000009f0000000000000bb800015772b7ea414879826e90da34f9030ad6f8b6fb3f7c07d766906d7d9f9a65752147961e3de57d8fcaa1dfd6d92e0d085af3491efdfe2ec78d9a403c258f5c092e0301000000000214f6decc7cfff2a413bd7cd4f53c25ad7fd1899acc0f736274632d7769746864726177616c1b696e6974696174652d7769746864726177616c2d726571756573740000000301000000000000000000000000000186a00c0000000209686173686279746573020000001457873a539bfb7c071f8cd91805068d546a4941950776657273696f6e0200000001010100000000000000000000000000000bb8",
//    "txid": "cd73c7c3023d4f271981d85cb1c29446a5513dcfc182963ee2d1cfee06b9a4ad"
// }
</code></pre>

{% endstep %}

{% step %}

#### Confirm BTC withdrawal

The Stacks contract call transaction will be confirmed by the Stacks network within seconds. But the actual BTC withdrawal confirmation is longer than the deposit confirmation. Usually around 6 Bitcoin block confirmations are needed.

After confirming the Stacks transaction, confirm that the user has received the withdrawn BTC back into their designated bitcoin address by polling the Emily API endpoint below:

```
https://sbtc-emily.com/withdrawal/sender/<stacks-sender>
```

This will return the status of all withdrawals from the specified sender:

<pre data-title="example return response"><code>{
  "nextToken": null,
  "withdrawals": [
    {
      "requestId": 748,
      "stacksBlockHash": "e19bea7a651136ed5a156e69d5952e86a3792f78df2bb20c8c5ab2009fd5617e",
      "stacksBlockHeight": 4461632,
      "recipient": "0020a6abc068c9783dea16451549cebb174ee82618f9999b53334b2397e02c8a106f",
      "sender": "SP14ZYP25NW67XZQWMCDQCGH9S178JT78QJYE6K37",
      "amount": 110000,
      "lastUpdateHeight": 4462339,
      "lastUpdateBlockHash": "32b2834eb507ec9484ea1bbce97cb2dc241c8ab18bd443181aa5b0c178546bed",
<strong>      "status": "confirmed",
</strong>      "txid": "a355cd64374446e1d0de7096a7c1583bb4564fb6a997650bd9af26605805bfa0"
    },
  ]
}
</code></pre>

So in total there are 2 on-chain transactions that make up the entire withdrawal (peg-out) flow:

1. \[Stacks] Initial sBTC withdrawal request by the user ([example](https://explorer.hiro.so/txid/0x4f4000a0ca61ea10e31bc7950672f57612880b6de3a61463bb98e29ca6bb6491?chain=mainnet))
2. \[Bitcoin] Returned BTC transaction by the Signers ([example](https://mempool.space/tx/4ec2396bebb79d11be6dae3ae133cb0501d05af4ff368425fe19740d050b74dc))
   {% endstep %}
   {% endstepper %}

And that's all to it. You've successfully allowed your app to handle incoming sBTC to be pegged out back into BTC.

***

### \[Additional Insights]

### What are the different bitcoin address types?

Bitcoin addresses come in several types, each serving specific purposes and providing different functionalities. Each address type has evolved to enhance security, scalability, and functionality of Bitcoin transactions in response to the network's growing needs.

Check out the dedicated Hiro blog post to learn more about the why and how different bitcoin addresses are constructed:

{% embed url="<https://www.hiro.so/blog/understanding-the-differences-between-bitcoin-address-formats-when-developing-your-app>" %}

### Why does the withdrawal (peg-out) take longer to provide a bitcoin txid from the Emily API?

The current flow right now goes like this:

1. The user creates a withdrawal request via a contract call on Stacks. In this example, let's say the withdrawal transaction is confirmed in a Stacks block anchored to a Bitcoin block at height N.
2. The Signers and Emily get the event from the contract call above. Emily marks the withdrawal as pending.
3. The Signers wait until that Bitcoin block is final enough, which is at Bitcoin block N+6. When that Bitcoin block arrives they create and broadcast a sweep transaction fulfilling the withdrawal request. Then the Signers tell Emily that they have accepted the withdrawal request.
4. Usually the sweep transaction is included in the next block, so it's confirmed at block N+7.
5. The Signers issue the contract call finalizing the withdrawal on Stacks, and Emily finds out about the transaction fulfilling the withdrawal.

Here are some useful notes about the above process:\
When the Signers tell Emily that the withdrawal has been accepted, they don't tell her about the bitcoin transaction that it's accepted in. This is intentional, because the final transaction fulfilling the withdrawal is not known until it is confirmed. It could also be the case that the Signers attempt to fulfill the withdrawal request but end up never fulfilling it. As in, the Signers could create a transaction fulfilling the withdrawal request, where they broadcast it to the Bitcoin network, but that transaction is never confirmed and never will be. Moreover, this situation is not too unlikely; it can happen when fees spike relative to the user's max fee. The current approach sidesteps all of that UX complexity and prudently informs Emily about the transaction ID after it is known to be confirmed. Moreover, some wallets can tell you if there is a payment made out to you by just examining the Bitcoin mempool.

[^1]: ```
    type AddressInfo = {
      bech32: boolean;
      network: Network;
      address: string;
      type: AddressType;
    }
    ```

[^2]: type: string

[^3]: type: Uint8Array


# Price Oracles

Leverage real-time market price data in your Clarity smart contract

<figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2Fgit-blob-850b421678f3e430f2a8d10bf8a6c3e53f2e61b1%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>

Smart contracts written in **Clarity** run in a deterministic sandbox: they can read data in the Stacks and Bitcoin chainstate, but *nothing else*. Whenever your dApp needs the latest **BTC/USD**, **STX/BTC**, or any other market price, you’ll rely on an **oracle** to bring that data on‑chain in a verifiable way.

This page explains why price‑feed oracles matter on Stacks and links to the specific oracle provider docs with instructions on how to integrate them.

***

## Why you need a price‑feed oracle

For DeFi smart contracts, it’s crucial to leverage trusted sources for asset pricing, which has profound implications for investor returns and trading strategies.&#x20;

Here are some possible scenarios where you might need an oracle.

| On‑chain need                        | Typical Stacks use case                        | What the oracle supplies            |
| ------------------------------------ | ---------------------------------------------- | ----------------------------------- |
| **Liquidations & collateral ratios** | Lending / borrowing protocols, margin trading  | Signed price updated every N blocks |
| **Stablecoin peg maintenance**       | BTC‑backed or exogenous‑collateral stablecoins | Reference BTC/USD (or other) price  |
| **AMM curve calculations**           | DEXs that tune fees or rebalance pools         | Time‑weighted average price (TWAP)  |
| **Derivatives settlement**           | Options, futures, or perpetual swaps           | Final settlement price at expiry    |

{% hint style="info" %}
Rule of thumb: if your contract’s math depends on a real‑time market price, you need a price‑feed oracle.
{% endhint %}

## Oracle Providers for Stacks

Here are the currently available oracle providers that Stacks builders commonly use for price data.

### **Pyth**

Pyth is a pull-based oracle. Stacks Labs currently maintains the Pyth bridge.

[Learn how to use Pyth.](https://docs.stacks.co/build/more-guides/price-oracles/pyth)

### **DIA**

DIA is another oracle provider used by Stacks builders. See DIA's [guide](https://nexus.diadata.org/how-to-guides/fetch-price-data/chain-specific-guide/stacks) for how to use DIA oracles with Stacks. Check out the video tutorial to learn more on how DIA works for Clarity smart contracts:

{% embed url="<https://youtu.be/bhWQxHGpv2s?si=dWlBAEAuYtoQj2sC>" %}


# Using Pyth with Stacks

{% hint style="success" %}
For the latest releases and versions of the Stacks-Pyth contracts, check out the open-source repo [here](https://github.com/stx-labs/stacks-pyth-bridge).
{% endhint %}

The contract logic, that we’ll use for this example, will mint an NFT in exchange for $100 of sBTC. Our Clarity contract will read the price of BTC/USD from the Pyth integration contract to calculate the amount of sBTC required to mint the NFT.

Each Pyth Network price feed is referred to via a unique ID. The full list of price feeds is listed on the pyth.network website. To use a price feed on-chain, look up its ID, then store the feed ID in your program for price feed queries. Each price feed has its own unique id:

**Available Pyth price feeds for Stacks:**

* **BTC**: [0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43](https://www.pyth.network/price-feeds/crypto-btc-usd)
* **STX:** [0xec7a775f46379b5e943c3526b1c8d54cd49749176b0b98e02dde68d1bd335c17](https://www.pyth.network/price-feeds/crypto-stx-usd)
* **USDC:** [0xeaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a](https://www.pyth.network/price-feeds/crypto-usdc-usd)
* **ETH**: [0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace](https://www.pyth.network/price-feeds/crypto-eth-usd)

{% hint style="info" %}
To request more supported price feeds, open an issue in the Pyth maintained repo for Stacks [here](https://github.com/Trust-Machines/stacks-pyth-bridge).
{% endhint %}

Pyth Network uses a pull price update model that is slightly different from other oracles you may be more familiar with. Most oracles today use a push model, where the oracle runs an off-chain process that continuously sends transactions to update an on-chain price. In contrast, Pyth Network does not operate an off-chain process that pushes prices on-chain. Instead, it delegates this work to Pyth Network users.

<div data-with-frame="true"><figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2F7JkmgeOKaznQ3eLpJuyu%2Fpyth-pull-flow-diagram.png?alt=media&#x26;token=9f928672-025d-41f1-bfc4-283415d6bdea" alt=""><figcaption></figcaption></figure></div>

The maintained Pyth integration contract for Stacks is called [.pyth-oracle-v4](https://explorer.stacks.co/txid/SP1CGXWEAMG6P6FT04W66NVGJ7PQWMDAC19R7PJ0Y.pyth-oracle-v4?chain=mainnet). This contract serves as the main entry point for updating and getting price feed data. The Pyth protocol integration is available as a Beta on both testnet and mainnet networks, to help developers test, give feedback, and ensure the reliability and stability of the integration.

#### File setup

Below are how the contracts and mainfest files are setup in this example Clarinet project. We'll be using Clarinet's mainnet simulation for this example, hence why we are adding mainnet contracts for Pyth in our files.

{% tabs %}
{% tab title="main.clar" %}
{% code expandable="true" %}

```clarity
(define-constant CONTRACT_OWNER tx-sender)
(define-constant COST-OF-BENJAMIN-NFT u100)

(define-constant ERR_READING_SBTC_BALANCE (err u7001))
(define-constant ERR_NOT_ENOUGH_SBTC (err u7002))
(define-constant ERR_NOT_OWNER (err u7003))

(define-public (join-the-benjamin-club (price-feed-bytes (buff 8192)))
  (let (
      ;; Update & verify VAA for BTC price feed
      (update-status (try! (contract-call? 'SP1CGXWEAMG6P6FT04W66NVGJ7PQWMDAC19R7PJ0Y.pyth-oracle-v4
        verify-and-update-price-feeds price-feed-bytes {
        pyth-storage-contract: 'SP1CGXWEAMG6P6FT04W66NVGJ7PQWMDAC19R7PJ0Y.pyth-storage-v4,
        pyth-decoder-contract: 'SP1CGXWEAMG6P6FT04W66NVGJ7PQWMDAC19R7PJ0Y.pyth-pnau-decoder-v3,
        wormhole-core-contract: 'SP1CGXWEAMG6P6FT04W66NVGJ7PQWMDAC19R7PJ0Y.wormhole-core-v4,
      })))
      ;; Get fresh BTC price
      (price-data (try! (contract-call? 'SP1CGXWEAMG6P6FT04W66NVGJ7PQWMDAC19R7PJ0Y.pyth-oracle-v4
        get-price
        ;; The official BTC price feed id.
        0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43
        'SP1CGXWEAMG6P6FT04W66NVGJ7PQWMDAC19R7PJ0Y.pyth-storage-v4
      )))
      ;; Adjust price and get user sBTC balance
      ;; Price feeds represent numbers in a fixed-point format. The expo property tells us
      ;; at what certain position is the decimal point implicity fixed.
      (price-denomination (pow 10 (* (get expo price-data) -1)))
      ;; We'll adjust the price to its normal decimal representation.
      (adjusted-price (to-uint (/ (get price price-data) price-denomination)))
      ;; Get the user's current sBTC balance.
      (user-sbtc-balance (unwrap!
        (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token
          get-balance-available tx-sender
        )
        ERR_READING_SBTC_BALANCE
      ))
    )
    ;; Determine if the user has at least $100 worth of sBTC to join the Benjamin Club and mint NFT
    (if (> (/ (* user-sbtc-balance adjusted-price) (to-uint price-denomination))
        COST-OF-BENJAMIN-NFT
      )
      (let ((hundred-dollars-in-sbtc (/ (* COST-OF-BENJAMIN-NFT (to-uint price-denomination)) adjusted-price)))
        (try! (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token
          transfer hundred-dollars-in-sbtc tx-sender current-contract
          none
        ))
        (contract-call? .nft mint tx-sender)
      )
      ERR_NOT_ENOUGH_SBTC
    )
  )
)
```

{% endcode %}
{% endtab %}

{% tab title="nft.clar" %}
{% code expandable="true" %}

```clarity
;; This contract implements the SIP-009 community-standard Non-Fungible Token trait
(impl-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)

;; Define the NFT's name
(define-non-fungible-token benjamin uint)

;; Keep track of the last minted token ID
(define-data-var last-token-id uint u0)

;; Define constants
(define-constant CONTRACT_OWNER tx-sender)
(define-constant COLLECTION_LIMIT u100)

(define-constant ERR_OWNER_ONLY (err u100))
(define-constant ERR_NOT_TOKEN_OWNER (err u101))
(define-constant ERR_SOLD_OUT (err u300))

(define-data-var base-uri (string-ascii 80) "")

;; SIP-009 function: Get the last minted token ID.
(define-read-only (get-last-token-id)
  (ok (var-get last-token-id))
)

;; SIP-009 function: Get link where token metadata is hosted
(define-read-only (get-token-uri (token-id uint))
  (ok (some (var-get base-uri)))
)

;; SIP-009 function: Get the owner of a given token
(define-read-only (get-owner (token-id uint))
  (ok (nft-get-owner? benjamin token-id))
)

;; SIP-009 function: Transfer NFT token to another owner.
(define-public (transfer
    (token-id uint)
    (sender principal)
    (recipient principal)
  )
  (begin
    ;; #[filter(sender)]
    (asserts! (is-eq tx-sender sender) ERR_NOT_TOKEN_OWNER)
    (nft-transfer? benjamin token-id sender recipient)
  )
)

;; Mint a new NFT.
(define-public (mint (recipient principal))
  ;; Create the new token ID by incrementing the last minted ID.
  (let ((token-id (+ (var-get last-token-id) u1)))
    ;; Ensure the collection stays within the limit.
    (asserts! (< (var-get last-token-id) COLLECTION_LIMIT) ERR_SOLD_OUT)
    ;; Only the contract owner can mint.
    (asserts! (is-eq contract-caller .main) ERR_OWNER_ONLY)
    ;; Mint the NFT and send it to the given recipient.
    (try! (nft-mint? benjamin token-id recipient))
    ;; Update the last minted token ID.
    (var-set last-token-id token-id)
    ;; Return a success status and the newly minted NFT ID.
    (ok token-id)
  )
)

```

{% endcode %}
{% endtab %}

{% tab title="Clarinet.toml" %}
{% code expandable="true" %}

```toml
[project]
name = 'clarity-contracts'
description = ''
authors = []
telemetry = false
cache_dir = './.cache'

[[project.requirements]]
contract_id = 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait'

[[project.requirements]]
contract_id = 'SP1CGXWEAMG6P6FT04W66NVGJ7PQWMDAC19R7PJ0Y.pyth-oracle-v4'

[[project.requirements]]
contract_id = 'SP1CGXWEAMG6P6FT04W66NVGJ7PQWMDAC19R7PJ0Y.wormhole-core-v4'

[[project.requirements]]
contract_id = 'SP1CGXWEAMG6P6FT04W66NVGJ7PQWMDAC19R7PJ0Y.pyth-pnau-decoder-v3'

[[project.requirements]]
contract_id = 'SP1CGXWEAMG6P6FT04W66NVGJ7PQWMDAC19R7PJ0Y.pyth-storage-v4'

[[project.requirements]]
contract_id = 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token'

[contracts.main]
path = 'contracts/main.clar'
clarity_version = 4
epoch = 'latest'

[contracts.nft]
path = 'contracts/nft.clar'
clarity_version = 4
epoch = 'latest'

[repl.analysis]
passes = ['check_checker']

[repl.analysis.lints]

[repl.analysis.check_checker]
strict = false
trusted_sender = false
trusted_caller = false
callee_filter = false

[repl.remote_data]
enabled = true
api_url = 'https://api.hiro.so'
use_mainnet_wallets = true
```

{% endcode %}
{% endtab %}
{% endtabs %}

### Contract Walkthrough

The walkthrough below will use a example contract that will mint an NFT in exchange for $100 of sBTC. Our Clarity contract will read the price of BTC/USD from the Pyth integration contract to calculate the amount of sBTC required to mint the NFT. The action of minting an NFT if one has at least $100 worth of sBTC will be deemed as *"joining the benjamin club"*. Benjamin is in reference to Benjamin Franklin being the face of a one hundred dollar bill, get it?

{% stepper %}
{% step %}

#### Verify and update the BTC price feed

We'll open up our function by accepting a `(price-feed-bytes (buff 8192))` parameter. This `price-feed-bytes` is in reference to a VAA message payload. Later in this guide we'll show you how to fetch this payload on the front end.&#x20;

You'll notice in the Clarity snippet below we open up `let` bindings of our function to:

1. Verify and update the BTC price feed with its latest VAA message (more on how to pull the VAA later in this guide). This is a means of participating in the pull price update model.
2. Getting a fresh instance of the updated price data for BTC.

{% hint style="info" %}
The `pyth-oracle-contract`, `pyth-storage-contract`, `pyth-decoder-contract`, and `wormhole-core-contract` do not need to be hardcorded in your contract. It's recommended to pass these contracts into the outer function as arguments since these contracts are susceptible to future upgrades.
{% endhint %}

{% code title="main.clar" expandable="true" %}

```clarity
;; --snip--

(define-public (join-the-benjamin-club (price-feed-bytes (buff 8192)))
  (let (
      ;; Update & verify VAA for BTC price feed
      (update-status (try! (contract-call? 'SP1CGXWEAMG6P6FT04W66NVGJ7PQWMDAC19R7PJ0Y.pyth-oracle-v4
        verify-and-update-price-feeds price-feed-bytes {
        pyth-storage-contract: 'SP1CGXWEAMG6P6FT04W66NVGJ7PQWMDAC19R7PJ0Y.pyth-storage-v4,
        pyth-decoder-contract: 'SP1CGXWEAMG6P6FT04W66NVGJ7PQWMDAC19R7PJ0Y.pyth-pnau-decoder-v3,
        wormhole-core-contract: 'SP1CGXWEAMG6P6FT04W66NVGJ7PQWMDAC19R7PJ0Y.wormhole-core-v4,
      })))
      ;; Get fresh BTC price
      (price-data (try! (contract-call? 'SP1CGXWEAMG6P6FT04W66NVGJ7PQWMDAC19R7PJ0Y.pyth-oracle-v4
        get-price
        ;; The official BTC price feed id.
        0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43
        'SP1CGXWEAMG6P6FT04W66NVGJ7PQWMDAC19R7PJ0Y.pyth-storage-v4
      )))

;; --snip---
```

{% endcode %}
{% endstep %}

{% step %}

#### Handling \`get-price\` data

After updating and verifying the price feed in question, and then getting the updated price feed data, we'll need to handle the price feed data and its properties.

The price feed data returned from invoking the `get-price` function of the `.pyth-oracle-v4` contract looks like the below:

```
{
  price-identifier: 0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43,
  price: 10603557773590,
  conf: u3776653890,
  ema-price: 10602069900000,
  ema-conf: u4062895700,
  expo: -8,
  publish-time: u1750425711,
  prev-publish-time: u1750425710
}
```

{% endstep %}

{% step %}

#### Adjust returned price value and determine mint eligibility

With the latest price feed data returned, we can adjust the price based on the `expo` property. Price feeds represent numbers in a fixed-point format. Fixed-point numeric representation is a way of storing numbers with fractional parts using integers, where the decimal point is implicitly fixed at a certain position. So in the above returned price feed data, the returned price of `10603557773590` and given expo of `-8` should be formatted as `106035`. The same exponent is used for both the price and confidence interval.

We can then determine the USD amount of sBTC the user owns and decide if it is enough to mint a `benjamin-nft` for $100 worth of sBTC. Benjamin is in reference to Benjamin Franklin being the face of a one hundred dollar bill, get it?

{% code title="main.clar" fullWidth="false" expandable="true" %}

```clarity
;; --snip--

      ;; Price feeds represent numbers in a fixed-point format. The expo property tells us
      ;; at what certain position is the decimal point implicity fixed.
      (price-denomination (pow 10 (* (get expo price-data) -1)))
      ;; We'll adjust the price to its normal decimal representation.
      (adjusted-price (to-uint (/ (get price price-data) price-denomination)))
      ;; Get the user's current sBTC balance.
      (user-sbtc-balance (unwrap!
        (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token
          get-balance-available tx-sender
        )
        ERR_READING_SBTC_BALANCE
      ))
    )
    ;; Determine if the user has at least $100 worth of sBTC to join the Benjamin Club and mint NFT
    (if (> (/ (* user-sbtc-balance adjusted-price) (to-uint price-denomination))
        COST-OF-BENJAMIN-NFT
      )
      (let ((hundred-dollars-in-sbtc (/ (* COST-OF-BENJAMIN-NFT (to-uint price-denomination)) adjusted-price)))
        (try! (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token
          transfer hundred-dollars-in-sbtc tx-sender current-contract
          none
        ))
        (contract-call? .nft mint tx-sender)
      )
      ERR_NOT_ENOUGH_SBTC
    )
  )
)
```

{% endcode %}
{% endstep %}
{% endstepper %}

### Interact with contract in console using mxs

Since we are using Pyth and sBTC's mainnet contract addresses in our contract, we'll use Clarinet's mainnet simulation feature to interact with the contract in simnet.

{% hint style="warning" %}
Be sure you've enabled mainnet simulation in your manifest file. See the Clarinet.toml file above.
{% endhint %}

{% stepper %}
{% step %}

#### Set \`tx\_sender\` to a mainnet address

In the Clarinet console run: `::set_tx_sender <mainnet-address>`     &#x20;

You'll want to grab a `<mainnet-address>` that most likely has over $100 of sBTC. This is so we can have a simulation of being able to mint the NFT. Then switch the `tx_sender` context so that we can have *that* mainnet address simulate calling our contract.
{% endstep %}

{% step %}

#### Call \`join-the-benjamin-club\` with a VAA payload

In the Clarinet console run: `(contract-call? 'SP1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRCBGD7R.main join-the-benjamin-club <vaa-payload-hex>)`&#x20;

Pass in a valid VAA payload into the `join-the-benjamin-club` function. If everything passes, you should see the events emitted from the contract along with an `(ok u1)` response.

<details>

<summary>Where to get a sample VAA payload?</summary>

You can use this sample VAA payload to test with. This VAA payload is outdated but should be testable in simnet/console.

```
0x504e41550100000003b801000000040d0064f9d65f754bc6426b50d45047fc50c905196202e888b73182a8177579ec838f652d710879a9a0c3026bd9e44b32509b9c94e86328d89235c5221e4cd20303ca000265aa2173fe44b28c3942c984ee953e9e2a06a686656c8bd36fbf396d7b4bfe9338bd6017a484b60ca1c80a75458f55ff9c9dd3e5edfa45f6243c13d77f414d4000045529833b17cfc6b011de0b72709c785a86d0ce9281a8c21a250f55d3fbfd79b47b89f110c63acdf8e0fa251d245b6e87ccbf5747dab2ba6eaf22e27f16fc97580006f673a3f384580e0bc7c5a246fb77a37f83ded9fe1368f3c15cdbad2475f2378d0daae7d3201e23ba45c04606dedea0327bd095f7b45d9dd84600b8e877af0c810008a4018e5793e30ac8439aef1b3ce284b670e95ab5ce76090f4dac860a1267177355102ddc46d33f4c53c253b30cb945ce63c710773fa40ae846192c6d1e335921000aea43bd88cc9891274d2b7f493b362c7799b2bf1e40630181fecce951118c987345da8f194ac0a44a2f956dce99b61f2254fe6b2409382d8e887e8fa07e6894aa000b9639228e880e97da54c07a9b762849a232a6f4358d9c82ec2e9a57c55cf0d89767e9e690586e52c752f31d541b1d68f7a86f3d7dffbbd6229fae2aa9b7647815010ca826b369905ff52daa0204b2ce3cedde1eee11d167e0cbdad3350362210840523db4c95c4669bd59b5e3dcd84d8bed673d0452d2229832f9af0904f070721fd0010d1b6af9c169ab48b47d6726d35f030eddabf9e6e04058097730bca037284a114a439b7ceb984013e8bc4873182dfd893d52c91a558a4bafe32f6d9a692765fc27010ef1c798f6db4a3c6387797dff6c06779b45b03bc1fde7a1eb86942bbb8ab3d5fc70c317d51dd71cbac39b8bd038bcf72552e4bc048f4e0731b9643090eb8bb1b6000fca5d6ac6f0e6569e1072566a56075dae7db43d8a008e939422863890c64e76b81544ae0ebaaacb473241c75cf5e2a8a1fd5c1cd5ee99970113e4d4bd0a86d9c70010c66616689026b43cbcd0012c7e87c9de75b7b8f60d2c765ec298ade7862d64ce63ef95670553bc120b08b52e6c5893a0509287ad5b38cd44a9113ddce5dc4c12001177acdc2be20bef459c68d319fd121fea8c2fbd1aad4ee8ebe36a5750214c39510b60e89b4c247e6e354f64722a49eb40ba2ba164cb9e6191e14b81155f16e6a4006935e74900000000001ae101faedac5851e32b9b23b5f9411a8c2bac4aae3ed4dd7b811dd1a72ea4aa71000000000a6abf2a014155575600000000000f78660e00002710c82bc426063e681025b2a2462b81da02fbdc9ab001005500e62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b4300000852e1a4948000000000ac606b00fffffff8000000006935e749000000006935e7480000084e36eef02000000000a4da13a40d0d91f61daad89890a2c5da1abd4009915ccb2042e737bd6a369235eadc65f71867b56b312545c86c2cd2cd18971f74e0ef4e849a2b295b12dab11d5650dc565595a445ea019e1258a1397dc974e42ef8315937dc38ca22e8327aa6c21decb109199d18fec07feded692d0a8b1660748d3402dcd9e84229dd201c5da161c653ae21e63acdbf9ee603deec2668923bc0435272b1fc3851957c2a7a4867704a39d4e0c43b378456f0695c944f2bc3ba3ea356d4d3318a0b8c666d8df3a74fa3cea21e74470dc680878ff8dac909832fea3e4dc56c1fa5287cd472db6db3eb54c232d4faf9080009f4fa433b6b465ced1e2826dc510e7cf81c7261bf377e1847c0f08d7280f8
```

</details>

<details>

<summary>Run unit tests</summary>

You can also test your contract using mxs in unit tests. See the below unit test setup that shows how you can fetch the latest VAA for your contract call.

{% code title="main.test.ts" expandable="true" %}

```typescript
import { describe, expect, it } from "vitest"
import { Cl, } from "@stacks/transactions"
import { HermesClient } from "@pythnetwork/hermes-client";

const accounts = simnet.getAccounts()
const deployer = accounts.get("deployer")

async function handleFetchLatestVaa() {
  const connection = new HermesClient("https://hermes.pyth.network", {});

  const priceIds = [
    "0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43",
  ];

  const priceUpdates = await connection.getLatestPriceUpdates(priceIds);
  console.log(priceUpdates);
  
  let latestVaaHex = `0x${priceUpdates.binary.data[0]}`;

  return latestVaaHex;
}

describe("pyth unit tests", () => {
  it("ensures joining of Benjaming Club", async () => {
    let VAA = await handleFetchLatestVaa()

    let confirmation = simnet.callPublicFn(
      `${deployer}.main`,
      "join-the-benjamin-club",
      [Cl.bufferFromHex(VAA)],
      "<mainnet-address>"
    )

    expect(confirmation.result).toBeOk(Cl.uint(1))
    
  // an extended timeout value is set below due to long processing of Pyth functions
  }, 12000)
})
```

{% endcode %}

</details>
{% endstep %}
{% endstepper %}

### Frontend Walkthrough

Wormhole is a decentralized attestation engine that leverages its network of guardians to trustlessly bridge information between the chains it supports. Wormhole has a simple, elegant, and pragmatic design that has enabled it to be the first real solution to ship to market and has received wide recognition and support from its member chains.

Hermes is a web service that listens to the Wormhole Network for signed and attested price updates, and serves them via a convenient web [API](https://hermes.pyth.network/docs/#/rest/latest_price_updates). It provides Pyth's latest price update data format that is more cost-effective to verify and use on-chain. Hermes allows users to easily query for recent price updates via a REST API, or subscribe to a websocket for streaming updates. The Pyth Network also provides a Javascript [SDK](https://github.com/pyth-network/pyth-crosschain/tree/main/price_service/client/js) to connect to an instance of Hermes for fetching price updates.

In your front-end application code, you can install and use the methods brought by Pyth Network's `hermes-client` Javascript SDK to fetch the latest price update, known as a VAA (Verified Action Approvals) message.

```typescript
import { HermesClient } from "@pythnetwork/hermes-client";
import { Cl, Pc } from "@stacks/transactions"
import { request } from "@stacks/connect"

// --snip--

async function handleFetchLatestVaa() {
  const connection = new HermesClient("https://hermes.pyth.network", {});

  const priceIds = [
    "0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43",
  ];

  const priceUpdates = await connection.getLatestPriceUpdates(priceIds);
  let latestVaaHex = `0x${priceUpdates.binary.data[0]}`;

  return latestVaaHex;
}

// --snip--
```

The binary data returned from the Pyth SDK will already be in hexadecimal format. We'll then take this hexadecimal VAA message and pass it into our Clarity function as an argument.

Using Stacks Connect of the stacks.js monorepo, we'll open up a `stx_callContract` request and invoke our public function while passing in the `latestVaaHex` as the function argument.

```typescript
// --snip--

let latestVaaHex = await handleFetchLatestVaa();

let postCond1 = Pc.principal("<tx-sender>")
  .willSendLte(1)
  .ustx();

const response = await request("stx_callContract", {
  contract: `SP1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRCBGD7R.benjamin-club`,
  functionName: "join-the-benjamin-club",
  functionArgs: [Cl.bufferFromHex(latestVaaHex)],
  network: "mainnet",
  postConditions: [postCond1],
  postConditionMode: "allow",
});
```

If you noticed, we set a post-condition statement of our user transferring less than or equal to 1 uSTX, which is 0.000001 STX. This is because the `verify-and-update-price-feeds` of the `.pyth-oracle-v4` contract applies a fee for this.&#x20;

Setting a separate post-condition statement on the actual sbtc token transfer in our example will also be needed. Beforehand, you could invoke the `decode-price-feeds` function with the `latestVaaHex` to simply have the contained price data decoded and returned. From there you could pre-determine the estimated amount of sbtc tokens to be transferred and set in a separate post-condition.

***

### Additional Resources

* \[[Hiro YT](https://youtu.be/eybqQVRh_hw?si=uwlpiZq36Ad7bBb0)] How To Pull Real-Time Price Data in Your Clarity Smart Contracts (Using Pyth)
* \[[Pyth Docs](https://docs.pyth.network/price-feeds/core/use-real-time-data/pull-integration/stacks)] How to Use Real-Time Data in Stacks Applications
* \[[Hiro Blog](https://www.hiro.so/blog/new-oracle-alert-pyth-integration-with-stacks)] New Oracle Alert: Pyth Integration With Stacks&#x20;


# Bitcoin Integration

One of the unique features of the Stack chain and the Clarity language is that it allows for directly reading from the Bitcoin chain itself. These tutorials walk you through some different ways you can accomplish that.


# Sending Bitcoin with Leather

<figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2Fgit-blob-cc6def54374254795dfc69c9d57119cb885e9a83%2Fimage.png?alt=media" alt=""><figcaption><p>source: <a href="https://leather.io/">leather.io</a></p></figcaption></figure>

Using Leather's web wallet, you can initiate a simple Bitcoin transaction from a JS app in a few lines of code.

{% hint style="info" %}
You must be authenticated with the Leather wallet for this to work. See the Authentication with Stacks.js tutorial for how to authenticate before using the API.
{% endhint %}

{% stepper %}
{% step %}

#### Prepare the send call

Use the `window.btc?.request("sendTransfer", ...)` API to initiate a transaction. Provide the destination address and the amount in satoshis.

```javascript
const sendBitcoin = async () => {
  const resp = await window.btc?.request("sendTransfer", {
    address: "tb1qya9wtp4dyq67ldxz2pyuz40esvgd0cgx9s3pjl", // replace with the recipient address
    amount: "10000", // amount in satoshis
  });

  // Storing txid in local storage
  // We'll get back the transaction ID, which we can then use as needed
  if (typeof window !== "undefined") {
    localStorage.setItem("txid", JSON.stringify(resp.result.txid));
  }

  // Optionally mark the transaction as pending and poll a Bitcoin API (e.g., mempool.space) to check confirmation status
  localStorage.setItem("txStatus", "pending");
};
```

{% endstep %}

{% step %}

#### Hook up the UI

Call the `sendBitcoin` function from your UI (for example, a button click).

{% code title="Example component" %}

```javascript
<button onClick={sendBitcoin}>Send Bitcoin</button>
```

{% endcode %}
{% endstep %}

{% step %}

#### Next steps

* To verify a transaction was mined, use the returned txid and query a Bitcoin explorer or API (for example, mempool.space).
* See the "Verifying a transaction on the BTC chain" recipe for a more complete flow using the returned transaction ID as a starting point.
  {% endstep %}
  {% endstepper %}


# Verifying a Bitcoin Transaction

One of the coolest things about Clarity is that it allows us to have visibility into the state of the Bitcoin blockchain. Since Stacks blocks are mined in lockstep with Bitcoin blocks, we can directly read the burnchain header info of each Bitcoin block using Clarity's built-in [`get-burn-block-info?`](https://docs.stacks.co/docs/clarity/language-functions#get-burn-block-info-clarity2) function.

There are quite a few relatively complex things that need to happen to do this successfully, but a [clarity-bitcoin library](https://github.com/friedger/clarity-bitcoin/) exists to make the process a lot easier and handle some of the heavy lifting for us.

Let's take a look at how to verify a Bitcoin transaction was mined using Clarity using the library. If you take a look at the `clarity-bitcoin.clar` file in the linked repo, you'll find a function called `was-tx-mined-compact`. That's what we'll be working with, and it looks like this:

{% code title="clarity-bitcoin.clar" %}

```clarity
(define-read-only (was-tx-mined-compact (height uint) (tx (buff 1024)) (header (buff 80)) (proof { tx-index: uint, hashes: (list 14 (buff 32)), tree-depth: uint}))
    (let ((block (unwrap! (parse-block-header header) (err ERR-BAD-HEADER))))
      (was-tx-mined-internal height tx header (get merkle-root block) proof)))
```

{% endcode %}

The transaction itself is relatively simple, but there's a lot happening within other private function calls. I encourage you to read the contract for yourself and trace what is happening, step-by-step, when we call this function.

For now, we'll just go over how to actually call this function successfully.

You can see that it takes a few pieces of information:

* `(height uint)` the block height you are looking to verify the transaction within
* `(tx (buff 1024))` the raw transaction hex of the transaction you are looking to verify
* `(header (buff 80))` the block header of the block
* `(proof { tx-index: uint, hashes: (list 14 (buff 32)), tree-depth: uint})` a merkle proof formatted as a tuple

{% hint style="info" %}
A Merkle proof is a compact way to prove that a transaction is included in a block in the Bitcoin blockchain. Here's how it works:
{% endhint %}

{% stepper %}
{% step %}

#### How transactions are combined into the Merkle root

Transactions in a block are hashed and paired, then the hashes of the pairs are hashed and paired, and so on until a single hash remains — this is called the Merkle root.
{% endstep %}

{% step %}

#### Merkle root in the block header

The Merkle root is included in the block header. By providing the hashes that lead from a transaction's hash up to the Merkle root, along with the block header, one can prove that the transaction is included in that block.
{% endstep %}

{% step %}

#### Merkle proof (Merkle path)

The hashes that connect a transaction to the Merkle root are called the Merkle proof or Merkle path. By providing the Merkle proof along with the transaction hash and block header, anyone can verify that the transaction is part of that block.
{% endstep %}

{% step %}

#### Efficient decentralized verification

This allows for efficient decentralized verification of transactions without having to download the entire blockchain. One only needs the transaction hash, Merkle proof, and block header to verify.
{% endstep %}
{% endstepper %}

Once we have this information, we can call into the `clarity-bitcoin.clar` contract and pass in this data. A common practice would be to get this data from a Bitcoin block explorer API like Mempool.space or Blockstream's esplora, parse it into the correct format for this helper, and then pass it to this function.

We could do that directly via this contract if we just need a direct response on if the transaction was included or not, but more likely we would want to integrate this functionality into a Clarity contract of our own where we can `asserts!` that a transaction was mined before taking another action.

Here's a basic example where we are calling [Blockstream's API](https://github.com/Blockstream/esplora/blob/master/API.md) using JavaScript, parsing the data into the right format, and then calling into our own `mint` function to only mint an NFT if the selected transaction was mined.

We can get all the information we need with nothing but the transaction ID, which will usually be passed to us when we use a wallet like [Hiro's web wallet](https://hirowallet.gitbook.io/developers/bitcoin/sign-transactions/sending-bitcoin) to initiate the Bitcoin transaction.

Let's go through the code we can use to implement this. For full context, this code is taken from the example [bitbadge](https://github.com/kenrogers/bitbadge) repo, which you can take a look at. For a complete step-by-step walkthrough of how to implement this, check out the [Bitcoin Primer](https://bitcoinprimer.dev/).

Here's the mint function:

{% code title="contract.clar" %}

```clarity
(define-public (mint (recipient principal) (height uint) (tx (buff 1024)) (header (buff 80)) (proof { tx-index: uint, hashes: (list 14 (buff 32)), tree-depth: uint}))
    (let
        (
            (token-id (+ (var-get last-token-id) u1))
            (tx-was-mined (try! (contract-call? .clarity-bitcoin was-tx-mined-compact height tx header proof)))
        )
        (asserts! (is-eq tx-sender contract-owner) err-owner-only)
        (asserts! (is-eq tx-was-mined true) err-tx-not-mined)
        (try! (nft-mint? bitbadge token-id recipient))
        (var-set last-token-id token-id)
        (ok token-id)
    )
)
```

{% endcode %}

Note the `(asserts! (is-eq tx-was-mined true) err-tx-not-mined)` line. This is what is doing the heavy lifting.

{% hint style="warning" %}
Right now the clarity-bitcoin library only supports legacy transactions. Work is in-progress to add support for segwit, but until then we have to do a bit of work on the front end to strip the witness data from the raw transaction hex.
{% endhint %}

Here's the JavaScript code we can use to get the data we need.

First we get the raw transaction and the merkle proof (we do this when we first get the transaction ID back).

The `useEffect` here is so that we can check to see if the transaction was confirmed every 10 seconds before we get the rest of the information.

{% code title="useEffect - poll transaction status" %}

```javascript
// Effect hook to check and see if the tx has been confirmed using blockstream API
useEffect(() => {
  const intervalId = setInterval(() => {
    const txid = JSON.parse(localStorage.getItem("txid"));
    if (txid) {
      fetch(`https://blockstream.info/testnet/api/tx/${txid}/status`)
        .then((response) => response.json())
        .then(async (status) => {
          // set txStatus in localStorage if it is confirmed, otherwise we want to leave it pending
          if (status.confirmed) {
            localStorage.setItem("txStatus", "confirmed");
            // set the block details
            const blockDetails = {
              block_height: status.block_height,
              block_hash: status.block_hash,
            };
            setBlockDetails(blockDetails);
            localStorage.setItem("blockDetails", JSON.stringify(blockDetails));
            // fetch and set the tx raw
            const rawResponse = await fetch(
              `https://blockstream.info/testnet/api/tx/${txid}/hex`
            );
            const txRaw = await rawResponse.text();
            localStorage.setItem("txRaw", txRaw);
            // fetch and set the merkle proof
            const proofResponse = await fetch(
              `https://blockstream.info/testnet/api/tx/${txid}/merkle-proof`
            );
            const txMerkleProof = await proofResponse.json();
            localStorage.setItem(
              "txMerkleProof",
              JSON.stringify(txMerkleProof)
            );
            clearInterval(intervalId);
          }
        })
        .catch((err) => console.error(err));
    }
  }, 10000);
  return () => clearInterval(intervalId); // Clean up on component unmount
}, []);
```

{% endcode %}

Then we get and parse the rest of the data when we call the actual mint function.

{% code title="mintBitbadge - prepare and call contract" %}

```javascript
// This function retrieves raw transaction and merkle proof from localStorage and calls the mint Clarity function
const mintBitbadge = async () => {
  // Retrieving rawTx and merkleProof from local storage
  let txRaw = "";
  let txMerkleProof = "";

  if (typeof window !== "undefined") {
    txRaw = removeWitnessData(localStorage.getItem("txRaw"));
    txMerkleProof = JSON.parse(localStorage.getItem("txMerkleProof"));
  }

  // First we need to verify that the sender of this transaction is the same as the user that is signed in
  if (!verifyCorrectSender()) {
    console.log("wrong sender");
    return false;
  }

  const blockHeight = blockDetails.block_height;

  // Fetch the block hash
  const blockHashResponse = await fetch(
    `https://blockstream.info/testnet/api/block-height/${blockHeight}`
  );
  const blockHash = await blockHashResponse.text();

  // Fetch the block header
  const blockHeaderResponse = await fetch(
    `https://blockstream.info/testnet/api/block/${blockHash}/header`
  );
  const blockHeaderHex = await blockHeaderResponse.text();

  const txIndex = txMerkleProof.pos;
  const hashes = txMerkleProof.merkle.map(
    (hash) => bufferCV(hexToBytes(hash).reverse()) // lib needs reversed hashes
  ); // Convert each hash to BufferCV and reverse it

  const functionArgs = [
    principalCV(userData.profile.stxAddress.testnet),
    uintCV(blockHeight),
    bufferCV(Buffer.from(txRaw, "hex")),
    bufferCV(Buffer.from(blockHeaderHex, "hex")),
    tupleCV({
      "tx-index": uintCV(txIndex),
      hashes: listCV(hashes),
      "tree-depth": uintCV(txMerkleProof.merkle.length),
    }),
  ];

  const contractAddress = "ST3QFME3CANQFQNR86TYVKQYCFT7QX4PRXM1V9W6H"; // Replace with your contract address
  const contractName = "bitbadge-v3"; // Replace with your contract name
  const functionName = "mint"; // Replace with your function name

  const options = {
    contractAddress,
    contractName,
    functionName,
    functionArgs,
    appDetails: {
      name: "BitBadge",
      icon: "https://freesvg.org/img/bitcoin.png",
    },
    onFinish: (data) => {
      console.log(data);
    },
  };

  await openContractCall(options);
};
```

{% endcode %}

That's the end-to-end flow: retrieve tx raw and merkle proof from Blockstream's API, adapt formats (strip witness data for legacy-only support, reverse hashes for the library), assemble the arguments, and call the Clarity contract function that verifies inclusion using the clarity-bitcoin helper.


# Parsing a Bitcoin Transaction

While we can verify that a transaction was mined using a library and Clarity's built-in functions (see the Verifying a transaction on the BTC chain docs), we can also parse a Bitcoin transaction using Clarity directly.

This doesn't require access to the chain — all we need is the raw transaction hex.

If you aren't familiar with how Bitcoin transactions are encoded in raw form, take a quick look at that. The short version is that all of the data from a Bitcoin transaction is encoded in hex form in a string of bytes; we can slice out pieces of that hex value to pull out all of our transaction data.

The process to do this is relatively complex, but the Clarity-Bitcoin library provides a function called `parse-tx` that makes this simple. All we need to do is pass it a raw transaction hex and we get back the data of the transaction, including inputs and outputs.

{% hint style="warning" %}
Note that currently the library only supports legacy transactions. Work to support segwit and taproot transactions is underway.
{% endhint %}

You can view a deployed version of the library on the explorer: <https://explorer.hiro.so/txid/0xd493b9ada8899be8773d3f55b21d300ef83ac5c0dd38c8a4dd52a295bd71d539?chain=mainnet>

And the GitHub repo here: <https://github.com/friedger/clarity-bitcoin>

The `parse-tx` function looks like this:

{% code title="parse-tx.clar" %}

```clarity
(define-read-only (parse-tx (tx (buff 1024)))
    (let ((ctx { txbuff: tx, index: u0})
          (parsed-version (try! (read-uint32 ctx)))
          (parsed-txins (try! (read-txins (get ctx parsed-version))))
          (parsed-txouts (try! (read-txouts (get ctx parsed-txins))))
          (parsed-locktime (try! (read-uint32 (get ctx parsed-txouts)))))
     (ok {version: (get uint32 parsed-version),
          ins: (get txins parsed-txins),
          outs: (get txouts parsed-txouts),
          locktime: (get uint32 parsed-locktime)})))
```

{% endcode %}

Example raw transaction hex (from a block explorer API like mempool):

`0200000000010196277c04c986c1ad78c909287fd12dba2924324699a0232e0533f46a6a3916bb0100000000ffffffff026400000000000000160014274ae586ad2035efb4c25049c155f98310d7e106ca16440000000000160014599bcef6387256c6b019030c421b4a4d382fe2600247304402204d94a1e4047ca38a450177ccb6f88585ca147f1939df343d8ac5d962c5f35bb302206f7fa42c21c47ebccdc460393d35c5dfd3b6f0a26cf10fac23d3e6fab71835c20121020cb972a66e3fb1cdcc9efcad060b4457ebec534942700d4af1c0d82a33aa13f100000000`

You can paste this into a raw transaction decoder like this one to inspect the decoded fields: <https://live.blockcypher.com/btc/decodetx/>

If using stacks.js, pass the raw hex to your Clarity function as a buffer like this:

{% code title="JavaScript (stacks.js)" %}

```javascript
bufferCV(Buffer.from(txRaw, "hex"));
```

{% endcode %}

Where `txRaw` is a string containing the raw transaction hex. Passing that buffer into `parse-tx` returns the parsed transaction object with version, inputs (ins), outputs (outs), and locktime. You can then extract whatever fields you need from that returned data.

{% stepper %}
{% step %}

#### Get the raw transaction hex

Obtain the raw transaction hex from a Bitcoin block explorer API (for example, mempool or blockcypher). This is a single hex string representing the entire transaction.
{% endstep %}

{% step %}

#### Pass the hex into Clarity-Bitcoin's parser

Convert the hex string to a buffer and pass it to the `parse-tx` function (via your Stacks/Clarity call). In stacks.js:

`bufferCV(Buffer.from(txRaw, "hex"));`
{% endstep %}

{% step %}

#### Use the parsed result

`parse-tx` returns an object containing:

* version
* ins (transaction inputs)
* outs (transaction outputs)
* locktime

Extract whatever fields you need from that returned object.
{% endstep %}
{% endstepper %}


# c32check

Generating and decoding addresses on the Stacks blockchain.

{% hint style="info" %}
For the c32check open-source repo: <https://github.com/stacks-network/c32check>
{% endhint %}

The Stacks blockchain uses c32-encoded public key hashes as addresses. Specifically, a **c32check address** is a c32check-encoded ripemd160 hash. This library is meant for generating and decoding addresses on the Stacks blockchain.

### How it works

Each c32check string encodes a 1-byte version and a 4-byte checksum. When decoded as a hex string, the wire format looks like this:

```
0      1                             n+1             n+5
|------|-----------------------------|---------------|
version     n-byte hex payload          4-byte hash
```

If `version` is the version byte (a 1-byte `number`) and `payload` is the raw bytes (e.g. as a `string`), then the `checksum` is calculated as follows:

```
checksum = sha256(sha256(version + payload)).substring(0,4)
```

In other words, the checksum is the first four bytes of the double-sha256 of the bytestring concatenation of the `version` and `payload`. This is similar to base58check encoding, for example.

### Examples

**Installation**

{% code title="terminal" %}

```shellscript
npm install c32check
```

{% endcode %}

```typescript
> c32 = require('c32check')
{ c32encode: [Function: c32encode],
  c32decode: [Function: c32decode],
  c32checkEncode: [Function: c32checkEncode],
  c32checkDecode: [Function: c32checkDecode],
  c32address: [Function: c32address],
  c32addressDecode: [Function: c32addressDecode],
  versions:
   { mainnet: { p2pkh: 22, p2sh: 20 },
     testnet: { p2pkh: 26, p2sh: 21 } },
  c32ToB58: [Function: c32ToB58],
  b58ToC32: [Function: b58ToC32] }
```

#### c32encode, c32decode

```typescript
> c32check.c32encode(Buffer.from('hello world').toString('hex'))
'38CNP6RVS0EXQQ4V34'
> c32check.c32decode('38CNP6RVS0EXQQ4V34')
'68656c6c6f20776f726c64'
> Buffer.from('68656c6c6f20776f726c64', 'hex').toString()
'hello world'
```

#### c32checkEncode, c32checkDecode

```typescript
> version = 12
> c32check.c32checkEncode(version, Buffer.from('hello world').toString('hex'))
'CD1JPRV3F41VPYWKCCGRMASC8'
> c32check.c32checkDecode('CD1JPRV3F41VPYWKCCGRMASC8')
[ 12, '68656c6c6f20776f726c64' ]
> Buffer.from('68656c6c6f20776f726c64', 'hex').toString()
'hello world'
```

#### c32address, c32addressDecode

> **Note**: These methods only work on ripemd160 hashes

```typescript
> hash160 = 'a46ff88886c2ef9762d970b4d2c63678835bd39d'
> version = c32check.versions.mainnet.p2pkh
22
> c32check.c32address(version, hash160)
'SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7'
> c32check.c32addressDecode('SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7')
[ 22, 'a46ff88886c2ef9762d970b4d2c63678835bd39d' ]
```

#### c32ToB58, b58ToC32

Convert a Stacks address to its corresponding Bitcoin address, or vice versa.

> **Note**: Common address versions are converted between c32check and base58check seamlessly, in order to accommodate Stacks addresses.

```typescript
> b58addr = '16EMaNw3pkn3v6f2BgnSSs53zAKH4Q8YJg'
> c32check.b58ToC32(b58addr)
'SPWNYDJ3STG7XH7ERWXMV6MQ7Q6EATWVY5Q1QMP8'
> c32check.c32ToB58('SPWNYDJ3STG7XH7ERWXMV6MQ7Q6EATWVY5Q1QMP8')
'16EMaNw3pkn3v6f2BgnSSs53zAKH4Q8YJg'
```

```typescript
> b58addr = '3D2oetdNuZUqQHPJmcMDDHYoqkyNVsFk9r'
> c32check.b58ToC32(b58addr)
'SM1Y6EXF21RZ9739DFTEQKB1H044BMM0XVCM4A4NY'
> c32check.c32ToB58('SM1Y6EXF21RZ9739DFTEQKB1H044BMM0XVCM4A4NY')
'3D2oetdNuZUqQHPJmcMDDHYoqkyNVsFk9r'
```


# Community Tutorials

<figure><img src="https://284917788-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FZz9BLmTU9oydDpL3qiUh%2Fuploads%2Fgit-blob-0209b9426ab0b3937c2d7381be6b5911de8d4c90%2FGcHiZWjXgAA21Kf.jpeg?alt=media" alt=""><figcaption><p>source: EasyA x Stacks hackathon at Harvard University [2024]</p></figcaption></figure>

These tutorials have been created by various developers of the Stacks community. Have a tutorial to suggest? View the [contribution guide](http://localhost:3000/docs/contribute/docs) to submit a PR with a new tutorial added.

### Written Tutorials

* [Create a server-side rendered Stacks app with Remix](https://micro-stacks.dev/guides/with-remix)
* [Build a Stacks app with Next.js](https://micro-stacks.dev/guides/with-nextjs)
* [Creating a Voting Contract](https://www.clearness.dev/01-voting-clarity-smart-contract/01-getting-started)
* [Building an NFT with Stacks and Clarity](https://blog.developerdao.com/building-an-nft-with-stacks-and-clarity)
* [Minting NFTs with QuickNode](https://www.quicknode.com/guides/web3-sdks/how-to-mint-nfts-on-the-stacks-blockchain)
* [Order Book Contract Walkthrough](https://byzantion.hiro.so/)
* [Build a DEX on Stacks](https://www.pointer.gg/tutorials/build-a-dex-with-stacks/56abb3a4-05c1-4608-b096-f82189e9f759)
* [NFT Tutorial](https://docs.hiro.so/tutorials/clarity-nft)
* [Billboard Tutorial](https://docs.hiro.so/tutorials/clarity-billboard)
* [Integrating NFTs Into a Game](https://gamefi-stacks.gitbook.io/gamefistacks/tutorials/integrate-nfts-into-game)
* [Building on Stacks](https://github.com/amoweolubusayo/stacks-clarinet-tutorial)

### Video Tutorials

* [Web3 for Bitcoin](https://www.crowdcast.io/e/web3-for-bitcoin/)

### Other Resources

There are also a great amount of both tutorials and developer tools in the [Awesome Stacks repo](https://github.com/friedger/awesome-stacks-chain#clarity-resources).


# Run a Node

<figure><img src="https://4065274862-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F4cpTb2lbw0LAOuMHrvhA%2Fuploads%2Fgit-blob-b80d52e8b70eb9c3e790a912afacb358bdb87830%2FFrame%20316126262.jpg?alt=media" alt=""><figcaption></figcaption></figure>

This section walks through the technical setup steps required to run Stacks network nodes and miners. There are multiple options available for running a node, including Docker, Digital Ocean, and Render.

Running your own Stacks node is a great way to increase the decentralization of the ecosystem and avoid relying on third-party centralized providers.

## Minimum viable requirements

While you can run a node using these specs, it's recommended to assign more than the minimum for better performance.

{% hint style="warning" %}

* ⚠️ docker-compose version `2.2.2` or greater is **required** — <https://docs.docker.com/compose/install/>
* **8 GB memory** if running only a Stacks node
* **16 GB memory** if running Stacks + Bitcoin node
* **2 vCPU**
* **1 TB disk** for Stacks node
* **1 TB disk** for Bitcoin node
  {% endhint %}


# Run a Node with Docker

### Stacks Blockchain with Docker

Run your own Stacks Blockchain node using [docker-compose](https://docs.docker.com/compose/) with just a few commands using [stacks-blockchain-docker](https://github.com/stacks-network/stacks-blockchain-docker)

### Requirements

The minimum viable requirements are listed below.

While you *can* run a node using these specs, it's *recommended* to assign more than the minimum for better performance.

* ⚠️ [docker-compose](https://docs.docker.com/compose/install/) version `2.2.2` or greater is **required**
* **8GB memory if running only a Stacks node**
* **16 GB memory if running Stacks + Bitcoin node**
* **1 Vcpu** ( *minimum of 2 Vcpu is recommended* )
* **500GB disk for Stacks node**
* **1TB disk space for Bitcoin node**

{% hint style="warning" %}
MacOS with an ARM (M-series chip) processor is NOT recommended

The way Docker for Mac on an Arm CPU is designed makes the I/O incredibly slow, and blockchains are ***very*** heavy on I/O. This only seems to affect MacOS with the M-series chip, other Arm based systems like Raspberry Pi work as expected.
{% endhint %}

### Quickstart

The `<network>` placeholder used below can be replaced with one of:

* mainnet
* testnet
* mocknet

{% stepper %}
{% step %}

#### Clone the repository

Clone the stacks-blockchain-docker repository locally and change into the directory:

{% code title="Clone repository" %}

```bash
git clone https://github.com/stacks-network/stacks-blockchain-docker && cd stacks-blockchain-docker
```

{% endcode %}
{% endstep %}

{% step %}

#### Start the services

Start the docker-compose services for the chosen network:

{% code title="Start services" %}

```bash
./manage.sh -n <network> -a start
```

{% endcode %}

{% hint style="info" %}
With an optional HTTP proxy on port 80:

{% code title="Start with proxy" %}

```bash
./manage.sh -n <network> -a start -f proxy
```

{% endcode %}
{% endhint %}
{% endstep %}
{% endstepper %}

### Accessing the services

{% hint style="info" %}
For networks other than `mocknet`, downloading the initial headers can take several minutes. Until the headers are downloaded, the `/v2/info` endpoints won't return any data.

Follow the logs to track the sync progress:

{% code title="Follow logs" %}

```bash
./manage.sh -n <network> -a logs
```

{% endcode %}
{% endhint %}

stacks-blockchain:

* Ports `20443-20444` are exposed on `localhost`

{% code title="Check stacks-blockchain /v2/info" %}

```bash
curl -sL localhost:20443/v2/info | jq -r
```

{% endcode %}

stacks-blockchain-api:

* Port `3999` is exposed on `localhost`

{% code title="Check stacks-blockchain-api" %}

```bash
curl -sL localhost:3999 | jq -r
```

{% endcode %}

proxy:

* Port `80` is exposed on `localhost`

{% code title="Check proxy" %}

```bash
curl -sL localhost/v2/info | jq -r
curl -sL localhost | jq -r
```

{% endcode %}

### Upgrades

{% hint style="warning" %}
For schema-breaking upgrades to running instances of this repo, you'll need to [run an event-replay](https://github.com/stacks-network/stacks-blockchain-docker/blob/master/docs/upgrade.md).
{% endhint %}


# Run a Node with Digital Ocean

### Introduction

This is a step by step guide to deploy the [Stacks Blockchain](https://github.com/stacks-network/stacks-blockchain) on [DigitalOcean](https://digitalocean.com/).

Build code is hosted on this [Github repository](https://github.com/stacksfoundation/stacks-machine-images) using the [methods from here](https://github.com/stacks-network/stacks-blockchain-docker).

### Steps

{% stepper %}
{% step %}

#### Create the Droplet from the Marketplace

Go to the [Stacks Blockchain page](https://marketplace.digitalocean.com/apps/stacks-blockchain) in DigitalOcean's marketplace. Click on `Create Stacks Blockchain Droplet`.
{% endstep %}

{% step %}

#### Choose plan and region

Choose a plan (it will only allow you to select a droplet that meets the minimum requirements) and your preferred datacenter region.
{% endstep %}

{% step %}

#### Authentication

Enter a root password or [enable SSH keys](https://docs.digitalocean.com/products/droplets/how-to/add-ssh-keys/) if you prefer.
{% endstep %}

{% step %}

#### Create the Droplet

You can leave the rest of the options as they are and click on `Create Droplet`.
{% endstep %}

{% step %}

#### Wait for creation

You will need to wait a few seconds for the droplet to get created. Once created click on it to see more information.
{% endstep %}

{% step %}

#### Access the Droplet

Congratulations! You are now running the Stacks Blockchain. You can click on `Console` for a terminal window to open or login using SSH to the public IP you've been assigned to with user `root`.
{% endstep %}
{% endstepper %}

### Getting started after deploying Stacks Blockchain

Once the droplet is launched, the initial startup can take several minutes while BNS data is imported (this is a one time operation) and the Bitcoin headers are synced.

To keep track of the progress, you can SSH to the host and view logs:

```bash
ssh root@your_droplet_public_ipv4
/opt/stacks-blockchain-docker/manage.sh -n mainnet -a logs
```

After the stacks blockchain finishes the initial header sync and starts to sync with its peers, the application ports will open (`20443` and `3999`) and HTTP port `80` will now start proxying requests.

Use `http://your_droplet_public_ipv4` to access the data directly, with output being similar to:

```json
{
  "server_version": "stacks-blockchain-api v6.2.3 (master:77ab3ae2)",
  "status": "ready",
  "chain_tip": {
    "block_height": 91820,
    "block_hash": "0x06b276e85f238151414616618ae0adaf5eeda4eac6cad5bbefceeb37948ab275",
    "index_block_hash": "0x4d7c075d7ab0f90b1dbc175f5c42b7344265d00cfef202dd9681d95388eeed8c",
    "microblock_hash": "0xcf4f9037cc10696b2812b617ca105885be625c6acf8ad67e71bb4c09fa6ebb21",
    "microblock_sequence": 4
  }
}
```

{% hint style="info" %}
For the full list of API endpoints for the Stacks Blockchain, consult the [Hiro API Docs](https://docs.hiro.so/api)
{% endhint %}

All services are managed by a [systemd unit file](https://github.com/stacksfoundation/stacks-machine-images/blob/master/files/etc/systemd/system/stacks.service) that is set to start on boot.

Manual control is also possible via the [manage.sh script](https://github.com/stacks-network/stacks-blockchain-docker/blob/master/manage.sh) at `/opt/stacks-blockchain-docker/manage.sh` on the host.

Full details on how to use the manage.sh script is [available here](https://github.com/stacks-network/stacks-blockchain-docker/blob/master/docs/usage.md).

### Launching a Droplet using the DigitalOcean API

In addition to creating a Droplet from the Stacks Blockchain 1-Click App via the control panel, you can also use the [DigitalOcean API](https://digitalocean.com/docs/api).

As an example, to create a 4GB Stacks Blockchain Droplet in the SFO2 region, you can use the following curl command. You’ll need to either save your [API access token](https://docs.digitalocean.com/reference/api/create-personal-access-token/) to an environment variable or substitute it into the command below.

{% hint style="info" %}
The `name`, `region` and `size` values below are hardcoded, so adjust as desired.
{% endhint %}

```bash
$ export TOKEN=<digitalocean API token>
$ curl -X POST -H 'Content-Type: application/json' \
     -H 'Authorization: Bearer '$TOKEN'' -d \
    '{"name":"stacks-blockchain","region":"sfo2","size":"s-2vcpu-4gb","image":"stacksfoundation-stacksblockchain"}' \
    "https://api.digitalocean.com/v2/droplets"
```


# Run a Node with a Hosted Provider

We're always looking for new hosting providers that enable anyone to run the Stacks Blockchain. Below, you'll find some examples of the current providers that are known to support running a node.

### Quicknode

Please refer to the Quicknode Section for instructions on launching an instance with Quicknode.

### Stacks on Render

The [render-stacks](https://github.com/stacksfoundation/render-stacks) GitHub repo has instructions so anyone can deploy a Stacks node to the hosted [Render](https://render.com/) service in one click.

{% hint style="warning" %}
While it is possible to use the free plan with some modifications, it is recommended to run this on a paid plan.
{% endhint %}

### Stacks on Fly

The [fly-stacks](https://github.com/stacksfoundation/fly-stacks) GitHub repo has instructions so anyone can deploy a Stacks node to the hosted [Fly](https://fly.io/) service.


# Run a Node with Quicknode

[QuickNode](https://www.quicknode.com/) is a service for rapidly getting set up with a Stacks node. As an easy and fast alternative to running your own node, you can utilize QuickNode to serve as an API.

{% stepper %}
{% step %}

#### Create a QuickNode account

Sign up on QuickNode: <https://www.quicknode.com/signup>
{% endstep %}

{% step %}

#### Create an endpoint

Once signed in, click "Create an endpoint". Select:

* Stacks
* your desired network (e.g., mainnet or testnet)
* your desired QuickNode plan level

After that you'll have an API endpoint URL you can use to connect to Stacks.
{% endstep %}

{% step %}

#### Install the Stacks network package

Install the `@stacks/network` package in your frontend project.
{% endstep %}

{% step %}

#### Import the network class

In your frontend code, import the network class:

{% code title="example.js" %}

```javascript
import { StacksTestnet } from "@stacks/network";
```

{% endcode %}
{% endstep %}

{% step %}

#### Configure the network with your QuickNode endpoint

Create the network instance using your QuickNode endpoint URL:

{% code title="example.js" %}

```javascript
const network = new StacksTestnet({ url: "<QUICKNODE_ENDPOINT_HERE>" });
```

{% endcode %}

Replace \<QUICKNODE\_ENDPOINT\_HERE> with the full endpoint URL provided by QuickNode.
{% endstep %}

{% step %}

#### Use with @stacks/transactions

You can now call transactions and other Stacks RPC methods as you normally would using the `@stacks/transactions` library, passing the `network` instance where required.

For an example integration and walkthrough, refer to the Hello Stacks tutorial.
{% endstep %}
{% endstepper %}


# Run a Bitcoin Node

{% stepper %}
{% step %}

#### Requirements

This guide is written for a Unix based system. It's reasonable to expect some modifications will be required for other operating systems.

When started, the Bitcoin node will take several days to reach chain tip.

* Bitcoin Core >= v25.0
  * <https://github.com/bitcoin/bitcoin>
  * <https://bitcoincore.org/en/download/>
* Host with a minimum of:
  * 2 vCPU (a single dedicated cpu for the bitcoind process)
  * 4GB Memory (during sync, more available memory will improve sync time)
  * 1TB free disk space
* User account: `bitcoin:bitcoin`
* Chainstate directory located at: `/bitcoin/mainnet`
  * `bitcoin` user must have read/write access.
* Config directory located at: `/etc/bitcoin`
  * `bitcoin` user must have at least read access
    {% endstep %}

{% step %}

#### Add bitcoin user and set file ownership

Run the following commands:

{% code title="Create directories and add user" %}

```shell
$ sudo mkdir -p /bitcoin/mainnet
$ sudo mkdir /etc/bitcoin
$ sudo useradd bitcoin -d /bitcoin
$ sudo chown -R bitcoin:bitcoin /bitcoin /etc/bitcoin/
```

{% endcode %}
{% endstep %}

{% step %}

#### Bitcoin config

Below is a sample config used to sync a bitcoin node - feel free to adjust as needed.

{% hint style="info" %}
If using the [systemd unit below](#systemd-unit-file), save this file as `/etc/bitcoin/bitcoin.conf`
{% endhint %}

* `btuser:btcpass` is hardcoded as an rpcauth user/password ([generated using this script](https://github.com/bitcoin/bitcoin/tree/master/share/rpcauth)).
* Only localhost access is allowed (`127.0.0.1`) on the standard mainnet ports.
* `dbcache` is set to the maximum of 16GB.
* Wallet (and wallet rpc calls) are disabled.

{% code title="Sample /etc/bitcoin/bitcoin.conf" %}

```
## [rpc]

# Accept command line and JSON-RPC commands.
server=1

# Allow JSON-RPC connections from specified source.
rpcallowip=127.0.0.1/0

# Bind to given address to listen for JSON-RPC connections.
rpcbind=127.0.0.1:8332

# Username and HMAC-SHA-256 hashed password for JSON-RPC connections.

#   Use the script at https://github.com/bitcoin/bitcoin/tree/master/share/rpcauth to generate

#   Note: may be specified multiple times for different users.
rpcauth=btcuser:18857b4df4b1f0f5e6b1d7884617ab39$de6e02e1da8ee138ee702e13e0637e24679d844756216b066c3aeac4bcac5e10 # btuser:btcpass

# Optional: rpcwhitelist can restrict listed RPC calls to specific rpcauth users.

#   Uncomment the below the restrict the `limited` user to a small subset of `get` commands

# rpcauth=limited:350c91a60895b567c4662c27e63e9a41$25188b0f51f2f974dcdc75c1e0d41174e8f7ae19fb96927abf68ac5bc1e8897b # limited:limited

# rpcwhitelist=limited:getblockchaininfo,getblock,getblockcount,getblockhash,getblockheader,getnetworkinfo

# rpcwhitelistdefault=0

## [core]

# Specify data directory
datadir=/bitcoin/mainnet

# Do not keep transactions in the mempool longer than <n> hours (default: 336)
mempoolexpiry=24

# Bind to given address and always listen on it (default: 0.0.0.0)
bind=127.0.0.1:8333

# Maximum database cache size <n> MiB (4 to 16384, default: 450). In addition, unused mempool memory is shared for this cache
dbcache=16384

# Maintain a full transaction index, used by the getrawtransaction rpc call
txindex=1

## [wallet]

# Do not load the wallet and disable wallet RPC calls
disablewallet=1
```

{% endcode %}
{% endstep %}

{% step %}

#### Systemd unit file

Reference: <https://github.com/bitcoin/bitcoin/blob/master/contrib/init/bitcoind.service>

Save the following as your systemd unit (for example `/etc/systemd/system/bitcoin.service`):

{% code title="bitcoind.service" %}

```
[Unit]
Description=Bitcoin daemon
Documentation=https://github.com/bitcoin/bitcoin/blob/master/doc/init.md

# https://www.freedesktop.org/wiki/Software/systemd/NetworkTarget/
After=network-online.target
Wants=network-online.target

[Service]
ExecStart=/usr/bin/bitcoind -pid=/run/bitcoind/bitcoind.pid \
                            -conf=/etc/bitcoin/bitcoin.conf \
                            -startupnotify='systemd-notify --ready' \
                            -shutdownnotify='systemd-notify --stopping'

# Make sure the config directory is readable by the service user
PermissionsStartOnly=true
ExecStartPre=/bin/chgrp bitcoin /etc/bitcoin

# Process management
####################

Type=notify
NotifyAccess=all
PIDFile=/run/bitcoind/bitcoind.pid

Restart=on-failure
TimeoutStartSec=infinity
TimeoutStopSec=600

# Directory creation and permissions
####################################

# Run as bitcoin:bitcoin
User=bitcoin
Group=bitcoin

# /run/bitcoind
RuntimeDirectory=bitcoind
RuntimeDirectoryMode=0710

# /etc/bitcoin
ConfigurationDirectory=bitcoin
ConfigurationDirectoryMode=0710

# /var/lib/bitcoind
StateDirectory=bitcoind
StateDirectoryMode=0710

# Hardening measures
####################

# Provide a private /tmp and /var/tmp.
PrivateTmp=true

# Mount /usr, /boot/ and /etc read-only for the process.
ProtectSystem=full

# Deny access to /home, /root and /run/user
ProtectHome=true

# Disallow the process and all of its children to gain

# new privileges through execve().
NoNewPrivileges=true

# Use a new /dev namespace only populated with API pseudo devices

# such as /dev/null, /dev/zero and /dev/random.
PrivateDevices=true

# Deny the creation of writable and executable memory mappings.
MemoryDenyWriteExecute=true

# Restrict ABIs to help ensure MemoryDenyWriteExecute is enforced
SystemCallArchitectures=native

[Install]
WantedBy=multi-user.target
```

{% endcode %}
{% endstep %}

{% step %}

#### Enable and start the Bitcoin service

Run:

{% code title="Enable and start service" %}

```shell
$ sudo systemctl daemon-reload
$ sudo systemctl enable bitcoin.service
$ sudo systemctl start bitcoin.service
```

{% endcode %}
{% endstep %}

{% step %}

#### Track sync progress

{% hint style="info" %}
Once started, you may track the sync progress:
{% endhint %}

{% code title="Tail debug log and query RPC" %}

```
$ sudo tail -f /bitcoin/mainnet/debug.log
2024-12-05T19:35:31Z UpdateTip: new best=00000000000000000058990a84cc8f8eab25dbbd572f123f9190cea7256d7349 height=509258 version=0x20000000 log2_work=88.128280 tx=299522737 date='2018-02-15T03:42:14Z' progress=0.295203 cache=43.5MiB(172740txo)
...
$ bitcoin-cli \
    -rpcconnect=127.0.0.1 \
    -rpcport=8332 \
    -rpcuser=btcuser \
    -rpcpassword=btcpass \
    getblockcount
509016
```

{% endcode %}
{% endstep %}
{% endstepper %}


# Run a Pruned Bitcoin Node

This guide is written for a Unix based system. It's reasonable to expect some modifications will be required for other operating systems.

When started, the pruned Bitcoin node will take roughly \~24 hours to reach chain tip.

{% hint style="warning" %}
While bitcoin is syncing, it's recommended to keep a stacks-blockchain node at chain tip, or [use a stacks chainstate archive](https://docs.hiro.so/stacks/archive/guides/stacks-blockchain).
{% endhint %}

Requirements:

* Bitcoin Core >= v25.0
  * <https://github.com/bitcoin/bitcoin>
  * <https://bitcoincore.org/en/download/>
* Host with a minimum of:
  * 2 vCPU (a single dedicated cpu for the bitcoind process)
  * 4GB Memory (during sync, more available memory will improve sync time)
  * 50GB free disk space (actual usage is closer to 20GB)
* User account: `bitcoin:bitcoin`
* Chainstate directory located at: `/bitcoin/mainnet`
  * `bitcoin` user must have read/write access.
* Config directory located at: `/etc/bitcoin`
  * `bitcoin` user must have at least read access

Caveats

[BIP-0159](https://github.com/bitcoin/bips/blob/master/bip-0159.mediawiki)

In short, this BIP specifies that pruned nodes will advertise the service bit `NODE_NETWORK_LIMITED`, which restricts syncing blocks older than 288 blocks (\~2 days).

What this means is that in practice, a stacks-blockchain node:

* Cannot sync from genesis using a pruned node.
* Must not be offline or otherwise down for longer than \~2 days (or 288 Bitcoin blocks).

{% stepper %}
{% step %}

#### Add bitcoin user and set file ownership

```shell
$ sudo mkdir -p /bitcoin/mainnet
$ sudo mkdir /etc/bitcoin
$ sudo useradd bitcoin -d /bitcoin
$ sudo chown -R bitcoin:bitcoin /bitcoin /etc/bitcoin/
```

{% endstep %}

{% step %}

#### Bitcoin Config

Below is a sample config used to sync a pruned bitcoin node - feel free to adjust as needed.

{% hint style="info" %}
If using the [systemd unit below](#systemd-unit-file), save this file as `/etc/bitcoin/bitcoin.conf`
{% endhint %}

Notes:

* `btuser:btcpass` is hardcoded as an rpcauth user/password ([generated using this script](https://github.com/bitcoin/bitcoin/tree/master/share/rpcauth)).
* Only localhost access is allowed (`127.0.0.1`) on the standard mainnet ports.
* Pruning is set to be small, storing only the last 1GB of blocks (for p2p traffic, this is more than enough).
* `dbcache` is set to the maximum of 16GB.
* Wallet (and wallet rpc calls) are disabled.

```
## [rpc]

# Accept command line and JSON-RPC commands.
server=1

# Allow JSON-RPC connections from specified source.
rpcallowip=127.0.0.1/0

# Bind to given address to listen for JSON-RPC connections.
rpcbind=127.0.0.1:8332

# Username and HMAC-SHA-256 hashed password for JSON-RPC connections.

#   Use the script at https://github.com/bitcoin/bitcoin/tree/master/share/rpcauth to generate

#   Note: may be specified multiple times for different users.
rpcauth=btcuser:18857b4df4b1f0f5e6b1d7884617ab39$de6e02e1da8ee138ee702e13e0637e24679d844756216b066c3aeac4bcac5e10 # btuser:btcpass

# Optional: rpcwhitelist can restrict listed RPC calls to specific rpcauth users.

#   Uncomment the below the restrict the `limited` user to a small subset of `get` commands

# rpcauth=limited:350c91a60895b567c4662c27e63e9a41$25188b0f51f2f974dcdc75c1e0d41174e8f7ae19fb96927abf68ac5bc1e8897b # limited:limited

# rpcwhitelist=limited:getblockchaininfo,getblock,getblockcount,getblockhash,getblockheader,getnetworkinfo

# rpcwhitelistdefault=0

## [core]

# Specify data directory
datadir=/bitcoin/mainnet

# Do not keep transactions in the mempool longer than <n> hours (default: 336)
mempoolexpiry=24

# Bind to given address and always listen on it (default: 0.0.0.0)
bind=127.0.0.1:8333

# Maximum database cache size <n> MiB (4 to 16384, default: 450). In addition, unused mempool memory is shared for this cache
dbcache=16384

# Maintain a full transaction index, used by the getrawtransaction rpc call (**Running a pruned node requires that this option is disabled**)
txindex=0

# Reduce storage requirements by enabling pruning (deleting) of old

# blocks. This allows the pruneblockchain RPC to be called to

# delete specific blocks and enables automatic pruning of old

# blocks if a target size in MiB is provided. This mode is

# incompatible with -txindex. Warning: Reverting this setting

# requires re-downloading the entire blockchain. (default: 0 =

# disable pruning blocks, 1 = allow manual pruning via RPC, >=550 =

# automatically prune block files to stay under the specified

# target size in MiB)
prune=1024 # 1GB of chainstate is enough for p2p block data (if using the RPC,this can be adjusted higher to store more blocks)

## [wallet]

# Do not load the wallet and disable wallet RPC calls
disablewallet=1
```

{% endstep %}

{% step %}

#### Systemd unit file

ref: <https://github.com/bitcoin/bitcoin/blob/master/contrib/init/bitcoind.service>

```
[Unit]
Description=Bitcoin daemon
Documentation=https://github.com/bitcoin/bitcoin/blob/master/doc/init.md

# https://www.freedesktop.org/wiki/Software/systemd/NetworkTarget/
After=network-online.target
Wants=network-online.target

[Service]
ExecStart=/usr/bin/bitcoind -pid=/run/bitcoind/bitcoind.pid \
                            -conf=/etc/bitcoin/bitcoin.conf \
                            -startupnotify='systemd-notify --ready' \
                            -shutdownnotify='systemd-notify --stopping'

# Make sure the config directory is readable by the service user
PermissionsStartOnly=true
ExecStartPre=/bin/chgrp bitcoin /etc/bitcoin

# Process management
####################

Type=notify
NotifyAccess=all
PIDFile=/run/bitcoind/bitcoind.pid

Restart=on-failure
TimeoutStartSec=infinity
TimeoutStopSec=600

# Directory creation and permissions
####################################

# Run as bitcoin:bitcoin
User=bitcoin
Group=bitcoin

# /run/bitcoind
RuntimeDirectory=bitcoind
RuntimeDirectoryMode=0710

# /etc/bitcoin
ConfigurationDirectory=bitcoin
ConfigurationDirectoryMode=0710

# /var/lib/bitcoind
StateDirectory=bitcoind
StateDirectoryMode=0710

# Hardening measures
####################

# Provide a private /tmp and /var/tmp.
PrivateTmp=true

# Mount /usr, /boot/ and /etc read-only for the process.
ProtectSystem=full

# Deny access to /home, /root and /run/user
ProtectHome=true

# Disallow the process and all of its children to gain

# new privileges through execve().
NoNewPrivileges=true

# Use a new /dev namespace only populated with API pseudo devices

# such as /dev/null, /dev/zero and /dev/random.
PrivateDevices=true

# Deny the creation of writable and executable memory mappings.
MemoryDenyWriteExecute=true

# Restrict ABIs to help ensure MemoryDenyWriteExecute is enforced
SystemCallArchitectures=native

[Install]
WantedBy=multi-user.target
```

{% endstep %}

{% step %}

#### Enable and start the Bitcoin service

```shell
$ sudo systemctl daemon-reload
$ sudo systemctl enable bitcoin.service
$ sudo systemctl start bitcoin.service
```

{% endstep %}

{% step %}

#### Track sync progress

{% hint style="info" %}
Once started, you may track the sync progress:

```
$ sudo tail -f /bitcoin/mainnet/debug.log
2024-12-05T19:35:31Z UpdateTip: new best=00000000000000000058990a84cc8f8eab25dbbd572f123f9190cea7256d7349 height=509258 version=0x20000000 log2_work=88.128280 tx=299522737 date='2018-02-15T03:42:14Z' progress=0.295203 cache=43.5MiB(172740txo)
...
$ bitcoin-cli \
    -rpcconnect=127.0.0.1 \
    -rpcport=8332 \
    -rpcuser=btcuser \
    -rpcpassword=btcpass \
    getblockcount
509016
```

{% endhint %}
{% endstep %}
{% endstepper %}


# Run a Miner

If you are interested in running a Stacks miner, there are a few things you'll need to understand. Running a miner is similar to running a node, but you'll need to set up some additional configuration.

These guides will help you get up and running with both a testnet and mainnet Stacks miner.


# Miner Prerequisites

## Prerequisites

### VM setup

The VM will not need a lot of resources to run a miner - the most resources will be consumed during the blockchain syncs (for both Bitcoin and Stacks). For this example, we'll assume a [**Debian**](https://www.debian.org/) host with `x86_64` architecture (*commands may also work on any Debian-derived distribution*).

A single CPU system with at least 4GB of memory and 1TB of disk space should be considered the minimum required specs to run the miner.

#### VM Specs

* Minimum CPU: `1 vCPU`
* Minimum Memory: `4GB`
* Minimum Storage: `1TB Disk` to allow for chainstate growth
  * as of **July 2022**:
    * Bitcoin chainstate is roughly `420GB`
    * Stacks chainstate is roughly `45GB`

#### Disk Configuration

Two options here — either are fine but it's recommended to mount the chainstate from a separate disk that only contains the chainstate (see the first option).

{% stepper %}
{% step %}

#### Separate disks for chainstate(s) and OS

* mount a dedicated disk for bitcoin at `/bitcoin` of 1TB
* mount a dedicated disk for stacks-blockchain at `/stacks-blockchain` of at least 100GB
* root volume `/` of at least 25GB
  {% endstep %}

{% step %}

#### Combined Disk for all data

* root volume `/` of at least 1TB
  {% endstep %}
  {% endstepper %}

Create the required directories:

{% code title="Create directories" %}

```bash
$ sudo mkdir -p /bitcoin
$ sudo mkdir -p /stacks-blockchain
$ sudo mkdir -p /etc/bitcoin
$ sudo mkdir -p /etc/stacks-blockchain
```

{% endcode %}

If using mounted disks: mount the disks to each filesystem created above — edit `/etc/fstab` to automount these disks at boot.

Example `/etc/fstab` entries:

```
/dev/xvdb1 /bitcoin xfs rw,relatime,attr2,inode64,noquota
/dev/xvdc1 /stacks-blockchain xfs rw,relatime,attr2,inode64,noquota
```

Mount the disks:

```bash
sudo mount -a
```

### Scripted install

You can use the scripts/prerequisites.sh to install everything:

```bash
curl --proto '=https' --tlsv1.2 -sSf https://raw.githubusercontent.com/stacksfoundation/miner-docs/main/scripts/prerequisites.sh | bash
```

### Install required packages

The following packages are required and used by the rest of these docs:

{% code title="Install packages" %}

```bash
$ curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -
$ sudo apt-get update -y && sudo apt-get install -y \
    build-essential \
    jq \
    netcat \
    nodejs \
    git \
    autoconf \
    libboost-system-dev \
    libboost-filesystem-dev \
    libboost-thread-dev \
    libboost-chrono-dev \
    libevent-dev \
    libzmq5 \
    libtool \
    m4 \
    automake \
    pkg-config \
    libtool \
    libboost-system-dev \
    libboost-filesystem-dev \
    libboost-chrono-dev \
    libboost-program-options-dev \
    libboost-test-dev \
    libboost-thread-dev \
    libboost-iostreams-dev
$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh && source $HOME/.cargo/env
$ sudo npm install -g @stacks/cli rimraf shx
```

{% endcode %}


# Miner Costs and Fees

### Configuring Cost and Fee Estimation

{% code title="config.toml" %}

```toml
[fee_estimation]
cost_estimator = naive_pessimistic
fee_estimator = fuzzed_weighted_median_fee_rate
fee_rate_fuzzer_fraction = 0.1
fee_rate_window_size = 5
cost_metric = proportion_dot_product
log_error = true
enabled = true
```

{% endcode %}

Fee and cost estimators observe transactions on the network and use the observed costs of those transactions to build estimates for viable fee rates and expected execution costs. Estimators and metrics can be selected using the configuration fields above (the defaults shown are currently the only options). `log_error` controls whether the INFO logger will display information about cost estimator accuracy as new costs are observed. Setting `enabled = false` turns off the cost estimators.

{% hint style="info" %}
Cost estimators are not consensus-critical components — they are intended for miners to rank mempool transactions or for clients to pick appropriate fee rates before broadcasting.
{% endhint %}

The `fuzzed_weighted_median_fee_rate` estimator:

* uses a median estimate from a window of the fees paid in the last `fee_rate_window_size` blocks, and
* then applies a uniform random "fuzz" up to `fee_rate_fuzzer_fraction` of the base estimate.

<details>

<summary>Mining calculator (external)</summary>

There is a mining calculator that can help with this process: <https://friedger.github.io/mining-calculator/\\>
Source code: <https://github.com/friedger/mining-calculator>

</details>


# Mine Testnet Stacks Tokens

### Introduction

For more on the technical details of mining, please review the mining guide.

The following is an abridged version of the [walkthrough here](https://github.com/stacksfoundation/miner-docs/tree/testnet), written for a Linux system. If you're on Windows or MacOS, there will be some slight modifications needed (PR's welcome!).

If you're interested in mining on the Stacks testnet, you can find instructions on how to do that here:

### Running a Bitcoin Testnet Full Node

To participate as a miner on testnet, you must have access to a testnet bitcoin node with a wallet (and the wallet's private key). One way to accomplish this is to run bitcoin locally.

* [Ensure your computer meets the minimum hardware requirements before continuing.](https://bitcoin.org/en/bitcoin-core/features/requirements#system-requirements)

First, download a [bitcoin binary](https://bitcoin.org/en/download), or [build from source](https://github.com/stacksfoundation/miner-docs/blob/testnet/bitcoin.md#source-install) (*there may be some extra requirements to building,* [*defined here*](https://github.com/stacksfoundation/miner-docs/blob/testnet/prerequisites.md#install-required-packages)).

{% hint style="info" %}
Tip: It is recommended to use a persistent location for the chainstate, in the steps below we're using `/bitcoin`.
{% endhint %}

#### Update the Bitcoin Configuration File

Next, update the bitcoin configuration:

* Optional, but recommended: Use a persistent directory to store the Bitcoin chainstate, i.e. `datadir=/bitcoin`.
* Optional, but recommended: Update the `rpcallowip` value to only allow `127.0.0.1`, or the stacks miner IPv4.
* Modify the `rpcuser` and `rpcpassword` values from the defaults below.
* Store the following configuration somewhere on your filesystem (ex: `$HOME/bitcoin.conf`).

```toml
server=1
testnet=1
disablewallet=0
datadir=/bitcoin
rpcuser=btcuser
rpcpassword=btcpass
rpcallowip=0.0.0.0/0
dbcache=512
banscore=1
rpcthreads=256
rpcworkqueue=256
rpctimeout=100
txindex=1

[test]
bind=0.0.0.0:18333
rpcbind=0.0.0.0:18332
rpcport=18332
```

#### Start Bitcoin

Finally, start `bitcoind` as follows (adjust the `conf` path to where it was created in the previous step, i.e. `$HOME/bitcoin.conf`):

```bash
bitcoind -conf=$HOME/bitcoin.conf
```

{% hint style="info" %}
Note: It will take a few hours for the node to synchronize with Bitcoin Testnet.
{% endhint %}

While it's syncing, you can track the progress with `bitcoin-cli` or the logfile (will be located where the chainstate is stored, i.e. `/bitcoin/testnet3/debug.log`):

```bash
$ bitcoin-cli \
 -rpcconnect=127.0.0.1 \
 -rpcport=18332 \
 -rpcuser=btcuser \
 -rpcpassword=btcpass \
getblockchaininfo | jq .blocks
2583513
```

***

### Running a Stacks Blockchain miner

First, download the latest tagged [stacks blockchain binary](https://github.com/stacks-network/stacks-blockchain/releases/latest), or [build from source](https://github.com/stacksfoundation/miner-docs/blob/testnet/stacks-blockchain.md#build-and-install-stacks-blockchain-from-source) (*there may be some extra requirements to building,* [*defined here*](https://github.com/stacksfoundation/miner-docs/blob/testnet/prerequisites.md#install-required-packages)).

{% hint style="info" %}
Tip: It is recommended to use a persistent location for the chainstate, in the steps below we're using `/stacks-blockchain`.
{% endhint %}

#### Generate a keychain

First, a keychain needs to be generated. With this keychain, we'll get some testnet BTC from a faucet, and then use that BTC to start mining.

To create a keychain, the simplest way is to use the [stacks-cli](https://docs.hiro.so/references/stacks-cli) with the `make_keychain` command.

```bash
npx @stacks/cli make_keychain -t 2>/dev/null | jq -r
```

After this runs, you should see some JSON printed to the screen that looks like this:

```json
{
  "mnemonic": "spare decade dog ghost luxury churn flat lizard inch nephew nut drop huge divert mother soccer father zebra resist later twin vocal slender detail",
  "keyInfo": {
    "privateKey": "ooxeemeitar4ahw0ca8anu4thae7aephahshae1pahtae5oocahthahho4ahn7eici",
    "address": "STTXOG3AIHOHNAEH5AU6IEX9OOTOH8SEIWEI5IJ9",
    "btcAddress": "Ook6goo1Jee5ZuPualeiqu9RiN8wooshoo",
    "wif": "rohCie2ein2chaed9kaiyoo6zo1aeQu1yae4phooShov2oosh4ox",
    "index": 0
  }
}
```

{% hint style="danger" %}
Do not lose this information - we'll need to use the `privateKey`, `btcAddress` and `wif` fields in later steps.
{% endhint %}

The above `wif` (`cPdTdMgww2njhnekUZmHmFNKsWAjVdCR4cfvD2Y4UQhFzMmwoW33`) will then need to be imported into the bitcoin testnet network.

Next, a bitcoin wallet is created:

```bash
bitcoin-cli \
  -rpcconnect=127.0.0.1 \
  -rpcport=18332 \
  -rpcuser=btcuser \
  -rpcpassword=btcpass \
  createwallet "miner" \
  false \
  false \
  "" \
  false \
  false \
  true
```

Now, import your wif (bitcoin private key) inside the newly created wallet.

{% hint style="info" %}
Note: Be sure to replace `<wif from JSON above>` with the wif value in the `Generate a keychain` step.
{% endhint %}

```bash
bitcoin-cli \
  -rpcport=18332 \
  -rpcuser=btcuser \
  -rpcpassword=btcpassword \
  importprivkey <wif from JSON above>
```

{% hint style="info" %}
Note: The import may take a while, because a wallet rescan is triggered. After the import has completed successfully, you can check that the address is imported with `getaddressinfo`.
{% endhint %}

```bash
bitcoin-cli \
  -rpcconnect=127.0.0.1 \
  -rpcport=18332 \
  -rpcuser=btcuser \
  -rpcpassword=btcpass \
  getaddressinfo <btcAddress from JSON above>
```

Once imported, we need to get some testnet BTC to that address. Grab the `btcAddress` field, and paste it into [this Bitcoin testnet faucet](https://tbtc.bitaps.com/). You'll be sent `0.01` testnet BTC to that address.

#### Update the Stacks Blockchain Configuration File

Now, we need to configure our node to use this Bitcoin keychain. Copy the [sample testnet miner config](https://raw.githubusercontent.com/stacks-network/stacks-blockchain/master/testnet/stacks-node/conf/testnet-miner-conf.toml) to your local machine in a memorable location like `$HOME/testnet-miner-conf.toml`.

Next, update the stacks configuration:

* Optional, but recommended: Use a persistent directory to store the Stacks chainstate, i.e. `working_dir = "/stacks-blockchain"`
* From the `make_keychain` step, modify the `seed` value with `privatekey`
* Store the following configuration somewhere on your filesystem (ex: `$HOME/testnet-miner-conf.toml`)

```toml
[node]
working_dir = "/stacks-blockchain"
rpc_bind = "0.0.0.0:20443"
p2p_bind = "0.0.0.0:20444"
seed = "<privateKey from JSON above>"
miner = true
bootstrap_node = "029266faff4c8e0ca4f934f34996a96af481df94a89b0c9bd515f3536a95682ddc@seed.testnet.hiro.so:30444"
mine_microblocks = false
wait_time_for_microblocks = 10000

[burnchain]
wallet_name = "miner"
chain = "bitcoin"
mode = "xenon"
peer_host = "127.0.0.1"
username = "<bitcoin config rpcuser>"
password = "<bitcoin config rpcpassword>"
rpc_port = 18332
peer_port = 18333

[[ustx_balance]]
address = "ST2QKZ4FKHAH1NQKYKYAYZPY440FEPK7GZ1R5HBP2"
amount = 10000000000000000

[[ustx_balance]]
address = "ST319CF5WV77KYR1H3GT0GZ7B8Q4AQPY42ETP1VPF"
amount = 10000000000000000

[[ustx_balance]]
address = "ST221Z6TDTC5E0BYR2V624Q2ST6R0Q71T78WTAX6H"
amount = 10000000000000000

[[ustx_balance]]
address = "ST2TFVBMRPS5SSNP98DQKQ5JNB2B6NZM91C4K3P7B"
amount = 10000000000000000
```

#### Start the Stacks Blockchain

To run your miner, run this in the command line:

```bash
stacks-node start --config $HOME/testnet-miner-conf.toml
```

Your node should start. It will take some time to sync, and then your miner will be running.

#### Enable Debug Logging

In case you are running into issues or would like to see verbose logging, you can run your node with debug logging enabled. In the command line, run:

```bash
STACKS_LOG_DEBUG=1 stacks-node start --config $HOME/testnet-miner-conf.toml
```

***

### Optional: Running a Stacks Blockchain miner with Docker

Alternatively, you can run a Stacks testnet miner with Docker.

{% hint style="warning" %}
Ensure you have [Docker](https://docs.docker.com/get-docker/) installed.
{% endhint %}

#### Generate a Keychain and Get Some Tokens

Generate a keychain:

```bash
docker run -i node:20-alpine npx @stacks/cli make_keychain 2>/dev/null | jq -r
```

Now, we need to get some tBTC. Grab the `btcAddress` field, and paste it into [this Bitcoin testnet faucet](https://tbtc.bitaps.com/). You'll be sent `0.01` tBTC to that address.

#### Update Stacks Blockchain Docker Configuration File

Use the steps outlined above to create the configuration file.

#### Start the Stacks Blockchain miner with Docker

{% hint style="info" %}
Info: The ENV VARS `RUST_BACKTRACE` and `STACKS_LOG_DEBUG` are optional. If removed, debug logs will be disabled.
{% endhint %}

```bash
docker run -d \
  --name stacks_miner \
  --rm \
  --network host \
  -e RUST_BACKTRACE="full" \
  -e STACKS_LOG_DEBUG="1" \
  -v "$HOME/testnet-miner-conf.toml:/src/stacks-node/testnet-miner-conf.toml" \
  -v "/stacks-blockchain:/stacks-blockchain" \
  -p 20443:20443 \
  -p 20444:20444 \
  blockstack/stacks-blockchain:latest \
/bin/stacks-node start --config /src/stacks-node/testnet-miner-conf.toml
```

You can review the node logs with this command:

```bash
docker logs -f stacks_miner
```

***

### Optional: Running in Kubernetes with Helm

In addition, you're also able to run a Stacks miner in a Kubernetes cluster using the [stacks-blockchain Helm chart](https://github.com/stacks-network/stacks-blockchain/tree/master/deployment/helm/stacks-blockchain).

Ensure you have the following prerequisites installed:

* [Docker](https://docs.docker.com/get-docker/)
* [minikube](https://minikube.sigs.k8s.io/docs/start/) (Only needed if standing up a local Kubernetes cluster)
* [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/)
* [helm](https://helm.sh/docs/intro/install/)

#### Generate keychain and get some tokens

Use the steps outlined above

#### Install the chart and run the miner

To install the chart with the release name `my-release` and run the node as a miner:

```bash
minikube start # Only run this if standing up a local Kubernetes cluster
helm repo add blockstack https://charts.blockstack.xyz
helm install my-release blockstack/stacks-blockchain \
  --set config.node.miner=true \
  --set config.node.seed="privateKey-from-generate-keychain-step" \
```

You can review the node logs with this command:

```bash
kubectl logs -l app.kubernetes.io/name=stacks-blockchain
```

For more information on the Helm chart and configuration options, please refer to the [chart's homepage](https://github.com/stacks-network/stacks-blockchain/tree/master/deployment/helm/stacks-blockchain).


# Mine Mainnet Stacks Tokens

### Introduction

For more on the technical details of mining, please review the mining guide.

The following is an abridged version of the [walkthrough here](https://github.com/stacksfoundation/miner-docs), written for a Linux system. If you're on Windows or MacOS, there will be some slight modifications needed (PR's welcome!).

If you're interested in mining on the Stacks mainnet, you can find instructions on how to do that here:

### Running a Bitcoin Mainnet Full Node

To participate as a miner on mainnet, you must have access to a mainnet bitcoin node with a wallet (and the wallet's private key). One way to accomplish this is to run bitcoin locally.

* [Ensure your computer meets the minimum hardware requirements before continuing.](https://bitcoin.org/en/bitcoin-core/features/requirements#system-requirements)

First, download a [bitcoin binary](https://bitcoin.org/en/download), or [build from source](https://github.com/stacksfoundation/miner-docs/blob/main/bitcoin.md#source-install) (*there may be some extra requirements to building,* [*defined here*](https://github.com/stacksfoundation/miner-docs/blob/main/prerequisites.md#install-required-packages)).

If you want to learn more about the technical details of mining, please review the mining guide:

{% hint style="info" %}
**Tip:** It is recommended to use a persistent location for the chainstate, in the steps below we're using `/bitcoin`.
{% endhint %}

#### Update the Bitcoin Configuration File

Next, update the bitcoin configuration:

* **Optional, but recommended:** Use a persistent directory to store the Bitcoin chainstate, i.e. `datadir=/bitcoin`.
* **Optional, but recommended:** Update the `rpcallowip` value to only allow `127.0.0.1`, or the stacks miner IPv4.
* Modify the `rpcuser` and `rpcpassword` values from the defaults below.
* Store the following configuration somewhere on your filesystem (ex: `$HOME/bitcoin.conf`).

```toml
server=1
disablewallet=0
datadir=/bitcoin
rpcuser=btcuser
rpcpassword=btcpass
rpcallowip=0.0.0.0/0
bind=0.0.0.0:8333
rpcbind=0.0.0.0:8332
dbcache=512
banscore=1
rpcthreads=256
rpcworkqueue=256
rpctimeout=100
txindex=1
```

#### Start Bitcoin

Finally, start `bitcoind` as follows (adjust the `conf` path to where it was created in the previous step, i.e. `$HOME/bitcoin.conf`):

```bash
bitcoind -conf=$HOME/bitcoin.conf
```

{% hint style="info" %}
**Note:** It will take a few hours for the node to synchronize with Bitcoin Mainnet.
{% endhint %}

While it's syncing, you can track the progress with `bitcoin-cli` or the logfile (will be located where the chainstate is stored, i.e. `/bitcoin/debug.log`):

```bash
$ bitcoin-cli \
 -rpcconnect=127.0.0.1 \
 -rpcport=8332 \
 -rpcuser=btcuser \
 -rpcpassword=btcpass \
getblockchaininfo | jq .blocks
836745
```

### Running a Stacks Blockchain miner

First, download the latest tagged [stacks blockchain binary](https://github.com/stacks-network/stacks-blockchain/releases/latest), or [build from source](https://github.com/stacksfoundation/miner-docs/blob/main/stacks-blockchain.md#build-and-install-stacks-blockchain-from-source) (*there may be some extra requirements to building,* [*defined here*](https://github.com/stacksfoundation/miner-docs/blob/main/prerequisites.md#install-required-packages)).

{% hint style="info" %}
**Tip:** It is recommended to use a persistent location for the chainstate, in the steps below we're using `/stacks-blockchain`.
{% endhint %}

#### Generate a keychain

First, a keychain needs to be generated. With this keychain, we'll purchase some BTC from a cryptocurrency exchange, and then use that BTC to start mining.

To create a keychain, the simplest way is to use the [stacks-cli](https://docs.hiro.so/references/stacks-cli) with the `make_keychain` command.

```bash
npx @stacks/cli make_keychain 2>/dev/null | jq -r
```

After this runs, you should see some JSON printed to the screen that looks like this:

```json
{
  "mnemonic": "spare decade dog ghost luxury churn flat lizard inch nephew nut drop huge divert mother soccer father zebra resist later twin vocal slender detail",
  "keyInfo": {
    "privateKey": "ooxeemeitar4ahw0ca8anu4thae7aephahshae1pahtae5oocahthahho4ahn7eici",
    "address": "SPTXOG3AIHOHNAEH5AU6IEX9OOTOH8SEIWEI5IJ9",
    "btcAddress": "Ook6goo1Jee5ZuPualeiqu9RiN8wooshoo",
    "wif": "rohCie2ein2chaed9kaiyoo6zo1aeQu1yae4phooShov2oosh4ox",
    "index": 0
  }
}
```

{% hint style="danger" %}
**Do not lose this information** - we'll need to use the `privateKey`, `btcAddress` and `wif` fields in later steps.
{% endhint %}

The above `wif` (`Kyk49jsPGen5C1ThhyJJH4CndLk8yLESuQJVGsbbTV3FFF9CRTJG`) will then need to be imported into the bitcoin mainnet network.

Next, a bitcoin wallet is created:

```bash
bitcoin-cli \
  -rpcconnect=127.0.0.1 \
  -rpcport=8332 \
  -rpcuser=btcuser \
  -rpcpassword=btcpass \
  createwallet \
  wallet_name="miner" \
  disable_private_keys=false \
  blank=false \
  passphrase="" \
  avoid_reuse=false \
  descriptors=false \
  load_on_startup=true
```

Now, import your wif (bitcoin private key) inside the newly created wallet.

{% hint style="info" %}
**Note:** Be sure to replace `<wif from JSON above>` with the wif value in the `Generate a keychain` step.
{% endhint %}

```bash
bitcoin-cli \
  -rpcport=8332 \
  -rpcuser=btcuser \
  -rpcpassword=btcpassword \
  importprivkey <wif from JSON above>
```

{% hint style="info" %}
**Note:** The import may take a while, because a wallet rescan is triggered. After the import has completed successfully, you can check that the address is imported with `getaddressinfo`.
{% endhint %}

```bash
bitcoin-cli \
  -rpcconnect=127.0.0.1 \
  -rpcport=8332 \
  -rpcuser=btcuser \
  -rpcpassword=btcpass \
  getaddressinfo <btcAddress from JSON above>
```

Once imported, we need to get some BTC to that address. You should be able to transfer BTC to this address using a cryptocurrency exchange such as [Coinbase](https://www.coinbase.com/), [Binance](https://www.binance.com/), or [Kraken](https://www.kraken.com/).

#### Update the Stacks Blockchain Configuration File

Now, we need to configure our node to use this Bitcoin keychain. Copy the [sample mainnet miner config](https://raw.githubusercontent.com/stacks-network/stacks-blockchain/master/testnet/stacks-node/conf/mainnet-miner-conf.toml) to your local machine in a *memorable* location like `$HOME/mainnet-miner-conf.toml`.

Next, update the stacks configuration:

* **Optional, but recommended:** Use a persistent directory to store the Stacks chainstate, i.e. `working_dir = "/stacks-blockchain"`
* From the `make_keychain` step, modify the `seed` and `mining_key` values with `privatekey`
* Store the following configuration somewhere on your filesystem (ex: `$HOME/mainnet-miner-conf.toml`)

```toml
[node]
working_dir = "/stacks-blockchain"
rpc_bind = "0.0.0.0:20443"
p2p_bind = "0.0.0.0:20444"
seed = "<privateKey from JSON above>"
miner = true
bootstrap_node = "02196f005965cebe6ddc3901b7b1cc1aa7a88f305bb8c5893456b8f9a605923893@seed.mainnet.hiro.so:20444,02539449ad94e6e6392d8c1deb2b4e61f80ae2a18964349bc14336d8b903c46a8c@cet.stacksnodes.org:20444,02ececc8ce79b8adf813f13a0255f8ae58d4357309ba0cedd523d9f1a306fcfb79@sgt.stacksnodes.org:20444,0303144ba518fe7a0fb56a8a7d488f950307a4330f146e1e1458fc63fb33defe96@est.stacksnodes.org:20444"
mine_microblocks = false

[burnchain]
wallet_name = "miner"
chain = "bitcoin"
mode = "mainnet"
peer_host = "127.0.0.1"
username = "<bitcoin config rpcuser>"
password = "<bitcoin config rpcpassword>"
rpc_port = 8332
peer_port = 8333
satoshis_per_byte = 100
burn_fee_cap = 450000

[miner]
mining_key = "<privateKey from JSON above>"
activated_vrf_key_path = "/stacks-blockchain/saved_vrf_key.json"

[connection_options]
private_neighbors = false
```

#### Start the Stacks Blockchain

To run your miner, run this in the command line:

```bash
stacks-node start --config $HOME/mainnet-miner-conf.toml
```

Your node should start. It will take some time to sync, and then your miner will be running.

#### Enable Debug Logging

In case you are running into issues or would like to see verbose logging, you can run your node with debug logging enabled. In the command line, run:

```bash
STACKS_LOG_DEBUG=1 stacks-node start --config $HOME/mainnet-miner-conf.toml
```

### Optional: Running a Stacks Blockchain miner with Docker

Alternatively, you can run a Stacks mainnet miner with Docker.

{% hint style="warning" %}
Ensure you have [Docker](https://docs.docker.com/get-docker/) installed.
{% endhint %}

#### Generate a Keychain and Get Some Tokens

Generate a keychain:

```bash
docker run -i node:20-alpine npx @stacks/cli make_keychain 2>/dev/null | jq -r
```

We need to get some BTC to that address. You should be able to transfer BTC to this address using a cryptocurrency exchange such as [Coinbase](https://www.coinbase.com/), [Binance](https://www.binance.com/), or [Kraken](https://www.kraken.com/).

#### Update Stacks Blockchain Docker Configuration File

Use the steps outlined above to create the configuration file.

#### Start the Stacks Blockchain miner with Docker

{% hint style="info" %}
**Info:** The ENV VARS `RUST_BACKTRACE` and `STACKS_LOG_DEBUG` are optional. If removed, debug logs will be disabled.
{% endhint %}

```bash
docker run -d \
  --name stacks_miner \
  --rm \
  --network host \
  -e RUST_BACKTRACE="full" \
  -e STACKS_LOG_DEBUG="1" \
  -v "$HOME/mainnet-miner-conf.toml:/src/stacks-node/mainnet-miner-conf.toml" \
  -v "/stacks-blockchain:/stacks-blockchain" \
  -p 20443:20443 \
  -p 20444:20444 \
  blockstack/stacks-blockchain:latest \
/bin/stacks-node start --config /src/stacks-node/mainnet-miner-conf.toml
```

You can review the node logs with this command:

```bash
docker logs -f stacks_miner
```

### Optional: Running in Kubernetes with Helm

In addition, you're also able to run a Stacks miner in a Kubernetes cluster using the [stacks-blockchain Helm chart](https://github.com/stacks-network/stacks-blockchain/tree/master/deployment/helm/stacks-blockchain).

Ensure you have the following prerequisites installed:

* [Docker](https://docs.docker.com/get-docker/)
* [minikube](https://minikube.sigs.k8s.io/docs/start/) (Only needed if standing up a local Kubernetes cluster)
* [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/)
* [helm](https://helm.sh/docs/intro/install/)

#### Generate keychain and get some tokens

Use the steps outlined above

#### Install the chart and run the miner

To install the chart with the release name `my-release` and run the node as a miner:

```bash
minikube start # Only run this if standing up a local Kubernetes cluster
helm repo add blockstack https://charts.blockstack.xyz
helm install my-release blockstack/stacks-blockchain \
  --set config.node.miner=true \
  --set config.node.seed="your-privateKey-from-generate-keychain-step" \
  --set config.burnchain.mode="mainnet"
```

You can review the node logs with this command:

```bash
kubectl logs -l app.kubernetes.io/name=stacks-blockchain
```

For more information on the Helm chart and configuration options, please refer to the [chart's homepage](https://github.com/stacks-network/stacks-blockchain/tree/master/deployment/helm/stacks-blockchain).


# Verify Miner

## Verify Configuration

You can verify that your node is operating as a miner by checking its log output to verify that it was able to find its Bitcoin UTXOs:

{% code title="logs" %}

```bash
$ head -n 1000 /path/to/your/node/logs | grep -i utxo
INFO [1630127492.031042] [testnet/stacks-node/src/run_loop/neon.rs:146] [main] Miner node: checking UTXOs at address: <redacted>
INFO [1630127492.062652] [testnet/stacks-node/src/run_loop/neon.rs:164] [main] UTXOs found - will run as a Miner node
```

{% endcode %}

## Verify Operations

The first transaction of the miner is a registration transaction on Bitcoin. It just contains an `OP_RETURN` utxo.

Thereafter, the miner creates for each block one transaction on Bitcoin with one data output, and two commit outputs to the stackers. The amount is half the value of the configured `burn_fee_cap` property.

If the miner won a sortition, the corresponding Stacks address will create a tenure change transaction and a coinbase transaction. The block rewards will be awarded 100 blocks later if mining was successful.


# Run a Signer

### How to Use This Guide

If you are not familiar with the concept of signing and stacking, and how they work together, be sure to check out the [Stackers and Signing concept guide](https://app.gitbook.com/s/H74xqoobupBWwBsVMJhK/block-production/signing).

This guide is a step-by-step walkthrough for setting up and running a signer. If you need to troubleshoot your signer setup, see the Signer Troubleshooting section. If you need to Stack your STX, or have questions about how that process works, check out the Stack STX guide.

### Background and High-Level Process

To run a signer you'll run a signer and a Stacks node side-by-side. Specifically, run a follower node. The signer monitors events from the Stacks node and uses the generated account (see Preflight Setup) to sign incoming Stacks blocks sent from the Stacks node.

This doc provides instructions to set up both using either Docker or the release binaries available in the [stacks core releases](https://github.com/stacks-network/stacks-core/releases) repository, and how to configure them so the signer and Stacks node communicate correctly.

### Knowledge Prerequisites

* Docker and basic knowledge of pulling and running images
* Basic knowledge of [Stacks accounts](https://app.gitbook.com/s/H74xqoobupBWwBsVMJhK/network-fundamentals/accounts)
* Basic knowledge of [stacking](https://app.gitbook.com/s/H74xqoobupBWwBsVMJhK/block-production/stacking) and the stacking flow

{% stepper %}
{% step %}

#### Signer Checklist — Pre-Launch Setup

Quick reference of major setup steps prior to launching a signer.

* Ensure your system meets the [minimum system requirements](#minimum-system-requirements).
* Acquire Docker and basic knowledge of Stacks accounts, stacking, and the Nakamoto stacking flow (links above).
  {% endstep %}

{% step %}

#### Signer Checklist — Preflight Setup

* Generate a new private key using stacks-cli (see Preflight Setup).
* Save the generated account information securely.
  {% endstep %}

{% step %}

#### Signer Checklist — Configuration Setup

* Create a `signer-config.toml` file with necessary configurations:
  * node\_host
  * endpoint
  * network
  * db\_path
  * auth\_password
  * stacks\_private\_key
* Store `signer-config.toml` securely and note down the values used.
  {% endstep %}

{% step %}

#### Signer Checklist — Running the Signer

* Decide whether to run the signer using Docker (recommended) or as a binary.
* If using Docker:
  * Set up the necessary ports and volumes.
  * Run the Docker container with the appropriate settings.
* If running as a binary:
  * Build `stacks-core` from source or download the pre-built binary.
  * Run the signer using: `stacks-signer run --config <path_to_config>`.
    {% endstep %}

{% step %}

#### Signer Checklist — Verify Signer Operation

* Check that the signer is listening on its configured endpoint.
* Confirm that there are no errors and that the system is ready for connections.
  {% endstep %}

{% step %}

#### Signer Checklist — Setting Up the Stacks Node

* Create a `node-config.toml`, include:
  * connection\_options.sauth\_token
  * events\_observer.endpoint (matching signer config)
* Decide whether to run the Stacks node using Docker or as a binary and follow the respective run steps.
  {% endstep %}

{% step %}

#### Signer Checklist — Verify Stacks Node Operation

* Check Stacks node logs for successful connection to the signer.
* Confirm the node is syncing Bitcoin headers properly.
  {% endstep %}

{% step %}

#### Signer Checklist — Setup Stacks Accounts

* Set up a pool operator wallet in a Stacks wallet (e.g., Leather or Xverse).
* Fund the pool operator wallet with sufficient STX for transaction fees.
* Share the pool operator wallet’s STX address with delegating parties.
* Fund your signer's STX wallet with enough STX to cover transaction fees (recommend at least 100–200 STX).
  {% endstep %}
  {% endstepper %}

### Minimum System Requirements

These are the minimum required specs to run a node and signer. More resources are recommended for optimal performance.

#### Signer, Stacks node and Bitcoin node

* 4 vCPU
* 8 GB memory if running only a Stacks node and signer
* 16 GB memory if running Stacks + Bitcoin node + signer
* 1.5+ TB storage (1 TB for Bitcoin node, 500 GB for Stacks node, and 50 GB for signer)

***

## Preflight Setup

Before you get your signer set up, you'll need to [generate a new private key](https://docs.stacks.co/stacks-101/accounts#creation). The `stacks-cli` provides a mechanism for quickly generating a new account keychain via a simple CLI interface. The linked guide shows how to create one of those accounts on testnet.

Save the generated account information securely; you'll need it later.

{% hint style="info" %}
What should the networking setup look like?

Signers are intended to work with a local node. The node<->signer connection is not run over SSL, which means you can be exposed to a man-in-the-middle attack if your signer and node are hosted on separate machines. Ensure your signer isn't allowing requests from the public internet. We recommend having the signer and node running locally on the same machine or using internal networking between them.
{% endhint %}

***

## Create a Configuration File

Create a file named `signer-config.toml`. Populate it with the example signer config file contents from the [Sample Configuration Files](https://app.gitbook.com/s/GVj1Z9vMuEOMe7oH7Wnq/node-operations/signer-configuration) page. Each field is described on that page.

***

## Running the Signer

Two options: Docker (recommended) or binary. Binaries are available on the [Stacks Core releases page](https://github.com/stacks-network/stacks-core/releases).

### Running the Signer with Docker

You can run the signer as a Docker container using the `blockstack/stacks-signer:3.1.0.0.5.0` image.

Requirements when running the container:

* The port configured as the `endpoint` (example: 30000) must be exposed to your Stacks node (endpoint should not be public).
* A volume with at least a few GB available that contains the folder specified by your `db_path` (example: `/var`).
* Mount your `signer-config.toml` file as a volume.

Example docker run command:

```bash
IMG="blockstack/stacks-signer"
VER="3.1.0.0.5.0"
STX_SIGNER_PATH="./"
STX_SIGNER_DATA="$STX_SIGNER_PATH/data"
STX_SIGNER_CONFIG="$STX_SIGNER_PATH/signer-config.toml"

docker run -d \
    -v $STX_SIGNER_CONFIG:/config.toml \
    -v $STX_SIGNER_DATA:/var/stacks \
    -p 30000:30000 \
    -e RUST_BACKTRACE=full \
    -e BLOCKSTACK_DEBUG=0 \
    --name stacks-signer \
    $IMG:$VER \
    stacks-signer run \
    --config /config.toml
```

Hint about platform mismatch:

{% hint style="info" %}
If you get an error about the manifest not found or the image platform not matching the host platform, you probably are running on an architecture other than x64. Add `--platform=linux/amd64` to the command (for example, on M1 Mac).
{% endhint %}

Or, using a custom Dockerfile:

```docker
FROM blockstack/stacks-signer:3.1.0.0.5.0
COPY signer-config.toml /config.toml
EXPOSE 30000
CMD ["stacks-signer", "run", "--config", "/config.toml"]
```

### Running the Signer as a Binary

Download the pre-built binaries from the [Stacks Core releases page on Github](https://github.com/stacks-network/stacks-core/releases), unzip the archive for your architecture — inside is a `stacks-signer` binary.

Run the signer:

```bash
stacks-signer run --config ../signer-config.toml
```

(Replace `../signer-config.toml` with the actual path to your config.)

***

## Verify the Signer is Running

List running containers:

```bash
docker ps
```

Check the container logs:

```bash
docker logs <container-id>
```

You should see:

Signer spawned successfully. Waiting for messages to process...

You may also see a warning like:

```
WARN [1712003997.160121] [stacks-signer/src/runloop.rs:247] [signer_runloop] Signer is not registered for reward cycle 556. Waiting for confirmed registration...
```

This means your signer is running and awaiting registration; proceed to set up the Stacks node and begin stacking.

{% hint style="warning" %}
Even after you Stack, you may still see messages saying the signer is not registered for the current or next reward cycle. This is normal until the prepare phase for your chosen reward cycle; assuming you meet the stacking minimum, the signer will be registered during that phase.
{% endhint %}

***

## Set Up Your Bitcoin Node

Optional but recommended to improve signer health and performance.

Guides:

* Run a full Bitcoin node: <https://docs.stacks.co/guides-and-tutorials/nodes-and-miners/run-a-bitcoin-node>
* Run a pruned Bitcoin node: <https://docs.stacks.co/guides-and-tutorials/nodes-and-miners/run-a-pruned-bitcoin-node>

***

## Set Up Your Stacks Node

Start the Stacks node after the signer is running — the node will not run unless it can send events to the signer.

### Stacks Node Configuration

Create `node-config.toml`. See the [Sample Configuration Files](https://app.gitbook.com/s/GVj1Z9vMuEOMe7oH7Wnq/node-operations/signer-configuration) page for the full contents.

Important fields to change:

* `working_dir`: directory where the node persists data
* `auth_token`: authentication token used by signer (must match signer `auth_password`)
* `events_observer.endpoint`: host and port where your signer listens (example: `127.0.0.1:30000` or `stacks-signer.local:30000`)

### Start with an archive

Starting from an archive snapshot is much faster than syncing from genesis. Archives are at <https://archive.hiro.so>.

Example to download and extract the latest mainnet snapshot:

```bash
curl -# https://archive.hiro.so/mainnet/stacks-blockchain/mainnet-stacks-blockchain-latest.tar.gz -o stacks-snapshot.tar.gz
tar -zxvf stacks-snapshot.tar.gz
```

This creates a `mainnet` folder where downloaded. Set `working_dir` to the parent directory containing `mainnet`.

See best practices for snapshots: ../best-practices-to-snapshot-the-chainstate.md

### Run a Stacks Node with Docker

Use the `blockstack/stacks-core` image (example tag: `3.1.0.0.13`).

When running the container:

* Expose the port configured for `p2p_bind` to the internet.
* Make the port configured for `rpc_bind` accessible by your signer.
* `working_dir` needs 500 GB–1 TB storage.
* Include your `node-config.toml`.

Example docker run:

```bash
IMG="blockstack/stacks-core"
VER="3.1.0.0.13"
STX_NODE_CONFIG="./node-config.toml"

docker run -d \
    -v $STX_NODE_CONFIG:/config.toml \
    -v /var/stacks \
    -p 20443:20443 \
    -p 20444:20444 \
    -e RUST_BACKTRACE=full \
    --name stacks-node \
    $IMG:$VER \
    stacks-node start \
    --config /config.toml
```

Or with a custom Dockerfile:

```docker
FROM blockstack/stacks-core:3.1.0.0.13
COPY node-config.toml /config.toml
EXPOSE 20444
EXPOSE 20443
CMD ["stacks-node", "start", "--config", "/config.toml"]
```

If you get connection refused errors, you may need to point `events_observer.endpoint` to the Docker signer container. If using default Docker bridge mode, `localhost` inside the container is not the host — point the endpoint to the Docker host or the signer container hostname accordingly.

### Run a Stacks Node with a Binary

Download the pre-built `stacks-node` binary from the [Stacks Core releases](https://github.com/stacks-network/stacks-core/releases).

Start the node:

```bash
./stacks-node start --config node-config.toml
```

### Verify Stacks Node is Running

Typical startup logs:

```bash
Mar  6 19:35:08.212848 INFO stacks-node 0.1.0
Mar  6 19:35:08.213084 INFO Loading config at path ./Stacks-config.toml
Mar  6 19:35:08.216674 INFO Registering event observer at: localhost:30000
Mar  6 19:35:08.221603 INFO Migrating sortition DB to the latest schema version
Mar  6 19:35:08.224082 INFO Migrating chainstate DB to the latest schema version
Mar  6 19:35:08.227404 INFO Start syncing Bitcoin headers, feel free to grab a cup of coffee, this can take a while
```

Ensure you see the `Registering event observer at XXX` log with your signer endpoint. Once Bitcoin headers are synced, you can GET `/v2/info` on the node RPC endpoint (default port 20443).

You may see many logs while syncing; refer to How to Read the Signer Logs if concerned.

***

## Setup Your Stacks Accounts

{% hint style="info" %}
For more on stacking and signing relationship, see the [Stack STX](https://github.com/stacks-network/docs/blob/master/docs/operate/run-a-signer/broken-reference/README.md) guide.
{% endhint %}

As a signer you’ll manage two Stacks accounts:

1. A “pool operator” wallet, which commits delegated STX to your signer
2. Your signer’s wallet

{% hint style="warning" %}
For testing, make sure you are using testnet (not mainnet). Testnet STX can be [requested from a faucet](https://explorer.hiro.so/sandbox/faucet?chain=testnet).
{% endhint %}

### Setup Your Pool Operator Wallet

Set up a pool operator wallet using any Stacks wallet, such as [Leather](https://leather.io/) or [Xverse](https://www.xverse.app/). You may generate a new account or use an existing one. Leather supports Ledger hardware wallets if you prefer.

Fund the wallet with enough STX to cover transaction fees (testnet: faucet at <https://explorer.hiro.so/sandbox/faucet?chain=testnet>).

Share this wallet’s STX address with parties that will delegate STX to you. For improved UX, you might use the helper contract allowing a BTC address for stackers ([pox4-pools](https://explorer.hiro.so/txid/SP001SFSMC2ZY76PD4M68P3WGX154XCH7NE3TYMX.pox4-pools?chain=mainnet)) and add your pool to [earn.leather.io](https://earn.leather.io/).

***

If you need more detailed troubleshooting or further setup examples (config snippets, sample signer-config.toml or node-config.toml), let me know which files or examples you'd like converted or added.


# Signer Quickstart

{% hint style="info" %}
**Current Signer and Stacks Node Versions**

**Stacks Signer - latest**

* [Docker Image](https://hub.docker.com/layers/blockstack/stacks-signer/latest)
* [GitHub Release](https://github.com/stacks-network/stacks-core/releases/latest)

**Stacks Node - latest**

* [Docker Image](https://hub.docker.com/layers/blockstack/stacks-core/latest)
* [GitHub Release](https://github.com/stacks-network/stacks-core/releases/latest)
  {% endhint %}

If you want to get up and running as an active signer as quickly as possible, here is a list of the commands you need to run and actions to take.

If you are not familiar with how signing works yet, be sure to check out the [Signing concept guide](https://app.gitbook.com/s/H74xqoobupBWwBsVMJhK/block-production/signing).

If you would like a more detailed walkthrough of all of these steps, take a look at the [Running a Signer](file:///) guide.

{% hint style="danger" %}
The CLI examples below may show outdated release versions. For the latest releases, always refer to the links above in the top info block.
{% endhint %}

{% stepper %}
{% step %}

#### Prerequisites

{% tabs %}
{% tab title="Mainnet" %}

```bash
# Create the required directories
mkdir -p ~/stacks-signer/data
mkdir -p ~/stacks-node/data

# Install needed packages
sudo apt install -y npm wget unzip jq tar

# Install Stacks CLI globally
npm install --global @stacks/cli

# Generate a new account and store details in a file
stx make_keychain | jq > ~/stacks-signer/keychain.json
```

{% endtab %}

{% tab title="Testnet" %}

```bash
# Create the required directories
mkdir -p ~/stacks-signer/data
mkdir -p ~/stacks-node/data

# Install needed packages
sudo apt install -y npm wget unzip jq tar

# Install Stacks CLI globally
npm install --global @stacks/cli

# Generate a new account and store details in a file

# '-t' option makes this a testnet account
stx make_keychain -t | jq > ~/stacks-signer/keychain.json
```

{% endtab %}
{% endtabs %}

The account file previously created looks like this:

```json
{
  "mnemonic": "aaa bbb ccc ddd ...",
  "keyInfo": {
    "privateKey": "65f3...",
    "publicKey": "03a3...",
    "address": "SP1G...",
    "btcAddress": "19tg...",
    "wif": "Kzdt...",
    "index": 0
  }
}
```

From this file, you'll need the `privateKey` value.
{% endstep %}

{% step %}

#### Set Up Your Stacks Signer

**Download the stacks-signer binary**

Official binaries are available from the [Stacks Core releases page on Github](https://github.com/stacks-network/stacks-core/releases). Each release includes pre-built binaries. Download the [latest signer release ZIP file](https://github.com/stacks-network/stacks-core/releases/latest) for your server’s architecture and decompress it. Inside of that folder is a `stacks-signer` binary.

Assuming a `Linux x64 glibc` machine, the commands to download and uncompress the signer binary look like this:

```bash
# The CLI examples below may show outdated release versions.
# Enter the signer directory
cd ~/stacks-signer

# Download the signer binary zip
wget https://github.com/stacks-network/stacks-core/releases/latest/download/linux-glibc-x64.zip

# Unzip the signer binary archive
unzip linux-glibc-x64.zip
```

**Create the configuration file**

Create the configuration file required to start the signer (be sure to replace `<your_token>` and `<your_private_key>` with your auth token and private key values):

{% tabs %}
{% tab title="Mainnet" %}

```bash
# The CLI examples below may show outdated release versions.
# Set environment variables
AUTH_TOKEN=<your_token> # Used for signer-node authentication
PRIVATE_KEY=<your_private_key> # privateKey from Step 1, this is the signer's private key

# Create the signer's configuration file
cat <<EOF> ~/stacks-signer/signer-config.toml
node_host = "127.0.0.1:20443"
endpoint = "127.0.0.1:30000"
network = "mainnet"
db_path = "$HOME/stacks-signer/data/signer.sqlite"
auth_password = "$AUTH_TOKEN"
stacks_private_key = "$PRIVATE_KEY"
metrics_endpoint = "127.0.0.1:9154"
block_proposal_timeout_ms = 180000
tenure_idle_timeout_secs = 120
EOF
```

{% endtab %}

{% tab title="Testnet" %}

```bash
# Set environment variables
AUTH_TOKEN=<your_token> # Used for signer-node authentication
PRIVATE_KEY=<your_private_key> # privateKey from Step 1, this is the signer's private key

# Create the signer's configuration file
cat <<EOF> ~/stacks-signer/signer-config.toml
node_host = "127.0.0.1:20443"
endpoint = "127.0.0.1:30000"
network = "testnet"
db_path = "$HOME/stacks-signer/data/signer.sqlite"
auth_password = "$AUTH_TOKEN"
stacks_private_key = "$PRIVATE_KEY"
metrics_endpoint = "127.0.0.1:9154"
block_proposal_timeout_ms = 180000
EOF
```

{% endtab %}
{% endtabs %}

**Verify the setup**

To ensure the signer has been set up correctly, you can run the following commands:

```bash
# The CLI examples below may show outdated release versions.
# Verify the signer's version
~/stacks-signer/stacks-signer --version

# Output:
stacks-signer stacks-signer signer-3.1.0.0.5.0 (release/signer-3.1.0.0.5.0:513dbc5, release build, linux [x86_64])

# Verify the config file
~/stacks-signer/stacks-signer check-config -c ~/stacks-signer/signer-config.toml

# Output:
Config: 
Stacks node host: 127.0.0.1:20443
Signer endpoint: 127.0.0.1:30000
Stacks address: SP1G... # address from keychain file
Public key: 03a3... # publicKey from keychain file
Network: mainnet # or testnet
Chain ID: 0x1 # or 0x80000000 for testnet
Database path: /home/admin/stacks-signer/data/signer.sqlite
Metrics endpoint: 127.0.0.1:9154
```

**Start the signer**

If the outputs of the previous commands are correct, you can proceed and start the signer:

```bash
~/stacks-signer/stacks-signer run -c ~/stacks-signer/signer-config.toml
```

{% endstep %}

{% step %}

#### Optional: Set up a Bitcoin node (strongly recommended)

In order to optimize signer health and performance, we highly recommend setting up your own Bitcoin node rather than relying on a third-party node.

We have created guides for running both a [full Bitcoin node](https://docs.stacks.co/operate/readme/run-a-bitcoin-node) and a [pruned Bitcoin node](https://docs.stacks.co/operate/readme/run-a-pruned-bitcoin-node) you can follow.
{% endstep %}

{% step %}

#### Set Up Your Stacks Node

**Download the stacks-node binary**

Official binaries are available from the [Stacks Core releases page on Github](https://github.com/stacks-network/stacks-core/releases). Each release includes pre-built binaries. Download the [latest node release ZIP file](https://github.com/stacks-network/stacks-core/releases/latest) for your server’s architecture and decompress it. Inside of that folder is a `stacks-node` binary.

Assuming a `Linux x64 glibc` machine, the commands to download and uncompress the node binary look like this:

```bash
# The CLI examples below may show outdated release versions.
# Enter the node directory
cd ~/stacks-node

# Download the node binary zip
wget https://github.com/stacks-network/stacks-core/releases/latest/download/linux-glibc-x64.zip

# Unzip the node binary archive
unzip linux-glibc-x64.zip
```

**Create the configuration file**

Create the configuration file required to start the node (be sure to replace `<your_token>` with your auth token value):

{% tabs %}
{% tab title="Mainnet" %}
{% hint style="warning" %}
For mainnet, we strongly recommended that you run your own bitcoin node (you can follow guides on how to run a [full Bitcoin node](https://docs.stacks.co/guides-and-tutorials/nodes-and-miners/run-a-bitcoin-node) or a [pruned Bitcoin node](https://docs.stacks.co/guides-and-tutorials/nodes-and-miners/run-a-pruned-bitcoin-node)) in order to ensure you have no connection issues when downloading bitcoin blocks. A hosted bitcoin node may cause your stacks node to fall behind tip and remain unsynced.

If you run your own bitcoin node, you'll have to update `peer_host` and optionally add `rpc_port`, `peer_port`, `username` and `password` fields under the `[burnchain]` section of the node's configuration file.
{% endhint %}

```bash
# The CLI examples below may show outdated release versions.
# Set environment variables
AUTH_TOKEN=<your_token> # Used for signer-node authentication, same token as the one set up in the signer configuration

# Create the node's configuration file
cat <<EOF> ~/stacks-node/node-config.toml
[node]
working_dir = "$HOME/stacks-node/data"
rpc_bind = "127.0.0.1:20443"
p2p_bind = "0.0.0.0:20444"
prometheus_bind = "127.0.0.1:9153" 
bootstrap_node = "02196f005965cebe6ddc3901b7b1cc1aa7a88f305bb8c5893456b8f9a605923893@seed.mainnet.hiro.so:20444,02539449ad94e6e6392d8c1deb2b4e61f80ae2a18964349bc14336d8b903c46a8c@cet.stacksnodes.org:20444,02ececc8ce79b8adf813f13a0255f8ae58d4357309ba0cedd523d9f1a306fcfb79@sgt.stacksnodes.org:20444,0303144ba518fe7a0fb56a8a7d488f950307a4330f146e1e1458fc63fb33defe96@est.stacksnodes.org:20444"
stacker = true

[burnchain]
chain = "bitcoin"
mode = "mainnet"
peer_host = "bitcoin.mainnet.stacks.org"

[connection_options]
auth_token = "$AUTH_TOKEN"

[[events_observer]]
endpoint = "127.0.0.1:30000"
events_keys = ["stackerdb", "block_proposal", "burn_blocks"]
EOF
```

{% endtab %}

{% tab title="Testnet" %}

```bash
# Set environment variables
AUTH_TOKEN=<your_token> # Used for signer-node authentication, same token as the one set up in the signer configuration

# Create the node's configuration file
cat <<EOF> ~/stacks-node/node-config.toml
[node]
working_dir = "$HOME/stacks-node/data"
rpc_bind = "127.0.0.1:20443"
p2p_bind = "0.0.0.0:20444"
bootstrap_node = "029266faff4c8e0ca4f934f34996a96af481df94a89b0c9bd515f3536a95682ddc@seed.testnet.hiro.so:30444"
prometheus_bind = "127.0.0.1:9153" 
stacker = true
pox_sync_sample_secs = 30
always_use_affirmation_maps = true
require_affirmed_anchor_blocks = true

[burnchain]
mode = "krypton"
peer_host = "bitcoin.regtest.hiro.so"
peer_port = 18444
pox_prepare_length = 100
pox_reward_length = 900

[connection_options]
auth_token = "$AUTH_TOKEN"
private_neighbors = false

[[events_observer]]
endpoint = "127.0.0.1:30000"
events_keys = ["stackerdb", "block_proposal", "burn_blocks"]

[[ustx_balance]]
address = "ST2QKZ4FKHAH1NQKYKYAYZPY440FEPK7GZ1R5HBP2"
amount = 10000000000000000

[[ustx_balance]]
address = "ST319CF5WV77KYR1H3GT0GZ7B8Q4AQPY42ETP1VPF"
amount = 10000000000000000

[[ustx_balance]]
address = "ST221Z6TDTC5E0BYR2V624Q2ST6R0Q71T78WTAX6H"
amount = 10000000000000000

[[ustx_balance]]
address = "ST2TFVBMRPS5SSNP98DQKQ5JNB2B6NZM91C4K3P7B"
amount = 10000000000000000

[[burnchain.epochs]]
epoch_name = "1.0"
start_height = 0

[[burnchain.epochs]]
epoch_name = "2.0"
start_height = 0

[[burnchain.epochs]]
epoch_name = "2.05"
start_height = 1

[[burnchain.epochs]]
epoch_name = "2.1"
start_height = 2

[[burnchain.epochs]]
epoch_name = "2.2"
start_height = 3

[[burnchain.epochs]]
epoch_name = "2.3"
start_height = 4

[[burnchain.epochs]]
epoch_name = "2.4"
start_height = 5

[[burnchain.epochs]]
epoch_name = "2.5"
start_height = 6

[[burnchain.epochs]]
epoch_name = "3.0"
start_height = 1_900

[[burnchain.epochs]]
epoch_name = "3.1"
start_height = 2_000
EOF
```

{% endtab %}
{% endtabs %}

**Optional: Start the node with a data archive**

You can [download a chainstate archive](https://archive.hiro.so/) in order to quickly sync your node, otherwise it will take a long time to get up-to-date with the other nodes.

{% tabs %}
{% tab title="Mainnet" %}

```bash
# Enter the node's datadir
cd ~/stacks-node/data

# Download the archive
wget https://archive.hiro.so/mainnet/stacks-blockchain/mainnet-stacks-blockchain-latest.tar.gz

# Decompress the archive
tar -xvf mainnet-stacks-blockchain-latest.tar.gz

# Remove the archive
rm mainnet-stacks-blockchain-latest.tar.gz
```

{% endtab %}

{% tab title="Testnet" %}

```bash
# Enter the node's datadir
cd ~/stacks-node/data

# Download the archive
wget https://archive.hiro.so/testnet/stacks-blockchain/testnet-stacks-blockchain-latest.tar.gz

# Decompress the archive
tar -xvf testnet-stacks-blockchain-latest.tar.gz

# Remove the archive
rm testnet-stacks-blockchain-latest.tar.gz
```

{% endtab %}
{% endtabs %}

**Verify the setup**

To ensure the node has been set up correctly, you can run the following commands:

```bash
# The CLI examples below may show outdated release versions.
# Verify the node's version
~/stacks-node/stacks-node version

# Output:
INFO [1738695915.769633] [testnet/stacks-node/src/main.rs:278] [main] stacks-node 3.1.0.0.5 (release/3.1.0.0.5:513dbc5, release build, linux [x86_64])
stacks-node 3.1.0.0.5 (release/3.1.0.0.5:513dbc5, release build, linux [x86_64])

# Verify the node's config
~/stacks-node/stacks-node check-config --config ~/stacks-node/node-config.toml

# Output:
INFO [1738695915.769633] [testnet/stacks-node/src/main.rs:278] [main] stacks-node 3.1.0.0.5 (release/3.1.0.0.5:513dbc5, release build, linux [x86_64])
INFO [1729788064.913175] [testnet/stacks-node/src/main.rs:318] [main] Loading config at path /home/admin/stacks-node/node-config.toml
INFO [1729788064.969551] [testnet/stacks-node/src/main.rs:331] [main] Loaded config!
```

**Start the node**

If the outputs of the previous commands are correct, you can proceed and start the node:

```bash
~/stacks-node/stacks-node start --config ~/stacks-node/node-config.toml
```

{% endstep %}

{% step %}

#### Generate your signer signature

In order to stack, you'll need your signer signature. The fields required are further explained in the [Generate a signer key signature](https://docs.stacks.co/guides-and-tutorials/stack-stx/stacking-flow#step-2-generate-a-signer-key-signature) guide.

The command to generate a signature looks like this:

```bash
~/stacks-signer/stacks-signer generate-stacking-signature \
  --method stack-stx \
  --max-amount 1000000000000 \
  --auth-id 195591226970828652622091037492597751808 \
  --period 12 \
  --reward-cycle 100 \
  --pox-address 19tg... \
  --config ~/stacks-signer/signer-config.toml \
  --json
```

The generated JSON can be then copy-pasted directly in the [Leather Earn](https://earn.leather.io/) website mentioned in the next step.
{% endstep %}

{% step %}

#### Start stacking

The simplest route is to solo stack. You can do that by using [Leather Earn](https://earn.leather.io/). Click on the 'Stack Independently' button and follow the instructions there.

If you would like to learn more about solo stacking or running a pool operator, take a look at the [Stack STX](https://docs.stacks.co/guides-and-tutorials/stack-stx) guide.
{% endstep %}

{% step %}

#### Monitoring

If you would like to learn more about monitoring your signer and its corresponding node, you can check the [How to Monitor a Signer](https://docs.stacks.co/guides-and-tutorials/running-a-signer/how-to-monitor-signer) guide.
{% endstep %}
{% endstepper %}


# How to Read Signer Logs

There are a lot of different messages you can get in the logs when running a signer. Getting a good grasp on what some of these logs mean can help you troubleshoot effectively and determine if your signer is running successfully or not.

There are three types of log messages you should be aware of:

* Successful
* Informational
* Errors

Successful log messages indicate that you are on track and everything is working as expected. However, there are various success stages depending on several factors including your stacking status and the timing of the current reward cycle.

There are also several informational/warning logs that you don't necessarily need to take action on, but they provide useful context about the network or the signer.

Finally, error logs indicate something has gone wrong and you need to take action.

Below are some common log messages you might see, what they mean, and what action (if any) you should take.

{% hint style="info" %}
Successful / informational / error categories — general guidance:

* Successful: nothing to do unless the message indicates a different stage of operation that requires action (e.g., registration needed).
* Informational: often safe to ignore, but useful for context.
* Errors: require investigation and remediation.
  {% endhint %}

## Successful

### Signer uninitialized or not registered

If you get a message saying your signer is uninitialized, it means your signer is not registered for the current or upcoming reward cycle (or the burnchain block height is not yet at the second block in the prepare phase) so the signer cannot determine registration status yet. This does not mean the signer process itself has failed — it is running successfully, but the signer cannot act until registration/delegation occurs.

Example log:

`Signer spawned successfully. Waiting for messages to process... INFO [1711088054.872542] [stacks-signer/src/runloop.rs:278] [signer_runloop] Running one pass for signer ID# 0. Current state: Uninitialized`

You may also see a warning like:

```
WARN [1712003997.160121] [stacks-signer/src/runloop.rs:247] [signer_runloop] Signer is not registered for reward cycle 556. Waiting for confirmed registration...
```

Action:

* If you want the signer to participate, either delegate to it or stack on your own for an upcoming reward cycle.
* For more details on stacking and registration, see the How to Stack doc: ../stack-stx/stacking-flow\.md

## Informational

### Peer not connecting

If you see a message about a peer not connecting, for example:

```
INFO [1711988555.021567] [stackslib/src/net/neighbors/walk.rs:1015] [p2p-(0.0.0.0:20444,0.0.0.0:20443)] local.80000000://(bind=0.0.0.0:20444)(pub=Some(10.0.19.16:20444)): Failed to connect to facade0b+80000000://172.16.60.18:20444: PeerNotConnected
```

This means your node attempted to connect to another node on the network but was unable to. This can happen for many reasons (network connectivity, remote node offline, NAT/firewall, etc.).

Action:

* Usually not a cause for concern and does not impact whether your signer is running correctly.
* If you see many such messages or persistent connectivity issues, investigate network connectivity, firewall/NAT rules, or peer configuration.


# How to Monitor Signer

We will use [Grafana Cloud](https://grafana.com/) to observe and monitor both the Signer and its corresponding Stacks node.

## Requirements

Grafana's application observability docs have a [great quick-start](https://grafana.com/docs/grafana-cloud/monitor-applications/application-observability/). We will use:

* Grafana Cloud to collect metrics and visualize them.
* Grafana Alloy, on the Signer host, to push the metrics.

### Creating a Grafana Cloud account

Before we begin, create a [Grafana Cloud](https://grafana.com/docs/grafana-cloud/monitor-applications/application-observability/grafana-cloud/) account (they offer a free tier that you can use).

Once done, access your dashboard and follow these steps:

{% stepper %}
{% step %}

#### Add a new connection

Click on "Connections", then "Add new connection".
{% endstep %}

{% step %}

#### Select Hosted Prometheus metrics

Select "Hosted Prometheus metrics".
{% endstep %}

{% step %}

#### Choose via Grafana Alloy

Select "Via Grafana Alloy", then on step 2 choose "Run Grafana Alloy" to generate an API token.
{% endstep %}
{% endstepper %}

Note the token `GCLOUD_RW_API_KEY` and the parameters `GCLOUD_HOSTED_METRICS_URL` and `GCLOUD_HOSTED_METRICS_ID`; we will use them later.

### Configuring the Signer and the Stacks node

Ensure both your Signer configuration and your node configuration include the following lines:

```toml
# signer-config.toml

# ...

# Adjust to 0.0.0.0:30001 if running in Docker.
metrics_endpoint = "127.0.0.1:30001"
```

```toml
# node-config.toml
[node]

# ...

# Adjust to 0.0.0.0:9153 if running in Docker.
prometheus_bind = "127.0.0.1:9153"
```

The pre-compiled binaries already include the monitoring feature. However, if you are compiling the application binaries yourself, remember to enable the Cargo feature `monitoring_prom` while building them, for example:

```bash
cargo build --features monitoring_prom,slog_json --release
```

Once both binaries are running with the updated configuration, you can peek at the metrics being exposed:

```bash
curl 127.0.0.1:30001/metrics

# HELP stacks_signer_current_reward_cycle The current reward cycle

# TYPE stacks_signer_current_reward_cycle gauge
stacks_signer_current_reward_cycle 95

# HELP stacks_signer_node_rpc_call_latencies_histogram Time (seconds) measuring round-trip RPC call latency to the Stacks node

# TYPE stacks_signer_node_rpc_call_latencies_histogram histogram
...
stacks_signer_node_rpc_call_latencies_histogram_bucket{path="/v2/info",le="0.005"} 0
stacks_signer_node_rpc_call_latencies_histogram_bucket{path="/v2/info",le="0.01"} 0
stacks_signer_node_rpc_call_latencies_histogram_bucket{path="/v2/info",le="0.025"} 0
stacks_signer_node_rpc_call_latencies_histogram_bucket{path="/v2/info",le="0.05"} 985
stacks_signer_node_rpc_call_latencies_histogram_bucket{path="/v2/info",le="0.1"} 1194
...
```

Also, you'll have a `/info` endpoint on the same port:

```bash
curl 127.0.0.1:30001/info
```

### Install Alloy

Follow these instructions to install [Grafana Alloy](https://grafana.com/docs/alloy/latest/set-up/install/linux/).

On Debian-based distributions:

```bash
sudo apt install gpg
sudo mkdir -p /etc/apt/keyrings/
wget -q -O - https://apt.grafana.com/gpg.key | gpg --dearmor | sudo tee /etc/apt/keyrings/grafana.gpg > /dev/null
echo "deb [signed-by=/etc/apt/keyrings/grafana.gpg] https://apt.grafana.com stable main" | sudo tee /etc/apt/sources.list.d/grafana.list
sudo apt-get update
sudo apt-get install alloy
```

### Configure Alloy

Edit the file `/etc/alloy/config.alloy` as follows, replacing the placeholders related to the `prometheus` endpoint with the parameters obtained when creating a Grafana Cloud account:

* `GCLOUD_HOSTED_METRICS_URL`
* `GCLOUD_HOSTED_METRICS_ID`
* `GCLOUD_RW_API_KEY`

```conf
// For a full configuration reference, see https://grafana.com/docs/alloy
// For a default configuration, integrating all environmental variables from Grafana Cloud
// see https://storage.googleapis.com/cloud-onboarding/alloy/config/config.alloy

logging {
  level = "warn"
}

prometheus.exporter.unix "default" {
  include_exporter_metrics = true
  disable_collectors       = ["mdadm"]
}

prometheus.scrape "default" {
  targets = array.concat(
    prometheus.exporter.unix.default.targets,
    [
      {
        // Self-collect metrics
        job         = "alloy",
        __address__ = "127.0.0.1:12345",
      },
      {
        // stacks-signer
        job         = "stacks-signer",
        __address__ = "127.0.0.1:30001",
      },
      {
        // stacks-node
        job         = "stacks-node",
        __address__ = "127.0.0.1:9153",
      },
    ],
  )

  forward_to = [prometheus.remote_write.metrics_service.receiver]
}

prometheus.remote_write "metrics_service" {
  external_labels = {"instance" = constants.hostname}
  endpoint {
    # TODO: Edit the URL below with your Grafana production URL.
    # should end with /api/prom/push
    url = "<your GCLOUD_HOSTED_METRICS_URL>"

    # TODO: Edit with your Grafana Cloud ID and Token
    basic_auth {
      username = "<your GCLOUD_HOSTED_METRICS_ID>"
      password = "<your GCLOUD_RW_API_KEY>"
    }
  }
}
```

Enable and start Alloy:

```bash
sudo systemctl daemon-reload
sudo systemctl enable alloy.service
sudo systemctl start alloy.service
```

Metrics from your Signer and node will now start being pushed to Grafana Cloud.

## Visualizing the metrics

You can now start building a dashboard to visualize the metrics.

1. Log in to Grafana Cloud and create a new Dashboard.
2. Pick the Prometheus instance you created before as the data source.
3. Create a new panel and pick `stacks_signer_current_reward_cycle` from the metrics.

You should now be able to see Stacks' current reward cycle, as measured by the Signer, in the dashboard.

Grafana comes with powerful data visualization tools. You can read about how to query and transform data [here](https://grafana.com/docs/grafana-cloud/visualizations/panels-visualizations/query-transform-data/), and find examples on how to build [Prometheus queries](https://prometheus.io/docs/prometheus/latest/querying/basics/).

[This template](https://grafana.com/grafana/dashboards/22137-stacks-signer-template/) will kick-start your dashboard.

![A screenshot of the Grafana dashboard instantiated from the template](https://grafana.com/api/dashboards/22137/images/17368/image)

## Bonus: monitoring the host

Since we are here, we can also monitor the host itself. Debian-based distributions make it very easy for us by using [`node_exporter`](https://github.com/prometheus/node_exporter/tree/master).

```bash
sudo apt install prometheus-node-exporter
sudo systemctl enable prometheus-node-exporter
sudo systemctl start prometheus-node-exporter
```

This will expose metrics on port `9100` of `localhost`.

We can now configure `alloy` to push them to Grafana. Edit your `/etc/alloy/config.alloy` file and add the following scrape target to the `prometheus.scrape "default"` targets list:

```conf
{
  job         = "node_exporter",
  __address__ = "127.0.0.1:9100",
}
```

Now reload `alloy` and check its status:

```bash
sudo systemctl reload alloy
sudo systemctl status alloy
```

`node_exporter` provides a lot of metrics. Explore them through the Grafana Explorer or use one of the many prepared dashboards (e.g., [this one](https://grafana.com/grafana/dashboards/1860-node-exporter-full/)) to see comprehensive information. Once you have a dashboard ready, you can also use it to configure alerts (e.g., on disk space, etc.).


# Best Practices to Run a Signer

{% hint style="info" %}
**Intended audience**: solo Stackers or Stacking pool operators.
{% endhint %}

The following best practices suggest how to create a resilient setup for running your Signer.

{% hint style="info" %}
tl;dr: avoid single point of failures, introduce redundancy, monitor things.
{% endhint %}

### Monitor your Signer and collect logs

* See [here](https://docs.stacks.co/operate/run-a-signer/how-to-monitor-signer) on how to set up monitoring.
* Retain at least 1 week of logs for both the Signer and the Stacks node.

### Downstream components

* Run a dedicated Bitcoin node and Stacks node per Signer.
  * Ensure the nodes are provisioned with the minimum hardware requirements described [here](https://docs.stacks.co/guides-and-tutorials/running-a-signer#minimum-system-requirements).
  * Nodes should be exclusively dedicated to serve the Signer. Avoid re-using them to serve other clients as that may negatively affect performance (no mock-signing, no Stacks API nodes).
* If running dedicated nodes is not possible, then ensure that the Bitcoin / Stacks nodes do not become single points of failure for multiple signers depending on them.
  * Introduce redundancy, load balancing, rely on a robust Bitcoin RPC provider, etc.

### Split voting power across multiple Signers

* Distribute your voting power across multiple, distinct Signer public keys to mitigate the risk of loss or downtime from a single compromised key.
* Each Signer should also limit voting power to a maximum amount and invite Stackers to use a different Signer when the limit is reached.

### Monitor new software releases

* Stay up-to-date with new releases, patches, and security advisories (e.g., GitHub, mailing lists, Discord).
* Apply updates as quickly as possible, especially those addressing a security vulnerability.

### Upgrade procedures

{% stepper %}
{% step %}

#### Test one instance first

Upgrade one Signer instance at a time. Test the update on a single instance and verify functionality before proceeding to others.
{% endstep %}

{% step %}

#### Roll out gradually

If the test is successful, proceed to upgrade the remaining instances one-by-one.
{% endstep %}

{% step %}

#### Minimize downtime

While a Signer is offline for upgrades, it won't sign any blocks. Ensure that the downtime is as short as possible.
{% endstep %}
{% endstepper %}

### Diversified hosting

* Use different provider / configuration where feasible (e.g., a self-hosted instance and one in the cloud, or in two different data center regions, etc.).
* Ensure each host has redundant power supply and network connectivity.

### Fall-back deployments

* Deploy additional Stacks nodes and Bitcoin nodes to be used as fall-back.
  * Use the same configuration as your active instances.
  * For the Stacks node, comment out the `event_observer` section.
* Prepare a backup Signer (same configuration) to be quickly activated, but do not run it.
  * At all times, there should be exactly one Signer instance running for each Signer private key.
* These fall-back instances should be hosted on separate physical hosts (see diversified hosting) from the instances usually active in operations (serving each Signer).

To switch to the fall-back configuration quickly if an active instance fails, follow these steps:

{% stepper %}
{% step %}

#### Run the backup Signer

Start the prepared backup Signer instance.
{% endstep %}

{% step %}

#### Enable event observer

Enable the `event_observer` section of the Stacks node configuration.
{% endstep %}

{% step %}

#### Restart the node

Restart the Stacks node so it runs with the enabled `event_observer`.
{% endstep %}
{% endstepper %}

### Redundancy in operations

* Ensure that multiple, trusted users can manage and maintain signer instances.
* Where feasible, users should span different timezones.

### Backup signer keys in cold-storage

* Keep an offline, secure backup of all Signer private keys (e.g., hardware security modules or encrypted storage devices).


# OpSec Best Practices

#### Threat Modeling

A threat actor that is able to compromise > 70% of Signers (by stake weight) would be able to successfully propose Stacks blocks that would otherwise be considered invalid.

Some potential vectors for signer key compromise are as follows:

* stacks-signer node is compromised and key is exfiltrated from the filesystem
* Signer key is compromised during generation or deployment
* Signer key is accidentally checked into SCM (eg Github or Gitlab)
* Social engineering attack against Signer community: eg a malicious link is posted to social media that harvests key material
* An undisclosed backdoor is discovered in the Signer binary.
* Supply chain attack against stacks-signer source code: threat actor compromises upstream dependencies of stacks-signer

#### Countermeasures

What can Signers do to mitigate the threat vectors identified above? Let's identify countermeasures in response to each of the threats identified above, starting with the first vector: stacks-signer node compromise and key exfiltration.

{% stepper %}
{% step %}

#### Run the stacks-signer on a separate system from the stacks-node

This reduces discoverability of the signer. Systems running the stacks-node participate in the peer-to-peer network and are more easily enumerated. If an attacker can't find your stacks-signer, they can't attack it directly.

Best practice: ensure stacks-node and stacks-signer communicate only over trusted networks, ideally using localhost (127.0.0.1) or a secure private subnet.

Note: Running the stacks-signer on a separate system is an option, but not strictly necessary. Running both on the same virtual machine within a private network, with traffic firewalled to allow only incoming P2P connections (port 20444), provides a secure and easier setup while minimizing exposure.
{% endstep %}

{% step %}

#### Run the stacks-signer as a separate user from the stacks-node

When resource constraints prevent separate workloads, run the stacks-signer under a distinct unprivileged user account from the stacks-node. Ensure exclusive ownership and restrictive permissions for each user's configuration files.

Example: the user running the signer binary (e.g., signer) should own the signer’s config file and set permissions to prevent other users from reading it. The same principle applies to the stacks-node user. This ensures only appropriate processes can access sensitive configuration details.
{% endstep %}

{% step %}

#### Harden the systemd configuration for the stacks-signer

Hardening systemd can reduce blast radius if an attacker gains control of the stacks-signer process. An example stacks-signer.service systemd unit is shown below. This unit prevents certain filesystem writes and otherwise restricts the process.

{% code title="stacks-signer.service" %}

```ini
[Unit]
Description=Stacks Signer
After=network.target
StartLimitBurst=3
StartLimitIntervalSec=300
ConditionFileIsExecutable=/usr/local/bin/stacks-signer
ConditionPathExists=/etc/stacks/signer
ConditionFileNotEmpty=/etc/stacks/signer/signer-config.toml

[Service]
ExecStart=/usr/local/bin/stacks-signer run --config /home/etc/stacks/signer/signer-config.toml
User={{ svc_user }}
Group={{ svc_user }}
Type=simple
Restart=on-failure
TimeoutStopSec=600
KillSignal=SIGTERM
#KillSignal=SIGINT

# Provide a private /tmp and /var/tmp.
PrivateTmp=true

# Mount /usr, /boot/ and /etc read-only for the process.
ProtectSystem=full

# Deny access to /home, /root and /run/user
ProtectHome=true

# Disallow the process and all of its children to gain

# new privileges through execve().
NoNewPrivileges=true

# Use a new /dev namespace only populated with API pseudo devices

# such as /dev/null, /dev/zero and /dev/random.
PrivateDevices=true

[Install]
WantedBy=multi-user.target
```

{% endcode %}

Read more about systemd hardening: <https://www.ctrl.blog/entry/systemd-service-hardening.html>
{% endstep %}

{% step %}

#### Restrict access to unnecessary ports and protocols

The stacks-signer requires outbound TCP access to the stacks-node, but typically no other inbound network exposure is needed (except for OS updates and administrative access). Restrict network access to the minimum required for operation.
{% endstep %}

{% step %}

#### Harden the operating system

A few practical OS hardening measures:

* Run stacks-signer as an unprivileged user (not root).
* Set permissions on the stacks-signer key/config to be readable only by the user running the stacks-signer process, e.g.:
  * sudo chmod 600 signer/signer-config.toml
* Require public-key authentication for SSH and disable SSH root login.
* Consider running sshd on a non-standard port to reduce noise from port scanners and credential-stuffing attacks.
  {% endstep %}
  {% endstepper %}

This post outlines essential operational security best practices for Stacks Signers, key actors in the Nakamoto architecture.

By implementing these strategies, signer operators can effectively mitigate risks and maintain the security and reliability of the Stacks network.


# Run a sBTC Signer

{% hint style="info" %}
This documentation provides guidelines, best-practices and recommendations for running an sBTC Signer. Review it and adapt it to your infrastructure policy before deploying it.
{% endhint %}

{% hint style="warning" %}
Each sBTC signer will control a set of signing shares used to sign transactions on both Bitcoin and Stacks.

Such shares will be encrypted by using the `private_key` specified in the Signer's config and stored in the PostgreSQL database attached to each signer.

It is of the utmost importance to follow the recommendations below.
{% endhint %}

{% stepper %}
{% step %}

#### Prevent unauthorized access to signer infrastructure

Prevent unauthorized access to the sBTC Signer infrastructure (the signer itself, its private key, and the associated PostgreSQL database).
{% endstep %}

{% step %}

#### Keep an offline, secure backup of the Signer private key

Keep an offline, secure backup of the sBTC Signer private key.
{% endstep %}

{% step %}

#### Regularly backup PostgreSQL database

Regularly backup the PostgreSQL database and store it in a secure location.
{% endstep %}
{% endstepper %}

See [here](https://docs.stacks.co/operate/run-a-sbtc-signer/best-practices-for-running-an-sbtc-signer) for additional best practices to run an sBTC signer.

## Minimum System Requirements

Below are the **minimum required specs** to be able to run a sBTC signer.

* 2 CPU
* 4GB memory
* 50GB storage

Note that these are in *addition* to the hardware requirements for running a Stacks node and Bitcoin node outlined in the [How to Run a Signer doc](https://docs.stacks.co/operate/run-a-signer).

## Connection diagram

<figure><img src="https://github.com/stacks-network/docs/blob/master/docs/operate/.gitbook/assets/image%20(8).png" alt=""><figcaption></figcaption></figure>

## Configure your Bitcoin node

### Minimum version

You will need `bitcoind` version 25 or higher.

### Settings

Your Bitcoin node must include these settings for sBTC signer operation:

* `txindex=1`: Transaction indexing must be enabled
* `server=1`: RPC server must be enabled

### RPC-Based Block Detection

Starting with sBTC v1.1.0, the signer uses RPC polling instead of ZeroMQ for block detection.

The signer connects to Bitcoin Core via RPC and polls for new bitcoin blocks. This process works as follows:

{% stepper %}
{% step %}

#### Bitcoin Core validates a new block

Bitcoin Core validates a new block.
{% endstep %}

{% step %}

#### Signer detects the block via RPC polling

Signer detects the block via RPC polling.
{% endstep %}

{% step %}

#### Signer processes relevant sBTC transactions

Signer processes relevant sBTC transactions.
{% endstep %}
{% endstepper %}

### Example

```bash
bitcoind \
  -server \
  -datadir=${BITCOIN_DATA} \
  -rpcbind=0.0.0.0 \
  -rpcuser=${BITCOIN_RPC_USERNAME} \
  -rpcpassword=${BITCOIN_RPC_PASSWORD} \
  -rpcport=${BITCOIN_RPC_PORT} \
  -rpcallowip=0.0.0.0/0 \
  -rpcallowip=::/0 \
  -txindex
```

## Configure your Stacks node

### Minimum version

Please ensure your Stacks version is up-to-date (using the latest release).

### Event observer

You will need to add a *new* event observer that relays information from the sBTC smart contracts to the sBTC signer:

```toml
[[events_observer]]
endpoint = "sbtc-signer:8801"
events_keys = [
    "SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-registry::print",
]
```

### Reference configuration

See [here](https://github.com/stacks-network/sbtc/blob/main/docker/mainnet/nodes/stacks/Config.toml.in).

## Configure your sBTC Signer

The signer configuration file (`signer-config.toml`) defines the signer's operation parameters. The configuration sections include:

### Blocklist Client Settings

```toml
[blocklist_client]
endpoint = "http://blocklist-client:3032"
```

### Bitcoin Connection Settings

Defines how the signer connects to Bitcoin Core:

```toml
[bitcoin]
rpc_endpoints = ["http://user:pass@your-bitcoin-node:8332"]

# Note: block_hash_stream_endpoints are no longer used as of v1.1.0

# The signer now uses RPC polling for block detection
```

### Core Signer Parameters

Defines the signer's identity and network participation:

```toml
[signer]
private_key = "your-private-key"  # 32 or 33-byte hex format
network = "mainnet"
deployer = "SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4"
```

### P2P Network Configuration

Controls how the signer communicates with other network participants:

```toml
[signer.p2p]
listen_on = ["tcp://0.0.0.0:4122"]
```

The signer operates on port 4122 by default and supports both TCP and QUIC protocols for peer communication. The signer will attempt QUIC connections first for improved performance, automatically falling back to TCP if QUIC is unavailable or blocked on the network.

### Reference configuration

See [here](https://github.com/stacks-network/sbtc/blob/main/docker/mainnet/sbtc-signer/signer-config.toml.in).

## Set up your containers

See [here](https://github.com/stacks-network/sbtc/blob/main/docker/mainnet/docker-compose.yml) for a Docker Compose including all the required components.

{% hint style="warning" %}
When deploying with Docker, always use [immutable image tags](https://docs.docker.com/reference/cli/docker/image/pull/#pull-an-image-by-digest-immutable-identifier) - the image digests are provided below. Verify the attestation of these images using this [guide](https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-to-establish-provenance-for-builds#verifying-artifact-attestations-with-the-github-cli).

We publish our images on [GitHub Container Registry](https://github.com/stacks-sbtc/sbtc/pkgs/container/sbtc).
{% endhint %}

## Monitoring

Monitoring Details TBD

## Troubleshooting

Troubleshooting Guide TBD


# Best Practices for Running a sBTC Signer

The following best practices suggest how to create a resilient setup for running your sBTC Signer.

## Protect your private key and have a cold-storage backup

* Prevent unauthorised access to the sBTC Signer private key.
* Keep an offline, secure backup of your sBTC Signer private key (e.g., hardware security modules or encrypted storage devices).

## Backup your sBTC Signer PostgreSQL DB

* Perform daily backups of the sBTC Signer PostgreSQL DB.
* Periodically verify the integrity of backups (see steps below).

### Verifying integrity of PostgreSQL DB backups

{% stepper %}
{% step %}

#### Import the backup

Import the backup into a fresh PostgreSQL instance. The database alone is sufficient — you do not need to spin up a Stacks or Bitcoin node or the sBTC signer.
{% endstep %}

{% step %}

#### Run the verification query

Execute the following query:

{% code title="PostgreSQL" %}

```
```

{% endcode %}

```sql
SELECT aggregate_key FROM sbtc_signer.dkg_shares
WHERE dkg_shares_status = 'verified'
ORDER BY created_at DESC;
```

This returns rows like:

```sql
                            aggregate_key
----------------------------------------------------------------------
 \x03d8c4344861fc7590fd812c24884a3bfd9374d8ba865a787ff53c9060020aa967
 \x03f898f8a6ddb86dd4608dd168355ec6135fe2839222240c01942e8e7e50dd4c89
(2 rows)
```

The most recent `aggregate_key` is the first row.
{% endstep %}

{% step %}

#### Compare with the on-chain aggregate key

Fetch the current aggregate pubkey from the sbtc-registry contract and compare it to the most recent `aggregate_key` from the DB query:

```bash
curl -s 'https://api.hiro.so/v2/contracts/call-read/SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4/sbtc-registry/get-current-aggregate-pubkey' \
           -H 'content-type: application/json' --data-raw '{"sender":"SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4","arguments":[]}' | jq .result
```

Example output:

```
"0x020000002103d8c4344861fc7590fd812c24884a3bfd9374d8ba865a787ff53c9060020aa967"
```

Discard the prefix `0x02000000210` (Clarity encoding). The remaining hex `3d8c4344861fc7590fd812c24884a3bfd9374d8ba865a787ff53c9060020aa967` should match the first row of the PostgreSQL query (excluding `\x0` which indicates hex encoding).
{% endstep %}
{% endstepper %}

## Setup proper access control

* Require hardware 2FA keys for access control (e.g., YubiKey) to connect through SSH, to authenticate to AWS, and for every other relevant action.
* Follow the principle of least privilege: if you don’t need access, you don’t get access; if you get access, it expires after the action is taken.

{% hint style="info" %}
Optional, but strongly recommended: Implement a "4-eyes" process (require that any activity by an individual must be reviewed or approved by a second individual) to access critical resources (e.g., deploying a new version of the sBTC signer).
{% endhint %}

## Maintain a strict firewall configuration

* Allow connections to your sBTC signer `listen_on` address (used for P2P communication).
* Do not expose any non-essential service to the internet: use a DEFAULT DENY policy with explicit ALLOWs for necessary network traffic (such as sBTC signer P2P and SSH).

## Maintain a robust secrets management program

* Ensure all relevant secrets are safely managed and rotated (where possible), e.g., if someone leaves the team.

## Monitor and observe your sBTC Signer

* Retain at least 90 days of logs for the sBTC Signer, the Stacks node, and the Bitcoin node.
* The sBTC signer can optionally expose Prometheus metrics (see `prometheus_exporter_endpoint` configuration option).

{% hint style="info" %}
You can use Prometheus metrics to monitor signer health. For example, see how Alloy can be configured to collect metrics on Grafana Cloud: ../running-a-signer/how-to-monitor-signer.md
{% endhint %}

## Provision dedicated downstream components

* Run a dedicated Bitcoin node and Stacks node for your sBTC Signer.
  * Ensure the nodes are provisioned with the minimum hardware requirements described here: <https://docs.stacks.co/guides-and-tutorials/running-a-signer#minimum-system-requirements>
  * Nodes should be exclusively dedicated to serve the sBTC Signer. Avoid re-using them to serve other clients as that may negatively affect performance (no mock-signing, no Stacks API nodes).

## Monitor new software releases

* Stay up-to-date with new releases, patches, and security advisories for all used operating systems, software and packages.
  * <https://www.cve.org/> is a useful resource for popular software packages.
  * Subscribe to security notifications from your vendors.
  * Join relevant messaging channels as applicable (Discord, Slack, etc.).
* Exercise vulnerability management for all packages.
* Apply updates promptly, especially those addressing security vulnerabilities.
* Use inventory and patch management software, if available.

## Ensure redundancy in operations

* Ensure that multiple, trusted system administrators can manage and maintain your sBTC Signer instance.
* Where feasible, system administrators should span different time zones.
* Document your operations procedures and ensure that relevant personnel have access to them.


# Snapshot the Chainstate

{% hint style="info" %}
**Intended audience**: Solo Stackers, Stacking pool operators, and node operators who need to create reliable chainstate backups.
{% endhint %}

Regular snapshots of your Stacks chainstate help you recover quickly when things go wrong. This guide shows you how to create and manage chainstate snapshots properly.

{% hint style="warning" %}
**Critical**: Always shut down your Stacks node properly before creating a snapshot. Creating snapshots while the node is running will result in corrupted chainstate data.
{% endhint %}

### Shutdown Procedure

To produce a valid chainstate backup, the node should be stopped gracefully before making a copy. The following steps will correctly shutdown the Stacks node:

{% stepper %}
{% step %}

#### Check node status before shutdown

```bash
# Verify if the node is responsive
curl http://localhost:20443/v2/info
```

{% endstep %}

{% step %}

#### Initiate graceful shutdown

* For Docker: `docker stop stacks-node` (allows at least 10 seconds for graceful shutdown)
* For systemd: `systemctl stop stacks-node`
* For manual processes:

```bash
kill $(ps aux | grep stacks-node | grep -v grep | awk '{print $2}')
```

{% endstep %}

{% step %}

#### Verify complete shutdown

```bash
# Ensure no stacks-node processes are running
ps aux | grep stacks-node
```

{% endstep %}
{% endstepper %}

### Overview of Snapshot Methods

There are two primary approaches for creating Stacks chainstate snapshots:

1. **File-based snapshots** - compress up the chainstate folder
2. **Volume snapshots** - snapshot the entire disk/volume

Each method has its advantages depending on your infrastructure setup and recovery requirements.

### File-Based Snapshots

This method involves compressing the chainstate directory and storing it locally, or uploading to a cloud storage service.

#### Steps (see [Example Automation Code section](#example-automation-code) below)

1. **Stop the Stacks node gracefully**
2. **Create compressed archive**
3. **Upload to cloud storage or save it locally**
4. **Restart the Stacks node**

### Volume-Based Snapshots

This method creates block-level snapshots of the entire storage volume containing the chainstate. Different filesystems have different tools:

* **ZFS**: Use `zfs snapshot` - [OpenZFS documentation](https://openzfs.github.io/openzfs-docs/man/v2.3/8/zfs-snapshot.8.html)
* **XFS**: Use `xfsdump` - [XFS documentation](https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/7/html/storage_administration_guide/xfsbackuprestore)
* **ext4**: Use LVM snapshots - [LVM guide](https://kerneltalks.com/disk-management/how-to-guide-lvm-snapshot/)

You can also use cloud provider snapshot tools (AWS EBS, Azure Disk, GCP Persistent Disk).

#### Steps

1. **Stop the Stacks node gracefully**
2. **Create volume snapshot** using ZFS or cloud provider tools
3. **Restart the Stacks node**

### How to Restore

After restoring the chainstate, you can check for corruption by waiting for a few blocks to download and ensuring the node syncs correctly.

#### From File Snapshots

1. Stop the Stacks node
2. Download and extract the snapshot
3. Replace the chainstate directory
4. Restart the node

#### From Volume Snapshots

1. Stop the Stacks node
2. Create a new volume from the snapshot
3. Attach the volume to your instance
4. Update mount points if necessary
5. Restart the node

### Example Automation Code

Here's a simple script that handles both file and volume snapshots on AWS.

{% code title="snapshot.sh" %}

```
#!/bin/bash
set -euo pipefail

# Configuration variables - modify these for your setup
SERVICE_NAME="stacks-node"                   # systemd service name
SNAPSHOT_DIR="/var/stacks/mainnet"           # path to chainstate directory
SNAPSHOT_BASE="/tmp"                         # temporary directory for archives
EBS_VOLUME_ID="vol-1234567890abcdef0"        # EBS volume ID containing chainstate
S3_BUCKET="s3://my-stacks-snapshots"         # S3 bucket for archive storage
SNAPSHOT_TYPE="archive"                      # Options: ebs, archive, or both

# Stop the Stacks node service gracefully
stop_service() {
  echo "Stopping $SERVICE_NAME..."
  sudo systemctl stop "$SERVICE_NAME"
}

# Start the Stacks node service
start_service() {
  echo "Starting $SERVICE_NAME..."
  sudo systemctl start "$SERVICE_NAME"
}

# Create compressed archive and upload to S3
snapshot_archive() {
  echo "Creating archive snapshot..."
  
  # Generate timestamp and version info for filename
  TIMESTAMP=$(date +"%Y%m%d")
  DIR_NAME=$(basename "$SNAPSHOT_DIR")
  VERSION=$(stacks-node version 2>&1 | tail -n 1 | awk '{print $2}')
  DEST="$SNAPSHOT_BASE/$DIR_NAME-$VERSION-$TIMESTAMP.tar.zst"
  
  # Create compressed archive (using zstd for better compression)
  tar -cf - -C "$(dirname $SNAPSHOT_DIR)" "$(basename $SNAPSHOT_DIR)" | pzstd -o "$DEST"
  echo "Archive created at: $DEST"

  # Upload to S3
  echo "Uploading to S3..."
  aws s3 cp "$DEST" "$S3_BUCKET/"
  echo "S3 upload complete: $S3_BUCKET/$(basename "$DEST")"
  
  # Clean up local archive
  rm "$DEST"
}

# Create EBS volume snapshot
snapshot_ebs() {
  echo "Creating EBS snapshot of $EBS_VOLUME_ID..."
  
  # Generate description with timestamp
  TIMESTAMP=$(date +"%Y%m%d")
  DESC="Stacks Node Snapshot - $TIMESTAMP"
  
  # Create snapshot with tags
  SNAPSHOT_ID=$(aws ec2 create-snapshot \
                  --volume-id "$EBS_VOLUME_ID" \
                  --description "$DESC" \
                  --tag-specifications "ResourceType=snapshot,Tags=[{Key=Name,Value=Stacks Snapshot},{Key=type,Value=chainstate}]" \
                  --query 'SnapshotId' --output text)

  echo "EBS Snapshot ID: $SNAPSHOT_ID"
}

# Main execution function
main() {
  case "$SNAPSHOT_TYPE" in
    ebs)
      stop_service
      snapshot_ebs
      start_service
      ;;
    archive)
      stop_service
      snapshot_archive
      start_service
      ;;
    both)
      stop_service
      snapshot_archive  # Create archive first
      snapshot_ebs      # Then EBS snapshot
      start_service
      ;;
    *)
      echo "Invalid snapshot type: $SNAPSHOT_TYPE. Available options: ebs, archive, or both."
      exit 1
      ;;
  esac
  
  echo "Snapshot process completed successfully!"
}

# Execute main function
main
```

{% endcode %}

#### How to Use <a href="#how-to-use" id="how-to-use"></a>

1. **Edit the variables** at the top of the script for your setup
2. **Make it executable**: `chmod +x snapshot.sh`
3. **Run it**: `./snapshot.sh`
4. **Schedule it with cron** for daily backups:

   ```
   # Daily snapshot at 2 AM
   0 2 * * * /path/to/snapshot.sh
   ```

#### What You Need

* AWS CLI set up with the right permissions
* `pzstd` installed (comes with the zstd package)


# Stacking STX

Stacking is an essential component of Stacks.

There are three different ways you can potentially stack your STX tokens and we have a dedicated guide for each of these scenarios.

If you aren't familiar with how stacking works, especially as it relates to signing after the Nakamoto upgrade, be sure to check out the following concept guides:

* [Stackers and signing](https://app.gitbook.com/s/H74xqoobupBWwBsVMJhK/block-production/signing)
* [Stacking](https://app.gitbook.com/s/H74xqoobupBWwBsVMJhK/block-production/stacking)

In Nakamoto, stacking flows have significant changes in comparison to previous versions of Stacks. Because Nakamoto requires stackers to run a signer, which validates blocks produced by Stacks miners, stackers need to provide new information when making Stacking transactions.

These changes affect both solo Stacking and delegated Stacking. This document outlines the new flows for solo stacking. The next doc outlines the flow and steps for operating a pool.

The following sections will walk you through how to begin operating as a solo stacker.

Stacking utilizes the `pox-4` contract. There is a detailed [walkthrough of the stacking contract](https://app.gitbook.com/s/GVj1Z9vMuEOMe7oH7Wnq/clarity/example-contracts/stacking) that you can look at to see what functions are being called at each phase and some common errors you may encounter. This will be especially useful for pool operators who need to call these functions.

This doc is also useful if you run into errors when calling stacking functions, as it both walks through several common error scenarios and walks through each function call so you can more easily trace what might be happening.

Before we get into the step-by-step of how to actually stack, it's important to make sure you have an understanding of the different roles, processes and functions involved in Stacking.

### Definitions and Roles

* **Stacker**: an entity locking their STX to receive PoX rewards. This is a broad term including solo Stackers and Stackers who use pools.
* **Solo stacker**: an entity that locks their own STX and runs a signer. They don’t receive delegation.
* **Delegator**: a stacker who locks their STX by delegating to a pool operator that runs a signer. They don’t run the signer.
* **Pool operator**: an entity that runs a Signer and allows others to delegate their STX to them. A pool operator doesn’t need to Stack their own STX, but they can. They will also run a signer, but the pool operator and signer address may be different
* **Signer**: an entity that runs the stacks-signer software and participates in block validation. This can be either a solo Stacker or an entity receiving delegated STX. Depending on context, this may also refer to the signer software that validates blocks.

{% hint style="info" %}
It's important to understand that in the context of the pool operator and signer, these are likely the same *entity* but may not be the same Stacks address.

This distinction will be discussed further as we cover the step-by-step process below.
{% endhint %}

Below are the primary ways you can stack:

{% stepper %}
{% step %}

#### Solo stacking

If you meet the minimum and want to [solo stack](https://docs.stacks.co/operate/stacking-stx/solo-stack), you will either need to run a signer, collaborate with an existing one, or use [stacking.tools](https://stacking.tools/). This guide will walk you through all options.
{% endstep %}

{% step %}

#### Operate a pool

You can also [operate a pool](https://docs.stacks.co/operate/stacking-stx/operate-a-stacking-pool) and have others delegate their STX to you. If you are a pool operator, you will need to run a signer, collaborate with an existing one, or use [stacking.tools](https://stacking.tools/).
{% endstep %}

{% step %}

#### Stack with a pool

If you do not meet the minimum amount of STX to solo stack, you can [delegate your STX to a pool operator ](https://docs.stacks.co/operate/stacking-stx/stack-with-a-pool)and have them stack on your behalf. The minimum stacking amount is dynamic and can be found by visiting the <https://api.hiro.so/v2/pox> endpoint and looking at the `min_threshold_ustx` field. Note it is denoted in uSTX (1 STX = 1,000,000 uSTX). This is the most common stacking scenario.
{% endstep %}
{% endstepper %}

As you read through these, it may be helpful to follow along with the functions in the [pox-4 contract](https://explorer.hiro.so/txid/SP000000000000000000002Q6VF78.pox-4?chain=mainnet) to get an idea of what each function is doing.

### Relationship between manual stacking transactions and the running signer

This section describes the various transactions that signer entities need to make in order to be registered as a signer for a certain reward cycle. The order of operations between the automated signer and the stacking transactions that need to be done “manually” is important for ensuring that a signer is fully set up for a certain reward cycle.

#### Prerequisite: ensure the signer is hosted and running

It's important to emphasize the importance of getting the signer running in a hosted environment before making Stacking transactions. If the signer doesn’t do that, they run the risk of being registered as a signer without their signer software being ready to run DKG and other important consensus mechanisms.

Some of the important things to double check to ensure the signer is “running” are:

* The signer software is configured with a private key that the user can access (either through SSH or other means). This is important because their signer needs to utilize this private key to generate signer key signatures that are used in Stacking transactions.
* The signer software is properly configured to make RPC calls to a Stacks node. This refers to the `endpoint` signer configuration field. If properly configured, there should be logs in the Stacks node that show the RPC calls being made from the signer.
* The stacks node is properly configured to send events to the signer. This refers to the \[`event_observers`] field in the Stacks Node’s configuration. If properly configured, the signer should have logs indicating that it’s receiving events from the Stacks node.

### How a signer becomes registered in the signer set

Each of the stacking transactions described above are done “manually”. More specifically, this means that none of these transactions are executed automatically by the signer software. The transactions must be done “out of band”.

In order for a signer to actually be registered in a reward cycle, there need to be manual transactions made in the `pox-4` contract. While the signer software is running, it is continually polling the Stacks node and asking “am I a signer in reward cycle N?”.

If these manual transactions are confirmed, and the signer has enough STX associated with the signer’s public key, the signer will be registered as a signer in the signer set.

#### Solo stacking

The workflow for solo stackers is simpler, because there are less stacking transactions that need to be made.

For solo stacking, the only transaction that needs to be made is `stack-stx`. Included in this transaction’s payload is the signer’s public key.

In order for the signer to be registered in reward cycle N+1, the `stack-stx` transaction must be confirmed during the first 2000 blocks of reward cycle N. The last 100 blocks of cycle N (the “prepare phase”) is where DKG occurs.

The start of the prepare phase is when Stacks nodes determine the official signer set of the next reward cycle.

#### Delegated Stacking

The workflow for delegated signers is more complex, because it requires more transactions.

This workflow is explained more in detail in the [operate a pool](https://docs.stacks.co/operate/stacking-stx/operate-a-stacking-pool) guide, but the high-level workflow is:

{% stepper %}
{% step %}

#### Stackers delegate their STX to a pool operator

Stackers delegate their STX to a pool operator.
{% endstep %}

{% step %}

#### The pool operator approves specific stackers

The pool operator makes `delegate-stack-stx` transactions to “approve” specific stackers. This needs to be called for every individual stacker that delegates to them.
{% endstep %}

{% step %}

#### The pool operator commits delegated STX

The pool operator makes a `stack-aggregation-commit` transaction to “commit” all of its delegated STX up to this point.
{% endstep %}
{% endstepper %}

Similar to solo stacking, these steps must be made before the prepare phase of an upcoming reward cycle.

### Once a signer is registered in the signer set

During the prepare phase before a reward cycle, Stacks nodes automatically determine the signer set for the upcoming cycle. When this occurs, the Stacks nodes make an “internal” transaction to update the `.signers` contract with the list of signers.

The signer software is continuously polling the Stacks node to see if it is registered for a cycle. If the signer software finds that it is registered (by matching its public key to the signers stored in the `signers` contract) it begins performing its duties as a signer.

During the prepare phase, the signers perform DKG through StackerDB messages. Once an aggregate public key is determined, the signer automatically makes a `vote-for-aggregate-key` transaction. No out-of-band action is needed to be taken for this to occur.


# Solo Stack

This doc assumes you are familiar with stacking at a conceptual level. If not, you may want to read the [Stacking](https://app.gitbook.com/s/H74xqoobupBWwBsVMJhK/block-production/stacking) concept guide.

The guide below applies to those who want to solo stack, meaning they meet the minimum stacking requirement and need to either run a signer or collaborate with a signer.

{% hint style="info" %}
There is a dapp created by Degen Lab for [solo stacking](https://solo.stacking.tools/) without needing a signer, as Degen Lab operates a signer. This is likely the easiest option for solo stacking. We'll cover this option below.
{% endhint %}

If you prefer to participate in a pool by delegating your STX, you do not need to operate a signer either. If you fall into this category, check out the [Stack with a Pool](https://docs.stacks.co/operate/stacking-stx/stack-with-a-pool) guide.

### Solo Stacker Flow

{% hint style="info" %}
Note that in order to solo stack, you need to have the minimum number of STX tokens. This number can be found by visiting the pox endpoint of Hiro's API at <https://api.mainnet.hiro.so/v2/pox> and looking at the `min_threshold_ustx` field. (1 STX = 1,000,000 uSTX)
{% endhint %}

#### Call the function `stack-stx`

<details>

<summary>Function source code</summary>

```clojure
;; Lock up some uSTX for stacking!  Note that the given amount here is in micro-STX (uSTX).
;; The STX will be locked for the given number of reward cycles (lock-period).
;; This is the self-service interface.  tx-sender will be the Stacker.
;;
;; * The given stacker cannot currently be stacking.
;; * You will need the minimum uSTX threshold.  This will be determined by (get-stacking-minimum)
;; at the time this method is called.
;; * You may need to increase the amount of uSTX locked up later, since the minimum uSTX threshold
;; may increase between reward cycles.
;; * You need to provide a signer key to be used in the signer DKG process.
;; * The Stacker will receive rewards in the reward cycle following `start-burn-ht`.
;; Importantly, `start-burn-ht` may not be further into the future than the next reward cycle,
;; and in most cases should be set to the current burn block height.
;; 
;; To ensure that the Stacker is authorized to use the provided `signer-key`, the stacker
;; must provide either a signature have an authorization already saved. Refer to
;; `verify-signer-key-sig` for more information.
;;
;; The tokens will unlock and be returned to the Stacker (tx-sender) automatically.
(define-public (stack-stx (amount-ustx uint)
                          (pox-addr (tuple (version (buff 1)) (hashbytes (buff 32))))
                          (start-burn-ht uint)
                          (lock-period uint)
                          (signer-sig (optional (buff 65)))
                          (signer-key (buff 33))
                          (max-amount uint)
                          (auth-id uint))
    ;; this stacker's first reward cycle is the _next_ reward cycle
    (let ((first-reward-cycle (+ u1 (current-pox-reward-cycle)))
          (specified-reward-cycle (+ u1 (burn-height-to-reward-cycle start-burn-ht))))
      ;; the start-burn-ht must result in the next reward cycle, do not allow stackers
      ;;  to "post-date" their `stack-stx` transaction
      (asserts! (is-eq first-reward-cycle specified-reward-cycle)
                (err ERR_INVALID_START_BURN_HEIGHT))

      ;; must be called directly by the tx-sender or by an allowed contract-caller
      (asserts! (check-caller-allowed)
                (err ERR_STACKING_PERMISSION_DENIED))

      ;; tx-sender principal must not be stacking
      (asserts! (is-none (get-stacker-info tx-sender))
        (err ERR_STACKING_ALREADY_STACKED))

      ;; tx-sender must not be delegating
      (asserts! (is-none (get-check-delegation tx-sender))
        (err ERR_STACKING_ALREADY_DELEGATED))

      ;; the Stacker must have sufficient unlocked funds
      (asserts! (>= (stx-get-balance tx-sender) amount-ustx)
        (err ERR_STACKING_INSUFFICIENT_FUNDS))

      ;; Validate ownership of the given signer key
      (try! (consume-signer-key-authorization pox-addr (- first-reward-cycle u1) "stack-stx" lock-period signer-sig signer-key amount-ustx max-amount auth-id))

      ;; ensure that stacking can be performed
      (try! (can-stack-stx pox-addr amount-ustx first-reward-cycle lock-period))

      ;; register the PoX address with the amount stacked
      (let ((reward-set-indexes (try! (add-pox-addr-to-reward-cycles pox-addr first-reward-cycle lock-period amount-ustx tx-sender signer-key))))
          ;; add stacker record
         (map-set stacking-state
           { stacker: tx-sender }
           { pox-addr: pox-addr,
             reward-set-indexes: reward-set-indexes,
             first-reward-cycle: first-reward-cycle,
             lock-period: lock-period,
             delegated-to: none })

          ;; return the lock-up information, so the node can actually carry out the lock.
          (ok { stacker: tx-sender, lock-amount: amount-ustx, signer-key: signer-key, unlock-burn-height: (reward-cycle-to-burn-height (+ first-reward-cycle lock-period)) }))))
```

</details>

The first thing solo stackers will need to do is call the `stack-stx` function.

Just like in previous versions of PoX, Stackers call `stack-stx`, but with the new arguments added in Nakamoto. The arguments are:

* Amount: Denoted in uSTX (1 STX = 1,000,000 uSTX)
* PoX Address: the BTC wallet address where to receive Stacking rewards
* Start burn height: the current BTC block height
* Lock period: the number of cycles to lock for (between 1 and 12)
* Signer key: the public key that your signer is using
* Signer signature: the signature that proves control of this signer key
* Max Amount: This parameter is used to validate the signer signature provided. It represents the maximum number of uSTX that can be stacked in this transaction.
* Auth Id: This parameter is used to validate the signer signature provided. It is a random integer that prevents the re-use of this particular signer signature.

Solo stackers have two choices when it comes to operating as a signer. They can choose to run a signer themselves or work with a signer on their behalf.

#### Option 1: Act as a signer

In the “prepare phase” before the next stacking cycle (last 100 blocks), the exact set of Stackers will be selected based on the amount of STX stacked. Just like in previous versions of PoX, each Stacker will have some number of reward slots based on the amount of STX locked.

It is critical that solo stackers have their signer running during this period. The prepare phase is when distributed key generation (DKG) occurs, which is used when validating blocks by signers.

In general, you don’t need to do anything actively during this period, other than monitoring your signer software to ensure it’s running properly.

#### Option 2: Work with a signer

If you do not want to operate a signer on your own, you can work with another signer. To do this, you will need to collaborate with them to get their signer key and signer signature (details in the following sections), which will have to be passed when calling the stacking functions.

Rather than needing to find a signer to collaborate with, you can use the solo stacking dapp created by Degen Lab in order to use their signer to solo stack. They've created a UI that makes this process really simple.

They also have a tool for you to generate a signer signature if you prefer to call the stacking functions yourself.

#### Extending the stacking period

Just like in the current version of PoX, you can extend your lock period while still Stacking. The function called is `stack-extend`.

<details>

<summary>Function source code</summary>

```clojure
;; Extend an active Stacking lock.
;; *New in Stacks 2.1*
;; This method extends the `tx-sender`'s current lockup for an additional `extend-count`
;;    and associates `pox-addr` with the rewards, The `signer-key` will be the key
;;    used for signing. The `tx-sender` can thus decide to change the key when extending.
;; 
;; Because no additional STX are locked in this function, the `amount` field used
;; to verify the signer key authorization is zero. Refer to `verify-signer-key-sig` for more information.
(define-public (stack-extend (extend-count uint)
                             (pox-addr { version: (buff 1), hashbytes: (buff 32) })
                             (signer-sig (optional (buff 65)))
                             (signer-key (buff 33))
                             (max-amount uint)
                             (auth-id uint))
   (let ((stacker-info (stx-account tx-sender))
         ;; to extend, there must already be an etry in the stacking-state
         (stacker-state (unwrap! (get-stacker-info tx-sender) (err ERR_STACK_EXTEND_NOT_LOCKED)))
         (amount-ustx (get locked stacker-info))
         (unlock-height (get unlock-height stacker-info))
         (cur-cycle (current-pox-reward-cycle))
         ;; first-extend-cycle will be the cycle in which tx-sender *would have* unlocked
         (first-extend-cycle (burn-height-to-reward-cycle unlock-height))
         ;; new first cycle should be max(cur-cycle, stacker-state.first-reward-cycle)
         (cur-first-reward-cycle (get first-reward-cycle stacker-state))
         (first-reward-cycle (if (> cur-cycle cur-first-reward-cycle) cur-cycle cur-first-reward-cycle)))

    ;; must be called with positive extend-count
    (asserts! (>= extend-count u1)
              (err ERR_STACKING_INVALID_LOCK_PERIOD))

    ;; stacker must be directly stacking
      (asserts! (> (len (get reward-set-indexes stacker-state)) u0)
                (err ERR_STACKING_IS_DELEGATED))

    ;; stacker must not be delegating
    (asserts! (is-none (get delegated-to stacker-state))
              (err ERR_STACKING_IS_DELEGATED))

    ;; Verify signature from delegate that allows this sender for this cycle
    (try! (consume-signer-key-authorization pox-addr cur-cycle "stack-extend" extend-count signer-sig signer-key u0 max-amount auth-id))

    ;; TODO: add more assertions to sanity check the `stacker-info` values with
    ;;       the `stacker-state` values

    (let ((last-extend-cycle  (- (+ first-extend-cycle extend-count) u1))
          (lock-period (+ u1 (- last-extend-cycle first-reward-cycle)))
          (new-unlock-ht (reward-cycle-to-burn-height (+ u1 last-extend-cycle))))

      ;; first cycle must be after the current cycle
      (asserts! (> first-extend-cycle cur-cycle) (err ERR_STACKING_INVALID_LOCK_PERIOD))
      ;; lock period must be positive
      (asserts! (> lock-period u0) (err ERR_STACKING_INVALID_LOCK_PERIOD))

      ;; must be called directly by the tx-sender or by an allowed contract-caller
      (asserts! (check-caller-allowed)
                (err ERR_STACKING_PERMISSION_DENIED))

      ;; tx-sender must be locked
      (asserts! (> amount-ustx u0)
        (err ERR_STACK_EXTEND_NOT_LOCKED))

      ;; tx-sender must not be delegating
      (asserts! (is-none (get-check-delegation tx-sender))
        (err ERR_STACKING_ALREADY_DELEGATED))

      ;; standard can-stack-stx checks
      (try! (can-stack-stx pox-addr amount-ustx first-extend-cycle lock-period))

      ;; register the PoX address with the amount stacked
      ;;   for the new cycles
      (let ((extended-reward-set-indexes (try! (add-pox-addr-to-reward-cycles pox-addr first-extend-cycle extend-count amount-ustx tx-sender signer-key)))
            (reward-set-indexes
                ;; use the active stacker state and extend the existing reward-set-indexes
                (let ((cur-cycle-index (- first-reward-cycle (get first-reward-cycle stacker-state)))
                      (old-indexes (get reward-set-indexes stacker-state))
                      ;; build index list by taking the old-indexes starting from cur cycle
                      ;;  and adding the new indexes to it. this way, the index is valid starting from the current cycle
                      (new-list (concat (default-to (list) (slice? old-indexes cur-cycle-index (len old-indexes)))
                                        extended-reward-set-indexes)))
                  (unwrap-panic (as-max-len? new-list u12)))))
          ;; update stacker record
          (map-set stacking-state
            { stacker: tx-sender }
            { pox-addr: pox-addr,
              reward-set-indexes: reward-set-indexes,
              first-reward-cycle: first-reward-cycle,
              lock-period: lock-period,
              delegated-to: none })

        ;; return lock-up information
        (ok { stacker: tx-sender, unlock-burn-height: new-unlock-ht })))))
```

</details>

You can “rotate” your signing key when extending your lock period.

The arguments are:

* Extend count: the number of cycles to add to your lock period. The resulting lock period cannot be larger than 12. For example, if you're currently locked with 6 cycles remaining, the maximum number you can extend is 6.
* Pox Address: the BTC address to receive rewards
* Signer public key: the public key used for signing. This can stay the same, or you can use a new key.
* Signer signature: a signature proving control of your signing key
* Max Amount: This parameter is used to validate the signer signature provided. It represents the maximum number of uSTX (1 stx = 1,000,000 uSTX) that can be stacked in this transaction.
* Auth Id: This parameter is used to validate the signer signature provided. It is a random integer that prevents the re-use of this particular signer signature.

#### Increasing the stacking amount

The stacking amount can also be increased while actively Stacking. The increased position will take effect starting with the next Stacking cycle. The function called is `stack-increase`.

<details>

<summary>Function source code</summary>

```clojure
;; Increase the number of STX locked.
;; *New in Stacks 2.1*
;; This method locks up an additional amount of STX from `tx-sender`'s, indicated
;; by `increase-by`.  The `tx-sender` must already be Stacking & must not be
;; straddling more than one signer-key for the cycles effected. 
;; Refer to `verify-signer-key-sig` for more information on the authorization parameters
;; included here.
(define-public (stack-increase 
  (increase-by uint)
  (signer-sig (optional (buff 65)))
  (signer-key (buff 33))
  (max-amount uint)
  (auth-id uint))
   (let ((stacker-info (stx-account tx-sender))
         (amount-stacked (get locked stacker-info))
         (amount-unlocked (get unlocked stacker-info))
         (unlock-height (get unlock-height stacker-info))
         (cur-cycle (current-pox-reward-cycle))
         (first-increased-cycle (+ cur-cycle u1))
         (stacker-state (unwrap! (map-get? stacking-state
                                          { stacker: tx-sender })
                                          (err ERR_STACK_INCREASE_NOT_LOCKED)))
         (cur-pox-addr (get pox-addr stacker-state))
         (cur-period (get lock-period stacker-state)))
      ;; tx-sender must be currently locked
      (asserts! (> amount-stacked u0)
                (err ERR_STACK_INCREASE_NOT_LOCKED))
      ;; must be called with positive `increase-by`
      (asserts! (>= increase-by u1)
                (err ERR_STACKING_INVALID_AMOUNT))
      ;; stacker must have enough stx to lock
      (asserts! (>= amount-unlocked increase-by)
                (err ERR_STACKING_INSUFFICIENT_FUNDS))
      ;; must be called directly by the tx-sender or by an allowed contract-caller
      (asserts! (check-caller-allowed)
                (err ERR_STACKING_PERMISSION_DENIED))
      ;; stacker must be directly stacking
      (asserts! (> (len (get reward-set-indexes stacker-state)) u0)
                (err ERR_STACKING_IS_DELEGATED))
      ;; stacker must not be delegating
      (asserts! (is-none (get delegated-to stacker-state))
                (err ERR_STACKING_IS_DELEGATED))

      ;; Validate that amount is less than or equal to `max-amount`
      (asserts! (>= max-amount (+ increase-by amount-stacked)) (err ERR_SIGNER_AUTH_AMOUNT_TOO_HIGH))

      ;; Verify signature from delegate that allows this sender for this cycle
      (try! (consume-signer-key-authorization cur-pox-addr cur-cycle "stack-increase" cur-period signer-sig signer-key increase-by max-amount auth-id))

      ;; update reward cycle amounts
      (asserts! (is-some (fold increase-reward-cycle-entry
            (get reward-set-indexes stacker-state)
            (some { first-cycle: first-increased-cycle,
                    reward-cycle: (get first-reward-cycle stacker-state),
                    stacker: tx-sender,
                    add-amount: increase-by,
                    signer-key: signer-key })))
            (err ERR_INVALID_INCREASE))
      ;; NOTE: stacking-state map is unchanged: it does not track amount-stacked in PoX-4
      (ok { stacker: tx-sender, total-locked: (+ amount-stacked increase-by)})))
```

</details>

The arguments are:

* Increase by: the amount of uSTX to add to your lock amount.
* Signer public key: the public key used for signing. This can stay the same, or you can use a new key.
* Signer signature: a signature proving control of your signing key
* Max Amount: This parameter is used to validate the signer signature provided. It represents the maximum number of uSTX (1 stx = 1,000,000 uSTX) that can be stacked in this transaction.
* Auth Id: This parameter is used to validate the signer signature provided. It is a random integer that prevents the re-use of this particular signer signature.

### Step by Step Stacking Guide

Now that you are familiar with the overall stacking flow and the different roles played, let's dive into the step-by-step guide for actually conducting the stacking process.

{% hint style="info" %}
There are several ways you can go about stacking. This guide will cover using Leather Earn, which is a stacking web application and the simplest option.

Additionally, you can choose to call the stacking functions directly from the [deployed contract](https://explorer.hiro.so/txid/SP000000000000000000002Q6VF78.pox-4?chain=mainnet) in the explorer.

The fields and process will be the same, but the UI will differ.

Finally, you can stack using JS and the [@stacks/stacking](https://github.com/stx-labs/stacks.js/tree/main/packages/stacking) package if you prefer. Again, the functions and parameters will be the same, you will just be writing your JS code directly instead of using a UI.

If you are interested in using this method, you'll want to follow the [stacking guide](https://docs.hiro.so/stacks.js/guides/how-to-integrate-stacking) created by Hiro, and be sure to integrate the new parameters described in [Hiro's Nakamoto update doc](https://docs.hiro.so/nakamoto/stacks-js).
{% endhint %}

### Step 1: Run or work with a signer

This is a necessary prerequisite to stacking as a solo stacker or pool operator.

Running a signer involves setting up a hosted production environment that includes both a Stacks Node and the Stacks Signer. For more information, refer to the [running a signer doc](https://docs.stacks.co/operate/run-a-signer).

Once the signer software is running, you'll have to keep track of the `stacks_private_key` that you used when configuring your signer software. This will be used in subsequent Stacking transactions.

{% hint style="info" %}
In the note above about pool operator vs signer keys, this corresponds to your signer key, not your pool operator wallet
{% endhint %}

Alternatively, you can work with a signer and have them perform step 2 below on your behalf.

### Step 2: Generate a signer key signature

#### Overview of signer keys and signatures

The main difference with Stacking in Nakamoto is that the Signer (either solo Stacker or signer running a pool) needs to include new parameters in their Stacking transactions. These are Clarity transactions that Stackers will call when interacting with the `pox-4.clar` contract. Interacting with this contract is how you as a Stacker actually stack your STX tokens.

{% hint style="info" %}
The current pox-4 contract address can be found by visiting the following endpoint of the Hiro API: <https://api.mainnet.hiro.so/v2/pox>.

You can then visit the [Explorer](https://explorer.hiro.so/?chain=mainnet) to view the contract and pass in the contract id.

You may want to review this contract to familiarize yourself with it.
{% endhint %}

Here is an overview of the fields you will need to pass. We'll cover how to get and pass these fields as we dive further into this doc:

{% stepper %}
{% step %}

#### signer-key

The public key that corresponds to the `stacks_private_key` your signer is using.
{% endstep %}

{% step %}

#### signer-signature

A signature that demonstrates that you actually control your `signer-key`. Because signer keys need to be unique, this is also a safety check to ensure that other Stackers can’t use someone else’s public key.
{% endstep %}

{% step %}

#### max-amount

The maximum amount of uSTX (1 STX = 1,000,000 uSTX) that can be locked in the transaction that uses this signature. For example, if calling `stack-increase`, this parameter dictates the maximum amount of uSTX that can be used to add more locked STX.
{% endstep %}

{% step %}

#### auth-id

A random integer that prevents the re-use of a particular signature, similar to how nonces are used with transactions. Must be less than 14 characters.
{% endstep %}
{% endstepper %}

Signer signatures are signatures created using a particular signer key. They demonstrate that the controller of that signer key is allowing a Stacker to use their signing key. The signer signature’s message hash is created using the following data:

* `method`: a string that indicates the Stacking method that is allowed to utilize this signature. The valid options are `stack-increase`, `stack-stx`, `stack-extend`, `agg-commit` (for stack-aggregation-commit-indexed), or `agg-increase` (for stack-aggregation-increase)
* `max-amount`: described above
* `auth-id`: described above
* `period`: a value between 1 and 12, which indicates the number of cycles that the Stacker is allowed to lock their STX for in this particular Stacking transaction. For `agg-commit`, this must be equal to 1
* `reward-cycle`: This represents the reward cycle in which the Stacking transaction can be confirmed. For solo stacking operations (`stack-stx`, `stack-extend` and `stack-increase`), this has to be set as the current cycle.
* `pox-address`: The Bitcoin address that is allowed to be used for receiving rewards. This can be set to any Bitcoin address that you have access to.
* `config`: This represents the signer configuration file path where the `stacks_private_key` is located, and it is used for signing the generated signature.

Now that we have an overview of role and contents of signatures, let's see how to actually generate them. You have several options available.

Generating your signature with Degen Lab's stacks.tools

Degen Lab has a signature generation tool that will generate a signature using their signer. This is the quickest and simplest option. To generate a signature using this method, all you need to do is visit their [signature tool](https://signature.stacking.tools/) and pass in the relevant information as covered on this page.

#### Generating your signature with stacks.js

The [@stacks/stacking](https://www.npmjs.com/package/@stacks/stacking) NPM package provides interfaces to generate and use signer signatures.

There is a function called `signPoxSignature` that will allow you to generate this signature and pass it in to the stacking function.

More information and code samples can be found on [Hiro's Nakamoto docs](https://docs.hiro.so/nakamoto/stacks-js).

#### Generating your signature using the stacks-signer CLI

If you already have your signer configured and set up, you can use the `stacks-signer` CLI to generate this signature. You can either SSH into your running signer or use the `stacks-signer` CLI locally. If using the CLI locally, you will need to ensure you have a matching configuration file located on your filesystem. Having a matching configuration file is important to ensure that the signer public key you make in Stacking transactions is the same as in your hosted signer.

The CLI command is:

```bash
# Max Amount equivallent to 1M STX

# Auth Id should be a random string less than 14 characters
stacks-signer generate-stacking-signature \
  --method stack-stx \
  --max-amount 1000000000000 \
  --auth-id 71948271489 \
  --period 1 \
  --reward-cycle 100 \
  --pox-address bc1... \
  --config ./config.toml \
  --json
```

These arguments match those described in section [Overview of signer keys and signatures](#overview-of-signer-keys-and-signatures), with the addition of:

* `--json`, to optionally output the resulting signature in JSON

You can use the following command to generate a random `32` bit integer as `auth-id`:

```bash
python3 -c 'import secrets; print(secrets.randbits(32))'
```

Once the `generate-stacking-signature` command is run, the CLI will output a JSON:

```json
{"authId":"1234","maxAmount":"12345","method":"stack-stx","period":1,"poxAddress":"bc1...","rewardCycle":100,"signerKey":"aaaaaaaa","signerSignature":"bbbbbbbbbbb"}
```

You will use the JSON when calling Stacking transactions from your Stacker address as outlined above. Remember that this may be different than your signer address.

#### Generating your signature with Leather Earn

Leather Earn is a web application that provides an easy-to-use interface for stacking and generating signatures. We'll cover using Leather Earn for stacking at the end of this document, here we will cover how to use it to generate a signature.

{% hint style="info" %}
At the time of writing, this has only been tested using the [Leather](https://leather.io/) wallet.
{% endhint %}

You can visit [earn.leather.io](https://earn.leather.io/) to generate a signer key signature. Make sure you’re connected to the correct network.\
To generate a signer key signature, it’s important that you’ve logged in Leather with the same secret key that was used to [generate your signer key](https://github.com/stacks-network/docs/blob/master/docs/operate/stacking-stx/broken-reference/README.md), not the account that will serve as your pool operator address. Once you’ve setup that account on Leather, you can log in to Leather Earn.\
Click the link “Signer key signature” at the bottom of the page. This will open the “generate a signer key signature” page.

The fields are:

* Reward cycle:
  * For all solo stacking transactions, this must equal the current reward cycle, not the cycle in which they will start stacking. The field defaults to the current reward cycle.
  * For stack-aggregation-commit-indexed, this field must equal the cycle used in that function’s “reward cycle” argument. Typically, that equates to current\_cycle + 1.
* Bitcoin address: the PoX reward address that can be used
* Topic: the stacking function that will use this signature
* Max amount: max amount of STX that can be used. Defaults to “max possible amount”
* Auth ID: defaults to random int
* Duration: must match the number of cycles used in the stacking transaction. For stack-aggregation-commit-indexed, use “1”.

{% hint style="warning" %}
Each of these fields must be exactly matched in order for the Stacking transaction to work. Future updates to Leather Earn will verify the signature before the transaction is made.
{% endhint %}

Click the “generate signature” button to popup a Leather page where you can generate the signature. Once you submit that popup, Leather Earn will have the signer key and signature you generated.

After you sign that message, you'll see the information you can use in your Stacking transactions, including the signer public key and signature.

You can click the “copy” icon next to “signer details to share with stackers”. This will copy a JSON string, which can be directly pasted into the Leather Earn page where you make your Stacking transaction. Alternatively, this information can be entered manually.

We'll cover the Leather Earn pages for actually making those transactions in the next section of this document.

#### Using a hardware or software wallet to generate signatures

When the signer is configured with a `stacks_private_key`, the signer may want to be able to use that key in a wallet to make stacking signatures.

If the signer uses a tool like [@stacks/cli](https://docs.hiro.so/get-started/command-line-interface) to generate the key, the CLI also outputs a mnemonic (aka “seed phrase”) that can be imported into a wallet. Because the Stacks CLI uses the standard derivation path for generating Stacks keys, any Stacks wallet will default to having that same private key when the wallet is imported from a derivation path. Similarly, if a hardware wallet is setup with that mnemonic, then the Signer can use a wallet like Leather to make stacking signatures.

The workflow for setting up a wallet to generate signatures:

{% stepper %}
{% step %}
Use @stacks/cli to generate the keychain and private key.

* Typically, when using a hardware wallet, it’s better to generate the mnemonic on the hardware wallet. For this use case, however, the signer software needs the private key, and hardware wallets (by design) don’t allow exporting private keys.
  {% endstep %}

{% step %}
Take the `privateKey` from the CLI output and add it to your signer’s configuration.
{% endstep %}

{% step %}
Take the mnemonic (24 words) and either:

* Setup a new hardware wallet with this mnemonic, or
* Store it somewhere securely, like a password manager. When the signer needs to generate signatures for Stacking transactions, they can import it into either Leather or XVerse.
  {% endstep %}
  {% endstepper %}

When the user needs to generate signatures:

{% stepper %}
{% step %}
Set up your wallet with your signer key’s private key. Either:

* Setup your Leather wallet with a Ledger hardware wallet, or
* Import your mnemonic into Leather, XVerse, or another Stacks wallet.
  {% endstep %}

{% step %}
Open an app that has stacking signature functionality built-in.
{% endstep %}

{% step %}
Connect your wallet to the app (aka sign in).
{% endstep %}

{% step %}
In the app, enter your PoX address and “submit”.

* The app will popup a window in your wallet that prompts you to sign the information and will show clear information about what you’re signing.
  {% endstep %}

{% step %}
Create the signature.

* If using a Ledger, confirm on your device.
  {% endstep %}

{% step %}
The app will display two results:

* Your signer key, which is the public key associated with your signer’s key.
* Your signer signature.
  {% endstep %}

{% step %}
Finally, make a Stacking transaction using the signer key and signer signature.
{% endstep %}
{% endstepper %}

Now that you have your signer signature generated, it's time to start stacking. This process will vary depending on your chosen method. We've included instructions for solo stacking using [Leather Earn](https://earn.leather.io/) below.

### Step 3: Stack your STX

#### stack-stx

To start, you'll visit [Leather Earn](https://earn.leather.io/) and click the “Stack independently” button on the home page.

This page will allow you to input the following input:

* The amount of STX you want to lock
* The duration (in number of cycles) to lock for
* Your BTC address where you will receive Stacking rewards
* New fields:
  * Your signer public key
  * Your signer key signature (this is what you generated in the previous step)
  * Auth ID
  * Max amount

#### stack-extend

If you want to extend the time that your STX will be locked for, you can use the stack-extend page on Leather Earn.

If you’re already stacking, the home page will provide a link to “view stacking details”. From there, you can choose to extend.

On this page are the following fields:

* The number of cycles you want to extend for
* Your BTC address to receive rewards
* New fields:
  * Signer public key
  * Signer key signature
  * Auth ID
  * Max amount

#### stack-increase

If you want to increase the amount of STX locked, you can use the stack-increase page on Leather Earn.

If you’re already stacking, the home page will provide a link to “view stacking details”. From there, you can choose to increase.

On this page are the following fields:

* The amount of STX you want to increase by
* New fields:
  * Signer public key
  * Signer key signature
  * Auth ID
  * Max amount


# Operate a Stacking Pool

This doc assumes you are familiar with stacking at a conceptual level. If not, you may want to read the [Stacking](https://app.gitbook.com/s/H74xqoobupBWwBsVMJhK/block-production/stacking) concept guide.

The guide below applies to those who want to operate a pool, meaning they want to have stackers delegate STX tokens to them. If you choose to operate a pool you will either need to run your own signer or collaborate with one.

### Pool Operator Stacking Flow

For pool operators, the flow is a bit different than solo stacking. Remember that as a pool operator, other stackers are delegating their STX to you to stack on behalf of them. This additional role adds a couple of extra steps to your stacking flow if operating as a pool operator.

Similar to the changes to solo Stacking, the big difference for delegation flows is the inclusion of signer keys and signatures. Because pool operators need to make transactions to “finalize” a delegation, these new arguments add new complexities to the stacking flow.

#### Delegator initiates delegation

{% hint style="info" %}
This step is not required to apply to pool operators/signers. It is included here to illustrate the end-to-end flow, but if you are operating as a pool operator/signer you will not have to perform this step. Instead, users delegate their STX to you as the pool operator.
{% endhint %}

The first step, where the delegator sets up their delegation to a pool operator, is to call `delegate-stx`. This function does not directly delegate the STX, but rather allows the pool operator to issue the stacking lock on behalf of the user calling this function. You can think of calling this function as the delegator giving permission to the pool operator to stack on their behalf.

<details>

<summary>Function source code</summary>

```clojure
;; Delegate to `delegate-to` the ability to stack from a given address.
;;  This method _does not_ lock the funds, rather, it allows the delegate
;;  to issue the stacking lock.
;; The caller specifies:
;;   * amount-ustx: the total amount of ustx the delegate may be allowed to lock
;;   * until-burn-ht: an optional burn height at which this delegation expires
;;   * pox-addr: an optional address to which any rewards *must* be sent
(define-public (delegate-stx (amount-ustx uint)
                             (delegate-to principal)
                             (until-burn-ht (optional uint))
                             (pox-addr (optional { version: (buff 1), hashbytes: (buff 32) })))

    (begin
      ;; must be called directly by the tx-sender or by an allowed contract-caller
      (asserts! (check-caller-allowed)
                (err ERR_STACKING_PERMISSION_DENIED))

      ;; delegate-stx no longer requires the delegator to not currently
      ;; be stacking.
      ;; delegate-stack-* functions assert that
      ;; 1. users can't swim in two pools at the same time.
      ;; 2. users can't switch pools without cool down cycle.
      ;;    Other pool admins can't increase or extend.
      ;; 3. users can't join a pool while already directly stacking.

      ;; pox-addr, if given, must be valid
      (match pox-addr
         address
            (asserts! (check-pox-addr-version (get version address))
                (err ERR_STACKING_INVALID_POX_ADDRESS))
         true)

      ;; tx-sender must not be delegating
      (asserts! (is-none (get-check-delegation tx-sender))
        (err ERR_STACKING_ALREADY_DELEGATED))

      ;; add delegation record
      (map-set delegation-state
        { stacker: tx-sender }
        { amount-ustx: amount-ustx,
          delegated-to: delegate-to,
          until-burn-ht: until-burn-ht,
          pox-addr: pox-addr })

      (ok true)))
```

</details>

The arguments here are unchanged from previous versions of PoX:

* Amount: Denoted in uSTX (1 STX = 1,000,000 uSTX)
* Delegate to: the STX address of the pool operator they're delegating to. Note that this is different from the “signer key” used. Instead, this is the STX address that is used to make PoX transactions.
* Until burn height: an optional argument representing the BTC block height when the delegation expires. If none is used, the delegation permission expires only when explicitly revoked.
* Pox Address: an optional BTC address that, if specified, the signer must use to accept this delegation

#### Pool operator “activates” the delegation

Just as in the older PoX contract, after a delegator calls the `delegate-stx` function, the pool operator calls `delegate-stack-stx` to commit the delegator’s STX.

<details>

<summary>Function source code</summary>

```clojure
;; As a delegate, stack the given principal's STX using partial-stacked-by-cycle
;; Once the delegate has stacked > minimum, the delegate should call stack-aggregation-commit
(define-public (delegate-stack-stx (stacker principal)
                                   (amount-ustx uint)
                                   (pox-addr { version: (buff 1), hashbytes: (buff 32) })
                                   (start-burn-ht uint)
                                   (lock-period uint))
    ;; this stacker's first reward cycle is the _next_ reward cycle
    (let ((first-reward-cycle (+ u1 (current-pox-reward-cycle)))
          (specified-reward-cycle (+ u1 (burn-height-to-reward-cycle start-burn-ht)))
          (unlock-burn-height (reward-cycle-to-burn-height (+ (current-pox-reward-cycle) u1 lock-period))))
      ;; the start-burn-ht must result in the next reward cycle, do not allow stackers
      ;;  to "post-date" their `stack-stx` transaction
      (asserts! (is-eq first-reward-cycle specified-reward-cycle)
                (err ERR_INVALID_START_BURN_HEIGHT))

      ;; must be called directly by the tx-sender or by an allowed contract-caller
      (asserts! (check-caller-allowed)
        (err ERR_STACKING_PERMISSION_DENIED))

      ;; stacker must have delegated to the caller
      (let ((delegation-info (unwrap! (get-check-delegation stacker) (err ERR_STACKING_PERMISSION_DENIED))))
        ;; must have delegated to tx-sender
        (asserts! (is-eq (get delegated-to delegation-info) tx-sender)
                  (err ERR_STACKING_PERMISSION_DENIED))
        ;; must have delegated enough stx
        (asserts! (>= (get amount-ustx delegation-info) amount-ustx)
                  (err ERR_DELEGATION_TOO_MUCH_LOCKED))
        ;; if pox-addr is set, must be equal to pox-addr
        (asserts! (match (get pox-addr delegation-info)
                         specified-pox-addr (is-eq pox-addr specified-pox-addr)
                         true)
                  (err ERR_DELEGATION_POX_ADDR_REQUIRED))
        ;; delegation must not expire before lock period
        (asserts! (match (get until-burn-ht delegation-info)
                         until-burn-ht (>= until-burn-ht
                                           unlock-burn-height)
                      true)
                  (err ERR_DELEGATION_EXPIRES_DURING_LOCK))
        )

      ;; stacker principal must not be stacking
      (asserts! (is-none (get-stacker-info stacker))
        (err ERR_STACKING_ALREADY_STACKED))

      ;; the Stacker must have sufficient unlocked funds
      (asserts! (>= (stx-get-balance stacker) amount-ustx)
        (err ERR_STACKING_INSUFFICIENT_FUNDS))

      ;; ensure that stacking can be performed
      (try! (minimal-can-stack-stx pox-addr amount-ustx first-reward-cycle lock-period))

      ;; register the PoX address with the amount stacked via partial stacking
      ;;   before it can be included in the reward set, this must be committed!
      (add-pox-partial-stacked pox-addr first-reward-cycle lock-period amount-ustx)

      ;; add stacker record
      (map-set stacking-state
        { stacker: stacker }
        { pox-addr: pox-addr,
          first-reward-cycle: first-reward-cycle,
          reward-set-indexes: (list),
          lock-period: lock-period,
          delegated-to: (some tx-sender) })

      ;; return the lock-up information, so the node can actually carry out the lock.
      (ok { stacker: stacker,
            lock-amount: amount-ustx,
            unlock-burn-height: unlock-burn-height })))
```

</details>

The arguments are:

* Stacker: the STX address of the delegator
* Amount: denoted in uSTX (1 STX = 1,000,000 uSTX)
* Pox Address: The BTC address of the pool operator where they will receive the BTC rewards. If the delegator has set his own BTC address in the `delegate-stx` call, this address will have to be the same one, otherwise the contract call will fail.
* Start burn height: The BTC block height in which delegation can begin. This field is used to ensure that an old transaction intended for an earlier cycle will fail, and also prevents callers from "post-dating" the call to a future cycle. The best option here is to add 1 or 2 to the current BTC block height when you initiate this transaction. Note that the delegation will not actively be stacked at this block height, but whatever reward cycle is passed in the aggregation commit function (explained below).
* Lock period: number of cycles to lock for. If the delegator provided the until burn height argument, then the end of these cycles cannot be past the expiration provided. The maximum lock period that a pool operator can provide in this function call is 12.

This step also allows the pool operator to proactively choose which Stackers they’ll accept delegation from. For “closed” pools, the pool operator will only call this function for approved Stackers. It is up to each pool operator who runs a closed pool to implement this process.

This step can be repeated for multiple Stackers before going to the next step.

{% hint style="info" %}
If you look at the function source code, you'll see that the `delegate-stack-stx` function sets the stacker's first reward cycle to be the *next* reward cycle.

When generating your signature and your `stack-aggregation-commit-indexed` transaction, you'll want to make sure that the reward cycles match.

So if you are in cycle 557 when you call the `delegate-stack-stx` function, you'll want to pass in cycle 558 or higher when you generate your signature and your `stack-aggregation-commit-indexed` transaction.

With `stack-aggregation-commit-indexed`, the `reward-cycle` arg is saying "I'm committing these stacks to be stacked in cycle N". But the `delegate-stack-stx` transaction gets you setup for next cycles, aka 558 and higher.

Also make sure that, when you generate your signature, you use 558 or higher as the reward cycle. In solo stacking methods, you use the current reward cycle in the signature, but not for `stack-aggregation-commit-indexed`. This is because with `stack-aggregation-commit-indexed` you can commit stacks for future cycles, not just the N+1 cycle.
{% endhint %}

#### Pool operator “commits” delegated STX

The next step is for the pool operator to call `stack-aggregation-commit-indexed`.

{% hint style="info" %}
In the contract source code, you'll notice a similarly named function called `stack-aggregation-commit`. This is a legacy function that makes it difficult to increase the stacking amount, as it does not return the reward index of the stacking slot, which is required in order to call the `stack-aggregation-increase` function. We recommend using `stack-aggregation-commit-indexed`.
{% endhint %}

<details>

<summary>Function source code</summary>

Note that the `stack-aggregation-commit-indexed` function wraps the `inner-stack-aggregation-commit` function. The wrapped inner function is included here.

Check out the [deployed contract](https://explorer.hiro.so/txid/SP000000000000000000002Q6VF78.pox-4?chain=mainnet) to see the flow of contract calls.

```clojure
;; Commit partially stacked STX and allocate a new PoX reward address slot.
;;   This allows a stacker/delegate to lock fewer STX than the minimal threshold in multiple transactions,
;;   so long as: 1. The pox-addr is the same.
;;               2. This "commit" transaction is called _before_ the PoX anchor block.
;;   This ensures that each entry in the reward set returned to the stacks-node is greater than the threshold,
;;   but does not require it be all locked up within a single transaction
;;
;; Returns (ok uint) on success, where the given uint is the reward address's index in the list of reward
;; addresses allocated in this reward cycle.  This index can then be passed to `stack-aggregation-increase`
;; to later increment the STX this PoX address represents, in amounts less than the stacking minimum.
;;
;; *New in Stacks 2.1.*
(define-private (inner-stack-aggregation-commit (pox-addr { version: (buff 1), hashbytes: (buff 32) })
                                                (reward-cycle uint)
                                                (signer-sig (optional (buff 65)))
                                                (signer-key (buff 33))
                                                (max-amount uint)
                                                (auth-id uint))
  (let ((partial-stacked
         ;; fetch the partial commitments
         (unwrap! (map-get? partial-stacked-by-cycle { pox-addr: pox-addr, sender: tx-sender, reward-cycle: reward-cycle })
                  (err ERR_STACKING_NO_SUCH_PRINCIPAL))))
    ;; must be called directly by the tx-sender or by an allowed contract-caller
    (asserts! (check-caller-allowed)
              (err ERR_STACKING_PERMISSION_DENIED))
    (let ((amount-ustx (get stacked-amount partial-stacked)))
      (try! (consume-signer-key-authorization pox-addr reward-cycle "agg-commit" u1 signer-sig signer-key amount-ustx max-amount auth-id))
      (try! (can-stack-stx pox-addr amount-ustx reward-cycle u1))
      ;; Add the pox addr to the reward cycle, and extract the index of the PoX address
      ;; so the delegator can later use it to call stack-aggregation-increase.
      (let ((add-pox-addr-info
                (add-pox-addr-to-ith-reward-cycle
                   u0
                   { pox-addr: pox-addr,
                     first-reward-cycle: reward-cycle,
                     num-cycles: u1,
                     reward-set-indexes: (list),
                     stacker: none,
                     signer: signer-key,
                     amount-ustx: amount-ustx,
                     i: u0 }))
           (pox-addr-index (unwrap-panic
                (element-at (get reward-set-indexes add-pox-addr-info) u0))))

        ;; don't update the stacking-state map,
        ;;  because it _already has_ this stacker's state
        ;; don't lock the STX, because the STX is already locked
        ;;
        ;; clear the partial-stacked state, and log it
        (map-delete partial-stacked-by-cycle { pox-addr: pox-addr, sender: tx-sender, reward-cycle: reward-cycle })
        (map-set logged-partial-stacked-by-cycle { pox-addr: pox-addr, sender: tx-sender, reward-cycle: reward-cycle } partial-stacked)
        (ok pox-addr-index)))))
```

</details>

At this point, the STX are committed to the pool operator, and the pool operator has some “aggregate balance” of committed STX. The pool operator is not actually eligible for reward slots and signer initialization until this step is finished.

The pool operator cannot call this function until the total number of STX committed is larger than the minimum threshold required to Stack. This minimum stacking threshold is a function of the total number of STX stacked divided by the available number of reward slots.

{% hint style="info" %}
This number varies and can be found by visiting the pox endpoint of Hiro's API at <https://api.hiro.so/v2/pox> and looking at the `min_threshold_ustx` field. (1 STX = 1,000,000 uSTX).
{% endhint %}

Once the threshold is reached, the pool operator calls `stack-aggregation-commit-indexed`. This is the point where you as the pool operator must provide your signer key and signer key signature. The arguments are:

* Pox Address: the BTC address to receive rewards
* Reward-cycle: a reward cycle in the future (see the note above on passing the correct reward cycle)
* Signer public key: the public key of your signer (remember that this may be different than the address you are using to operate the pool, but this step is how you associate the two together)
* Signer signature: A signature proving control of your signing key (details on how to do this are below)
* Max Amount: This parameter is used to validate the signer signature provided. It represents the maximum number of uSTX (1 STX = 1,000,000 uSTX) that can be stacked in this transaction.
* Auth Id: This parameter is used to validate the signer signature provided. It is a random integer that prevents the re-use of this particular signer signature.

{% hint style="info" %}
In the Definitions and Roles section in the previous document, we described how the pool operator and signer may be the same entity, but not necessarily have the same address.

Signers who are also pool operators and wish to have STX delegated to them should have a separate keychain associated with their pool operator account in order to make Stacking transactions such as `delegate-stack-stx` and `stack-aggregation-commit-indexed`.

So, as a signing entity operating a pool, you should have two accounts:

* Your pool operator account, which you will use to conduct all of the stacking operations we have covered here.
* Your signer account, which is what you used to set up your signer. This signer public key is what you will pass in to the above aggregation commit function, and is also the key you will use when generating your signer signature.

If you are operating as a signer and a pool operator, you should have a separate key because you might need to rotate your signer key when necessary.

The PoX contract is designed to support rotating the signer key without needing your Stackers to un-stack and re-stack later. You cannot rotate a pool operator key without needing to wait for all delegated Stackers to un-stack and finally re-stack to the new pool operator address.

Because of this limitation of being unable to rotate pool operator addresses, it’s highly recommended to have a separate pool operator key. The benefit of a separate pool operator key is that it can easily be used in existing wallets, including hardware wallets.
{% endhint %}

Once this succeeds, the signer is eligible for reward slots. The number of reward slots depends on the amount of STX committed to this signer. Even if the signer commits more than the “global minimum”, the minimum amount to receive a slot depends on the amount of STX locked for each cycle.

To act as a signer, each step up to this point must be taken before the prepare phase of the next cycle begins. It is crucial that the signer software is running.

#### Pool operator increases amount committed

Even after the signer commits to a certain amount of STX in the previous step, the signer can increase this amount once more delegations are received. The initial steps must be taken for each Stacker (`delegate-stx` and then `delegate-stack-stx`), and then `stack-aggregation-increase` can be called with the index returned from the first `stack-aggregation-commit-indexed` call and a new signature.

<details>

<summary>Function source code</summary>

```
;; Commit partially stacked STX to a PoX address which has already received some STX (more than the Stacking min).
;; This allows a delegator to lock up marginally more STX from new delegates, even if they collectively do not
;; exceed the Stacking minimum, so long as the target PoX address already represents at least as many STX as the
;; Stacking minimum.
;;
;; The `reward-cycle-index` is emitted as a contract event from `stack-aggregation-commit` when the initial STX are
;; locked up by this delegator.  It must be passed here to add more STX behind this PoX address.  If the delegator
;; called `stack-aggregation-commit` multiple times for the same PoX address, then any such `reward-cycle-index` will
;; work here.
;;
;; *New in Stacks 2.1*
;;
(define-public (stack-aggregation-increase (pox-addr { version: (buff 1), hashbytes: (buff 32) })
                                           (reward-cycle uint)
                                           (reward-cycle-index uint))
  (let ((partial-stacked
         ;; fetch the partial commitments
         (unwrap! (map-get? partial-stacked-by-cycle { pox-addr: pox-addr, sender: tx-sender, reward-cycle: reward-cycle })
                  (err ERR_STACKING_NO_SUCH_PRINCIPAL))))

    ;; must be called directly by the tx-sender or by an allowed contract-caller
    (asserts! (check-caller-allowed)
              (err ERR_STACKING_PERMISSION_DENIED))

    ;; reward-cycle must be in the future
    (asserts! (> reward-cycle (current-pox-reward-cycle))
              (err ERR_STACKING_INVALID_LOCK_PERIOD))

    (let ((amount-ustx (get stacked-amount partial-stacked))
          ;; reward-cycle must point to an existing record in reward-cycle-total-stacked
          ;; infallible; getting something from partial-stacked-by-cycle succeeded so this must succeed
          (existing-total (unwrap-panic (map-get? reward-cycle-total-stacked { reward-cycle: reward-cycle })))
          ;; reward-cycle and reward-cycle-index must point to an existing record in reward-cycle-pox-address-list
          (existing-entry (unwrap! (map-get? reward-cycle-pox-address-list { reward-cycle: reward-cycle, index: reward-cycle-index })
                          (err ERR_DELEGATION_NO_REWARD_SLOT)))
          (increased-ustx (+ (get total-ustx existing-entry) amount-ustx))
          (total-ustx (+ (get total-ustx existing-total) amount-ustx)))

          ;; must be stackable
          (try! (minimal-can-stack-stx pox-addr total-ustx reward-cycle u1))

          ;; new total must exceed the stacking minimum
          (asserts! (<= (get-stacking-minimum) total-ustx)
                    (err ERR_STACKING_THRESHOLD_NOT_MET))

          ;; there must *not* be a stacker entry (since this is a delegator)
          (asserts! (is-none (get stacker existing-entry))
                    (err ERR_DELEGATION_WRONG_REWARD_SLOT))

          ;; the given PoX address must match the one on record
          (asserts! (is-eq pox-addr (get pox-addr existing-entry))
                    (err ERR_DELEGATION_WRONG_REWARD_SLOT))

          ;; update the pox-address list -- bump the total-ustx
          (map-set reward-cycle-pox-address-list
                   { reward-cycle: reward-cycle, index: reward-cycle-index }
                   { pox-addr: pox-addr,
                     total-ustx: increased-ustx,
                     stacker: none,
                     ;; TODO: this must be authorized with a signature, or tx-sender allowance!
                     signer: (get signer existing-entry) })

          ;; update the total ustx in this cycle
          (map-set reward-cycle-total-stacked
                   { reward-cycle: reward-cycle }
                   { total-ustx: total-ustx })

          ;; don't update the stacking-state map,
          ;;  because it _already has_ this stacker's state
          ;; don't lock the STX, because the STX is already locked
          ;;
          ;; clear the partial-stacked state, and log it
          (map-delete partial-stacked-by-cycle { pox-addr: pox-addr, sender: tx-sender, reward-cycle: reward-cycle })
          (map-set logged-partial-stacked-by-cycle { pox-addr: pox-addr, sender: tx-sender, reward-cycle: reward-cycle } partial-stacked)
          (ok true))))
```

</details>

***

## Step by Step Stacking Guide

Now that you are familiar with the overall stacking flow and the different roles played, let's dive into the step-by-step guide for actually conducting the stacking process as a pool operator.

{% hint style="info" %}
There are several ways you can go about stacking. This guide will cover using [Leather Earn](https://earn.leather.io/), which is a stacking web application and the simplest option.

Additionally, you can choose to call the stacking functions directly from the [deployed contract](https://explorer.hiro.so/txid/SP000000000000000000002Q6VF78.pox-4?chain=mainnet) in the explorer.

The fields and process will be the same, but the UI will differ.

Finally, you can stack using JS and the [@stacks/stacking](https://github.com/stx-labs/stacks.js/tree/main/packages/stacking) package if you prefer. Again, the functions and parameters will be the same, you will just be writing your JS code directly instead of using a UI.

If you are interested in using this method, you'll want to follow the [stacking guide](https://docs.hiro.so/stacks.js/guides/how-to-integrate-stacking) created by Hiro, and be sure to integrate the new parameters described in [Hiro's Nakamoto update doc](https://docs.hiro.so/nakamoto/stacks-js).
{% endhint %}

### Step 1: Run or work with a signer

This is a necessary prerequisite to stacking as a pool operator. You will either need to run your own signer or work with one and have them conduct step 2 on your behalf and give you their signer signature.

Running a signer involves setting up a hosted production environment that includes both a Stacks Node and the Stacks Signer. For more information, refer to the [running a signer doc](https://docs.stacks.co/operate/run-a-signer/signer-quickstart).

Once the signer software is running, you'll to keep track of the `stacks_private_key` that you used when configuring your signer software. This will be used in subsequent Stacking transactions.

{% hint style="info" %}
In the note above about pool operator vs signer keys, this corresponds to your signer key, not your pool operator wallet
{% endhint %}

### Step 2: Generate a signer key signature

#### Overview of signer keys and signatures

The main difference with Stacking in Nakamoto is that the Signer needs to include new parameters in their Stacking transactions. These are Clarity transactions that pool operators will call when interacting with the `pox-4.clar` contract. Interacting with that contract is how you as a pool operator actually stack the delegated STX tokens.

{% hint style="info" %}
The current pox-4 contract address can be found by visiting the following endpoint of the Hiro API: <https://api.hiro.so/v2/pox>.

You can then visit the [Stacks Explorer](https://explorer.hiro.so/) to view the contract and pass in the contract id.

You may want to review this contract to familiarize yourself with it.
{% endhint %}

Here is an overview of the new fields you will need to pass in some of your stacking transactions:

1. `signer-key`: the public key that corresponds to the `stacks_private_key` your signer is using.
2. `signer-signature`: a signature that demonstrates that you actually control your `signer-key`. Because signer keys need to be unique, this is also a safety check to ensure that other Stackers can’t use someone else’s signer key.
3. `max-amount`: The maximum amount of uSTX (1 STX = 1,000,000 uSTX) that can be locked in the transaction that uses this signature. For example, if calling `stack-aggregation-increase`, then this parameter dictates the maximum amount of uSTX that can be used to add more locked STX to the already committed position.
4. `auth-id`: a random integer that prevents re-use of a particular signature, similar to how nonces are used with transactions.

Signer signatures are signatures created using a particular signer key. They demonstrate that the controller of that signer key is allowing a Stacker to use their signer's public key. The signer signature’s message hash is created using the following data:

* `method`: a string that indicates the Stacking method that is allowed to utilize this signature. The valid options are `stack-stx`, `stack-extend`, `stack-increase`, `agg-commit` (for `stack-aggregation-commit-indexed`) and `agg-increase` (for `stack-aggregation-increase`).
* `max-amount`: described above.
* `auth-id`: described above.
* `period`: a value between 1 and 12, which indicates how long the Stacker is allowed to lock their STX for in this particular Stacking transaction. For `agg-commit`, this must be equal to 1.
* `reward-cycle`: This represents the reward cycle in which the Stacking transaction can be confirmed (for `stack-aggregation-commit-indexed`, this has to be set to 1).
* `pox-address`: The Bitcoin address that is allowed to be used for receiving rewards. This corresponds to the Bitcoin address associated with your signer
* `config`: This represents the signer configuration file path where the `stacks_private_key` is located, and it is used for signing the generated signature.

Now that we have an overview of role and contents of signatures, let's see how to actually generate them. You have several options available.

Generating your signature with Degen Lab's stacks.tools

* Degen Lab has a signature generation tool that will generate a signature using their signer. This is the quickest and simplest option. To generate a signature using this method, all you need to do is visit their [signature tool](https://signature.stacking.tools/) and pass in the relevant information as covered on the page.

Generating your signature with stacks.js

* The [@stacks/stacking](https://www.npmjs.com/package/@stacks/stacking) NPM package provides interfaces to generate and use signer signatures.
* There is a function called `signPoxSignature` that will allow you to generate this signature and pass it in to the stacking function.
* More information and code samples can be found on [Hiro's Nakamoto docs](https://docs.hiro.so/nakamoto/stacks-js).

Generating your signature using the stacks-signer CLI

* If you already have your signer configured and set up, you can use the `stacks-signer` CLI to generate this signature. You can either SSH into your running signer or use the `stacks-signer` CLI locally. If using the CLI locally, you will need to ensure you have a matching configuration file located on your filesystem. Having a matching configuration file is important to ensure that the signer public key you make in Stacking transactions is the same as in your hosted signer.

The CLI command is:

```
```

These arguments match those described in section [Overview of signer keys and signatures](https://docs.stacks.co/operate/solo-stack#overview-of-signer-keys-and-signatures), with the addition of:

* `--json`, to optionally output the resulting signature in JSON.

You can use the following command to generate a random `32` bit integer as `auth-id`:

```
```

Once the `generate-stacking-signature` command is run, the CLI will output a JSON:

```json
{"authId":"12345","maxAmount":"1234","method":"agg-commit","period":1,"poxAddress":"bc1...","rewardCycle":100,"signerKey":"aaaaaaaa","signerSignature":"bbbbbbbbbbb"}
```

You will use the JSON when calling Stacking transactions from your pool operator address as outlined above. Remember that this may be different than your signer address.

Generating your signature with Leather Earn

* Leather Earn is a web application that provides an easy-to-use interface for stacking and generating signatures. We'll cover using Leather Earn for stacking at the end of this document, here we will cover how to use it to generate a signature.

{% hint style="info" %}
At the time of writing, this has only been tested using the [Leather](https://leather.io/) wallet.
{% endhint %}

You can visit [earn.leather.io](https://earn.leather.io/) to generate a signer key signature. Make sure you’re connected to the correct network.\
To generate a signer key signature, it’s important that you’ve logged in Leather with the same secret key that was used to generate your signer key, not the account that will serve as your pool operator address. Once you’ve setup that account on Leather, you can log in to Leather Earn.\
Click the link “Signer key signature” at the bottom of the page. This will open the “generate a signer key signature” page.

The fields are:

* Reward cycle:
  * For all solo stacking transactions, this must equal the current reward cycle, not the cycle in which they will start stacking. The field defaults to the current reward cycle.
  * For stack-aggregation-commit-indexed, this field must equal the cycle used in that function’s “reward cycle” argument. Typically, that equates to current\_cycle + 1.
* Bitcoin address: the PoX reward address that can be used
* Topic: the stacking function that will use this signature
* Max amount: max amount of STX that can be used. Defaults to “max possible amount”
* Auth ID: defaults to random int
* Duration: must match the number of cycles used in the stacking transaction. For `stack-aggregation-commit-indexed`, use “1”.

{% hint style="warning" %}
Each of these fields must be exactly matched in order for the Stacking transaction to work. Future updates to Leather Earn will verify the signature before the transaction is made.
{% endhint %}

Click the “generate signature” button to popup a Leather page where you can generate the signature. Once you submit that popup, Leather Earn will have the signer key and signature you generated.

After you sign that message, you'll see the information you can use in your Stacking transactions, including the signer public key and signature.

You can click the “copy” icon next to “signer details to share with stackers”. This will copy a JSON string, which can be directly pasted into the Leather Earn page where you make your Stacking transaction. Alternatively, this information can be entered manually.

We'll cover the Leather Earn pages for actually making those transactions in the next section of this document.

#### Using a hardware or software wallet to generate signatures

When the signer is configured with a `stacks_private_key`, the signer may want to be able to use that key in a wallet to make stacking signatures.

If the signer uses a tool like [@stacks/cli](https://docs.hiro.so/get-started/command-line-interface) to generate the key, the CLI also outputs a mnemonic (aka “seed phrase”) that can be imported into a wallet. Because the Stacks CLI uses the standard derivation path for generating Stacks keys, any Stacks wallet will default to having that same private key when the wallet is imported from a derivation path. Similarly, if a hardware wallet is setup with that mnemonic, then the Signer can use a wallet like Leather to make stacking signatures.

Use the following stepper for the recommended workflow for setting up a wallet to generate signatures:

{% stepper %}
{% step %}

#### Generate the keypair and configure signer

1. Use @stacks/cli to generate the keychain and private key.
   * Typically, when using a hardware wallet, it’s better to generate the mnemonic on the hardware wallet. For this use case, however, the signer software needs the private key, and hardware wallets (by design) don’t allow exporting private keys.
2. Take the `privateKey` from the CLI output and add it to your signer’s configuration.
3. Take the mnemonic (24 words) and either:
   * Setup a new hardware wallet with this mnemonic
   * Store it somewhere securely, like a password manager. When the signer needs to generate signatures for Stacking transactions, they can import it into either Leather or XVerse.
     {% endstep %}

{% step %}

#### When you need to generate signatures

1. Setup your wallet with your signer key’s private key. Either:
   * Setup your Leather wallet with a Ledger hardware wallet
   * Import your mnemonic into Leather, XVerse, or another Stacks wallet
2. Open an app that has stacking signature functionality built-in
3. Connect your wallet to the app (aka sign in)
4. In the app, enter your PoX address and “submit”
   * The app will popup a window in your wallet that prompts you to sign the information
   * The app will show clear information about what you’re signing
5. Create the signature
   * If using a Ledger, confirm on your device
6. The app will display two results:
   * Your signer key, which is the public key associated with your signer’s key
   * Your signer signature
7. Finally, make a Stacking transaction using the signer key and signer signature.
   {% endstep %}
   {% endstepper %}

Now that you have your signer signature generated, it's time to start stacking. This process will vary depending on your chosen method. We've included instructions for pool stacking using [Leather Earn](https://earn.leather.io/) below.

### Step 3: Stack as a pool operator

The first step with delegated stacking involves a stacker delegating their Stacks to a specific pool operator. Stackers can do this by visiting the “Stack in a pool” page on Leather Earn.

As the pool operator, you must provide a STX address (a “pool admin address”) that will manage delegations. As discussed in previous sections, this is a separate address from the signer’s private key, and this can be any address. This address is what will be used when making transactions to confirm and aggregate delegated STX.

Pool operators can log in to Leather Earn and visit <https://earn.leather.io/pool-admin> to make pool management transactions.

#### delegate-stack-stx

Once a user has delegated to a pool operator, the pool operator must call `delegate-stack-stx` for each individual stacker.

#### stack-aggregation-commit

Once a pool has enough delegated STX to become a signer, the pool admin needs to visit the `Stack Aggregation Commit` page on Leather Earn. The pool operator enters the following information:

* Reward cycle: the reward cycle where the operator is “committing” delegated STX. This must be done for every individual reward cycle where the pool will be acting as a signer.
* BTC address
* New fields:
  * Signer public key
  * Signer key signature (generated in a previous step using the signer key)
  * Auth ID
  * Max amount

Once this transaction has been confirmed, the pool operator is eligible to be a signer for an upcoming reward cycle.

For more on the relationship between automated signing and manual stacking transactions, be sure to check out the main [Stack STX](file:///) doc.


# Stack with a Pool

The most common stacking scenario is to be an individual stacker that does not meet the stacking minimum and to stack with a pool.

This is also the least complex version and is very easy to accomplish.

Be sure you are familiar with the [concept of stacking](https://app.gitbook.com/s/H74xqoobupBWwBsVMJhK/block-production/stacking) before digging into this.

The dynamic minimum required to stack STX changes based on the total liquid supply of STX in the network and can be found by looking at the `pox` endpoint of the Hiro API: <https://api.hiro.so/v2/pox>.

If you do not meet this minimum, you'll need to delegate your STX to a pool operator.

This is a non-custodial delegation, meaning that your STX do not actually leave your wallet.

{% hint style="info" %}
Pool operators have a lot of control over exactly how they implement stacking. Usually users will be interacting with a wrapper contract that the pool operator has created to utilize the core stacking contract.
{% endhint %}

Delegating your STX to a pool operator involves a few steps:

{% stepper %}
{% step %}

#### Find a pool

The first step is to find a stacking pool you would like to stack with. Pool operators have a lot of control over exactly how they implement stacking and reward distribution, and they all do things a bit differently, so it's important to do your research. The Stacks website has a great [page on stacking](https://www.stacks.co/learn/stacking) that links to several pool operators for you to research.
{% endstep %}

{% step %}

#### Use the pool's UI to call the delegate function

After you've chosen your pool operator, you'll need to get set up with a [Stacks-compatible wallet](https://www.stacks.co/explore/ecosystem?category=All+Teams#wallets) like Leather, Xverse, or Asigna.

Then you'll use your chosen pool operator's UI to call their delegation function. You may need to pass a couple of parameters here like how long you want to grant delegation permission for.
{% endstep %}

{% step %}

#### Pool operator stacks tokens

Once you grant permission for the pool operator to delegate, they will take over and call a separate function in the stacking contract to actually stack those delegated tokens. At this point your STX will be locked.

Depending on how the pool operator handles things, they may offer the option to automatically continue to stack your STX for up to 12 continuous cycles.
{% endstep %}

{% step %}

#### Pool operator allocates rewards

Next, the pool operator will track what proportion of rewards you should earn based on the proportion of STX you delegated. If distributing rewards directly in Bitcoin, the pool operator will need to take custody of the Bitcoin and manually distribute it.

This is why it is important to do your research and stack with a pool operator whose reward distribution mechanism you trust. Different operators have different methods to make this process transparent and as trust-minimized as possible.
{% endstep %}

{% step %}

#### Pool operator distributes rewards

Finally, the pool operator will distribute those rewards to you in either BTC or STX, depending on the model they use.
{% endstep %}
{% endstepper %}

If you want to learn more about the specific functions and the contract that handles the stacking process, be sure to take a look at the [stacking contract walkthrough](https://app.gitbook.com/s/GVj1Z9vMuEOMe7oH7Wnq/clarity/example-contracts/stacking).

### Liquid Stacking

Liquid stacking is when you delegate your STX tokens to a liquid stacking provider and they issue you a new token such as stSTX that you can then use in the ecosystem. This makes it so that stackers can still use their STX to participate in DeFi protocols and other apps even while their STX are locked.

This works a bit differently than traditional stacking and links to liquid stacking providers for you to research can be found on the [Stacks website](https://www.stacks.co/learn/stacking).


# Increase Stacked Position

This guide explains how to increase your stacked STX position. The process depends on your role:

* **Solo Stackers** use the `stack-increase` function.
* **Delegators** must first revoke their current delegation using `revoke-delegate-stx` and then re-delegate with a higher amount to the same pool operator using `delegate-stx`.
* **Pool Operators** increase their delegators' locked amount by calling `delegate-stack-increase` and then stacking the increased amount with either `stack-aggregation-commit-indexed` (if not already committed) or `stack-aggregation-increase` (if the commit has already been made).

## Solo Stackers

Solo stackers can add more STX to their active stacking position by calling the `stack-increase` function. The new amount takes effect from the next stacking cycle.

The `stack-increase` function locks an additional amount of STX from your account. Your account must be actively stacking and not delegating, and you must have enough unlocked STX to cover the increase.

<details>

<summary>Function source code</summary>

```clojure
;; Increase the number of STX locked.
;; *New in Stacks 2.1*
;; This method locks up an additional amount of STX from `tx-sender`'s, indicated
;; by `increase-by`.  The `tx-sender` must already be Stacking & must not be
;; straddling more than one signer-key for the cycles effected. 
;; Refer to `verify-signer-key-sig` for more information on the authorization parameters
;; included here.
(define-public (stack-increase 
  (increase-by uint)
  (signer-sig (optional (buff 65)))
  (signer-key (buff 33))
  (max-amount uint)
  (auth-id uint))
   (let ((stacker-info (stx-account tx-sender))
         (amount-stacked (get locked stacker-info))
         (amount-unlocked (get unlocked stacker-info))
         (unlock-height (get unlock-height stacker-info))
         (cur-cycle (current-pox-reward-cycle))
         (first-increased-cycle (+ cur-cycle u1))
         (stacker-state (unwrap! (map-get? stacking-state
                                          { stacker: tx-sender })
                                          (err ERR_STACK_INCREASE_NOT_LOCKED)))
         (cur-pox-addr (get pox-addr stacker-state))
         (cur-period (get lock-period stacker-state)))
      ;; tx-sender must be currently locked
      (asserts! (> amount-stacked u0)
                (err ERR_STACK_INCREASE_NOT_LOCKED))
      ;; must be called with positive `increase-by`
      (asserts! (>= increase-by u1)
                (err ERR_STACKING_INVALID_AMOUNT))
      ;; stacker must have enough stx to lock
      (asserts! (>= amount-unlocked increase-by)
                (err ERR_STACKING_INSUFFICIENT_FUNDS))
      ;; must be called directly by the tx-sender or by an allowed contract-caller
      (asserts! (check-caller-allowed)
                (err ERR_STACKING_PERMISSION_DENIED))
      ;; stacker must be directly stacking
      (asserts! (> (len (get reward-set-indexes stacker-state)) u0)
                (err ERR_STACKING_IS_DELEGATED))
      ;; stacker must not be delegating
      (asserts! (is-none (get delegated-to stacker-state))
                (err ERR_STACKING_IS_DELEGATED))

      ;; Validate that amount is less than or equal to `max-amount`
      (asserts! (>= max-amount (+ increase-by amount-stacked)) (err ERR_SIGNER_AUTH_AMOUNT_TOO_HIGH))

      ;; Verify signature from delegate that allows this sender for this cycle
      (try! (consume-signer-key-authorization cur-pox-addr cur-cycle "stack-increase" cur-period signer-sig signer-key increase-by max-amount auth-id))

      ;; update reward cycle amounts
      (asserts! (is-some (fold increase-reward-cycle-entry
            (get reward-set-indexes stacker-state)
            (some { first-cycle: first-increased-cycle,
                    reward-cycle: (get first-reward-cycle stacker-state),
                    stacker: tx-sender,
                    add-amount: increase-by,
                    signer-key: signer-key })))
            (err ERR_INVALID_INCREASE))
      ;; NOTE: stacking-state map is unchanged: it does not track amount-stacked in PoX-4
      (ok { stacker: tx-sender, total-locked: (+ amount-stacked increase-by)})))
```

</details>

Arguments:

* Increase by: the amount of uSTX to add to your lock amount.
* Signer public key: the public key used for signing. This can stay the same, or you can use a new key.
* Signer signature: a signature proving control of your signing key.
* Max Amount: used to validate the signer signature provided. It represents the maximum number of uSTX (1 STX = 1,000,000 uSTX) that can be stacked in this transaction.
* Auth Id: used to validate the signer signature provided. It is a random integer that prevents re-use of this particular signer signature.

## Delegators

Delegators have to increase their delegated amount in two steps.

{% stepper %}
{% step %}

#### Revoke Your Current Delegation

Before increasing your delegation, cancel your current delegation through the `revoke-delegate-stx` function, so that you can delegate an increased amount of STX afterwards.

<details>

<summary>Function source code</summary>

```clojure
;; Revokes the delegation to the current stacking pool.
;; New in pox-4: Fails if the delegation was already revoked.
;; Returns the last delegation state.
(define-public (revoke-delegate-stx)
  (let ((last-delegation-state (get-check-delegation tx-sender)))
    ;; must be called directly by the tx-sender or by an allowed contract-caller
    (asserts! (check-caller-allowed)
              (err ERR_STACKING_PERMISSION_DENIED))
    (asserts! (is-some last-delegation-state) (err ERR_DELEGATION_ALREADY_REVOKED))
    (asserts! (map-delete delegation-state { stacker: tx-sender }) (err ERR_DELEGATION_ALREADY_REVOKED))
    (ok last-delegation-state)))
```

</details>
{% endstep %}

{% step %}

#### Delegate with a Higher Amount

After revoking, call the `delegate-stx` function with your new, higher amount. This function does not directly delegate the STX, but rather allows the pool operator to issue the stacking lock on behalf of the user calling this function.

<details>

<summary>Function source code</summary>

```clojure
;; Delegate to `delegate-to` the ability to stack from a given address.
;;  This method _does not_ lock the funds, rather, it allows the delegate
;;  to issue the stacking lock.
;; The caller specifies:
;;   * amount-ustx: the total amount of ustx the delegate may be allowed to lock
;;   * until-burn-ht: an optional burn height at which this delegation expires
;;   * pox-addr: an optional address to which any rewards *must* be sent
(define-public (delegate-stx (amount-ustx uint)
                             (delegate-to principal)
                             (until-burn-ht (optional uint))
                             (pox-addr (optional { version: (buff 1), hashbytes: (buff 32) })))

    (begin
      ;; must be called directly by the tx-sender or by an allowed contract-caller
      (asserts! (check-caller-allowed)
                (err ERR_STACKING_PERMISSION_DENIED))

      ;; delegate-stx no longer requires the delegator to not currently
      ;; be stacking.
      ;; delegate-stack-* functions assert that
      ;; 1. users can't swim in two pools at the same time.
      ;; 2. users can't switch pools without cool down cycle.
      ;;    Other pool admins can't increase or extend.
      ;; 3. users can't join a pool while already directly stacking.

      ;; pox-addr, if given, must be valid
      (match pox-addr
         address
            (asserts! (check-pox-addr-version (get version address))
                (err ERR_STACKING_INVALID_POX_ADDRESS))
         true)

      ;; tx-sender must not be delegating
      (asserts! (is-none (get-check-delegation tx-sender))
        (err ERR_STACKING_ALREADY_DELEGATED))

      ;; add delegation record
      (map-set delegation-state
        { stacker: tx-sender }
        { amount-ustx: amount-ustx,
          delegated-to: delegate-to,
          until-burn-ht: until-burn-ht,
          pox-addr: pox-addr })

      (ok true)))
```

</details>

Arguments:

* Amount: Denoted in uSTX (1 STX = 1,000,000 uSTX).
* Delegate to: the STX address of the pool operator they're delegating to.
* Until burn height: optional BTC block height when the delegation expires.
* Pox Address: optional BTC address that, if specified, the signer must use to accept this delegation.

{% hint style="info" %}
Make sure the revocation is successful before initiating a new delegation. Otherwise, the `delegate-stx` transaction will fail.
{% endhint %}
{% endstep %}
{% endstepper %}

## Pool Operators

Pool operators can increase the total stacking amount through a two-step process. First, update the delegation's locked amount with `delegate-stack-increase`. Then, stack the increased amount by committing it in a future cycle, or increasing an already committed position.

### Increase the Locked Amount

The `delegate-stack-increase` function allows a pool operator to add more STX to the existing locked position for a given delegator. It performs necessary checks and updates the delegation state with the increased amount.

<details>

<summary>Function source code</summary>

```clojure
;; As a delegator, increase an active Stacking lock, issuing a "partial commitment" for the
;;   increased cycles.
;; *New in Stacks 2.1*
;; This method increases `stacker`'s current lockup and partially commits the additional
;;   STX to `pox-addr`
(define-public (delegate-stack-increase
                    (stacker principal)
                    (pox-addr { version: (buff 1), hashbytes: (buff 32) })
                    (increase-by uint))
    (let ((stacker-info (stx-account stacker))
          (existing-lock (get locked stacker-info))
          (available-stx (get unlocked stacker-info))
          (unlock-height (get unlock-height stacker-info)))

     ;; must be called with positive `increase-by`
     (asserts! (>= increase-by u1)
               (err ERR_STACKING_INVALID_AMOUNT))

     (let ((unlock-in-cycle (burn-height-to-reward-cycle unlock-height))
           (cur-cycle (current-pox-reward-cycle))
           (first-increase-cycle (+ cur-cycle u1))
           (last-increase-cycle (- unlock-in-cycle u1))
           (cycle-count (try! (if (<= first-increase-cycle last-increase-cycle)
                                  (ok (+ u1 (- last-increase-cycle first-increase-cycle)))
                                  (err ERR_STACKING_INVALID_LOCK_PERIOD))))
           (new-total-locked (+ increase-by existing-lock))
           (stacker-state
                (unwrap! (map-get? stacking-state { stacker: stacker })
                 (err ERR_STACK_INCREASE_NOT_LOCKED))))

      ;; must be called directly by the tx-sender or by an allowed contract-caller
      (asserts! (check-caller-allowed)
        (err ERR_STACKING_PERMISSION_DENIED))

      ;; stacker must not be directly stacking
      (asserts! (is-eq (len (get reward-set-indexes stacker-state)) u0)
                (err ERR_STACKING_NOT_DELEGATED))

      ;; stacker must be delegated to tx-sender
      (asserts! (is-eq (unwrap! (get delegated-to stacker-state)
                                (err ERR_STACKING_NOT_DELEGATED))
                       tx-sender)
                (err ERR_STACKING_PERMISSION_DENIED))

      ;; stacker must be currently locked
      (asserts! (> existing-lock u0)
        (err ERR_STACK_INCREASE_NOT_LOCKED))

      ;; stacker must have enough stx to lock
      (asserts! (>= available-stx increase-by)
        (err ERR_STACKING_INSUFFICIENT_FUNDS))

      ;; stacker must have delegated to the caller
      (let ((delegation-info (unwrap! (get-check-delegation stacker) (err ERR_STACKING_PERMISSION_DENIED)))
            (delegated-to (get delegated-to delegation-info))
            (delegated-amount (get amount-ustx delegation-info))
            (delegated-pox-addr (get pox-addr delegation-info))
            (delegated-until (get until-burn-ht delegation-info)))
        ;; must have delegated to tx-sender
        (asserts! (is-eq delegated-to tx-sender)
                  (err ERR_STACKING_PERMISSION_DENIED))
        ;; must have delegated enough stx
        (asserts! (>= delegated-amount new-total-locked)
                  (err ERR_DELEGATION_TOO_MUCH_LOCKED))
        ;; if pox-addr is set, must be equal to pox-addr
        (asserts! (match delegated-pox-addr
                         specified-pox-addr (is-eq pox-addr specified-pox-addr)
                         true)
                  (err ERR_DELEGATION_POX_ADDR_REQUIRED))
        ;; delegation must not expire before lock period
        (asserts! (match delegated-until
                        until-burn-ht
                            (>= until-burn-ht unlock-height)
                        true)
                  (err ERR_DELEGATION_EXPIRES_DURING_LOCK)))

      ;; delegate stacking does minimal-can-stack-stx
      (try! (minimal-can-stack-stx pox-addr new-total-locked first-increase-cycle (+ u1 (- last-increase-cycle first-increase-cycle))))

      ;; register the PoX address with the amount stacked via partial stacking
      ;;   before it can be included in the reward set, this must be committed!
      (add-pox-partial-stacked pox-addr first-increase-cycle cycle-count increase-by)

      ;; stacking-state is unchanged, so no need to update

      ;; return the lock-up information, so the node can actually carry out the lock.
      (ok { stacker: stacker, total-locked: new-total-locked}))))
```

</details>

Arguments:

* Stacker: the STX address of the delegator.
* Pox Address: the BTC address of the pool operator where they will receive the BTC rewards. If the delegator has set his own BTC address in the `delegate-stx` call, this address will have to be the same one.
* Increase by: the amount of uSTX to add to the delegator's locked amount.

## Stack the Increased Amount

Once the locked amount is updated, the operator must commit the change. There are two functions that can be used to stack the increased amount:

{% stepper %}
{% step %}
**If the Commit Has Not Yet Been Made: stack-aggregation-commit-indexed**

This function stacks the total locked amount for an upcoming reward cycle. Note that the `stack-aggregation-commit-indexed` function wraps the `inner-stack-aggregation-commit` function. The wrapped inner function is included here.

<details>

<summary>Function source code</summary>

```clojure
;; Commit partially stacked STX and allocate a new PoX reward address slot.
;;   This allows a stacker/delegate to lock fewer STX than the minimal threshold in multiple transactions,
;;   so long as: 1. The pox-addr is the same.
;;               2. This "commit" transaction is called _before_ the PoX anchor block.
;;   This ensures that each entry in the reward set returned to the stacks-node is greater than the threshold,
;;   but does not require it be all locked up within a single transaction
;;
;; Returns (ok uint) on success, where the given uint is the reward address's index in the list of reward
;; addresses allocated in this reward cycle.  This index can then be passed to `stack-aggregation-increase`
;; to later increment the STX this PoX address represents, in amounts less than the stacking minimum.
;;
;; *New in Stacks 2.1.*
(define-private (inner-stack-aggregation-commit (pox-addr { version: (buff 1), hashbytes: (buff 32) })
                                                (reward-cycle uint)
                                                (signer-sig (optional (buff 65)))
                                                (signer-key (buff 33))
                                                (max-amount uint)
                                                (auth-id uint))
  (let ((partial-stacked
         ;; fetch the partial commitments
         (unwrap! (map-get? partial-stacked-by-cycle { pox-addr: pox-addr, sender: tx-sender, reward-cycle: reward-cycle })
                  (err ERR_STACKING_NO_SUCH_PRINCIPAL))))
    ;; must be called directly by the tx-sender or by an allowed contract-caller
    (asserts! (check-caller-allowed)
              (err ERR_STACKING_PERMISSION_DENIED))
    (let ((amount-ustx (get stacked-amount partial-stacked)))
      (try! (consume-signer-key-authorization pox-addr reward-cycle "agg-commit" u1 signer-sig signer-key amount-ustx max-amount auth-id))
      (try! (can-stack-stx pox-addr amount-ustx reward-cycle u1))
      ;; Add the pox addr to the reward cycle, and extract the index of the PoX address
      ;; so the delegator can later use it to call stack-aggregation-increase.
      (let ((add-pox-addr-info
                (add-pox-addr-to-ith-reward-cycle
                   u0
                   { pox-addr: pox-addr,
                     first-reward-cycle: reward-cycle,
                     num-cycles: u1,
                     reward-set-indexes: (list),
                     stacker: none,
                     signer: signer-key,
                     amount-ustx: amount-ustx,
                     i: u0 }))
           (pox-addr-index (unwrap-panic
                (element-at (get reward-set-indexes add-pox-addr-info) u0))))

        ;; don't update the stacking-state map,
        ;;  because it _already has_ this stacker's state
        ;; don't lock the STX, because the STX is already locked
        ;;
        ;; clear the partial-stacked state, and log it
        (map-delete partial-stacked-by-cycle { pox-addr: pox-addr, sender: tx-sender, reward-cycle: reward-cycle })
        (map-set logged-partial-stacked-by-cycle { pox-addr: pox-addr, sender: tx-sender, reward-cycle: reward-cycle } partial-stacked)
        (ok pox-addr-index)))))
```

</details>

Arguments:

* Pox Address: the BTC address to receive rewards.
* Reward-cycle: a reward cycle in the future.
* Signer public key: the public key of your signer.
* Signer signature: a signature proving control of your signing key.
* Max Amount: used to validate the signer signature provided.
* Auth Id: used to validate the signer signature provided.
  {% endstep %}

{% step %}
**If the Commit Has Already Been Made: stack-aggregation-increase**

If you have previously committed an amount, you can further increase the stacked position by calling `stack-aggregation-increase`. This function adds an additional amount of STX to the already committed delegation.

<details>

<summary>Function source code</summary>

```clojure
;; Commit partially stacked STX to a PoX address which has already received some STX (more than the Stacking min).
;; This allows a delegator to lock up marginally more STX from new delegates, even if they collectively do not
;; exceed the Stacking minimum, so long as the target PoX address already represents at least as many STX as the
;; Stacking minimum.
;;
;; The `reward-cycle-index` is emitted as a contract event from `stack-aggregation-commit` when the initial STX are
;; locked up by this delegator.  It must be passed here to add more STX behind this PoX address.  If the delegator
;; called `stack-aggregation-commit` multiple times for the same PoX address, then any such `reward-cycle-index` will
;; work here.
;;
;; *New in Stacks 2.1*
;;
(define-public (stack-aggregation-increase (pox-addr { version: (buff 1), hashbytes: (buff 32) })
                                           (reward-cycle uint)
                                           (reward-cycle-index uint))
  (let ((partial-stacked
         ;; fetch the partial commitments
         (unwrap! (map-get? partial-stacked-by-cycle { pox-addr: pox-addr, sender: tx-sender, reward-cycle: reward-cycle })
                  (err ERR_STACKING_NO_SUCH_PRINCIPAL))))

    ;; must be called directly by the tx-sender or by an allowed contract-caller
    (asserts! (check-caller-allowed)
              (err ERR_STACKING_PERMISSION_DENIED))

    ;; reward-cycle must be in the future
    (asserts! (> reward-cycle (current-pox-reward-cycle))
              (err ERR_STACKING_INVALID_LOCK_PERIOD))

    (let ((amount-ustx (get stacked-amount partial-stacked))
          ;; reward-cycle must point to an existing record in reward-cycle-total-stacked
          ;; infallible; getting something from partial-stacked-by-cycle succeeded so this must succeed
          (existing-total (unwrap-panic (map-get? reward-cycle-total-stacked { reward-cycle: reward-cycle })))
          ;; reward-cycle and reward-cycle-index must point to an existing record in reward-cycle-pox-address-list
          (existing-entry (unwrap! (map-get? reward-cycle-pox-address-list { reward-cycle: reward-cycle, index: reward-cycle-index })
                          (err ERR_DELEGATION_NO_REWARD_SLOT)))
          (increased-ustx (+ (get total-ustx existing-entry) amount-ustx))
          (total-ustx (+ (get total-ustx existing-total) amount-ustx)))

          ;; must be stackable
          (try! (minimal-can-stack-stx pox-addr total-ustx reward-cycle u1))

          ;; new total must exceed the stacking minimum
          (asserts! (<= (get-stacking-minimum) total-ustx)
                    (err ERR_STACKING_THRESHOLD_NOT_MET))

          ;; there must *not* be a stacker entry (since this is a delegator)
          (asserts! (is-none (get stacker existing-entry))
                    (err ERR_DELEGATION_WRONG_REWARD_SLOT))

          ;; the given PoX address must match the one on record
          (asserts! (is-eq pox-addr (get pox-addr existing-entry))
                    (err ERR_DELEGATION_WRONG_REWARD_SLOT))

          ;; update the pox-address list -- bump the total-ustx
          (map-set reward-cycle-pox-address-list
                   { reward-cycle: reward-cycle, index: reward-cycle-index }
                   { pox-addr: pox-addr,
                     total-ustx: increased-ustx,
                     stacker: none,
                     ;; TODO: this must be authorized with a signature, or tx-sender allowance!
                     signer: (get signer existing-entry) })

          ;; update the total ustx in this cycle
          (map-set reward-cycle-total-stacked
                   { reward-cycle: reward-cycle }
                   { total-ustx: total-ustx })

          ;; don't update the stacking-state map,
          ;;  because it _already has_ this stacker's state
          ;; don't lock the STX, because the STX is already locked
          ;;
          ;; clear the partial-stacked state, and log it
          (map-delete partial-stacked-by-cycle { pox-addr: pox-addr, sender: tx-sender, reward-cycle: reward-cycle })
          (map-set logged-partial-stacked-by-cycle { pox-addr: pox-addr, sender: tx-sender, reward-cycle: reward-cycle } partial-stacked)
          (ok true))))
```

</details>

Arguments:

* Pox Address: the BTC address to receive rewards.
* Reward Cycle: a reward cycle in the future.
* Reward Cycle Index: the index returned by `stack-aggregation-commit-indexed`.
* Signer signature: a signature proving control of your signing key.
* Signer public key: the public key of your signer.
* Max Amount: used to validate the signer signature provided.
* Auth Id: used to validate the signer signature provided.
  {% endstep %}
  {% endstepper %}

{% hint style="warning" %}

* Sequential Process: First call `delegate-stack-increase` to update the locked amount of a delegation. Then, commit the change:
  * Use `stack-aggregation-commit-indexed` if this is the first commit in the given cycle.
  * Use `stack-aggregation-increase` if you have already committed in the cycle you want to increase.

Failing to commit (or properly increase after a commit) will result in the increased delegation not taking effect in upcoming stacking cycles.
{% endhint %}


# Stop Stacking

When you decide it's time to stop stacking your STX tokens, the process depends on whether you are stacking solo or delegating your tokens to a pool operator. This guide explains the steps for both scenarios.

***

## Stopping Solo Stacking

When stacking solo using the `stack-stx` function, your STX is locked for a fixed period (the lock period) defined when you initiated stacking or when you extended the lock period. **No additional action is required to stop stacking**, you simply have to wait until the lock period expires.

{% hint style="info" %}
In solo stacking, both the `stack-stx` and `stack-extend` functions emits an event that includes the `unlock-burn-height` field. This is the burn block height at which your tokens will be automatically unlocked.
{% endhint %}

## Stopping Pooled Stacking

If you're stacking with a pool (where you delegate your STX via the `delegate-stx` function), the process to stop stacking requires one extra step before your STX is eventually unlocked.

{% stepper %}
{% step %}

#### Revoke Delegation

Before your STX can be unlocked, you must cancel the delegation with the pool operator. This is done by calling the `revoke-delegate-stx` function through the pool's interface, or within the [pox-4](https://explorer.hiro.so/txid/SP000000000000000000002Q6VF78.pox-4?chain=mainnet) contract.

<details>

<summary>Function source code</summary>

```clojure
;; Revokes the delegation to the current stacking pool.
;; New in pox-4: Fails if the delegation was already revoked.
;; Returns the last delegation state.
(define-public (revoke-delegate-stx)
  (let ((last-delegation-state (get-check-delegation tx-sender)))
    ;; must be called directly by the tx-sender or by an allowed contract-caller
    (asserts! (check-caller-allowed)
              (err ERR_STACKING_PERMISSION_DENIED))
    (asserts! (is-some last-delegation-state) (err ERR_DELEGATION_ALREADY_REVOKED))
    (asserts! (map-delete delegation-state { stacker: tx-sender }) (err ERR_DELEGATION_ALREADY_REVOKED))
    (ok last-delegation-state)))
```

</details>

Calling `revoke-delegate-stx` cancels your STX delegation, revoking the pool operator's access to further lock/stack your funds. Even after revoking the delegation, your STX will remain locked until the end of the last stacking cycle chosen by the pool (can be at most 12 cycles in the future).

{% hint style="warning" %}
Failing to revoke your delegation will mean that you continue to allow the pool to stack your STX until the reach of the burn block height mentioned in the delegate function (`delegate-stx`). Ensure that you have successfully called `revoke-delegate-stx` if you want to stop stacking sooner.
{% endhint %}
{% endstep %}

{% step %}

#### Wait for Funds to Unlock

After revoking your delegation, your STX tokens will still remain locked until the last stacking cycle chosen by the pool operator completes. The unlock occurs automatically at the predefined unlock burn height for that cycle.

{% hint style="info" %}
Even in pooled stacking, the unlocking mechanism follows the same blockchain timing as solo stacking. Revoking delegation only stops future stacking actions, it does not immediately unlock your tokens.
{% endhint %}
{% endstep %}
{% endstepper %}

## Considerations

* Monitor Your Stacking Status: Use your wallet's interface or the [Hiro Explorer](https://explorer.hiro.so/?chain=mainnet) to track the status of your lock period and confirm when your tokens are available.
* Using the API: Hiro's API offers an endpoint to [Get account STX balance](https://docs.hiro.so/stacks/api/accounts/stx-balances), which contains the `burnchain_unlock_height` height, representing the burn block height where your STX unlocks.
* Plan Ahead: Since the unlocking is bound to cycle's timing, plan your stacking period or revocation accordingly to minimize delays in accessing your funds.


# Developer Stack

<figure><img src="https://1374237750-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FGVj1Z9vMuEOMe7oH7Wnq%2Fuploads%2FFeUJSzFDJYXf34AVfXOJ%2FFrame%20316124591.jpg?alt=media&#x26;token=0e88a42a-4daa-46da-b086-14e839c4792b" alt=""><figcaption><p>source: <a href="https://youtu.be/6Y1wj4FahhM?si=MeRoxOa20ImL6uw1">Hiro Youtube</a></p></figcaption></figure>

New to developing on Stacks or looking for a quick reference guide for all the important components and links? You're in the right place.

We'll go over all the building blocks you need to be aware of to build high-quality Stacks dapps. This page exists to serve as a reference to the Stacks developer's tool chest. In addition to the tools below, stacks.co houses an index of [apps, services, and other integrations available on Stacks](https://www.stacks.co/explore/ecosystem?category=All+Teams#tools).

### Building Blocks

#### Clarity

[Clarity](https://app.gitbook.com/s/H74xqoobupBWwBsVMJhK/clarity/overview) is the smart contract language on Stacks. If you want to build the next decentralized social network, DeFi protocol, or any other Stacks dapp, you'll need to know Clarity.

#### Post Conditions

[Post conditions](https://app.gitbook.com/s/H74xqoobupBWwBsVMJhK/transactions/post-conditions) are a cool feature of the Stacks blockchain that allow you to verify the legitimacy of a transaction on the client side before it is executed. This adds an additional layer of defense against malicious smart contracts.

#### Proof of Transfer

[PoX](https://app.gitbook.com/s/H74xqoobupBWwBsVMJhK/stacks-101/proof-of-transfer) is the unique consensus mechanism of Stacks that facilitates new block production and also allows Stackers to earn real Bitcoin yield by participating in locking their STX tokens.

#### Stacking

Speaking of [Stacking](https://app.gitbook.com/s/H74xqoobupBWwBsVMJhK/block-production/stacking), it's the mechanism that helps to secure the Stacks chain and allows Stackers to earn real Bitcoin yield transferred by miners.

#### SIP-009 and SIP-010 Tokens

Fungible and non-fungible tokens in Clarity are defined by [SIP-009](file:///) and [SIP-010](https://github.com/stacksgov/sips/blob/main/sips/sip-010/sip-010-fungible-token-standard.md) standards. You can learn more about how to work with these tokens in the Clarity book.

#### sBTC

[sBTC](https://docs.stacks.co/sbtc) is the trust-minimized 2-way peg for Bitcoin on the Stacks network. sBTC operates as a SIP-010 token and comes with a [stacks.js library](https://docs.stacks.co/build/misc.-guides/sbtc/how-to-use-the-sbtc-js-library-for-bridging) so it's easy for devs to work with. [Utilizing sBTC](https://docs.stacks.co/build/misc.-guides/sbtc/sbtc-builder-quickstart) in your contract is as simple as calling the `sbtc-token` contract's transfer function.

### Tools

#### Wallets

Wallets are a key tool in any web3 ecosystem, and Stacks is no different. There are several options available including:

* [Leather](https://leather.io/)
* [Xverse](https://www.xverse.app/)
* [Asigna](https://asigna.io/)

#### Platform

The [Hiro Platform](https://www.hiro.so/platform) is your all-in-one cloud development environment for Stacks development, and is integrated with most of the tools listed below.

It's by far the easiest way to get up and running quickly. Plus, they have SSH integration.

#### Explorer

Every developer needs a block explorer to take a look at information about blocks and transactions being submitted to the chain. You have two choices here: the [Hiro Explorer](https://explorer.hiro.so/) and [STXScan](https://stxscan.co/).

#### API

If you want to interact with or read data from the chain, there's a good chance the [Hiro API](https://docs.hiro.so/stacks-blockchain-api) has an endpoint for that.

#### Stacks.js

[Stacks.js](https://www.hiro.so/stacks-js) is the de-facto JavaScript library for the Stacks ecosystem. There are several packages here that will help you build robust frontends for your applications.

#### Clarinet

All good developer tooling needs a robust, easy-to-use development environment. Enter [Clarinet](https://www.hiro.so/clarinet). Clarinet provides everything you need to write, test, and deploy Clarity smart contracts, including a fully-featured local devnet blockchain.

#### Chainhook

One of the key use cases for Stacks is being able to directly interact with the Bitcoin chain. Hiro's [Chainhook](https://docs.hiro.so/chainhook) makes this easier by providing an IFTTT system for responding and reacting to events on both the Bitcoin and Stacks chains.

#### Stacking Tools

The Degen Lab team has created a [suite of tools](https://stacking.tools/) to make stacking significantly easier including a signer signature generator, a solo stacking dapp to stack without needing to run a signer, and a TypeScript library for mocking stacking functions.

#### Oracles and Price Feeds

DIA and Pyth provide oracle services for the Stacks layer. Find [documentation for DIA here](https://docs.diadata.org/use-nexus-product/nexus/data-delivery-usage/integrated-blockchains/stacks-price-oracles) and learn more about the [developer release of Pyth here](https://www.pyth.network/blog/developer-release-pyth-on-stacks).

### Educational Resources

#### Docs

These docs you are currently looking at are a great place to get a comprehensive view of all things in the Stacks ecosystem, as well as providing some links out to additional resources you'll find helpful.

#### Hiro Docs

Hiro is a key player in the Stacks ecosystem, providing several developer tools to make your life easier. They also publish excellent [guides and docs](https://docs.hiro.so/) to make using these tools a breeze.

#### Clarity Book

The [Clarity Book](https://book.clarity-lang.org/) is the go-to resource for learning how to be a Clarity developer. In it you'll not only get the basics of Clarity but go through several practice projects and learn best practices.

#### LearnWeb3

LearnWeb3 is one of the best education providers in the game. They have recently begun publishing courses as part of their [Stacks Developer Degree](https://learnweb3.io/degrees/stacks-developer-degree/). LearnWeb3 courses will teach you everything you need to know about building Stacks Dapps.

#### EasyA

[EasyA](https://www.easya.io/) is a mobile app with a Stacks course built in. The EasyA app allows you to learn on the go and is a great way to learn the basics of Stacks and Clarity development all directly in their app.

#### Bitcoin Primer

If you're new to Bitcoin, interested in how it works, and how you can build Stacks dapps that interact with it, the [Bitcoin Primer](https://start.bitcoinprimer.dev/) is a great place to start.


# Stacks Node Configuration

{% hint style="info" %}
Note that these config fields are for a Stacks follower node. If you are running a signer alongside your Stacks node, you'll want to use the sample file found on the [Signer Configuration](https://docs.stacks.co/reference/node-operations/broken-reference) page as it contains additional parameters needed for your signer and Stacks node to function properly.
{% endhint %}

### Usage

```bash
stacks-node sub-command [--subcommand-option <value>]
```

#### Subcommands

* `mocknet`: start a mocknet instance using defaults
* `testnet`: start a testnet instance using defaults (chainstate is not persistent)
* `mainnet`: start a mainnet instance using defaults (chainstate is not persistent)
* `start`: combined with `--config`, starts an instance with a specified configuration file
* `version`: displays binary version
* `help`: displays the help message

### Configuration File Options

The Stacks Blockchain configuration file has multiple sections under which an option may be placed.

* node
* events\_observer
* connection\_options
* burnchain
* ustx\_balance
* miner

For reference, several configuration file examples are [available here](https://github.com/stacks-network/stacks-core/tree/master/sample/conf).

#### node

Contains various configuration options for the stacks-node binary.

| Name                         | Required | Description                                                                                                |
| ---------------------------- | -------- | ---------------------------------------------------------------------------------------------------------- |
| rpc\_bind                    | ✓        | IPv4 address and port to open for RPC connections                                                          |
| p2p\_bind                    | ✓        | IPv4 address and port to open for P2P connections                                                          |
| working\_dir                 |          | Absolute path to the directory where chainstate data will be stored                                        |
| data\_url                    |          | IPv4 address and port for incoming RPC connections                                                         |
| p2p\_address                 |          | IPv4 address and port for incoming P2P connections                                                         |
| bootstrap\_node              |          | Public key, IPv4 address, and port to bootstrap the chainstate                                             |
| wait\_time\_for\_microblocks |          | The amount of time in ms to wait before trying to mine a block after catching up to the anchored chain tip |
| seed                         |          | The private key to use for mining. Only needed if `miner` is set to `true`                                 |
| local\_peer\_seed            |          | The private key to use for signing P2P messages in the networking stack                                    |
| miner                        |          | Determines whether the node is running a follower (`false`) or a miner (`true`). Defaults to `false`       |
| mock\_mining                 |          | Simulates running a miner (typically used for debugging)                                                   |
| mock\_mining\_output\_dir    |          | Folder for mock mining data                                                                                |
| mine\_microblocks            |          | Determines whether the node will mine microblocks. Will only take effect if `miner` is set to `true`       |
| prometheus\_bind             |          | Address and port for Prometheus metrics collection.                                                        |
| deny\_nodes                  |          | List of ip addresses of nodes that should be ignored                                                       |
| stacker                      |          | Determines whether the node is running a stacker (`true`) that issues events for signer binary             |

#### events\_observer

{% hint style="info" %}
This section is *optional* and not required

However, if this section is added, **all** fields are required.
{% endhint %}

Contains options for sending events emitted to the [stacks-blockchain-api](https://github.com/hirosystems/stacks-blockchain-api) service.

| Name         | Required | Description                                                                                                                                                       |
| ------------ | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| endpoint     | ✓        | Address and port to a [stacks-blockchain-api](https://github.com/hirosystems/stacks-blockchain-api) service                                                       |
| events\_keys | ✓        | Event keys for which to watch. The emitted node events can be restricted by account, function name and event type. Asterix ("\*") can be used to emit all events. |

#### connection\_options

{% hint style="info" %}
This section is *optional* and not required.
{% endhint %}

Specifies configuration options for others connecting to the stacks node.

| Name                                  | Required | Description                                                                                                                                                 |
| ------------------------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
| public\_ip\_address                   |          | Public IPv4 to advertise to other nodes                                                                                                                     |
| download\_interval                    |          | Time (in seconds) between attempts to download blocks                                                                                                       |
| walk\_interval                        |          | Time (in seconds) between attempts to walk the list of neighbors                                                                                            |
| private\_neighbors                    |          | If false, this node won't announce or accept neighbors that are behind private networks. Defaults to true.                                                  |
| read\_only\_call\_limit\_read\_length |          | Total number of bytes allowed to be read by an individual read-only function call                                                                           |
| read\_only\_call\_limit\_read\_count  |          | Total number of independent read operations permitted for an individual read-only function call                                                             |
| read\_only\_call\_limit\_runtime      |          | [Runtime cost](https://github.com/stacksgov/sips/blob/main/sips/sip-006/sip-006-runtime-cost-assessment.md) limit for an individual read-only function call |

#### burnchain

This section contains configuration options pertaining to the blockchain the stacks-node binds to on the backend for proof-of-transfer (BTC).

| Name       | Required | Description                                                                                                           |
| ---------- | -------- | --------------------------------------------------------------------------------------------------------------------- |
| chain      | ✓        | The blockchain stacks-node binds to on the backend for proof-of-transfer. Only value supported: `bitcoin`             |
| mode       | ✓        | The profile or test phase of which to run stacks-node. Valid values are \[ `mocknet`, `testnet`, `xenon`, `mainnet` ] |
| peer\_host |          | FQDN of the host running the backend Bitcoin blockchain                                                               |
| rpc\_port  |          | RPC port of `peer_host`                                                                                               |
| peer\_port |          | P2P port of `peer_host`                                                                                               |

**Mining**

| Name                             | Required | Description                                                                                        |
| -------------------------------- | -------- | -------------------------------------------------------------------------------------------------- |
| burn\_fee\_cap                   | ✓        | Maximum amount (in sats) of "burn commitment" to broadcast for the next block's leader election    |
| satoshis\_per\_byte              | ✓        | [Amount (in sats) per byte](https://bitcoinfees.net/) - Used to calculate the transaction fees     |
| commit\_anchor\_block\_within    |          | Sets the time period (in milliseconds) for commitments. Only used when `mode` is set to `mocknet`. |
| tenure\_extend\_cost\_threshold  |          | Percentage of block budget that must be used before attempting a time-based tenure extend          |
| block\_rejection\_timeout\_steps |          | Define the timeout to apply while waiting for signers responses, based on the amount of rejections |

#### ustx\_balance

{% hint style="info" %}
This section is only required for the `testnet` and `mocknet` networks.

However, if this section is added, **all** fields are required.
{% endhint %}

This section contains configuration options allocating microSTX per address in the genesis block

This section can repeat multiple times, but each section can only define a single address.

| Name    | Required | Description                                                           |
| ------- | -------- | --------------------------------------------------------------------- |
| address | ✓        | Address which maintains a microSTX balance                            |
| amount  | ✓        | The balance of microSTX given to the address at the start of the node |

### Example Mainnet Follower Configuration

{% code title="stacks-node-mainnet.toml" %}

```toml
[node]
working_dir = "/stacks-blockchain"
rpc_bind = "0.0.0.0:30443"
p2p_bind = "0.0.0.0:20444"
bootstrap_node = "02196f005965cebe6ddc3901b7b1cc1aa7a88f305bb8c5893456b8f9a605923893@seed.mainnet.hiro.so:20444,02539449ad94e6e6392d8c1deb2b4e61f80ae2a18964349bc14336d8b903c46a8c@cet.stacksnodes.org:20444,02ececc8ce79b8adf813f13a0255f8ae58d4357309ba0cedd523d9f1a306fcfb79@sgt.stacksnodes.org:20444,0303144ba518fe7a0fb56a8a7d488f950307a4330f146e1e1458fc63fb33defe96@est.stacksnodes.org:20444"

[burnchain]
chain = "bitcoin"
mode = "mainnet"
peer_host = "localhost"
peer_port = 8333

[[events_observer]]
endpoint = "localhost:3700"
events_keys = ["*"]
```

{% endcode %}

### Example Testnet Follower Configuration

{% code title="stacks-node-testnet.toml" %}

```toml
[node]

rpc_bind = "0.0.0.0:20443"
p2p_bind = "0.0.0.0:20444"
bootstrap_node = "029266faff4c8e0ca4f934f34996a96af481df94a89b0c9bd515f3536a95682ddc@seed.testnet.hiro.so:30444"
prometheus_bind = "127.0.0.1:9153"
working_dir = "/stacks-blockchain"

[burnchain]
chain = "bitcoin"
mode = "krypton"
peer_host = "bitcoin.regtest.hiro.so"
peer_port = 18444
pox_prepare_length = 100
pox_reward_length = 900

[[ustx_balance]]
address = "ST2QKZ4FKHAH1NQKYKYAYZPY440FEPK7GZ1R5HBP2"
amount = 10000000000000000

[[ustx_balance]]
address = "ST319CF5WV77KYR1H3GT0GZ7B8Q4AQPY42ETP1VPF"
amount = 10000000000000000

[[ustx_balance]]
address = "ST221Z6TDTC5E0BYR2V624Q2ST6R0Q71T78WTAX6H"
amount = 10000000000000000

[[ustx_balance]]
address = "ST2TFVBMRPS5SSNP98DQKQ5JNB2B6NZM91C4K3P7B"
amount = 10000000000000000

[fee_estimation]
fee_estimator = "fuzzed_weighted_median_fee_rate"

[[burnchain.epochs]]
epoch_name = "1.0"
start_height = 0

[[burnchain.epochs]]
epoch_name = "2.0"
start_height = 0

[[burnchain.epochs]]
epoch_name = "2.05"
start_height = 1

[[burnchain.epochs]]
epoch_name = "2.1"
start_height = 2

[[burnchain.epochs]]
epoch_name = "2.2"
start_height = 3

[[burnchain.epochs]]
epoch_name = "2.3"
start_height = 4

[[burnchain.epochs]]
epoch_name = "2.4"
start_height = 5

[[burnchain.epochs]]
epoch_name = "2.5"
start_height = 6

[[burnchain.epochs]]
epoch_name = "3.0"
start_height = 1_900

[[burnchain.epochs]]
epoch_name = "3.1"
start_height = 2_000

[[burnchain.epochs]]
epoch_name = "3.2"
start_height = 71_525
```

{% endcode %}


# Signer Configuration

{% hint style="info" %}
Note that in this version, the Stacks node will not boot if it sees config values that are unused. If your node is not booting, be sure to check your logs for any messages indicating
{% endhint %}

## Signer Configuration

#### Signer Configuration File Options

The signer configuration file is a TOML file that contains the configuration options for your signer. Below are the options you can set in the signer configuration file.

| Name                         | Required | Description                                                                                                                                                                                                                                                                                   |
| ---------------------------- | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| node\_host                   | ✓        | IP:PORT where your Stacks node can be accessed. The port 20443 is the default RPC endpoint for Stacks nodes. Note that you must use an IP address - DNS hosts are not supported at this time.                                                                                                 |
| endpoint                     | ✓        | IP:PORT where the signer will expose an RPC endpoint for receiving events from your Stacks node.                                                                                                                                                                                              |
| stacks\_private\_key         | ✓        | Hex representation of the signer's Stacks private key used for communicating with the Stacks Node, including writing to the Stacker DB instance.                                                                                                                                              |
| network                      | ✓        | Network to use. One of "mainnet", "testnet" or "mocknet".                                                                                                                                                                                                                                     |
| auth\_password               | ✓        | Authorization token for HTTP requests made from the signer to your Stacks node.                                                                                                                                                                                                               |
| db\_path                     | ✓        | Path to the signer's database file                                                                                                                                                                                                                                                            |
| block\_proposal\_timeout\_ms |          | Specifies the maximum time (in milliseconds) a signer waits after a Bitcoin block for a miner to produce their first Nakamoto block. If the miner exceeds this time, the signer marks their tenure as invalid and rejects subsequent block proposals. Default value of 600\_000 (10 minutes). |
| metrics\_endpoint            |          | IP:PORT for Prometheus metrics collection.                                                                                                                                                                                                                                                    |
| chain\_id                    |          | An optional ChainID, only used for custom networks (like Nakamoto Testnet)                                                                                                                                                                                                                    |

#### Example Configs

Below are sample configuration files for running a Stacks node and signer provided in one place for convenience. You'll need to modify some of these according to the [How to Run a Signer](https://docs.stacks.co/reference/node-operations/broken-reference) doc.

#### Testnet Signer

```toml
# The IP address and port where your Stacks node can be accessed.
# The port 20443 is the default RPC endpoint for Stacks nodes.
# Note that you must use an IP address - DNS hosts are not supported at this time.
# This should be the IP address accessible via Docker, usually via a network.
node_host = "127.0.0.1:20443"

# This is the location where the signer will expose an RPC endpoint for
# receiving events from your Stacks node.
endpoint = "127.0.0.1:30000"

# Either “testnet” or “mainnet”
network = "testnet"

# this is a file path where your signer will persist data. If using Docker,
# this must be within a volume, so that data can be persisted across restarts
db_path = "/var/stacks/signer.sqlite"

# an authentication token that is used for some HTTP requests made from the
# signer to your Stacks node. You’ll need to use this later on when configuring
# your Stacks node. You create this field yourself, rather than it being generated
# with your private key.
auth_password = "$your_http_auth_token"

# This is the privateKey field from the keys you generated in the
# previous step.
stacks_private_key = "$your_stacks_private_key"
```

#### Stacks Node Testnet Config

{% hint style="warning" %}
Note that the `block_proposal_token` field has changed to `auth_token` in the Stacks node configuration file.
{% endhint %}

This is the configuration you'll need to run a Stacks follower node if you are also running a signer. Be sure to change the commented lines to the appropriate data for your setup. If you are not familiar with the process of setting up a signer, be sure to follow the [How to Run a Signer](https://docs.stacks.co/reference/node-operations/broken-reference) guide.

An overview of all Stacks node configuration options can be found in the [Stacks Node Configuration](https://docs.stacks.co/reference/node-operations/broken-reference) doc.

Additions necessary specifically to run a signer are the `[connection_options]` and `[[events_observer]]` sections and the `stacker = true` line. There are also a few comments detailing other lines that need to change.

```toml
[node]

rpc_bind = "0.0.0.0:20443"
p2p_bind = "0.0.0.0:20444"
bootstrap_node = "029266faff4c8e0ca4f934f34996a96af481df94a89b0c9bd515f3536a95682ddc@seed.testnet.hiro.so:30444"
prometheus_bind = "127.0.0.1:9153"
working_dir = "/hirosystems/data"
local_peer_seed = "{{ redacted }}"

# Required for nodes attached to signers, optional for other nodes
stacker = true

[burnchain]
chain = "bitcoin"
mode = "krypton"
peer_host = "bitcoin.regtest.hiro.so"
peer_port = 18444
pox_prepare_length = 100
pox_reward_length = 900

# Set your auth token, which the signer uses
# This should match the auth_password field of your signer config
[connection_options]
auth_token = "12345"

# Set your signer as an event observer
[[events_observer]]

# This endpoint is where your signer will communicate with your Stacks node
endpoint = "127.0.0.1:30000"
events_keys = ["stackerdb", "block_proposal", "burn_blocks"]

[[ustx_balance]]
address = "ST2QKZ4FKHAH1NQKYKYAYZPY440FEPK7GZ1R5HBP2"
amount = 10000000000000000

[[ustx_balance]]
address = "ST319CF5WV77KYR1H3GT0GZ7B8Q4AQPY42ETP1VPF"
amount = 10000000000000000

[[ustx_balance]]
address = "ST221Z6TDTC5E0BYR2V624Q2ST6R0Q71T78WTAX6H"
amount = 10000000000000000

[[ustx_balance]]
address = "ST2TFVBMRPS5SSNP98DQKQ5JNB2B6NZM91C4K3P7B"
amount = 10000000000000000

[fee_estimation]
fee_estimator = "fuzzed_weighted_median_fee_rate"

[[burnchain.epochs]]
epoch_name = "1.0"
start_height = 0

[[burnchain.epochs]]
epoch_name = "2.0"
start_height = 0

[[burnchain.epochs]]
epoch_name = "2.05"
start_height = 1

[[burnchain.epochs]]
epoch_name = "2.1"
start_height = 2

[[burnchain.epochs]]
epoch_name = "2.2"
start_height = 3

[[burnchain.epochs]]
epoch_name = "2.3"
start_height = 4

[[burnchain.epochs]]
epoch_name = "2.4"
start_height = 5

[[burnchain.epochs]]
epoch_name = "2.5"
start_height = 6

[[burnchain.epochs]]
epoch_name = "3.0"
start_height = 1_900

[[burnchain.epochs]]
epoch_name = "3.1"
start_height = 2_000

[[burnchain.epochs]]
epoch_name = "3.2"
start_height = 71_525
```

#### Mainnet Signer

This config is very similar to the testnet config, except the `network` field is changed.

```toml
# The IP address and port where your Stacks node can be accessed.
# The port 20443 is the default RPC endpoint for Stacks nodes.
# Note that you must use an IP address - DNS hosts are not supported at this time.
# This should be the IP address accessible via Docker, usually via a network.
node_host = "127.0.0.1:20443"

# This is the location where the signer will expose an RPC endpoint for
# receiving events from your Stacks node.
endpoint = "127.0.0.1:30000"

# Either “testnet” or “mainnet”
network = "mainnet"

# this is a file path where your signer will persist data. If using Docker,
# this must be within a volume, so that data can be persisted across restarts
db_path = "/var/stacks/signer.sqlite"

# an authentication token that is used for some HTTP requests made from the
# signer to your Stacks node. You’ll need to use this later on when configuring
# your Stacks node. You create this field yourself, rather than it being generated
# with your private key.
auth_password = "$your_http_auth_token"

# This is the privateKey field from the keys you generated in the
# previous step.
stacks_private_key = "$your_stacks_private_key"

# The IP address and port where prometheus metrics can be accessed.
metrics_endpoint = "127.0.0.1:9154"

# Determining when a time-based tenure extend will be accepted
tenure_idle_timeout_secs = 120
```

#### Mainnet Stacks Node

With a mainnet Stacks node config, you'll need to change the bootstrap node field and the burnchain fields. Other than that, the `ustx_balance` fields are not necessary.

```toml
[node]

# Set this based on where you downloaded
# the chain state archive as described in the How to Run a Signer guide:
working_dir = "/data-dir-somewhere"
rpc_bind = "0.0.0.0:20443"
p2p_bind = "0.0.0.0:20444"

# This is the node that your node will use to begin syncing chain state
bootstrap_node = "02196f005965cebe6ddc3901b7b1cc1aa7a88f305bb8c5893456b8f9a605923893@seed.mainnet.hiro.so:20444,02539449ad94e6e6392d8c1deb2b4e61f80ae2a18964349bc14336d8b903c46a8c@cet.stacksnodes.org:20444,02ececc8ce79b8adf813f13a0255f8ae58d4357309ba0cedd523d9f1a306fcfb79@sgt.stacksnodes.org:20444,0303144ba518fe7a0fb56a8a7d488f950307a4330f146e1e1458fc63fb33defe96@est.stacksnodes.org:20444"

# Required for nodes attached to signers, optional for other nodes
stacker = true

[burnchain]
chain = "bitcoin"
mode = "mainnet"
peer_host = "bitcoin.mainnet.stacks.org"

# Set your auth token, which the signer uses
# This should match the auth_password field of your signer config
[connection_options]
auth_token = "12345"

# Set your signer as an event observer
[[events_observer]]

# This endpoint is where your signer will communicate with your Stacks node
endpoint = "127.0.0.1:30000"
events_keys = ["stackerdb", "block_proposal", "burn_blocks"]
```


# RPC API

### Introduction

The Stacks Blockchain API allows you to query the Stacks blockchain and interact with smart contracts. It was built to maintain pageable materialized views of the Stacks Blockchain.

Note that the [Stacks Node RPC API](https://github.com/stacks-network/stacks-blockchain/) and the [Hiro Stacks API](https://www.hiro.so/stacks-api) are two different things. The Hiro API is a centralized service run by Hiro, a developer tooling company, that makes it easy to get onboarded and begin interacting with the Stacks blockchain in a RESTful way. You can also [run your own API server](https://docs.hiro.so/get-started/running-api-node).

The Hiro Stacks API is a proxy for the Stacks Node API that makes it a bit easier to work with by providing additional functionality.

The RPC API is generated by every Stacks node and allows developers to self-host their own node and API for a more decentralized architecture.

The RPC API can be used without any authorization. The basepath for the API is:

```bash
# for mainnet, replace `testnet` with `mainnet`
https://api.testnet.hiro.so/
```

{% hint style="warning" %}
If you run a local node, it exposes an HTTP server on port `20443`. The info endpoint would be `localhost:20443/v2/info`.
{% endhint %}

***

### Stacks Node RPC API endpoints

The Stacks Blockchain RPC API is exposed by every running Stacks node. Below is an interactive list of common RPC endpoints.

## Broadcast raw transaction

> Broadcast raw transactions on the network. You can use the \[@stacks/transactions]\(<https://github.com/blockstack/stacks.js)\\>
> project to generate a raw transaction payload.\
> \
> The node performs static validation checks on transactions before accepting them into the mempool, including:\
> \- Transaction format validation\
> \- Signature verification\
> \- Nonce checking\
> \- Fee validation\
> \- Size limits<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Transactions","description":"Operations related to broadcasting and retrieving transactions."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/transactions":{"post":{"summary":"Broadcast raw transaction","tags":["Transactions"],"description":"Broadcast raw transactions on the network. You can use the [@stacks/transactions](https://github.com/blockstack/stacks.js)\nproject to generate a raw transaction payload.\n\nThe node performs static validation checks on transactions before accepting them into the mempool, including:\n- Transaction format validation\n- Signature verification\n- Nonce checking\n- Fee validation\n- Size limits\n","operationId":"broadcastTransaction","requestBody":{"content":{"application/octet-stream":{"schema":{"type":"string","format":"binary"}},"application/json":{"schema":{"type":"object","required":["tx"],"properties":{"tx":{"type":"string","pattern":"^[0-9a-f]+$","description":"Hex-encoded transaction"},"attachment":{"type":"string","pattern":"^[0-9a-f]+$","description":"Optional hex-encoded attachment for contract-call transactions"}}}}}},"responses":{"200":{"description":"Transaction ID of successful post of a raw tx to the node's mempool.","content":{"application/json":{"schema":{"type":"string","pattern":"^[0-9a-f]{64}$"}}}},"400":{"description":"Bad request","content":{"application/json":{"schema":{"$ref":"#/components/schemas/TransactionSubmissionError"}}}},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"schemas":{"TransactionSubmissionError":{"$ref":"#/x-ext/42bf70d"}},"responses":{"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get specific data-map inside a contract

> Attempt to fetch data from a contract data map. The contract is\
> identified with \[Stacks Address] and \[Contract Name] in the URL path.\
> The map is identified with \[Map Name].\
> \
> The key to lookup in the map is supplied via the POST body. This should\
> be supplied as the hex string serialization of the key (which should be\
> a Clarity value). Note, this is a JSON string.\
> \
> The response is a JSON object with the following properties:\
> \- \`data\`: The hex serialization of the map response. Note that map\
> &#x20; responses are Clarity option types, for non-existent values, this is\
> &#x20; a serialized none, and for all other responses, it is a serialized\
> &#x20; (some ...) object.\
> \- \`proof\`: The hex serialization of the Merkle proof for the data.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Smart Contracts","description":"Endpoints for interacting with Clarity smart contracts."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/map_entry/{contract_address}/{contract_name}/{map_name}":{"post":{"summary":"Get specific data-map inside a contract","tags":["Smart Contracts"],"operationId":"getContractDataMapEntry","description":"Attempt to fetch data from a contract data map. The contract is\nidentified with [Stacks Address] and [Contract Name] in the URL path.\nThe map is identified with [Map Name].\n\nThe key to lookup in the map is supplied via the POST body. This should\nbe supplied as the hex string serialization of the key (which should be\na Clarity value). Note, this is a JSON string.\n\nThe response is a JSON object with the following properties:\n- `data`: The hex serialization of the map response. Note that map\n  responses are Clarity option types, for non-existent values, this is\n  a serialized none, and for all other responses, it is a serialized\n  (some ...) object.\n- `proof`: The hex serialization of the Merkle proof for the data.\n","parameters":[{"$ref":"#/x-ext/7ec52b8"},{"$ref":"#/x-ext/5e1231d"},{"name":"map_name","in":"path","required":true,"schema":{"$ref":"#/components/schemas/ClarityName"}},{"$ref":"./components/parameters/proof.yaml"},{"$ref":"./components/parameters/tip.yaml"}],"requestBody":{"description":"Hex string serialization of the lookup key (which should be a Clarity value)","required":true,"content":{"application/json":{"schema":{"type":"string"}}}},"responses":{"200":{"description":"Success","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ClarityData"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"schemas":{"ClarityName":{"$ref":"#/x-ext/f80f851"},"ClarityData":{"$ref":"#/x-ext/0679af2"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get contract interface

> Get contract interface using a \`contract\_address\` and \`contract name\`

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Smart Contracts","description":"Endpoints for interacting with Clarity smart contracts."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/contracts/interface/{contract_address}/{contract_name}":{"get":{"summary":"Get contract interface","description":"Get contract interface using a `contract_address` and `contract name`","tags":["Smart Contracts"],"operationId":"getContractInterface","parameters":[{"$ref":"#/x-ext/7ec52b8"},{"$ref":"#/x-ext/5e1231d"},{"$ref":"./components/parameters/tip.yaml"}],"responses":{"200":{"description":"Contract interface","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ContractInterface"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"schemas":{"ContractInterface":{"$ref":"#/x-ext/480dca7"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get contract source

> Returns the Clarity source code of a given contract, along with the\
> block height it was published in, and the MARF proof for the data.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Smart Contracts","description":"Endpoints for interacting with Clarity smart contracts."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/contracts/source/{contract_address}/{contract_name}":{"get":{"summary":"Get contract source","tags":["Smart Contracts"],"operationId":"getContractSource","description":"Returns the Clarity source code of a given contract, along with the\nblock height it was published in, and the MARF proof for the data.\n","parameters":[{"$ref":"#/x-ext/7ec52b8"},{"$ref":"#/x-ext/5e1231d"},{"$ref":"./components/parameters/proof.yaml"},{"$ref":"./components/parameters/tip.yaml"}],"responses":{"200":{"description":"Success","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ContractSource"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"schemas":{"ContractSource":{"$ref":"#/x-ext/e51fc16"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Call read-only function

> Call a read-only public function on a given contract.\
> \
> The contract is identified with \[Stacks Address] and \[Contract Name] in the URL path.\
> The function is identified with \[Function Name].\
> \
> The arguments to the function are supplied via the POST body.\
> This should be a JSON object with two main properties:\
> \- \`sender\` which should be a standard Stacks address\
> \- \`arguments\` which should be an array of hex-encoded Clarity values.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Smart Contracts","description":"Endpoints for interacting with Clarity smart contracts."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/contracts/call-read/{contract_address}/{contract_name}/{function_name}":{"post":{"summary":"Call read-only function","description":"Call a read-only public function on a given contract.\n\nThe contract is identified with [Stacks Address] and [Contract Name] in the URL path.\nThe function is identified with [Function Name].\n\nThe arguments to the function are supplied via the POST body.\nThis should be a JSON object with two main properties:\n- `sender` which should be a standard Stacks address\n- `arguments` which should be an array of hex-encoded Clarity values.\n","tags":["Smart Contracts"],"operationId":"callReadOnlyFunction","parameters":[{"$ref":"#/x-ext/7ec52b8"},{"$ref":"#/x-ext/5e1231d"},{"name":"function_name","in":"path","required":true,"schema":{"$ref":"#/components/schemas/ClarityName"}},{"$ref":"./components/parameters/tip.yaml"}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ReadOnlyFunctionArgs"}}}},"responses":{"200":{"description":"Function executed successfully","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ReadOnlyFunctionResult"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"schemas":{"ClarityName":{"$ref":"#/x-ext/f80f851"},"ReadOnlyFunctionArgs":{"$ref":"#/x-ext/a589553"},"ReadOnlyFunctionResult":{"$ref":"#/x-ext/653d32f"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Call read-only function in fast mode (no cost and memory tracking)

> Call a read-only public function on a given smart contract without cost tracking.\
> \
> The contract is identified with \[Stacks Address] and \[Contract Name] in the URL path.\
> The function is identified with \[Function Name].\
> \
> The arguments to the function are supplied via the POST body.\
> This should be a JSON object with two main properties:\
> \- \`sender\` which should be a standard Stacks address\
> \- \`arguments\` which should be an array of hex-encoded Clarity values.\
> \
> \*\*This API endpoint requires a basic Authorization header.\*\*<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Smart Contracts","description":"Endpoints for interacting with Clarity smart contracts."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[{"rpcAuth":[]}],"components":{"securitySchemes":{"rpcAuth":{"type":"apiKey","in":"header","name":"authorization","description":"Plain-text secret value that must exactly equal the node's\nconfigured password.\n"}},"schemas":{"ClarityName":{"$ref":"#/x-ext/f80f851"},"ReadOnlyFunctionArgs":{"$ref":"#/x-ext/a589553"},"ReadOnlyFunctionResult":{"$ref":"#/x-ext/653d32f"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"Timeout":{"description":"Timeout","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}},"paths":{"/v3/contracts/fast-call-read/{contract_address}/{contract_name}/{function_name}":{"post":{"summary":"Call read-only function in fast mode (no cost and memory tracking)","description":"Call a read-only public function on a given smart contract without cost tracking.\n\nThe contract is identified with [Stacks Address] and [Contract Name] in the URL path.\nThe function is identified with [Function Name].\n\nThe arguments to the function are supplied via the POST body.\nThis should be a JSON object with two main properties:\n- `sender` which should be a standard Stacks address\n- `arguments` which should be an array of hex-encoded Clarity values.\n\n**This API endpoint requires a basic Authorization header.**\n","tags":["Smart Contracts"],"operationId":"fastCallReadOnlyFunction","parameters":[{"$ref":"#/x-ext/7ec52b8"},{"$ref":"#/x-ext/5e1231d"},{"name":"function_name","in":"path","required":true,"schema":{"$ref":"#/components/schemas/ClarityName"}},{"$ref":"./components/parameters/tip.yaml"}],"requestBody":{"description":"map of arguments and the simulated tx-sender where sender is either a Contract identifier or a normal Stacks address, and arguments is an array of hex serialized Clarity values.","required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ReadOnlyFunctionArgs"}}}},"responses":{"200":{"description":"Function executed successfully","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ReadOnlyFunctionResult"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"408":{"$ref":"#/components/responses/Timeout"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}}}
```

## Get account info

> Get the account data for the provided principal\
> \
> Where balance is the hex encoding of a unsigned 128-bit integer (big-endian), nonce is a unsigned 64-bit integer, and the proofs are provided as hex strings.\
> \
> For non-existent accounts, this does not 404, rather it returns an object with balance and nonce of 0.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Accounts","description":"Endpoints for retrieving account information."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/accounts/{principal}":{"get":{"summary":"Get account info","tags":["Accounts"],"operationId":"getAccountInfo","description":"Get the account data for the provided principal\n\nWhere balance is the hex encoding of a unsigned 128-bit integer (big-endian), nonce is a unsigned 64-bit integer, and the proofs are provided as hex strings.\n\nFor non-existent accounts, this does not 404, rather it returns an object with balance and nonce of 0.\n","parameters":[{"$ref":"./components/parameters/principal.yaml"},{"$ref":"./components/parameters/proof.yaml"},{"$ref":"./components/parameters/tip.yaml"}],"responses":{"200":{"description":"Success","content":{"application/json":{"schema":{"$ref":"#/components/schemas/AccountData"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"schemas":{"AccountData":{"$ref":"#/x-ext/83aa21e"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get approximate fees for the given transaction

> Get an estimated fee for the supplied transaction.  This\
> estimates the execution cost of the transaction, the current\
> fee rate of the network, and returns estimates for fee\
> amounts.\
> \
> \* \`transaction\_payload\` is a hex-encoded serialization of\
> &#x20; the TransactionPayload for the transaction.\
> \* \`estimated\_len\` is an optional argument that provides the\
> &#x20; endpoint with an estimation of the final length (in bytes)\
> &#x20; of the transaction, including any post-conditions and\
> &#x20; signatures\
> \
> If the node cannot provide an estimate for the transaction\
> (e.g., if the node has never seen a contract-call for the\
> given contract and function) or if estimation is not\
> configured on this node, a 400 response is returned.\
> The 400 response will be a JSON error containing a \`reason\`\
> field which can be one of the following:\
> \
> \* \`DatabaseError\` - this Stacks node has had an internal\
> &#x20; database error while trying to estimate the costs of the\
> &#x20; supplied transaction.\
> \* \`NoEstimateAvailable\` - this Stacks node has not seen this\
> &#x20; kind of contract-call before, and it cannot provide an\
> &#x20; estimate yet.\
> \* \`CostEstimationDisabled\` - this Stacks node does not perform\
> &#x20; fee or cost estimation, and it cannot respond on this\
> &#x20; endpoint.\
> \
> The 200 response contains the following data:\
> \
> \* \`estimated\_cost\` - the estimated multi-dimensional cost of\
> &#x20; executing the Clarity VM on the provided transaction.\
> \* \`estimated\_cost\_scalar\` - a unitless integer that the Stacks\
> &#x20; node uses to compare how much of the block limit is consumed\
> &#x20; by different transactions. This value incorporates the\
> &#x20; estimated length of the transaction and the estimated\
> &#x20; execution cost of the transaction. The range of this integer\
> &#x20; may vary between different Stacks nodes. In order to compute\
> &#x20; an estimate of total fee amount for the transaction, this\
> &#x20; value is multiplied by the same Stacks node"s estimated fee\
> &#x20; rate.\
> \* \`cost\_scalar\_change\_by\_byte\` - a float value that indicates how\
> &#x20; much the \`estimated\_cost\_scalar\` value would increase for every\
> &#x20; additional byte in the final transaction.\
> \* \`estimations\` - an array of estimated fee rates and total fees to\
> &#x20; pay in microSTX for the transaction. This array provides a range of\
> &#x20; estimates (default: 3) that may be used. Each element of the array\
> &#x20; contains the following fields:\
> &#x20;   \* \`fee\_rate\` - the estimated value for the current fee\
> &#x20;     rates in the network\
> &#x20;   \* \`fee\` - the estimated value for the total fee in\
> &#x20;     microSTX that the given transaction should pay. These\
> &#x20;     values are the result of computing:\
> &#x20;     \`fee\_rate\` x \`estimated\_cost\_scalar\`.\
> &#x20;     If the estimated fees are less than the minimum relay\
> &#x20;     fee \`(1 ustx x estimated\_len)\`, then that minimum relay\
> &#x20;     fee will be returned here instead.\
> \
> \
> Note: If the final transaction"s byte size is larger than\
> supplied to \`estimated\_len\`, then applications should increase\
> this fee amount by:\
> \
> &#x20; \`fee\_rate\` x \`cost\_scalar\_change\_by\_byte\` x (\`final\_size\` - \`estimated\_size\`)<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Fees","description":"Endpoints for fee estimation."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/fees/transaction":{"post":{"summary":"Get approximate fees for the given transaction","tags":["Fees"],"description":"Get an estimated fee for the supplied transaction.  This\nestimates the execution cost of the transaction, the current\nfee rate of the network, and returns estimates for fee\namounts.\n\n* `transaction_payload` is a hex-encoded serialization of\n  the TransactionPayload for the transaction.\n* `estimated_len` is an optional argument that provides the\n  endpoint with an estimation of the final length (in bytes)\n  of the transaction, including any post-conditions and\n  signatures\n\nIf the node cannot provide an estimate for the transaction\n(e.g., if the node has never seen a contract-call for the\ngiven contract and function) or if estimation is not\nconfigured on this node, a 400 response is returned.\nThe 400 response will be a JSON error containing a `reason`\nfield which can be one of the following:\n\n* `DatabaseError` - this Stacks node has had an internal\n  database error while trying to estimate the costs of the\n  supplied transaction.\n* `NoEstimateAvailable` - this Stacks node has not seen this\n  kind of contract-call before, and it cannot provide an\n  estimate yet.\n* `CostEstimationDisabled` - this Stacks node does not perform\n  fee or cost estimation, and it cannot respond on this\n  endpoint.\n\nThe 200 response contains the following data:\n\n* `estimated_cost` - the estimated multi-dimensional cost of\n  executing the Clarity VM on the provided transaction.\n* `estimated_cost_scalar` - a unitless integer that the Stacks\n  node uses to compare how much of the block limit is consumed\n  by different transactions. This value incorporates the\n  estimated length of the transaction and the estimated\n  execution cost of the transaction. The range of this integer\n  may vary between different Stacks nodes. In order to compute\n  an estimate of total fee amount for the transaction, this\n  value is multiplied by the same Stacks node\"s estimated fee\n  rate.\n* `cost_scalar_change_by_byte` - a float value that indicates how\n  much the `estimated_cost_scalar` value would increase for every\n  additional byte in the final transaction.\n* `estimations` - an array of estimated fee rates and total fees to\n  pay in microSTX for the transaction. This array provides a range of\n  estimates (default: 3) that may be used. Each element of the array\n  contains the following fields:\n    * `fee_rate` - the estimated value for the current fee\n      rates in the network\n    * `fee` - the estimated value for the total fee in\n      microSTX that the given transaction should pay. These\n      values are the result of computing:\n      `fee_rate` x `estimated_cost_scalar`.\n      If the estimated fees are less than the minimum relay\n      fee `(1 ustx x estimated_len)`, then that minimum relay\n      fee will be returned here instead.\n\n\nNote: If the final transaction\"s byte size is larger than\nsupplied to `estimated_len`, then applications should increase\nthis fee amount by:\n\n  `fee_rate` x `cost_scalar_change_by_byte` x (`final_size` - `estimated_size`)\n","operationId":"getFeeTransaction","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/FeeTransactionRequest"}}}},"responses":{"200":{"description":"Estimated fees for the transaction","content":{"application/json":{"schema":{"$ref":"#/components/schemas/FeeTransactionResponse"}}}},"400":{"description":"Fee estimation error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/FeeTransactionError"}}}},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"schemas":{"FeeTransactionRequest":{"$ref":"#/x-ext/e8d85ae"},"FeeTransactionResponse":{"$ref":"#/x-ext/60d0d71"},"FeeTransactionError":{"$ref":"#/x-ext/cdeb85d"}},"responses":{"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get estimated fee

> Get an estimated fee rate for STX transfer transactions. This is a fee\
> rate per byte, returned as a JSON integer (microSTX per byte).<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Fees","description":"Endpoints for fee estimation."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/fees/transfer":{"get":{"summary":"Get estimated fee","tags":["Fees"],"operationId":"getFeeTransfer","description":"Get an estimated fee rate for STX transfer transactions. This is a fee\nrate per byte, returned as a JSON integer (microSTX per byte).\n","responses":{"200":{"description":"Fee rate in microSTX per byte","content":{"application/json":{"schema":{"type":"integer","minimum":1,"description":"Fee rate in microSTX per byte"}}}},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"responses":{"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get Core API info

> Get Core API information

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Info","description":"General informational endpoints about the node."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/info":{"get":{"summary":"Get Core API info","description":"Get Core API information","tags":["Info"],"operationId":"getNodeInfo","responses":{"200":{"description":"Success","content":{"application/json":{"schema":{"$ref":"#/components/schemas/NodeInfo"}}}},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"schemas":{"NodeInfo":{"$ref":"#/x-ext/315b0be"}},"responses":{"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get PoX details

> Get Proof of Transfer (PoX) information. Can be used for Stacking.

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Info","description":"General informational endpoints about the node."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/pox":{"get":{"summary":"Get PoX details","description":"Get Proof of Transfer (PoX) information. Can be used for Stacking.","tags":["Info"],"operationId":"getPoxInfo","responses":{"200":{"description":"Success","content":{"application/json":{"schema":{"$ref":"#/components/schemas/PoxInfo"}}}}},"parameters":[{"$ref":"./components/parameters/tip.yaml"}]}}},"components":{"schemas":{"PoxInfo":{"$ref":"#/x-ext/0b86914"}}}}
```

## Get trait implementation details

> Determine whether or not a specified trait is implemented (either\
> explicitly or implicitly) within a given contract.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Smart Contracts","description":"Endpoints for interacting with Clarity smart contracts."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/traits/{contract_address}/{contract_name}/{trait_contract_address}/{trait_contract_name}/{trait_name}":{"get":{"summary":"Get trait implementation details","description":"Determine whether or not a specified trait is implemented (either\nexplicitly or implicitly) within a given contract.\n","tags":["Smart Contracts"],"operationId":"checkTraitImplementation","parameters":[{"$ref":"#/x-ext/7ec52b8"},{"$ref":"#/x-ext/5e1231d"},{"name":"trait_contract_address","in":"path","required":true,"description":"Stacks address of the trait-defining contract.\n","schema":{"type":"string","pattern":"^[0123456789ABCDEFGHJKMNPQRSTVWXYZ]{28,41}$","minLength":28,"maxLength":41}},{"name":"trait_contract_name","in":"path","required":true,"description":"Contract name of the trait-defining contract.","schema":{"type":"string","pattern":"^[a-zA-Z]([a-zA-Z0-9]|[-_]){0,127}$","minLength":1,"maxLength":128}},{"name":"trait_name","in":"path","required":true,"schema":{"$ref":"#/components/schemas/ClarityName"}},{"$ref":"./components/parameters/tip.yaml"}],"responses":{"200":{"description":"Success","content":{"application/json":{"schema":{"$ref":"#/components/schemas/IsTraitImplemented"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"}}}}},"components":{"schemas":{"ClarityName":{"$ref":"#/x-ext/f80f851"},"IsTraitImplemented":{"$ref":"#/x-ext/5c89f26"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get the MARF value for a given key

> Attempt to fetch the value of a MARF key. The key is a 64-character\
> hex string representing the MARF node hash.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Smart Contracts","description":"Endpoints for interacting with Clarity smart contracts."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/clarity/marf/{marf_key_hash}":{"get":{"summary":"Get the MARF value for a given key","tags":["Smart Contracts"],"operationId":"getClarityMarfValue","description":"Attempt to fetch the value of a MARF key. The key is a 64-character\nhex string representing the MARF node hash.\n","responses":{"200":{"description":"Success","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ClarityData"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"}},"parameters":[{"name":"marf_key_hash","in":"path","required":true,"description":"The 64-character hex-encoded hash of the MARF key.","schema":{"type":"string","pattern":"^[0-9a-f]{64}$","minLength":64,"maxLength":64}},{"$ref":"./components/parameters/proof.yaml"},{"$ref":"./components/parameters/tip.yaml"}]}}},"components":{"schemas":{"ClarityData":{"$ref":"#/x-ext/0679af2"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get the contract metadata for the metadata key

> Attempt to fetch the metadata of a contract. The contract is identified\
> with \[Contract Address] and \[Contract Name] in the URL path. The metadata\
> key is identified with \[Clarity Metadata Key].\
> \
> In the response, \`data\` is formatted as JSON.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Smart Contracts","description":"Endpoints for interacting with Clarity smart contracts."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/clarity/metadata/{contract_address}/{contract_name}/{clarity_metadata_key}":{"get":{"summary":"Get the contract metadata for the metadata key","tags":["Smart Contracts"],"operationId":"getClarityMetadata","description":"Attempt to fetch the metadata of a contract. The contract is identified\nwith [Contract Address] and [Contract Name] in the URL path. The metadata\nkey is identified with [Clarity Metadata Key].\n\nIn the response, `data` is formatted as JSON.\n","responses":{"200":{"description":"Success","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ClarityMetadata"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}},"parameters":[{"$ref":"#/x-ext/7ec52b8"},{"$ref":"#/x-ext/5e1231d"},{"name":"clarity_metadata_key","in":"path","required":true,"description":"Metadata key","schema":{"type":"string"}},{"$ref":"./components/parameters/tip.yaml"}]}}},"components":{"schemas":{"ClarityMetadata":{"$ref":"#/x-ext/017aaeb"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get the value of a constant inside a contract

> Attempt to fetch the value of a constant inside a contract. The contract\
> is identified with \[Stacks Address] and \[Contract Name] in the URL path.\
> The constant is identified with \[Constant Name].\
> \
> In the response, \`data\` is the hex serialization of the constant value.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Smart Contracts","description":"Endpoints for interacting with Clarity smart contracts."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/constant_val/{contract_address}/{contract_name}/{constant_name}":{"get":{"summary":"Get the value of a constant inside a contract","tags":["Smart Contracts"],"operationId":"getConstantValue","description":"Attempt to fetch the value of a constant inside a contract. The contract\nis identified with [Stacks Address] and [Contract Name] in the URL path.\nThe constant is identified with [Constant Name].\n\nIn the response, `data` is the hex serialization of the constant value.\n","responses":{"200":{"description":"Success","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ConstantValue"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}},"parameters":[{"$ref":"#/x-ext/7ec52b8"},{"$ref":"#/x-ext/5e1231d"},{"name":"constant_name","in":"path","required":true,"schema":{"$ref":"#/components/schemas/ClarityName"}},{"$ref":"./components/parameters/tip.yaml"}]}}},"components":{"schemas":{"ConstantValue":{"$ref":"#/x-ext/1cfd730"},"ClarityName":{"$ref":"#/x-ext/f80f851"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Validate a proposed Stacks block

> Used by stackers to validate a proposed Stacks block from a miner.\
> \*\*This API endpoint requires a basic Authorization header.\*\*<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Mining","description":"Endpoints related to Stacks block production and mining."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[{"rpcAuth":[]}],"components":{"securitySchemes":{"rpcAuth":{"type":"apiKey","in":"header","name":"authorization","description":"Plain-text secret value that must exactly equal the node's\nconfigured password.\n"}},"schemas":{"BlockProposalResponse":{"$ref":"#/x-ext/c3c2835"}},"responses":{"Unauthorized":{"description":"Unauthorized. Invalid or missing authentication token.","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}},"paths":{"/v3/block_proposal":{"post":{"summary":"Validate a proposed Stacks block","tags":["Mining"],"operationId":"postBlockProposal","description":"Used by stackers to validate a proposed Stacks block from a miner.\n**This API endpoint requires a basic Authorization header.**\n","requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","required":["block","chain_id"],"properties":{"block":{"type":"string","description":"Hex-encoded block data"},"chain_id":{"type":"integer","description":"Chain ID for the block"}}}}}},"responses":{"202":{"description":"Block proposal has been accepted for processing.\nThe result will be returned via the event observer.\n","content":{"application/json":{"schema":{"$ref":"#/components/schemas/BlockProposalResponse"}}}},"400":{"description":"Bad Request","content":{"application/json":{"schema":{"$ref":"#/components/schemas/BlockProposalResponse"}},"text/plain":{"schema":{"type":"string"}}}},"401":{"$ref":"#/components/responses/Unauthorized"},"429":{"description":"There is an ongoing proposal validation being processed, the new\nrequest cannot be accepted until the prior request has been processed.\n","content":{"application/json":{"schema":{"$ref":"#/components/schemas/BlockProposalResponse"}}}},"500":{"$ref":"#/components/responses/InternalServerError"}}}}}}
```

## Fetch the stacker and signer set information for a given cycle.

> Used to get stacker and signer set information for a given cycle.\
> \
> This will only return information for cycles started in Epoch-2.5\
> where PoX-4 was active and subsequent cycles.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Signers","description":"Endpoints for retrieving signer information."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v3/stacker_set/{cycle_number}":{"get":{"summary":"Fetch the stacker and signer set information for a given cycle.","tags":["Signers"],"operationId":"getStackerSet","description":"Used to get stacker and signer set information for a given cycle.\n\nThis will only return information for cycles started in Epoch-2.5\nwhere PoX-4 was active and subsequent cycles.\n","parameters":[{"name":"cycle_number","in":"path","required":true,"description":"reward cycle number","schema":{"type":"integer"}},{"$ref":"./components/parameters/tip.yaml"}],"responses":{"200":{"description":"Information for the given reward cycle","content":{"application/json":{"schema":{"$ref":"#/components/schemas/GetStackerSet"}}}},"400":{"description":"Could not fetch the given reward set","content":{"application/json":{"schema":{"type":"object","required":["response","err_msg"],"properties":{"response":{"type":"string","enum":["error"],"description":"Response status"},"err_type":{"type":"string","description":"Error type classification"},"err_msg":{"type":"string","description":"Detailed error message"}}}}}}}}}},"components":{"schemas":{"GetStackerSet":{"$ref":"#/x-ext/cded7df"}}}}
```

## Get Nakamoto block by ID

> Get a specific Nakamoto block (Stacks 3.x+) by its index block hash. This endpoint streams\
> the block data from the Nakamoto staging blocks database where Nakamoto blocks are stored\
> with additional metadata including tenure information.\
> \
> \*\*Compatibility\*\*: Works with Nakamoto blocks only. For Stacks 2.x blocks, use \`/v2/blocks/{block\_id}\`.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Blocks","description":"Operations for retrieving block and microblock data."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v3/blocks/{block_id}":{"get":{"summary":"Get Nakamoto block by ID","tags":["Blocks"],"operationId":"getNakamotoBlockById","description":"Get a specific Nakamoto block (Stacks 3.x+) by its index block hash. This endpoint streams\nthe block data from the Nakamoto staging blocks database where Nakamoto blocks are stored\nwith additional metadata including tenure information.\n\n**Compatibility**: Works with Nakamoto blocks only. For Stacks 2.x blocks, use `/v2/blocks/{block_id}`.\n","parameters":[{"name":"block_id","in":"path","description":"The block\"s ID hash","required":true,"schema":{"type":"string"}}],"responses":{"200":{"description":"The raw SIP-003-encoded block will be returned.","content":{"application/octet-stream":{"schema":{"type":"string","format":"binary"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Fetch a Nakamoto block by its height and optional tip

> Fetch a Nakamoto block by its height and optional tip.

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Blocks","description":"Operations for retrieving block and microblock data."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v3/blocks/height/{block_height}":{"get":{"summary":"Fetch a Nakamoto block by its height and optional tip","tags":["Blocks"],"operationId":"getNakamotoBlockByHeight","description":"Fetch a Nakamoto block by its height and optional tip.","parameters":[{"name":"block_height","in":"path","description":"The block's height","required":true,"schema":{"type":"integer"}},{"$ref":"./components/parameters/tip.yaml"}],"responses":{"200":{"description":"The raw SIP-003-encoded block will be returned.","content":{"application/octet-stream":{"schema":{"type":"string","format":"binary"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Fetch metadata about the ongoing Nakamoto tenure

> Fetch metadata about the ongoing Nakamoto tenure. This information is\
> sufficient to obtain and authenticate the highest complete tenure, as\
> well as obtain new tenure blocks.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Blocks","description":"Operations for retrieving block and microblock data."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v3/tenures/info":{"get":{"summary":"Fetch metadata about the ongoing Nakamoto tenure","tags":["Blocks"],"operationId":"getTenureInfo","description":"Fetch metadata about the ongoing Nakamoto tenure. This information is\nsufficient to obtain and authenticate the highest complete tenure, as\nwell as obtain new tenure blocks.\n","responses":{"200":{"description":"Metadata about the ongoing tenure","content":{"application/json":{"schema":{"$ref":"#/components/schemas/TenureInfo"}}}}}}}},"components":{"schemas":{"TenureInfo":{"$ref":"#/x-ext/a981077"}}}}
```

## Fetch a sequence of Nakamoto blocks in a tenure

> Fetch a sequence of Nakamoto blocks in a tenure. The blocks will be\
> served in order from highest to lowest. The blocks will be encoded in\
> their SIP-003 wire format, and concatenated together.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Blocks","description":"Operations for retrieving block and microblock data."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v3/tenures/{block_id}":{"get":{"summary":"Fetch a sequence of Nakamoto blocks in a tenure","tags":["Blocks"],"operationId":"getTenures","description":"Fetch a sequence of Nakamoto blocks in a tenure. The blocks will be\nserved in order from highest to lowest. The blocks will be encoded in\ntheir SIP-003 wire format, and concatenated together.\n","parameters":[{"name":"block_id","in":"path","description":"The tenure-start block ID of the tenure to query","required":true,"schema":{"type":"string"}},{"name":"stop","in":"query","description":"The block ID hash of the highest block in this tenure that is already\nknown to the caller. Neither the corresponding block nor any of its\nancestors will be served. This is used to fetch tenure blocks that the\ncaller does not have.\n","required":false,"schema":{"type":"string"}}],"responses":{"200":{"description":"SIP-003-encoded Nakamoto blocks, concatenated together","content":{"application/octet-stream":{"schema":{"type":"string","format":"binary"}}}}}}}}}
```

## Get the list of Stacks blocks in a tenure

> Get the list of blocks in a tenure. The blocks will be\
> shown in order from highest to lowest.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Blocks","description":"Operations for retrieving block and microblock data."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v3/tenures/blocks/{consensus_hash}":{"get":{"summary":"Get the list of Stacks blocks in a tenure","tags":["Blocks"],"operationId":"getTenureBlocks","description":"Get the list of blocks in a tenure. The blocks will be\nshown in order from highest to lowest.\n","parameters":[{"name":"consensus_hash","in":"path","description":"The hex-encoded consensus hash of the tenure to query (40 hexadecimal characters, without 0x prefix)","required":true,"schema":{"type":"string","pattern":"^[0-9a-f]{40}$"}}],"responses":{"200":{"description":"List of Stacks blocks in the tenure","content":{"application/json":{"schema":{"$ref":"#/components/schemas/TenureBlocks"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"schemas":{"TenureBlocks":{"$ref":"#/x-ext/a706cc5"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get the list of Nakamoto Stacks blocks in a tenure given Bitcoin block hash

> Get the list of Nakamoto blocks in a tenure given the Bitcoin block hash. The blocks will be\
> shown in order from highest to lowest. This is only for Nakamoto blocks, Epoch2 ones will not be shown.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Blocks","description":"Operations for retrieving block and microblock data."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v3/tenures/blocks/hash/{burnchain_block_hash}":{"get":{"summary":"Get the list of Nakamoto Stacks blocks in a tenure given Bitcoin block hash","tags":["Blocks"],"operationId":"getTenureBlocksByHash","description":"Get the list of Nakamoto blocks in a tenure given the Bitcoin block hash. The blocks will be\nshown in order from highest to lowest. This is only for Nakamoto blocks, Epoch2 ones will not be shown.\n","parameters":[{"name":"burnchain_block_hash","in":"path","description":"The hex-encoded Bitcoin block hash of the tenure to query (64 hexadecimal characters, without 0x prefix)","required":true,"schema":{"type":"string","pattern":"^[0-9a-f]{64}$"}}],"responses":{"200":{"description":"List of Stacks blocks in the tenure","content":{"application/json":{"schema":{"$ref":"#/components/schemas/TenureBlocks"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"schemas":{"TenureBlocks":{"$ref":"#/x-ext/a706cc5"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get the list of Nakamoto Stacks blocks in a tenure given Bitcoin block height

> Get the list of Nakamoto blocks in a tenure given the Bitcoin block height. The blocks will be\
> shown in order from highest to lowest. This is only for Nakamoto blocks, Epoch2 ones will not be shown.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Blocks","description":"Operations for retrieving block and microblock data."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v3/tenures/blocks/height/{burnchain_block_height}":{"get":{"summary":"Get the list of Nakamoto Stacks blocks in a tenure given Bitcoin block height","tags":["Blocks"],"operationId":"getTenureBlocksByHeight","description":"Get the list of Nakamoto blocks in a tenure given the Bitcoin block height. The blocks will be\nshown in order from highest to lowest. This is only for Nakamoto blocks, Epoch2 ones will not be shown.\n","parameters":[{"name":"burnchain_block_height","in":"path","description":"The Bitcoin block height of the tenure to query","required":true,"schema":{"type":"integer"}}],"responses":{"200":{"description":"List of Stacks blocks in the tenure","content":{"application/json":{"schema":{"$ref":"#/components/schemas/TenureBlocks"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"schemas":{"TenureBlocks":{"$ref":"#/x-ext/a706cc5"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get latest sortition information

> Get sortition information about the latest burnchain block processed by this node.\
> Returns a single-element array with the latest sortition.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Blocks","description":"Operations for retrieving block and microblock data."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v3/sortitions":{"get":{"summary":"Get latest sortition information","tags":["Blocks"],"operationId":"getLatestSortitions","description":"Get sortition information about the latest burnchain block processed by this node.\nReturns a single-element array with the latest sortition.\n","responses":{"200":{"description":"Latest sortition information","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Sortitions"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"schemas":{"Sortitions":{"$ref":"#/x-ext/8229df6"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get latest and last winning sortitions

> Get sortition information about the latest burn block with a winning miner\
> AND the previous such burn block. Returns an array with two sortition objects.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Blocks","description":"Operations for retrieving block and microblock data."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v3/sortitions/latest_and_last":{"get":{"summary":"Get latest and last winning sortitions","tags":["Blocks"],"operationId":"getLatestAndLastWinningSortitions","description":"Get sortition information about the latest burn block with a winning miner\nAND the previous such burn block. Returns an array with two sortition objects.\n","responses":{"200":{"description":"Latest and last sortition information","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Sortitions"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"schemas":{"Sortitions":{"$ref":"#/x-ext/8229df6"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get sortition by consensus hash

> Get sortition information for a specific consensus hash.\
> Returns a single-element array with the matching sortition.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Blocks","description":"Operations for retrieving block and microblock data."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v3/sortitions/consensus/{consensus_hash}":{"get":{"summary":"Get sortition by consensus hash","tags":["Blocks"],"operationId":"getSortitionByConsensusHash","description":"Get sortition information for a specific consensus hash.\nReturns a single-element array with the matching sortition.\n","parameters":[{"name":"consensus_hash","in":"path","required":true,"description":"Hex-encoded consensus hash (40 characters)","schema":{"type":"string","pattern":"^(0x)?[0-9a-f]{40}$"}}],"responses":{"200":{"description":"Sortition information for the consensus hash","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Sortitions"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"schemas":{"Sortitions":{"$ref":"#/x-ext/8229df6"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get sortition by burn header hash

> Get sortition information for a specific burn header hash.\
> Returns a single-element array with the matching sortition.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Blocks","description":"Operations for retrieving block and microblock data."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v3/sortitions/burn/{burn_header_hash}":{"get":{"summary":"Get sortition by burn header hash","tags":["Blocks"],"operationId":"getSortitionByBurnHeaderHash","description":"Get sortition information for a specific burn header hash.\nReturns a single-element array with the matching sortition.\n","parameters":[{"name":"burn_header_hash","in":"path","required":true,"description":"Hex-encoded burn header hash (64 characters)","schema":{"type":"string","pattern":"^(0x)?[0-9a-f]{64}$"}}],"responses":{"200":{"description":"Sortition information for the burn header hash","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Sortitions"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"schemas":{"Sortitions":{"$ref":"#/x-ext/8229df6"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get sortition by burn block height

> Get sortition information for a specific burn block height.\
> Returns a single-element array with the matching sortition.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Blocks","description":"Operations for retrieving block and microblock data."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v3/sortitions/burn_height/{height}":{"get":{"summary":"Get sortition by burn block height","tags":["Blocks"],"operationId":"getSortitionByBurnBlockHeight","description":"Get sortition information for a specific burn block height.\nReturns a single-element array with the matching sortition.\n","parameters":[{"name":"height","in":"path","required":true,"description":"Burn block height (integer)","schema":{"type":"integer","minimum":0}}],"responses":{"200":{"description":"Sortition information for the burn block height","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Sortitions"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"schemas":{"Sortitions":{"$ref":"#/x-ext/8229df6"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get number of blocks signed by signer during a given reward cycle

> Get number of blocks signed by signer during a given reward cycle

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Blocks","description":"Operations for retrieving block and microblock data."},{"name":"Signers","description":"Endpoints for retrieving signer information."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v3/signer/{signer_pubkey}/{cycle_number}":{"get":{"summary":"Get number of blocks signed by signer during a given reward cycle","tags":["Blocks","Signers"],"operationId":"getSignerBlocksSigned","description":"Get number of blocks signed by signer during a given reward cycle","parameters":[{"name":"signer_pubkey","in":"path","required":true,"description":"Hex-encoded compressed Secp256k1 public key of signer","schema":{"type":"string","pattern":"^0[23][0-9a-f]{64}$"}},{"name":"cycle_number","in":"path","required":true,"description":"Reward cycle number","schema":{"type":"integer","minimum":0}},{"$ref":"./components/parameters/tip.yaml"}],"responses":{"200":{"description":"Number of blocks signed","content":{"application/json":{"schema":{"$ref":"#/components/schemas/SignerBlocksSigned"}}}}}}}},"components":{"schemas":{"SignerBlocksSigned":{"$ref":"#/x-ext/21ab5ae"}}}}
```

## Retrieve transaction details by TXID

> Get a JSON with the transaction details including the \`index\_block\_hash\`,\
> the hex-encoded transaction body, and the \`result\`.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Transactions","description":"Operations related to broadcasting and retrieving transactions."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v3/transaction/{txid}":{"get":{"summary":"Retrieve transaction details by TXID","tags":["Transactions"],"description":"Get a JSON with the transaction details including the `index_block_hash`,\nthe hex-encoded transaction body, and the `result`.\n","operationId":"getTransactionById","parameters":[{"name":"txid","in":"path","required":true,"description":"Transaction ID (64 hexadecimal characters)","schema":{"type":"string","pattern":"^[0-9a-f]{64}$"}}],"responses":{"200":{"description":"Transaction JSON with index_block_hash, transaction body and result","content":{"application/json":{"schema":{"$ref":"#/components/schemas/TransactionInfo"}}}},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"},"501":{"description":"Transaction indexing not enabled","content":{"text/plain":{"schema":{"type":"string"}}}}}}}},"components":{"schemas":{"TransactionInfo":{"$ref":"#/x-ext/a3084c1"}},"responses":{"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Query the health of the node.

> Get node health information.\
> A node is considered healthy if its Stacks tip height matches the maximum Stacks tip height observed among its connected peers.\
> This endpoint returns:\
> \- \`difference\_from\_max\_peer\`: The difference in Stacks height between this node and its most advanced peer.\
> \- \`max\_stacks\_height\_of\_neighbors\`: The maximum Stacks height observed among the node"s connected peers.\
> \- \`node\_stacks\_tip\_height\`: The current Stacks tip height of this node.\
> \- \`max\_stacks\_neighbor\_address\`: The address of the most advanced peer. Null if no peer data is available.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Info","description":"General informational endpoints about the node."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v3/health":{"get":{"summary":"Query the health of the node.","description":"Get node health information.\nA node is considered healthy if its Stacks tip height matches the maximum Stacks tip height observed among its connected peers.\nThis endpoint returns:\n- `difference_from_max_peer`: The difference in Stacks height between this node and its most advanced peer.\n- `max_stacks_height_of_neighbors`: The maximum Stacks height observed among the node\"s connected peers.\n- `node_stacks_tip_height`: The current Stacks tip height of this node.\n- `max_stacks_neighbor_address`: The address of the most advanced peer. Null if no peer data is available.\n","tags":["Info"],"operationId":"getNodeHealth","responses":{"200":{"description":"Success","content":{"application/json":{"schema":{"$ref":"#/components/schemas/GetHealth"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"schemas":{"GetHealth":{"$ref":"#/x-ext/3d3a088"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get attachment by hash

> Get an attachment by its hash. Attachments are content stored in the Atlas network.\
> \
> The attachment hash is a 40-character hex string (SHA-1 hash).<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Atlas","description":"Operations related to the Atlas global namespace."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/attachments/{hash}":{"get":{"summary":"Get attachment by hash","tags":["Atlas"],"operationId":"getAttachment","description":"Get an attachment by its hash. Attachments are content stored in the Atlas network.\n\nThe attachment hash is a 40-character hex string (SHA-1 hash).\n","parameters":[{"name":"hash","in":"path","required":true,"description":"Hex-encoded SHA-1 hash of the attachment (40 characters)","schema":{"type":"string","pattern":"^[0-9a-f]{40}$"}}],"responses":{"200":{"description":"The attachment content","content":{"application/json":{"schema":{"$ref":"#/components/schemas/AttachmentData"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"}}}}},"components":{"schemas":{"AttachmentData":{"$ref":"#/x-ext/2c09e89"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get attachment inventory

> Get inventory of attachments for a given index block hash and page range.\
> This returns a bitfield indicating which attachments are available.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Atlas","description":"Operations related to the Atlas global namespace."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/attachments/inv":{"get":{"summary":"Get attachment inventory","tags":["Atlas"],"operationId":"getAttachmentsInventory","description":"Get inventory of attachments for a given index block hash and page range.\nThis returns a bitfield indicating which attachments are available.\n","parameters":[{"name":"index_block_hash","in":"query","required":true,"description":"Hex-encoded index block hash (64 characters)","schema":{"type":"string","pattern":"^[0-9a-f]{64}$"}},{"name":"pages_indexes","in":"query","required":true,"description":"Comma-separated list of page indexes to query","schema":{"type":"string","pattern":"^[0-9]+(,[0-9]+){0,7}$","description":"max 8 pages per request"}}],"responses":{"200":{"description":"Attachment inventory bitfield","content":{"application/json":{"schema":{"$ref":"#/components/schemas/AttachmentInventory"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"}}}}},"components":{"schemas":{"AttachmentInventory":{"$ref":"#/x-ext/81f45e7"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get stream of confirmed microblocks (Epoch 2.x)

> Get microblocks that were confirmed by the given anchored block.\
> The microblocks are returned as a binary stream of concatenated microblock data.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Blocks","description":"Operations for retrieving block and microblock data."},{"name":"Microblocks","description":"Operations for retrieving and submitting microblocks."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/microblocks/confirmed/{block_id}":{"get":{"summary":"Get stream of confirmed microblocks (Epoch 2.x)","tags":["Blocks","Microblocks"],"operationId":"getConfirmedMicroblocks","description":"Get microblocks that were confirmed by the given anchored block.\nThe microblocks are returned as a binary stream of concatenated microblock data.\n","parameters":[{"name":"block_id","in":"path","required":true,"description":"Hex-encoded Stacks block ID (64 characters)","schema":{"type":"string","pattern":"^[0-9a-f]{64}$"}},{"$ref":"./components/parameters/tip.yaml"}],"responses":{"200":{"description":"Stream of confirmed microblocks","content":{"application/octet-stream":{"schema":{"type":"string","format":"binary"}}}},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"responses":{"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## GET /v2/microblocks/{microblock\_id}

> Get a stream of microblocks beginning\
> with the given microblock (Epoch 2.x).<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Blocks","description":"Operations for retrieving block and microblock data."},{"name":"Microblocks","description":"Operations for retrieving and submitting microblocks."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/microblocks/{microblock_id}":{"get":{"summary":"Get a stream of microblocks beginning\nwith the given microblock (Epoch 2.x).\n","tags":["Blocks","Microblocks"],"operationId":"getMicroblockById","parameters":[{"name":"microblock_id","in":"path","required":true,"description":"Hex-encoded microblock hash (64 characters)","schema":{"type":"string","pattern":"^[0-9a-f]{64}$"}}],"responses":{"200":{"description":"The microblock data","content":{"application/octet-stream":{"schema":{"type":"string","format":"binary"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get stream of unconfirmed microblocks (Epoch 2.x)

> Get unconfirmed microblocks starting from a specific sequence number.\
> The microblocks are returned as a binary stream.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Blocks","description":"Operations for retrieving block and microblock data."},{"name":"Microblocks","description":"Operations for retrieving and submitting microblocks."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/microblocks/unconfirmed/{block_id}/{seq}":{"get":{"summary":"Get stream of unconfirmed microblocks (Epoch 2.x)","tags":["Blocks","Microblocks"],"operationId":"getUnconfirmedMicroblocks","description":"Get unconfirmed microblocks starting from a specific sequence number.\nThe microblocks are returned as a binary stream.\n","parameters":[{"name":"block_id","in":"path","required":true,"description":"Hex-encoded parent block ID (64 characters)","schema":{"type":"string","pattern":"^[0-9a-f]{64}$"}},{"name":"seq","in":"path","required":true,"description":"Starting sequence number (0-65535)","schema":{"type":"integer","minimum":0,"maximum":65535}}],"responses":{"200":{"description":"Stream of unconfirmed microblocks","content":{"application/octet-stream":{"schema":{"type":"string","format":"binary"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Submit a microblock (Epoch 2.x)

> Submit a microblock to the node for validation and relay.\
> The body \*\*must\*\* be the SIP-003 binary serialization of a \`Microblock\`\
> and sent with \`Content-Type: application/octet-stream\`.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Blocks","description":"Operations for retrieving block and microblock data."},{"name":"Microblocks","description":"Operations for retrieving and submitting microblocks."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/microblocks":{"post":{"summary":"Submit a microblock (Epoch 2.x)","tags":["Blocks","Microblocks"],"operationId":"postMicroblock","description":"Submit a microblock to the node for validation and relay.\nThe body **must** be the SIP-003 binary serialization of a `Microblock`\nand sent with `Content-Type: application/octet-stream`.\n","requestBody":{"required":true,"content":{"application/octet-stream":{"schema":{"type":"string","format":"binary"}}}},"responses":{"200":{"description":"Index-block hash of the accepted microblock","content":{"application/json":{"schema":{"type":"string","description":"32-byte block-header hash (hex)","pattern":"^[0-9a-f]{64}$"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get StackerDB chunk (latest version)

> Get the latest version of a chunk of data from a StackerDB instance.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"StackerDB","description":"Endpoints for interacting with StackerDB instances."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/stackerdb/{principal}/{contract_name}/{slot_id}":{"get":{"summary":"Get StackerDB chunk (latest version)","tags":["StackerDB"],"operationId":"getStackerDbChunk","description":"Get the latest version of a chunk of data from a StackerDB instance.\n","parameters":[{"$ref":"./components/parameters/principal.yaml"},{"$ref":"#/x-ext/5e1231d"},{"name":"slot_id","in":"path","required":true,"description":"Slot ID","schema":{"type":"integer","minimum":0}}],"responses":{"200":{"description":"StackerDB chunk data","content":{"application/octet-stream":{"schema":{"type":"string","format":"binary"}}}},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"responses":{"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get StackerDB chunk (specific version)

> Get a specific version of a chunk of data from a StackerDB instance.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"StackerDB","description":"Endpoints for interacting with StackerDB instances."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/stackerdb/{principal}/{contract_name}/{slot_id}/{slot_version}":{"get":{"summary":"Get StackerDB chunk (specific version)","tags":["StackerDB"],"operationId":"getStackerDbChunkVersioned","description":"Get a specific version of a chunk of data from a StackerDB instance.\n","parameters":[{"$ref":"./components/parameters/principal.yaml"},{"$ref":"#/x-ext/5e1231d"},{"name":"slot_id","in":"path","required":true,"description":"Slot ID","schema":{"type":"integer","minimum":0}},{"name":"slot_version","in":"path","required":true,"description":"Specific slot version","schema":{"type":"integer","minimum":0}}],"responses":{"200":{"description":"StackerDB chunk data","content":{"application/octet-stream":{"schema":{"type":"string","format":"binary"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get StackerDB metadata

> Get metadata about a StackerDB instance, including slot information.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"StackerDB","description":"Endpoints for interacting with StackerDB instances."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/stackerdb/{principal}/{contract_name}":{"get":{"summary":"Get StackerDB metadata","tags":["StackerDB"],"operationId":"getStackerDbMetadata","description":"Get metadata about a StackerDB instance, including slot information.\n","parameters":[{"$ref":"./components/parameters/principal.yaml"},{"$ref":"#/x-ext/5e1231d"}],"responses":{"200":{"description":"StackerDB metadata","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StackerDbMetadata"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"schemas":{"StackerDbMetadata":{"$ref":"#/x-ext/6b3a047"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Write StackerDB chunk

> Write a chunk of data to a StackerDB instance.\
> \
> The request body should contain a JSON object with the chunk data including\
> slot\_id, slot\_version, signature, and hex-encoded data.\
> \
> The response indicates whether the chunk was accepted, and if not, provides\
> detailed error information. Note that failed writes return HTTP 200 with\
> accepted: false, not HTTP error codes.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"StackerDB","description":"Endpoints for interacting with StackerDB instances."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/stackerdb/{principal}/{contract_name}/chunks":{"post":{"summary":"Write StackerDB chunk","tags":["StackerDB"],"operationId":"postStackerDbChunk","description":"Write a chunk of data to a StackerDB instance.\n\nThe request body should contain a JSON object with the chunk data including\nslot_id, slot_version, signature, and hex-encoded data.\n\nThe response indicates whether the chunk was accepted, and if not, provides\ndetailed error information. Note that failed writes return HTTP 200 with\naccepted: false, not HTTP error codes.\n","parameters":[{"$ref":"./components/parameters/principal.yaml"},{"$ref":"#/x-ext/5e1231d"}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/StackerDbChunkData"}}}},"responses":{"200":{"description":"Chunk submission result (both success and failure cases)","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StackerDbChunkAckData"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"schemas":{"StackerDbChunkData":{"$ref":"#/x-ext/0173c4f"},"StackerDbChunkAckData":{"$ref":"#/x-ext/a0abf33"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## List StackerDB replicas

> Get a list of replicas for a StackerDB instance.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"StackerDB","description":"Endpoints for interacting with StackerDB instances."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/stackerdb/{principal}/{contract_name}/replicas":{"get":{"summary":"List StackerDB replicas","tags":["StackerDB"],"operationId":"listStackerDbReplicas","description":"Get a list of replicas for a StackerDB instance.\n","parameters":[{"$ref":"./components/parameters/principal.yaml"},{"$ref":"#/x-ext/5e1231d"}],"responses":{"200":{"description":"List of StackerDB replicas","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StackerDbReplicas"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"schemas":{"StackerDbReplicas":{"$ref":"#/x-ext/a0fd617"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get contract data variable

> Fetch a data variable from a smart contract.\
> Returns the raw hex-encoded value of the variable.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Smart Contracts","description":"Endpoints for interacting with Clarity smart contracts."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/data_var/{principal}/{contract_name}/{var_name}":{"get":{"summary":"Get contract data variable","tags":["Smart Contracts"],"operationId":"getContractDataVariable","description":"Fetch a data variable from a smart contract.\nReturns the raw hex-encoded value of the variable.\n","parameters":[{"$ref":"./components/parameters/principal.yaml"},{"$ref":"#/x-ext/5e1231d"},{"name":"var_name","in":"path","required":true,"description":"Variable name","schema":{"type":"string"}},{"$ref":"./components/parameters/proof.yaml"},{"$ref":"./components/parameters/tip.yaml"}],"responses":{"200":{"description":"The data variable value","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ClarityData"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"}}}}},"components":{"schemas":{"ClarityData":{"$ref":"#/x-ext/0679af2"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get recent 2.x block headers

> \*\*Deprecated\*\*: This endpoint is deprecated since Nakamoto.\*\*\
> Stream (as a JSON array) up to \`quantity\` most recent anchored Stacks block headers.\
> The result is ordered from the current tip backwards.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Blocks","description":"Operations for retrieving block and microblock data."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/headers/{quantity}":{"get":{"summary":"Get recent 2.x block headers","tags":["Blocks"],"operationId":"getBlockHeaders","description":"**Deprecated**: This endpoint is deprecated since Nakamoto.**\nStream (as a JSON array) up to `quantity` most recent anchored Stacks block headers.\nThe result is ordered from the current tip backwards.\n","parameters":[{"name":"quantity","in":"path","required":true,"description":"Number of headers to return (max 256)","schema":{"type":"integer","minimum":1,"maximum":256}},{"$ref":"./components/parameters/tip.yaml"}],"responses":{"200":{"description":"Array of block headers","content":{"application/json":{"schema":{"$ref":"#/components/schemas/BlockHeaders"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"schemas":{"BlockHeaders":{"$ref":"#/x-ext/4f3e126"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get Stacks 2.x block by ID

> Get a specific Stacks 2.x era block by its block ID. This endpoint streams the block data\
> from the filesystem storage where traditional Stacks blocks are stored as individual files.\
> \
> \*\*Compatibility\*\*: Works with all Stacks 2.x blocks. For Nakamoto blocks (Stacks 3.x+), use \`/v3/blocks/{block\_id}\`.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Blocks","description":"Operations for retrieving block and microblock data."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/blocks/{block_id}":{"get":{"summary":"Get Stacks 2.x block by ID","tags":["Blocks"],"operationId":"getLegacyBlockById","description":"Get a specific Stacks 2.x era block by its block ID. This endpoint streams the block data\nfrom the filesystem storage where traditional Stacks blocks are stored as individual files.\n\n**Compatibility**: Works with all Stacks 2.x blocks. For Nakamoto blocks (Stacks 3.x+), use `/v3/blocks/{block_id}`.\n","parameters":[{"name":"block_id","in":"path","required":true,"description":"Hex-encoded block ID (64 characters)","schema":{"type":"string","pattern":"^[0-9a-f]{64}$"}}],"responses":{"200":{"description":"The block data","content":{"application/octet-stream":{"schema":{"type":"string","format":"binary"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get neighbor peers

> Get information about the node"s neighbor peers in the network.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Info","description":"General informational endpoints about the node."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/neighbors":{"get":{"summary":"Get neighbor peers","tags":["Info"],"operationId":"getNetworkPeers","description":"Get information about the node\"s neighbor peers in the network.\n","responses":{"200":{"description":"List of neighbor peers","content":{"application/json":{"schema":{"$ref":"#/components/schemas/NetworkPeers"}}}}}}}},"components":{"schemas":{"NetworkPeers":{"$ref":"#/x-ext/91808da"}}}}
```

## Get tenure fork information

> Get information about tenure forking between two consensus hashes.\
> This is used to identify conflicting tenures in the Nakamoto consensus.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Blocks","description":"Operations for retrieving block and microblock data."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v3/tenures/fork_info/{start}/{stop}":{"get":{"summary":"Get tenure fork information","tags":["Blocks"],"operationId":"getTenureForkInfo","description":"Get information about tenure forking between two consensus hashes.\nThis is used to identify conflicting tenures in the Nakamoto consensus.\n","parameters":[{"name":"start","in":"path","required":true,"description":"Starting consensus hash (40 hexadecimal characters, without 0x prefix)","schema":{"type":"string","pattern":"^[0-9a-f]{40}$"}},{"name":"stop","in":"path","required":true,"description":"Stopping consensus hash (40 hexadecimal characters, without 0x prefix)","schema":{"type":"string","pattern":"^[0-9a-f]{40}$"}}],"responses":{"200":{"description":"Ordered list of tenure fork events from `stop` back to (and including) `start`","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/TenureForkInfo"}}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"schemas":{"TenureForkInfo":{"$ref":"#/x-ext/a555259"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get tenure tip

> Get the tip block of a tenure identified by consensus hash.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Blocks","description":"Operations for retrieving block and microblock data."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v3/tenures/tip/{consensus_hash}":{"get":{"summary":"Get tenure tip","tags":["Blocks"],"operationId":"getTenureTip","description":"Get the tip block of a tenure identified by consensus hash.\n","parameters":[{"name":"consensus_hash","in":"path","required":true,"description":"Consensus hash (40 characters)","schema":{"type":"string","pattern":"^[0-9a-f]{40}$"}}],"responses":{"200":{"description":"Tenure tip block information","content":{"application/json":{"schema":{"$ref":"#/components/schemas/TenureTip"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"schemas":{"TenureTip":{"$ref":"#/x-ext/6031b30"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Get unconfirmed transaction

> Get an unconfirmed transaction by its transaction ID.\
> This looks in both the mempool and unconfirmed microblock stream.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Transactions","description":"Operations related to broadcasting and retrieving transactions."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/transactions/unconfirmed/{txid}":{"get":{"summary":"Get unconfirmed transaction","tags":["Transactions"],"operationId":"getUnconfirmedTransactionById","description":"Get an unconfirmed transaction by its transaction ID.\nThis looks in both the mempool and unconfirmed microblock stream.\n","parameters":[{"name":"txid","in":"path","required":true,"description":"Transaction ID (64 hexadecimal characters)","schema":{"type":"string","pattern":"^[0-9a-f]{64}$"}}],"responses":{"200":{"description":"Unconfirmed transaction details","content":{"application/json":{"schema":{"$ref":"#/components/schemas/UnconfirmedTransaction"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"schemas":{"UnconfirmedTransaction":{"$ref":"#/x-ext/5d76628"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Upload a Stacks block

> Upload a Stacks block to the node for processing.\
> The block must be in binary format and associated with the given consensus hash.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Mining","description":"Endpoints related to Stacks block production and mining."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/blocks/upload/{consensus_hash}":{"post":{"summary":"Upload a Stacks block","tags":["Mining"],"operationId":"uploadLegacyBlock","description":"Upload a Stacks block to the node for processing.\nThe block must be in binary format and associated with the given consensus hash.\n","parameters":[{"name":"consensus_hash","in":"path","required":true,"description":"Consensus hash (40 hex characters)","schema":{"type":"string","pattern":"^[0-9a-f]{40}$"}}],"requestBody":{"required":true,"content":{"application/octet-stream":{"schema":{"type":"string","format":"binary","description":"Binary-encoded Stacks block"}}}},"responses":{"200":{"description":"Block upload result","content":{"application/json":{"schema":{"$ref":"#/components/schemas/BlockUploadResponse"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"schemas":{"BlockUploadResponse":{"$ref":"#/x-ext/7ac8059"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Query mempool for missing transactions

> Query the mempool for transactions that might be missing from the requesting node.\
> This endpoint supports pagination and streaming of transaction data.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Transactions","description":"Operations related to broadcasting and retrieving transactions."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v2/mempool/query":{"post":{"summary":"Query mempool for missing transactions","tags":["Transactions"],"operationId":"queryMempool","description":"Query the mempool for transactions that might be missing from the requesting node.\nThis endpoint supports pagination and streaming of transaction data.\n","parameters":[{"name":"page_id","in":"query","description":"Transaction ID to start pagination from","schema":{"type":"string","pattern":"^[0-9a-f]{64}$"}}],"requestBody":{"required":true,"content":{"application/octet-stream":{"schema":{"type":"string","format":"binary","description":"Binary SIP-003 encoding of `MemPoolSyncData`\n(`BloomFilter` or `TxTags` variants).\n","properties":{"transactions":{"type":"array","items":{"type":"string","description":"Transaction IDs"}}}}}}},"responses":{"200":{"description":"Stream of missing transactions","content":{"application/octet-stream":{"schema":{"type":"string","format":"binary","description":"Binary stream of transactions and pagination data.\nThe stream contains serialized transactions followed by a page ID for continuation.\n"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

## Upload a Nakamoto block

> Upload a Nakamoto block to the node for processing.\
> \
> \- \*\*Body\*\* - must be the binary (SIP-003) serialization of a \`NakamotoBlock\`.\
> \- \*\*Authentication\*\* - only required when the query parameter \`broadcast=1\` is supplied.\
> &#x20; In that case the caller \*\*must\*\* include an \`Authorization\` header.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Blocks","description":"Operations for retrieving block and microblock data."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[{"rpcAuth":[]},{}],"components":{"securitySchemes":{"rpcAuth":{"type":"apiKey","in":"header","name":"authorization","description":"Plain-text secret value that must exactly equal the node's\nconfigured password.\n"}},"schemas":{"BlockUploadResponse":{"$ref":"#/x-ext/7ac8059"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"Unauthorized":{"description":"Unauthorized. Invalid or missing authentication token.","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}},"paths":{"/v3/blocks/upload":{"post":{"summary":"Upload a Nakamoto block","tags":["Blocks"],"operationId":"uploadNakamotoBlock","description":"Upload a Nakamoto block to the node for processing.\n\n- **Body** - must be the binary (SIP-003) serialization of a `NakamotoBlock`.\n- **Authentication** - only required when the query parameter `broadcast=1` is supplied.\n  In that case the caller **must** include an `Authorization` header.\n","parameters":[{"name":"broadcast","in":"query","description":"If set to `\"1\"` the node will broadcast the uploaded block to peers.\nWhen present the request must include a valid `Authorization` header.\n","schema":{"type":"string","enum":["1"]},"required":false}],"requestBody":{"required":true,"content":{"application/octet-stream":{"schema":{"type":"string","format":"binary","description":"Binary SIP-003 encoding of a `NakamotoBlock`"}}}},"responses":{"200":{"description":"Block upload result.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/BlockUploadResponse"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"401":{"$ref":"#/components/responses/Unauthorized"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}}}
```

## Replay mining of a block and returns its content

> Replay the mining of a block (no data is written in the MARF) and returns its content.<br>

```json
{"openapi":"3.1.0","info":{"title":"Stacks 3.0+ RPC API","version":"1.0.0"},"tags":[{"name":"Blocks","description":"Operations for retrieving block and microblock data."}],"servers":[{"url":"http://localhost:20443","description":"Local Stacks Node"}],"security":[],"paths":{"/v3/blocks/replay/{block_id}":{"get":{"summary":"Replay mining of a block and returns its content","tags":["Blocks"],"operationId":"blockReplay","description":"Replay the mining of a block (no data is written in the MARF) and returns its content.\n","parameters":[{"name":"block_id","in":"path","description":"The block ID hash","required":true,"schema":{"type":"string","pattern":"^[0-9a-f]{64}$"}}],"responses":{"200":{"description":"Content of the replayed block","content":{"application/json":{"schema":{"$ref":"#/components/schemas/BlockReplay"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"$ref":"#/components/responses/NotFound"},"500":{"$ref":"#/components/responses/InternalServerError"}}}}},"components":{"schemas":{"BlockReplay":{"$ref":"#/x-ext/777c51f"}},"responses":{"BadRequest":{"description":"Bad request","content":{"text/plain":{"schema":{"type":"string"}}}},"NotFound":{"description":"Not found","content":{"text/plain":{"schema":{"type":"string"}}}},"InternalServerError":{"description":"Internal Server Error","content":{"text/plain":{"schema":{"type":"string"}}}}}}}
```

***

For details about request/response schemas, consult the Stacks node OpenAPI spec:\
<https://raw.githubusercontent.com/stacks-network/stacks-core/master/docs/rpc/openapi.yaml>


# Functions

The complete reference guide to all Clarity functions.

## \* (multiply)

Introduced in: **Clarity 1**

**input:** `int, ... | uint, ...`\
**output:** `int | uint`\
**signature:** `(* i1 i2...)`

**description:**\
Multiplies a variable number of integer inputs and returns the result. In the event of an *overflow*, throws a runtime error.

**example:**

```clojure
(* 2 3) ;; Returns 6
(* 5 2) ;; Returns 10
(* 2 2 2) ;; Returns 8
```

***

## + (add)

Introduced in: **Clarity 1**

**input:** `int, ... | uint, ...`\
**output:** `int | uint`\
**signature:** `(+ i1 i2...)`

**description:**\
Adds a variable number of integer inputs and returns the result. In the event of an *overflow*, throws a runtime error.

**example:**

```clojure
(+ 1 2 3) ;; Returns 6
```

***

## - (subtract)

Introduced in: **Clarity 1**

**input:** `int, ... | uint, ...`\
**output:** `int | uint`\
**signature:** `(- i1 i2...)`

**description:**\
Subtracts a variable number of integer inputs and returns the result. In the event of an *underflow*, throws a runtime error.

**example:**

```clojure
(- 2 1 1) ;; Returns 0
(- 0 3) ;; Returns -3
```

***

## / (divide)

Introduced in: **Clarity 1**

**input:** `int, ... | uint, ...`\
**output:** `int | uint`\
**signature:** `(/ i1 i2...)`

**description:**\
Integer divides a variable number of integer inputs and returns the result. In the event of division by zero, throws a runtime error.

**example:**

```clojure
(/ 2 3) ;; Returns 0
(/ 5 2) ;; Returns 2
(/ 4 2 2) ;; Returns 1
```

***

## < (less than)

Introduced in: **Clarity 1**

**input:** `int, int | uint, uint | string-ascii, string-ascii | string-utf8, string-utf8 | buff, buff`\
**output:** `bool`\
**signature:** `(< i1 i2)`

**description:**\
Compares two integers (or other comparable types), returning `true` if `i1` is less than `i2` and `false` otherwise. i1 and i2 must be of the same type.

* Starting with Stacks 1.0: comparable types are `int` and `uint`.
* Starting with Stacks 2.1: comparable types also include `string-ascii`, `string-utf8` and `buff`.

**example:**

```clojure
(< 1 2) ;; Returns true
(< 5 2) ;; Returns false
(< "aaa" "baa") ;; Returns true
(< "aa" "aaa") ;; Returns true
(< 0x01 0x02) ;; Returns true
(< 5 u2) ;; Throws type error
```

***

## <= (less than or equal)

Introduced in: **Clarity 1**

**input:** `int, int | uint, uint | string-ascii, string-ascii | string-utf8, string-utf8 | buff, buff`\
**output:** `bool`\
**signature:** `(<= i1 i2)`

**description:**\
Compares two values, returning `true` if `i1` is less than or equal to `i2`. Types must match. Same type support notes as `<`.

**example:**

```clojure
(<= 1 1) ;; Returns true
(<= 5 2) ;; Returns false
(<= "aaa" "baa") ;; Returns true
(<= "aa" "aaa") ;; Returns true
(<= 0x01 0x02) ;; Returns true
(<= 5 u2) ;; Throws type error
```

***

## > (greater than)

Introduced in: **Clarity 1**

**input:** `int, int | uint, uint | string-ascii, string-ascii | string-utf8, string-utf8 | buff, buff`\
**output:** `bool`\
**signature:** `(> i1 i2)`

**description:**\
Compares two values, returning `true` if `i1` is greater than `i2`. Types must match. Same type support notes as `<`.

**example:**

```clojure
(> 1 2) ;; Returns false
(> 5 2) ;; Returns true
(> "baa" "aaa") ;; Returns true
(> "aaa" "aa") ;; Returns true
(> 0x02 0x01) ;; Returns true
(> 5 u2) ;; Throws type error
```

***

## >= (greater than or equal)

Introduced in: **Clarity 1**

**input:** `int, int | uint, uint | string-ascii, string-ascii | string-utf8, string-utf8 | buff, buff`\
**output:** `bool`\
**signature:** `(>= i1 i2)`

**description:**\
Compares two values, returning `true` if `i1` is greater than or equal to `i2`. Types must match. Same type support notes as `<`.

**example:**

```clojure
(>= 1 1) ;; Returns true
(>= 5 2) ;; Returns true
(>= "baa" "aaa") ;; Returns true
(>= "aaa" "aa") ;; Returns true
(>= 0x02 0x01) ;; Returns true
(>= 5 u2) ;; Throws type error
```

***

## and

Introduced in: **Clarity 1**

**input:** `bool, ...`\
**output:** `bool`\
**signature:** `(and b1 b2 ...)`

**description:**\
Returns `true` if all boolean inputs are `true`. Arguments are evaluated in-order and lazily (short-circuits on `false`).

**example:**

```clojure
(and true false) ;; Returns false
(and (is-eq (+ 1 2) 1) (is-eq 4 4)) ;; Returns false
(and (is-eq (+ 1 2) 3) (is-eq 4 4)) ;; Returns true
```

***

## append

Introduced in: **Clarity 1**

**input:** `list A, A`\
**output:** `list`\
**signature:** `(append (list 1 2 3 4) 5)`

**description:**\
Takes a list and a value of the same entry type, and returns a new list with max\_len += 1 (effectively appending the value).

**example:**

```clojure
(append (list 1 2 3 4) 5) ;; Returns (1 2 3 4 5)
```

***

## as-contract?

Introduced in: **Clarity 4**

{% hint style="info" %}
The previous version of `as-contract`, introduced in Clarity 1, has changed to `as-contract?` in Clarity 4, with several new security enhancements. If you are using Clarity 1-3, the previous signature and description for `as-contract` can be found in the dropdown below.
{% endhint %}

<details>

<summary>Previous <code>as-contract</code></summary>

**input:** `A` **output:** `A` **signature:** `(as-contract expr)`

**description:** Executes `expr` with the tx-sender switched to the contract's principal and returns the result.

**example:**

Copy

```
(as-contract tx-sender) ;; Returns S1G2081040G2081040G2081040G208105NK8PE5.docs-test
```

</details>

**Input**:

* `((with-stx|with-ft|with-nft|with-stacking)*|with-all-assets-unsafe)`: The set of allowances (at most 128) to grant during the evaluation of the body expressions. Note that `with-all-assets-unsafe` is mutually exclusive with other allowances.
* `AnyType* A`: The Clarity expressions to be executed within the context, with the final expression returning type `A`, where `A` is not a `response`

**Output**: `(response A uint)`

**Signature**: `(as-contract? ((with-stx|with-ft|with-nft|with-stacking)*|with-all-assets-unsafe) expr-body1 expr-body2 ... expr-body-last)`

**Description**: Switches the current context's `tx-sender` and `contract-caller` values to the contract's principal and executes the body expressions within that context, then checks the asset outflows from the contract against the granted allowances, in declaration order. If any allowance is violated, the body expressions are reverted and an error is returned. Note that the allowance setup expressions are evaluated before executing the body expressions. The final body expression cannot return a `response` value in order to avoid returning a nested `response` value from `as-contract?` (nested responses are error-prone). Returns:

* `(ok x)` if the outflows are within the allowances, where `x` is the result of the final body expression and has type `A`.
* `(err index)` if an allowance was violated, where `index` is the 0-based index of the first violated allowance in the list of granted allowances, or `u128` if an asset with no allowance caused the violation.

**Example**:

```
(define-public (foo)
  (as-contract? ()
    (try! (stx-transfer? u1000000 tx-sender recipient))
  )
) ;; Returns (err u128)
(define-public (bar)
  (as-contract? ((with-stx u1000000))
    (try! (stx-transfer? u1000000 tx-sender recipient))
  )
) ;; Returns (ok true)
```

***

## as-max-len?

Introduced in: **Clarity 1**

**input:** `sequence_A, uint`\
**output:** `(optional sequence_A)`\
**signature:** `(as-max-len? sequence max_length)`

**description:**\
If the sequence length ≤ max\_length, returns `(some sequence)`, otherwise `none`. Applies to `(list A)`, `buff`, `string-ascii`, `string-utf8`.

**example:**

```clojure
(as-max-len? (list 2 2 2) u3) ;; Returns (some (2 2 2))
(as-max-len? (list 1 2 3) u2) ;; Returns none
(as-max-len? "hello" u10) ;; Returns (some "hello")
(as-max-len? 0x010203 u10) ;; Returns (some 0x010203)
```

***

## asserts!

Introduced in: **Clarity 1**

**input:** `bool, C`\
**output:** `bool`\
**signature:** `(asserts! bool-expr thrown-value)`

**description:**\
If `bool-expr` is `true`, returns `true` and continues. If `false`, returns `thrown-value` and exits current control-flow.

**example:**

```clojure
(asserts! (is-eq 1 1) (err 1)) ;; Returns true
```

***

## at-block

Introduced in: **Clarity 1**

**input:** `(buff 32), A`\
**output:** `A`\
**signature:** `(at-block id-block-hash expr)`

**description:**\
Evaluates `expr` as if evaluated at the end of the block identified by `id-block-hash`. `expr` must be read-only. The block hash must be from `id-header-hash`.

**example:**

```clojure
(define-data-var data int 1)
(at-block 0x0000000000000000000000000000000000000000000000000000000000000000 block-height) ;; Returns u0
(at-block (get-block-info? id-header-hash 0) (var-get data)) ;; Throws NoSuchDataVariable because `data` wasn't initialized at block height 0
```

***

## begin

Introduced in: **Clarity 1**

**input:** `AnyType, ... A`\
**output:** `A`\
**signature:** `(begin expr1 expr2 expr3 ... expr-last)`

**description:**\
Evaluates each expression in order and returns the value of the last expression. Note: intermediary statements returning a response type must be checked.

**example:**

```clojure
(begin (+ 1 2) 4 5) ;; Returns 5
```

***

## bit-and

Introduced in: **Clarity 2**

**input:** `int, ... | uint, ...`\
**output:** `int | uint`\
**signature:** `(bit-and i1 i2...)`

**description:**\
Bitwise AND across a variable number of integer inputs.

**example:**

```clojure
(bit-and 24 16) ;; Returns 16
(bit-and 28 24 -1) ;; Returns 24
(bit-and u24 u16) ;; Returns u16
(bit-and -128 -64) ;; Returns -128
```

***

## bit-not

Introduced in: **Clarity 2**

**input:** `int | uint`\
**output:** `int | uint`\
**signature:** `(bit-not i1)`

**description:**\
Returns the one's complement (bitwise NOT) of `i1`.

**example:**

```clojure
(bit-not 3) ;; Returns -4
(bit-not u128) ;; Returns u340282366920938463463374607431768211327
(bit-not 128) ;; Returns -129
(bit-not -128) ;; Returns 127
```

***

## bit-or

Introduced in: **Clarity 2**

**input:** `int, ... | uint, ...`\
**output:** `int | uint`\
**signature:** `(bit-or i1 i2...)`

**description:**\
Bitwise inclusive OR across a variable number of integer inputs.

**example:**

```clojure
(bit-or 4 8) ;; Returns 12
(bit-or 1 2 4) ;; Returns 7
(bit-or 64 -32 -16) ;; Returns -16
(bit-or u2 u4 u32) ;; Returns u38
```

***

## bit-shift-left

Introduced in: **Clarity 2**

**input:** `int, uint | uint, uint`\
**output:** `int | uint`\
**signature:** `(bit-shift-left i1 shamt)`

**description:**\
Shifts bits of `i1` left by `shamt` modulo 128. Does not check for arithmetic overflow — use `*`, `/`, `pow` if overflow detection is needed.

**example:**

```clojure
(bit-shift-left 2 u1) ;; Returns 4
(bit-shift-left 16 u2) ;; Returns 64
(bit-shift-left -64 u1) ;; Returns -128
(bit-shift-left u4 u2) ;; Returns u16
(bit-shift-left 123 u9999999999) ;; Returns -170141183460469231731687303715884105728
(bit-shift-left -1 u7) ;; Returns -128
(bit-shift-left -1 u128) ;; Returns -1
```

***

## bit-shift-right

Introduced in: **Clarity 2**

**input:** `int, uint | uint, uint`\
**output:** `int | uint`\
**signature:** `(bit-shift-right i1 shamt)`

**description:**\
Shifts bits of `i1` right by `shamt` modulo 128. For `uint` fills with zeros; for `int` preserves sign bit. Does not check for arithmetic overflow.

**example:**

```clojure
(bit-shift-right 2 u1) ;; Returns 1
(bit-shift-right 128 u2) ;; Returns 32
(bit-shift-right -64 u1) ;; Returns -32
(bit-shift-right u128 u2) ;; Returns u32
(bit-shift-right 123 u9999999999) ;; Returns 0
(bit-shift-right -128 u7) ;; Returns -1
```

***

## bit-xor

Introduced in: **Clarity 2**

**input:** `int, ... | uint, ...`\
**output:** `int | uint`\
**signature:** `(bit-xor i1 i2...)`

**description:**\
Bitwise exclusive OR across a variable number of integer inputs.

**example:**

```clojure
(bit-xor 1 2) ;; Returns 3
(bit-xor 120 280) ;; Returns 352
(bit-xor -128 64) ;; Returns -64
(bit-xor u24 u4) ;; Returns u28
(bit-xor 1 2 4 -1) ;; Returns -8
```

***

## buff-to-int-be

Introduced in: **Clarity 2**

**input:** `(buff 16)`\
**output:** `int`\
**signature:** `(buff-to-int-be (buff 16))`

**description:**\
Converts a buffer to a signed integer using big-endian encoding. Buffer up to 16 bytes; if fewer, it behaves as if left-zero-padded. Available starting Stacks 2.1.

**example:**

```clojure
(buff-to-int-be 0x01) ;; Returns 1
(buff-to-int-be 0x00000000000000000000000000000001) ;; Returns 1
(buff-to-int-be 0xffffffffffffffffffffffffffffffff) ;; Returns -1
(buff-to-int-be 0x) ;; Returns 0
```

***

## buff-to-int-le

Introduced in: **Clarity 2**

**input:** `(buff 16)`\
**output:** `int`\
**signature:** `(buff-to-int-le (buff 16))`

**description:**\
Converts a buffer to a signed integer using little-endian encoding. Up to 16 bytes; fewer bytes behave as right-zero-padded. Available starting Stacks 2.1.

**example:**

```clojure
(buff-to-int-le 0x01) ;; Returns 1
(buff-to-int-le 0x01000000000000000000000000000000) ;; Returns 1
(buff-to-int-le 0xffffffffffffffffffffffffffffffff) ;; Returns -1
(buff-to-int-le 0x) ;; Returns 0
```

***

## buff-to-uint-be

Introduced in: **Clarity 2**

**input:** `(buff 16)`\
**output:** `uint`\
**signature:** `(buff-to-uint-be (buff 16))`

**description:**\
Converts a buffer to an unsigned integer using big-endian encoding. Up to 16 bytes; fewer bytes behave as left-zero-padded. Available starting Stacks 2.1.

**example:**

```clojure
(buff-to-uint-be 0x01) ;; Returns u1
(buff-to-uint-be 0x00000000000000000000000000000001) ;; Returns u1
(buff-to-uint-be 0xffffffffffffffffffffffffffffffff) ;; Returns u340282366920938463463374607431768211455
(buff-to-uint-be 0x) ;; Returns u0
```

***

## buff-to-uint-le

Introduced in: **Clarity 2**

**input:** `(buff 16)`\
**output:** `uint`\
**signature:** `(buff-to-uint-le (buff 16))`

**description:**\
Converts a buffer to an unsigned integer using little-endian encoding. Up to 16 bytes; fewer bytes behave as right-zero-padded. Available starting Stacks 2.1.

**example:**

```clojure
(buff-to-uint-le 0x01) ;; Returns u1
(buff-to-uint-le 0x01000000000000000000000000000000) ;; Returns u1
(buff-to-uint-le 0xffffffffffffffffffffffffffffffff) ;; Returns u340282366920938463463374607431768211455
(buff-to-uint-le 0x) ;; Returns u0
```

***

## concat

Introduced in: **Clarity 1**

**input:** `sequence_A, sequence_A`\
**output:** `sequence_A`\
**signature:** `(concat sequence1 sequence2)`

**description:**\
Concatenates two sequences of the same type. Applicable to `(list A)`, `buff`, `string-ascii`, `string-utf8`.

**example:**

```clojure
(concat (list 1 2) (list 3 4)) ;; Returns (1 2 3 4)
(concat "hello " "world") ;; Returns "hello world"
(concat 0x0102 0x0304) ;; Returns 0x01020304
```

***

## contract-call?

Introduced in: **Clarity 1**

**input:** `ContractName, PublicFunctionName, Arg0, ...`\
**output:** `(response A B)`\
**signature:** `(contract-call? .contract-name function-name arg0 arg1 ...)`

**description:**\
Executes a public function on another contract (not the current contract). If that function returns `err`, any DB changes resulting from the call are aborted; if `ok`, DB changes occurred.

**example:**

```clojure
;; instantiate the sample-contracts/tokens.clar contract first
(as-contract (contract-call? .tokens mint! u19)) ;; Returns (ok u19)
```

***

## contract-hash?

Introduced in: **Clarity 4**

**Input**: `principal`

**Output**: `(response (buff 32) uint)`

**Signature**: `(contract-hash? contract-principal)`

**Description**: Returns the SHA-512/256 hash of the code body of the contract principal specified as input, or an error if the principal is not a contract or the specified contract does not exist. Returns:

* `(ok 0x<hash>)`, where `<hash>` is the SHA-512/256 hash of the code body, on success
* `(err u1)` if the principal is not a contract principal
* `(err u2)` if the specified contract does not exist

**Example**:

```
(contract-hash? 'SP2QEZ06AGJ3RKJPBV14SY1V5BBFNAW33D96YPGZF.BNS-V2) ;; Returns (ok 0x9f8104ff869aba1205cd5e15f6404dd05675f4c3fe0817c623c425588d981c2f)
```

***

## contract-of

Introduced in: **Clarity 1**

**input:** `Trait`\
**output:** `principal`\
**signature:** `(contract-of .contract-name)`

**description:**\
Returns the principal of the contract implementing the trait.

**example:**

```clojure
(use-trait token-a-trait 'SPAXYA5XS51713FDTQ8H94EJ4V579CXMTRNBZKSF.token-a.token-trait)
(define-public (forward-get-balance (user principal) (contract <token-a-trait>))
  (begin
    (ok (contract-of contract)))) ;; returns the principal of the contract implementing <token-a-trait>
```

***

## default-to

Introduced in: **Clarity 1**

**input:** `A, (optional A)`\
**output:** `A`\
**signature:** `(default-to default-value option-value)`

**description:**\
If the second argument is `(some v)`, returns `v`. If it is `none`, returns `default-value`.

**example:**

```clojure
(define-map names-map { name: (string-ascii 12) } { id: int })
(map-set names-map { name: "blockstack" } { id: 1337 })
(default-to 0 (get id (map-get? names-map (tuple (name "blockstack"))))) ;; Returns 1337
(default-to 0 (get id (map-get? names-map (tuple (name "non-existant"))))) ;; Returns 0
```

***

## define-constant

Introduced in: **Clarity 1**

**input:** `MethodSignature, MethodBody`\
**output:** `Not Applicable`\
**signature:** `(define-constant name expression)`

**description:**\
Defines a private constant evaluated at contract launch. Must be top-level. Be mindful of definition order.

**example:**

```clojure
(define-constant four (+ 2 2))
(+ 4 four) ;; Returns 8
```

***

## define-data-var

Introduced in: **Clarity 1**

**input:** `VarName, TypeDefinition, Value`\
**output:** `Not Applicable`\
**signature:** `(define-data-var var-name type value)`

**description:**\
Defines a new persisted variable for the contract. Only modifiable by the contract. Must be top-level.

**example:**

```clojure
(define-data-var size int 0)
(define-private (set-size (value int))
  (var-set size value))
(set-size 1)
(set-size 2)
```

***

## define-fungible-token

Introduced in: **Clarity 1**

**input:** `TokenName, <uint>`\
**output:** `Not Applicable`\
**signature:** `(define-fungible-token token-name <total-supply>)`

**description:**\
Defines a fungible token class in the contract. Optional total supply caps minting. Must be top-level.

**example:**

```clojure
(define-fungible-token stacks)
(define-fungible-token limited-supply-stacks u100)
```

***

## define-map

Introduced in: **Clarity 1**

**input:** `MapName, TypeDefinition, TypeDefinition`\
**output:** `Not Applicable`\
**signature:** `(define-map map-name key-type value-type)`

**description:**\
Defines a data map stored by the contract. Must be top-level.

**example:**

```clojure
(define-map squares { x: int } { square: int })
(define-private (add-entry (x int))
  (map-insert squares { x: 2 } { square: (* x x) }))
(add-entry 1)
(add-entry 2)
```

***

## define-non-fungible-token

Introduced in: **Clarity 1**

**input:** `AssetName, TypeSignature`\
**output:** `Not Applicable`\
**signature:** `(define-non-fungible-token asset-name asset-identifier-type)`

**description:**\
Defines an NFT class in the contract. Asset identifiers must be unique. Must be top-level.

**example:**

```clojure
(define-non-fungible-token names (buff 50))
```

***

## define-private

Introduced in: **Clarity 1**

**input:** `MethodSignature, MethodBody`\
**output:** `Not Applicable`\
**signature:** `(define-private (function-name (arg-name-0 arg-type-0) ...) function-body)`

**description:**\
Defines a private function callable only within the contract. Must be top-level.

**example:**

```clojure
(define-private (max-of (i1 int) (i2 int))
  (if (> i1 i2)
    i1
    i2))
(max-of 4 6) ;; Returns 6
```

***

## define-public

Introduced in: **Clarity 1**

**input:** `MethodSignature, MethodBody`\
**output:** `Not Applicable`\
**signature:** `(define-public (function-name (arg-name-0 arg-type-0) ...) function-body)`

**description:**\
Defines a public transaction function. Must return a ResponseType (`ok` or `err`). DB changes are aborted if `err`. Must be top-level.

**example:**

```clojure
(define-public (hello-world (input int))
  (begin
    (print (+ 2 input))
    (ok input)))
```

***

## define-read-only

Introduced in: **Clarity 1**

**input:** `MethodSignature, MethodBody`\
**output:** `Not Applicable`\
**signature:** `(define-read-only (function-name (arg-name-0 arg-type-0) ...) function-body)`

**description:**\
Defines a public read-only function. Cannot modify data maps or call mutating functions. May return any type. Must be top-level.

**example:**

```clojure
(define-read-only (just-return-one-hundred)
  (* 10 10))
```

***

## define-trait

Introduced in: **Clarity 1**

**input:** `VarName, [MethodSignature]`\
**output:** `Not Applicable`\
**signature:** `(define-trait trait-name ((func1-name (arg1-type ...) (return-type))))`

**description:**\
Defines a trait (interface) other contracts can implement. Must be top-level. Notes about Clarity 1 vs Clarity 2 trait usage and implicit casting in Clarity 2 are included.

**example:**

```clojure
(define-trait token-trait
  ((transfer? (principal principal uint) (response uint uint))
  (get-balance (principal) (response uint uint))))
```

***

## element-at

Introduced in: **Clarity 1**

**input:** `sequence_A, uint`\
**output:** `(optional A)`\
**signature:** `(element-at? sequence index)`

**description:**\
Returns the element at `index` in the sequence as an optional. Applicable types: `(list A)`, `buff`, `string-ascii`, `string-utf8`. In Clarity 1 spelled `element-at` (alias).

**example:**

```clojure
(element-at? "blockstack" u5) ;; Returns (some "s")
(element-at? (list 1 2 3 4 5) u5) ;; Returns none
(element-at? (list 1 2 3 4 5) (+ u1 u2)) ;; Returns (some 4)
(element-at? "abcd" u1) ;; Returns (some "b")
(element-at? 0xfb01 u1) ;; Returns (some 0x01)
```

***

## element-at?

Introduced in: **Clarity 2**

(Same as element-at; retained as Clarity 2 preferred spelling)

**example:** (see element-at above)

***

## err

Introduced in: **Clarity 1**

**input:** `A`\
**output:** `(response A B)`\
**signature:** `(err value)`

**description:**\
Constructs an `err` response. Use for returning errors from public functions; indicates DB changes should be rolled back.

**example:**

```clojure
(err true) ;; Returns (err true)
```

***

## filter

Introduced in: **Clarity 1**

**input:** `Function(A) -> bool, sequence_A`\
**output:** `sequence_A`\
**signature:** `(filter func sequence)`

**description:**\
Filters elements of a sequence by applying `func` to each element and keeping those where `func` returns `true`. `func` must be a literal function name. Applies to `(list A)`, `buff`, `string-ascii`, `string-utf8`.

**example:**

```clojure
(filter not (list true false true false)) ;; Returns (false false)
(define-private (is-a (char (string-utf8 1)))
  (is-eq char u"a"))
(filter is-a u"acabd") ;; Returns u"aa"
```

***

## fold

Introduced in: **Clarity 1**

**input:** `Function(A, B) -> B, sequence_A, B`\
**output:** `B`\
**signature:** `(fold func sequence_A initial_B)`

**description:**\
Reduces a sequence to a single value by applying `func` cumulatively, starting with `initial_B`.

**example:**

```clojure
(fold * (list 2 2 2) 1) ;; Returns 8
(fold - (list 3 7 11) 2) ;; Returns 5
```

(Examples showing string/buffer concatenation omitted here; see original for fuller set.)

***

## from-consensus-buff?

Introduced in: **Clarity 2**

**input:** `type-signature(t), buff`\
**output:** `(optional t)`\
**signature:** `(from-consensus-buff? type-signature buffer)`

**description:**\
Deserializes a buffer into a Clarity value using SIP-005 consensus serialization. Returns `some` on success, `none` on failure.

**example:**

```clojure
(from-consensus-buff? int 0x0000000000000000000000000000000001) ;; Returns (some 1)
(from-consensus-buff? uint 0x0000000000000000000000000000000001) ;; Returns none
(from-consensus-buff? bool 0x03) ;; Returns (some true)
(from-consensus-buff? principal 0x051fa46ff88886c2ef9762d970b4d2c63678835bd39d) ;; Returns (some SZ2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKQ9H6DPR)
```

***

## ft-burn?

Introduced in: **Clarity 1**

**input:** `TokenName, uint, principal`\
**output:** `(response bool uint)`\
**signature:** `(ft-burn? token-name amount sender)`

**description:**\
Burns (destroys) `amount` of `token-name` from `sender`'s balance. On success returns `(ok true)`. Error `(err u1)` - insufficient balance or non-positive amount.

**example:**

```clojure
(define-fungible-token stackaroo)
(ft-mint? stackaroo u100 'SPAXYA5XS51713FDTQ8H94EJ4V579CXMTRNBZKSF) ;; Returns (ok true)
(ft-burn? stackaroo u50 'SPAXYA5XS51713FDTQ8H94EJ4V579CXMTRNBZKSF) ;; Returns (ok true)
```

***

## ft-get-balance

Introduced in: **Clarity 1**

**input:** `TokenName, principal`\
**output:** `uint`\
**signature:** `(ft-get-balance token-name principal)`

**description:**\
Returns the `token-name` balance for `principal`. Token must be defined with `define-fungible-token`.

**example:**

```clojure
(define-fungible-token stackaroo)
(ft-mint? stackaroo u100 'SZ2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKQ9H6DPR)
(ft-get-balance stackaroo 'SZ2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKQ9H6DPR) ;; Returns u100
```

***

## ft-get-supply

Introduced in: **Clarity 1**

**input:** `TokenName`\
**output:** `uint`\
**signature:** `(ft-get-supply token-name)`

**description:**\
Returns circulating supply for the `token-name`. Token must be defined with `define-fungible-token`.

**example:**

```clojure
(define-fungible-token stackaroo)
(ft-mint? stackaroo u100 'SZ2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKQ9H6DPR)
(ft-get-supply stackaroo) ;; Returns u100
```

***

## ft-mint?

Introduced in: **Clarity 1**

**input:** `TokenName, uint, principal`\
**output:** `(response bool uint)`\
**signature:** `(ft-mint? token-name amount recipient)`

**description:**\
Mints `amount` of `token-name` to `recipient`. Non-positive amount returns `(err 1)`. On success returns `(ok true)`.

**example:**

```clojure
(define-fungible-token stackaroo)
(ft-mint? stackaroo u100 'SPAXYA5XS51713FDTQ8H94EJ4V579CXMTRNBZKSF) ;; Returns (ok true)
```

***

## ft-transfer?

Introduced in: **Clarity 1**

**input:** `TokenName, uint, principal, principal`\
**output:** `(response bool uint)`\
**signature:** `(ft-transfer? token-name amount sender recipient)`

**description:**\
Transfers `amount` of `token-name` from `sender` to `recipient` (token must be defined in contract). Anyone can call; proper guards are expected. Returns `(ok true)` on success. Error codes: `(err u1)` insufficient balance, `(err u2)` sender==recipient, `(err u3)` non-positive amount.

**example:**

```clojure
(define-fungible-token stackaroo)
(ft-mint? stackaroo u100 'SZ2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKQ9H6DPR)
(ft-transfer? stackaroo u50 'SZ2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKQ9H6DPR 'SPAXYA5XS51713FDTQ8H94EJ4V579CXMTRNBZKSF) ;; Returns (ok true)
```

***

## get

Introduced in: **Clarity 1**

**input:** `KeyName, (tuple) | (optional (tuple))`\
**output:** `A`\
**signature:** `(get key-name tuple)`

**description:**\
Fetches value associated with `key-name` from a tuple. If an optional tuple is supplied and is `none`, returns `none`.

**example:**

```clojure
(define-map names-map { name: (string-ascii 12) } { id: int })
(map-insert names-map { name: "blockstack" } { id: 1337 })
(get id (tuple (name "blockstack") (id 1337))) ;; Returns 1337
(get id (map-get? names-map (tuple (name "blockstack")))) ;; Returns (some 1337)
(get id (map-get? names-map (tuple (name "non-existent")))) ;; Returns none
```

***

## get-block-info?

Introduced in: **Clarity 1**

**input:** `BlockInfoPropertyName, uint`\
**output:** `(optional buff) | (optional uint)`\
**signature:** `(get-block-info? prop-name block-height)`

**description:**\
Fetches data for a Stacks block at given block height. If the height doesn't exist prior to current block, returns `none`. Property names and returned types described; newer Clarity versions split this into `get-stacks-block-info?` and `get-tenure-info?`. See original for full list of properties and notes.

**example:**

```clojure
(get-block-info? time u0) ;; Returns (some u1557860301)
(get-block-info? header-hash u0) ;; Returns (some 0x3747...)
```

***

## get-burn-block-info?

Introduced in: **Clarity 2**

**input:** `BurnBlockInfoPropertyName, uint`\
**output:** `(optional buff) | (optional (tuple ...))`\
**signature:** `(get-burn-block-info? prop-name block-height)`

**description:**\
Fetches burnchain block data for the given burnchain height. Valid properties include `header-hash` and `pox-addrs`. See original for full tuple shape of `pox-addrs`.

**example:**

```clojure
(get-burn-block-info? header-hash u677050) ;; Returns (some 0xe671...)
(get-burn-block-info? pox-addrs u677050) ;; Returns (some (tuple (addrs (...)) (payout u123)))
```

***

## get-stacks-block-info?

Introduced in: **Clarity 3**

**input:** `StacksBlockInfoPropertyName, uint`\
**output:** `(optional buff), (optional uint)`\
**signature:** `(get-stacks-block-info? prop-name stacks-block-height)`

**description:**\
Replacement for `get-block-info?` in Clarity 3; fetches Stacks block data for a given height. See original for property list and behavior differences before/after epoch 3.0.

**example:**

```clojure
(get-stacks-block-info? time u0) ;; Returns (some u1557860301)
(get-stacks-block-info? header-hash u0) ;; Returns (some 0x3747...)
```

***

## get-tenure-info?

Introduced in: **Clarity 3**

**input:** `TenureInfoPropertyName, uint`\
**output:** `(optional buff) | (optional uint)`\
**signature:** `(get-tenure-info? prop-name stacks-block-height)`

**description:**\
Fetches tenure-related info at the given block height (burnchain header for tenure, miner address, time, vrf-seed, block reward, miner spend totals). Returns `none` if height is not prior to current block. See original for full notes.

**example:**

```clojure
(get-tenure-info? time u0) ;; Returns (some u1557860301)
(get-tenure-info? vrf-seed u0) ;; Returns (some 0xf490...)
```

***

## hash160

Introduced in: **Clarity 1**

**input:** `buff|uint|int`\
**output:** `(buff 20)`\
**signature:** `(hash160 value)`

**description:**\
Computes RIPEMD160(SHA256(x)). If input is an integer, it is hashed over its little-endian representation.

**example:**

```clojure
(hash160 0) ;; Returns 0xe4352f72...
```

***

## if

Introduced in: **Clarity 1**

**input:** `bool, A, A`\
**output:** `A`\
**signature:** `(if bool1 expr1 expr2)`

**description:**\
Conditional expression: evaluates and returns `expr1` if `bool1` is true, otherwise `expr2`. Both exprs must return the same type.

**example:**

```clojure
(if true 1 2) ;; Returns 1
(if (> 1 2) 1 2) ;; Returns 2
```

***

## impl-trait

Introduced in: **Clarity 1**

**input:** `TraitIdentifier`\
**output:** `Not Applicable`\
**signature:** `(impl-trait trait-identifier)`

**description:**\
Asserts that the contract implements the given trait. Checked at publish time. Must be top-level.

**example:**

```clojure
(impl-trait 'SPAXYA5XS51713FDTQ8H94EJ4V579CXMTRNBZKSF.token-a.token-trait)
(define-public (get-balance (account principal))
  (ok u0))
```

***

## index-of

Introduced in: **Clarity 1**

**input:** `sequence_A, A`\
**output:** `(optional uint)`\
**signature:** `(index-of? sequence item)`

**description:**\
Returns first index of `item` in sequence using `is-eq`. Returns `none` if not found or if empty string/buffer. Clarity 1 spelling: `index-of` (alias).

**example:**

```clojure
(index-of? "blockstack" "b") ;; Returns (some u0)
(index-of? (list 1 2 3 4 5) 6) ;; Returns none
```

***

## index-of?

Introduced in: **Clarity 2**

(Same as index-of; retained for Clarity 2)

***

## int-to-ascii

Introduced in: **Clarity 2**

**input:** `int | uint`\
**output:** `(string-ascii 40)`\
**signature:** `(int-to-ascii (int|uint))`

**description:**\
Converts an integer to its ASCII string representation. Available starting Stacks 2.1.

**example:**

```clojure
(int-to-ascii 1) ;; Returns "1"
(int-to-ascii -1) ;; Returns "-1"
```

***

## int-to-utf8

Introduced in: **Clarity 2**

**input:** `int | uint`\
**output:** `(string-utf8 40)`\
**signature:** `(int-to-utf8 (int|uint))`

**description:**\
Converts an integer to its UTF-8 string representation. Available starting Stacks 2.1.

**example:**

```clojure
(int-to-utf8 1) ;; Returns u"1"
(int-to-utf8 -1) ;; Returns u"-1"
```

***

## is-eq

Introduced in: **Clarity 1**

**input:** `A, A, ...`\
**output:** `bool`\
**signature:** `(is-eq v1 v2...)`

**description:**\
Returns `true` if all inputs are equal. Unlike `and`, does not short-circuit. All arguments must be the same type.

**example:**

```clojure
(is-eq 1 1) ;; Returns true
(is-eq true false) ;; Returns false
(is-eq "abc" "abc") ;; Returns true
```

***

## is-err / is-ok / is-none / is-some

Introduced in: **Clarity 1**

* `(is-err value)` returns `true` if `value` is `(err ...)`.
* `(is-ok value)` returns `true` if `value` is `(ok ...)`.
* `(is-none value)` returns `true` if `value` is `none`.
* `(is-some value)` returns `true` if `value` is `(some ...)`.

**examples:**

```clojure
(is-err (err 1)) ;; Returns true
(is-ok (ok 1)) ;; Returns true
(is-none none) ;; Returns true
(is-some (some 1)) ;; Returns true
```

***

## is-standard

Introduced in: **Clarity 2**

**input:** `principal`\
**output:** `bool`\
**signature:** `(is-standard standard-or-contract-principal)`

**description:**\
Tests whether a principal matches the current network type (mainnet vs testnet) and therefore can spend tokens on that network. Available starting Stacks 2.1.

**example:**

```clojure
(is-standard 'STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6) ;; true on testnet; false on mainnet
```

***

## keccak256

Introduced in: **Clarity 1**

**input:** `buff|uint|int`\
**output:** `(buff 32)`\
**signature:** `(keccak256 value)`

**description:**\
Computes KECCAK256(value). If input is an integer, it is hashed over its little-endian representation.

**example:**

```clojure
(keccak256 0) ;; Returns 0xf490de29...
```

***

## len

Introduced in: **Clarity 1**

**input:** `sequence_A`\
**output:** `uint`\
**signature:** `(len sequence)`

**description:**\
Returns length of a sequence. Applies to `(list A)`, `buff`, `string-ascii`, `string-utf8`.

**example:**

```clojure
(len "blockstack") ;; Returns u10
(len (list 1 2 3 4 5)) ;; Returns u5
(len 0x010203) ;; Returns u3
```

***

## let

Introduced in: **Clarity 1**

**input:** `((name1 AnyType) ...), AnyType, ... A`\
**output:** `A`\
**signature:** `(let ((name1 expr1) ...) expr-body1 ... expr-body-last)`

**description:**\
Binds sequential variables then evaluates the body expressions in that context. Returns last body expression's value.

**example:**

```clojure
(let ((a 2) (b (+ 5 6 7)))
  (print a)
  (print b)
  (+ a b)) ;; Returns 20
```

***

## list

Introduced in: **Clarity 1**

**input:** `A, ...`\
**output:** `(list A)`\
**signature:** `(list expr1 expr2 expr3 ...)`

**description:**\
Constructs a list from supplied values (must be same type).

**example:**

```clojure
(list (+ 1 2) 4 5) ;; Returns (3 4 5)
```

***

## log2

Introduced in: **Clarity 1**

**input:** `int | uint`\
**output:** `int | uint`\
**signature:** `(log2 n)`

**description:**\
Returns floor(log2(n)). Fails on negative numbers.

**example:**

```clojure
(log2 u8) ;; Returns u3
(log2 8) ;; Returns 3
```

***

## map

Introduced in: **Clarity 1**

**input:** `Function(A, B, ..., N) -> X, sequence_A, sequence_B, ...`\
**output:** `(list X)`\
**signature:** `(map func sequence_A sequence_B ...)`

**description:**\
Applies `func` to each corresponding element of input sequences and returns a list of results. `func` must be a literal function name. Output is always a list.

**example:**

```clojure
(map + (list 1 2 3) (list 1 2 3) (list 1 2 3)) ;; Returns (3 6 9)
```

***

## map-delete / map-get? / map-insert / map-set

Introduced in: **Clarity 1**

Operations for manipulating contract data maps:

* `(map-delete map-name key-tuple)` — removes entry; returns `true` if removed, `false` if none existed.
* `(map-get? map-name key-tuple)` — returns `(some value)` or `none`.
* `(map-insert map-name key-tuple value-tuple)` — inserts only if key absent; returns `true` if inserted, `false` if existed.
* `(map-set map-name key-tuple value-tuple)` — blind overwrite; returns `true`.

Examples exist in the original content (omitted here for brevity).

***

## match

Introduced in: **Clarity 1**

**input:** `(optional A) name expression expression | (response A B) name expression name expression`\
**output:** `C`\
**signature:** `(match opt-input some-binding-name some-branch none-branch) | (match-resp input ok-binding-name ok-branch err-binding-name err-branch)`

**description:**\
Destructures `optional` and `response` types and evaluates only the matching branch. See original for type-checking caveats.

**example:**

```clojure
(define-private (add-10 (x (optional int)))
  (match x
    value (+ 10 value)
    10))
(add-10 (some 5)) ;; Returns 15
(add-10 none) ;; Returns 10
```

***

## merge

Introduced in: **Clarity 1**

**input:** `tuple, tuple`\
**output:** `tuple`\
**signature:** `(merge tuple { key1: val1 })`

**description:**\
Returns a new tuple combining fields (non-mutating).

**example:**

```clojure
(merge user { address: (some 'SPAXYA5X...) }) ;; Returns merged tuple
```

***

## mod

Introduced in: **Clarity 1**

**input:** `int, int | uint, uint | string-ascii, string-ascii | string-utf8, string-utf8 | buff, buff`\
**output:** `int | uint`\
**signature:** `(mod i1 i2)`

**description:**\
Returns remainder of integer division; division by zero throws runtime error.

**example:**

```clojure
(mod 5 2) ;; Returns 1
```

***

## nft-burn? / nft-get-owner? / nft-mint? / nft-transfer?

Introduced in: **Clarity 1**

NFT operations for assets defined with `define-non-fungible-token`:

* `(nft-mint? asset-class asset-identifier recipient)` — mint; returns `(ok true)` or `(err u1)` if exists.
* `(nft-get-owner? asset-class asset-identifier)` — returns `(some owner)` or `none`.
* `(nft-transfer? asset-class asset-identifier sender recipient)` — transfer; returns `(ok true)` or errors.
* `(nft-burn? asset-class asset-identifier sender)` — burn; returns `(ok true)` or errors.

Examples present in original content.

***

## not

Introduced in: **Clarity 1**

**input:** `bool`\
**output:** `bool`\
**signature:** `(not b1)`

**description:**\
Boolean negation.

**example:**

```clojure
(not true) ;; Returns false
```

***

## ok

Introduced in: **Clarity 1**

**input:** `A`\
**output:** `(response A B)`\
**signature:** `(ok value)`

**description:**\
Constructs an `ok` response. Use for successful public function returns.

**example:**

```clojure
(ok 1) ;; Returns (ok 1)
```

***

## or

Introduced in: **Clarity 1**

**input:** `bool, ...`\
**output:** `bool`\
**signature:** `(or b1 b2 ...)`

**description:**\
Returns `true` if any input is `true`. Evaluated in-order and lazily (short-circuits on `true`).

**example:**

```clojure
(or true false) ;; Returns true
```

***

## pow

Introduced in: **Clarity 1**

**input:** `int, int | uint, uint | string-ascii, string-ascii | string-utf8, string-utf8 | buff, buff`\
**output:** `int | uint`\
**signature:** `(pow i1 i2)`

**description:**\
Returns i1^i2. Throws runtime error on overflow. Special-case rules for 0^0, i1==1, etc. Throws runtime error if exponent negative or > u32::MAX.

**example:**

```clojure
(pow 2 3) ;; Returns 8
```

***

## principal-construct?

Introduced in: **Clarity 2**

**input:** `(buff 1), (buff 20), [(string-ascii 40)]`\
**output:** `(response principal { error_code: uint, principal: (option principal) })`\
**signature:** `(principal-construct? (buff 1) (buff 20) [(string-ascii 40)])`

**description:**\
Constructs a standard or contract principal from version byte and hash bytes, optionally with contract name. Returns `ok` with principal or `err` tuple with error code and optional principal. Available starting Stacks 2.1.

**example:** (see original for many examples)

***

## principal-destruct?

Introduced in: **Clarity 2**

**input:** `principal`\
**output:** `(response (tuple ...) (tuple ...))`\
**signature:** `(principal-destruct? principal-address)`

**description:**\
Decomposes a principal into `{version, hash-bytes, name}` tuple. Returns `ok` if version matches network, otherwise `err`. Available starting Stacks 2.1.

**example:** (see original)

***

## principal-of?

Introduced in: **Clarity 1**

**input:** `(buff 33)`\
**output:** `(response principal uint)`\
**signature:** `(principal-of? public-key)`

**description:**\
Derives the principal from a compressed public key. Returns `(err u1)` if invalid. Note: pre-2.1 bug returned testnet principals irrespective of network; fixed in 2.1.

**example:**

```clojure
(principal-of? 0x03adb8de4b...) ;; Returns (ok ST1AW6E...)
```

***

## print

Introduced in: **Clarity 1**

**input:** `A`\
**output:** `A`\
**signature:** `(print expr)`

**description:**\
Evaluates and returns its argument. On dev nodes prints to STDOUT.

**example:**

```clojure
(print (+ 1 2 3)) ;; Returns 6
```

***

## replace-at?

Introduced in: **Clarity 2**

**input:** `sequence_A, uint, A`\
**output:** `(optional sequence_A)`\
**signature:** `(replace-at? sequence index element)`

**description:**\
Returns a new sequence with element at `index` replaced. Returns `none` if index out of bounds.

**example:**

```clojure
(replace-at? u"ab" u1 u"c") ;; Returns (some u"ac")
(replace-at? (list 1 2) u3 4) ;; Returns none
```

***

## restrict-assets?

Introduced in: **Clarity 4**

**Input**:

* `asset-owner`: `principal`: The principal whose assets are being protected.
* `((with-stx|with-ft|with-nft|with-stacking)*)`: The set of allowances (at most 128) to grant during the evaluation of the body expressions .
* `AnyType* A`: The Clarity expressions to be executed within the context, with the final expression returning type `A`, where `A` is not a `response`

**Output**: `(response A uint)`

**Signature**: `(restrict-assets? asset-owner ((with-stx|with-ft|with-nft|with-stacking)*) expr-body1 expr-body2 ... expr-body-last)`

**Description**: Executes the body expressions, then checks the asset outflows against the granted allowances, in declaration order. If any allowance is violated, the body expressions are reverted and an error is returned. Note that the `asset-owner` and allowance setup expressions are evaluated before executing the body expressions. The final body expression cannot return a `response` value in order to avoid returning a nested `response` value from `restrict-assets?` (nested responses are error-prone). Returns:

* `(ok x)` if the outflows are within the allowances, where `x` is the result of the final body expression and has type `A`.
* `(err index)` if an allowance was violated, where `index` is the 0-based index of the first violated allowance in the list of granted allowances, or `u128` if an asset with no allowance caused the violation.

**Example**:

```
(define-public (foo)
  (restrict-assets? tx-sender ()
    (try! (stx-transfer? u1000000 tx-sender 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM))
  )
) ;; Returns (err u128)
(define-public (bar)
  (restrict-assets? tx-sender ()
    (+ u1 u2)
  )
) ;; Returns (ok u3)
```

***

## secp256k1-recover?

Introduced in: **Clarity 1**

**input:** `(buff 32), (buff 65)`\
**output:** `(response (buff 33) uint)`\
**signature:** `(secp256k1-recover? message-hash signature)`

**description:**\
Recovers the public key from a signature over message-hash. Returns `(err u1)` if signature doesn't match, `(err u2)` if signature invalid.

**example:** (see original)

***

## secp256k1-verify

Introduced in: **Clarity 1**

**input:** `(buff 32), (buff 64) | (buff 65), (buff 33)`\
**output:** `bool`\
**signature:** `(secp256k1-verify message-hash signature public-key)`

**description:**\
Verifies that `signature` of `message-hash` was produced by `public-key`. Signature is 64 or 65 bytes.

**example:** (see original)

***

## secp256r1-verify

**Input**: `(buff 32), (buff 64), (buff 33)`

**Output**: `bool`

**Signature**: `(secp256r1-verify message-hash signature public-key)`

**Description**: The `secp256r1-verify` function verifies that the provided `signature` of the `message-hash` was produced by the private key corresponding to `public-key`. The `message-hash` is the SHA-256 hash of the message. The `signature` must be 64 bytes (compact signature). Returns `true` if the signature is valid for the given `public-key` and message hash, otherwise returns `false`.

**Example**:

```clojure
(secp256r1-verify 0x033510403a646d23ee4f005061c2ca6af5da7c32c83758e8e9b6ac4cc1c2153c
  0x9608dc164b76d2e19365ffa67b48981e441d323c3109718aee245d6ac8ccd21ddadadb94303c922c0d79d131ea59a0b6ba83e1157695db01189bb4b7e9f14b72 0x037a6b62e3c8b14f1b5933f5d5ab0509a8e7d95a111b8d3b264d95bfa753b00296) ;; Returns true
(secp256r1-verify 0x0000000000000000000000000000000000000000000000000000000000000000
  0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0x037a6b62e3c8b14f1b5933f5d5ab0509a8e7d95a111b8d3b264d95bfa753b00296) ;; Returns false
```

***

## sha256 / sha512 / sha512/256

Introduced in: **Clarity 1**

Hash functions:

* `(sha256 value)` → `(buff 32)`
* `(sha512 value)` → `(buff 64)`
* `(sha512/256 value)` → `(buff 32)`

If integer supplied, hashed over little-endian representation.

**examples:**

```clojure
(sha256 0) ;; Returns 0x374708ff...
(sha512 1) ;; Returns 0x6fcee9a7...
(sha512/256 1) ;; Returns 0x515a7e92...
```

***

## slice?

Introduced in: **Clarity 2**

**input:** `sequence_A, uint, uint`\
**output:** `(optional sequence_A)`\
**signature:** `(slice? sequence left-position right-position)`

**description:**\
Returns subsequence \[left, right). If left==right returns empty sequence. Returns `none` if out of bounds or right < left.

**example:**

```clojure
(slice? "blockstack" u5 u10) ;; Returns (some "stack")
(slice? "abcd" u2 u2) ;; Returns (some "")
(slice? "abcd" u3 u1) ;; Returns none
```

***

## some

Introduced in: **Clarity 1**

**input:** `A`\
**output:** `(optional A)`\
**signature:** `(some value)`

**description:**\
Constructs `(some value)`.

**example:**

```clojure
(some 1) ;; Returns (some 1)
```

***

## sqrti

Introduced in: **Clarity 1**

**input:** `int | uint`\
**output:** `int | uint`\
**signature:** `(sqrti n)`

**description:**\
Returns floor(sqrt(n)). Fails on negative numbers.

**example:**

```clojure
(sqrti u11) ;; Returns u3
```

***

## string-to-int? / string-to-uint?

Introduced in: **Clarity 2**

**input:** `(string-ascii 1048576) | (string-utf8 262144)`\
**output:** `(optional int)` / `(optional uint)`\
**signature:** `(string-to-int? str)` / `(string-to-uint? str)`

**description:**\
Parse string to int/uint. Returns `(some value)` on success, `none` on failure. Available starting Stacks 2.1.

**example:**

```clojure
(string-to-int? "1") ;; Returns (some 1)
(string-to-uint? "1") ;; Returns (some u1)
(string-to-int? "a") ;; Returns none
```

***

## stx-account

Introduced in: **Clarity 2**

**input:** `principal`\
**output:** `(tuple (locked uint) (unlock-height uint) (unlocked uint))`\
**signature:** `(stx-account owner)`

**description:**\
Query the STX account for `owner`. Returns locked, unlock-height, and unlocked amounts (microstacks). Available starting Clarity 2.

**example:**

```clojure
(stx-account 'SZ2J6ZY48G...) ;; Returns (tuple (locked u0) (unlock-height u0) (unlocked u0))
```

***

## stx-burn?

Introduced in: **Clarity 1**

**input:** `uint, principal`\
**output:** `(response bool uint)`\
**signature:** `(stx-burn? amount sender)`

**description:**\
Destroys `amount` of STX from `sender` (microstacks). `sender` must be current `tx-sender`. Returns `(ok true)` on success. Error codes: `(err u1)` insufficient balance, `(err u3)` non-positive amount, `(err u4)` sender not tx-sender.

**example:**

```clojure
(as-contract (stx-burn? u60 tx-sender)) ;; Returns (ok true)
```

***

## stx-get-balance

Introduced in: **Clarity 1**

**input:** `principal`\
**output:** `uint`\
**signature:** `(stx-get-balance owner)`

**description:**\
Returns STX balance (microstacks) of `owner`. If owner not materialized returns 0.

**example:**

```clojure
(stx-get-balance (as-contract tx-sender)) ;; Returns u1000
```

***

## stx-transfer-memo?

Introduced in: **Clarity 2**

**input:** `uint, principal, principal, buff`\
**output:** `(response bool uint)`\
**signature:** `(stx-transfer-memo? amount sender recipient memo)`

**description:**\
Same as `stx-transfer?` but includes a `memo` buffer. Returns same error codes as `stx-transfer?`.

**example:**

```clojure
(as-contract (stx-transfer-memo? u60 tx-sender 'SZ2J6Z... 0x010203)) ;; Returns (ok true)
```

***

## stx-transfer?

Introduced in: **Clarity 1**

**input:** `uint, principal, principal`\
**output:** `(response bool uint)`\
**signature:** `(stx-transfer? amount sender recipient)`

**description:**\
Transfers STX (microstacks) from `sender` to `recipient`. `sender` must be current `tx-sender`. Returns `(ok true)` or errors: `(err u1)` insufficient funds, `(err u2)` same principal, `(err u3)` non-positive amount, `(err u4)` sender not tx-sender.

**example:**

```clojure
(as-contract (stx-transfer? u60 tx-sender 'SZ2J6Z...)) ;; Returns (ok true)
```

***

## to-ascii?

Introduced in: **Clarity 4**

**Input**: `int` | `uint` | `bool` | `principal` | `(buff 524284)` | `(string-utf8 262144)`

**Output**: `(response (string-ascii 1048571) uint)`

**Signature**: `(to-ascii? value)`

**Description**: Returns the `string-ascii` representation of the input value in an `ok` response on success. The only error condition is if the input type is `string-utf8` and the value contains non-ASCII characters, in which case, `(err u1)` is returned. Note that the limitation on the maximum sizes of `buff` and `string-utf8` inputs is due to the Clarity value size limit of 1MB. The `(string-utf8 262144)` is the maximum allowed size of a `string-utf8` value, and the `(buff 524284)` limit is chosen because the ASCII representation of a `buff` is `0x` followed by two ASCII characters per byte in the `buff`. This means that the ASCII representation of a `(buff 524284)` is `2 + 2 * 524284 = 1048570` characters at 1 byte each, and the remainder is required for the `response` value wrapping the `string-ascii`.

**Example**:

```clojure
(to-ascii? true) ;; Returns (ok "true")
(to-ascii? 42) ;; Returns (ok "42")
(to-ascii? 'SP2QEZ06AGJ3RKJPBV14SY1V5BBFNAW33D96YPGZF) ;; Returns (ok "SP2QEZ06AGJ3RKJPBV14SY1V5BBFNAW33D96YPGZF")
(to-ascii? 0x12345678) ;; Returns (ok "0x12345678")
```

***

## to-consensus-buff?

Introduced in: **Clarity 2**

**input:** `any`\
**output:** `(optional buff)`\
**signature:** `(to-consensus-buff? value)`

**description:**\
Serializes a Clarity value using SIP-005 consensus serialization. If serialized size fits into a buffer, returns `(some buff)`, else `none`. During type checking the maximal possible buffer length is inferred. Available starting Clarity 2.

**example:**

```clojure
(to-consensus-buff? 1) ;; Returns (some 0x0000...01)
(to-consensus-buff? true) ;; Returns (some 0x03)
```

***

## to-int

Introduced in: **Clarity 1**

**input:** `uint`\
**output:** `int`\
**signature:** `(to-int u)`

**description:**\
Converts `uint` to `int`. Runtime error if argument >= 2^127.

**example:**

```clojure
(to-int u238) ;; Returns 238
```

***

## to-uint

Introduced in: **Clarity 1**

**input:** `int`\
**output:** `uint`\
**signature:** `(to-uint i)`

**description:**\
Converts `int` to `uint`. Runtime error if argument is negative.

**example:**

```clojure
(to-uint 238) ;; Returns u238
```

***

## try!

Introduced in: **Clarity 1**

**input:** `(optional A) | (response A B)`\
**output:** `A`\
**signature:** `(try! option-input)`

**description:**\
Unpacks `(some v)` or `(ok v)` returning `v`. If input is `none` or `(err ...)`, `try!` returns the current function's `none` or `(err ...)` and exits control-flow.

**example:** (see original for longer usage)

***

## tuple

Introduced in: **Clarity 1**

**input:** `(key-name A), ...`\
**output:** `(tuple (key-name A) ...)`\
**signature:** `(tuple (key0 expr0) (key1 expr1) ...)`

**description:**\
Constructs a typed tuple. Shorthand using curly braces `{ key: val, ... }` is available.

**example:**

```clojure
(tuple (name "blockstack") (id 1337))
{name: "blockstack", id: 1337}
```

***

## unwrap! / unwrap-err! / unwrap-err-panic / unwrap-panic

Introduced in: **Clarity 1**

Utilities for unpacking optionals and responses with different failure behaviors:

* `(unwrap! option-or-response thrown-value)` — returns inner value or returns `thrown-value` from current function.
* `(unwrap-err! response-input thrown-value)` — returns err value or returns `thrown-value` if ok.
* `(unwrap-err-panic response-input)` — returns err inner value or throws runtime error if ok.
* `(unwrap-panic option-or-response)` — returns inner value or throws runtime error if none/err.

**example:** (see original for usage)

***

## use-trait

Introduced in: **Clarity 1**

**input:** `VarName, TraitIdentifier`\
**output:** `Not Applicable`\
**signature:** `(use-trait trait-alias trait-identifier)`

**description:**\
Imports an external trait under an alias for use in the contract (must be top-level).

**example:**

```clojure
(use-trait token-a-trait 'SPAXYA5X....token-a.token-trait)
```

***

## var-get / var-set

Introduced in: **Clarity 1**

* `(var-get var-name)` — returns the value of a data var.
* `(var-set var-name expr)` — sets the data var; returns `true`.

**example:**

```clojure
(define-data-var cursor int 6)
(var-get cursor) ;; Returns 6
(var-set cursor (+ (var-get cursor) 1)) ;; Returns true
```

***

{% hint style="info" %}
The following 5 `with-*` functions are meant to be used inside the new `restrict-assets?` function. See the tutorial on Restricting Assets in Clarity for more info on how to use this function.
{% endhint %}

## with-all-assets-unsafe

Introduced in: **Clarity 4**

**Input**: None

**Output**: Not applicable

**Signature**: `(with-all-assets-unsafe)`

**Description**: Grants unrestricted access to all assets of the contract to the enclosing `as-contract?` expression. Note that this is not allowed in `restrict-assets?` and will trigger an analysis error, since usage there does not make sense (i.e. just remove the `restrict-assets?` instead). **Security Warning:** This should be used with extreme caution, as it effectively disables all asset protection for the contract. This dangerous allowance should only be used when the code executing within the `as-contract?` body is verified to be trusted through other means (e.g. checking traits against an allow list, passed in from a trusted caller), and even then the more restrictive allowances should be preferred when possible.

**Example**:

```clojure
(define-public (execute-trait (trusted-trait <sample-trait>))
  (begin
    (asserts! (is-eq contract-caller TRUSTED_CALLER) ERR_UNTRUSTED_CALLER)
    (as-contract? ((with-all-assets-unsafe))
      (contract-call? trusted-trait execute)
    )
  )
)
```

***

## with-ft

**Input**:

* `contract-id`: `principal`: The contract defining the FT asset.
* `token-name`: `(string-ascii 128)`: The name of the FT or `"*"` for any FT defined in `contract-id`.
* `amount`: `uint`: The amount of FT to grant access to.

**Output**: Not applicable

**Signature**: `(with-ft contract-id token-name amount)`

**Description**: Adds an outflow allowance for `amount` of the fungible token defined in `contract-id` with name `token-name` from the `asset-owner` of the enclosing `restrict-assets?` or `as-contract?` expression. Note that `token-name` should match the name used in the `define-fungible-token` call in the contract. When `"*"` is used for the token name, the allowance applies to **all** FTs defined in `contract-id`.

**Example**:

```clojure
(restrict-assets? tx-sender
  ((with-ft (contract-of token-trait) "stackaroo" u50))
  (try! (contract-call? token-trait transfer u100 tx-sender 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM none))
) ;; Returns (err u0)
(restrict-assets? tx-sender
  ((with-ft (contract-of token-trait) "stackaroo" u50))
  (try! (contract-call? token-trait transfer u20 tx-sender 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM none))
) ;; Returns (ok true)
```

***

## with-nft

**Input**:

* `contract-id`: `principal`: The contract defining the NFT asset.
* `token-name`: `(string-ascii 128)`: The name of the NFT or `"*"` for any NFT defined in `contract-id`.
* `identifiers`: `(list 128 T)`: The identifiers of the token to grant access to.

**Output**: Not applicable

**Signature**: `(with-nft contract-id token-name identifiers)`

**Description**: Adds an outflow allowance for the non-fungible token(s) identified by `identifiers` defined in `contract-id` with name `token-name` from the `asset-owner` of the enclosing `restrict-assets?` or `as-contract?` expression. Note that `token-name` should match the name used in the `define-non-fungible-token` call in the contract. When `"*"` is used for the token name, the allowance applies to **all** NFTs defined in `contract-id`.

**Example**:

```clojure
(restrict-assets? tx-sender
  ((with-nft (contract-of nft-trait) "stackaroo" (list u123)))
  (try! (contract-call? nft-trait transfer u4 tx-sender 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM))
) ;; Returns (err u0)
(restrict-assets? tx-sender
  ((with-nft (contract-of nft-trait) "stackaroo" (list u123)))
  (try! (contract-call? nft-trait transfer u123 tx-sender 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM))
) ;; Returns (ok true)
```

***

## with-stacking

**Input**:

* `amount`: `uint`: The amount of uSTX that can be locked.

**Output**: Not applicable

**Signature**: `(with-stacking amount)`

**Description**: Adds a stacking allowance for `amount` uSTX from the `asset-owner` of the enclosing `restrict-assets?` or `as-contract?` expression. This restricts calls to the active PoX contract that either delegate funds for stacking or stack directly, ensuring that the locked amount is limited by the amount of uSTX specified.

**Example**:

```clojure
(restrict-assets? tx-sender
  ((with-stacking u1000000000000))
  (try! (contract-call? 'SP000000000000000000002Q6VF78.pox-4 delegate-stx
    u1100000000000 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM none none
  ))
) ;; Returns (err u0)
(restrict-assets? tx-sender
  ((with-stacking u1000000000000))
  (try! (contract-call? 'SP000000000000000000002Q6VF78.pox-4 delegate-stx
    u900000000000 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM none none
  ))
) ;; Returns (ok true)
```

***

## with-stx

**Input**:

* `amount`: `uint`: The amount of uSTX to grant access to.

**Output**: Not applicable

**Signature**: `(with-stx amount)`

**Description**: Adds an outflow allowance for `amount` uSTX from the `asset-owner` of the enclosing `restrict-assets?` or `as-contract?` expression.

**Example**:

```
(restrict-assets? tx-sender
  ((with-stx u1000000))
  (try! (stx-transfer? u2000000 tx-sender 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM))
) ;; Returns (err u0)
(restrict-assets? tx-sender
  ((with-stx u1000000))
  (try! (stx-transfer? u1000000 tx-sender 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM))
) ;; Returns (ok true)
```

***

## xor

Introduced in: **Clarity 1**

**input:** `int, int | uint, uint | string-ascii, string-ascii | string-utf8, string-utf8 | buff, buff`\
**output:** `int | uint`\
**signature:** `(xor i1 i2)`

**description:**\
Bitwise exclusive OR of `i1` and `i2`.

**example:**

```clojure
(xor 1 2) ;; Returns 3
```


# Keywords

The complete reference guide to all Clarity keywords.

{% hint style="info" %}
The Nakamoto hard fork will introduce a few new Clarity keywords. It's important to note that even with the new block production mechanism, the `block-height` keyword behavior will not change. It will simply correspond to the current tenure height. This means any Clarity contracts using this keyword will be backwards compatible after the Nakamoto Upgrade.
{% endhint %}

### block-height

Introduced in: Clarity 1

output: `uint`

description:

Returns the current block height of the Stacks blockchain in Clarity 1 and 2. Upon activation of epoch 3.0, `block-height` will return the same value as `tenure-height`. In Clarity 3, `block-height` is removed and has been replaced with `stacks-block-height`.

example:

```clarity
(> block-height u1000) ;; returns true if the current block-height has passed 1000 blocks.
```

***

### burn-block-height

{% hint style="warning" %}
There is a bug in Clarity 3 when `burn-block-height` is used within an `at-block` expression. Normally, keywords executed within an `at-block` expression will return the data for that specified block. This bug causes `burn-block-height` always to return the burn block at the current chain tip, even within an `at-block` expression. This behavior affects any Clarity 3 contracts and will be fixed in a future hard fork.
{% endhint %}

Introduced in: Clarity 1

output: `uint`

description:

Returns the current block height of the underlying burn blockchain as a uint

example:

```clarity
(> burn-block-height 1000) ;; returns true if the current height of the underlying burn blockchain has passed 1000 blocks.
```

***

### chain-id

Introduced in: Clarity 2

output: `uint`

description:

Returns the 32-bit chain ID of the blockchain running this transaction

example:

```clarity
(print chain-id) ;; Will print 'u1' if the code is running on mainnet, and 'u2147483648' on testnet, and other values on different chains.
```

***

### contract-caller

Introduced in: Clarity 1

output: `principal`

description:

Returns the caller of the current contract context. If this contract is the first one called by a signed transaction, the caller will be equal to the signing principal. If `contract-call?` was used to invoke a function from a new contract, `contract-caller` changes to the *calling* contract's principal. If `as-contract` is used to change the `tx-sender` context, `contract-caller` *also* changes to the same contract principal.

example:

```clarity
(print contract-caller) ;; Will print out a Stacks address of the transaction sender
```

{% hint style="warning" %}
Use caution when leveraging all contract calls, particularly tx-sender and contract-caller as based on the design, you can unintentionally introduce attack surface area. [Read more](https://www.setzeus.com/community-blog-posts/clarity-carefully-tx-sender).
{% endhint %}

***

### current-contract

Introduced in: Clarity 4

output: `principal`

description: Returns the principal of the current contract.

example:

```
(stx-transfer? u1000000 tx-sender current-contract)
```

***

### false

Introduced in: Clarity 1

output: `bool`

description:

Boolean false constant.

example:

```clarity
(and true false) ;; Evaluates to false
(or false true)  ;; Evaluates to true
```

***

### is-in-mainnet

Introduced in: Clarity 2

output: `bool`

description:

Returns a boolean indicating whether or not the code is running on the mainnet

example:

```clarity
(print is-in-mainnet) ;; Will print 'true' if the code is running on the mainnet
```

***

### is-in-regtest

Introduced in: Clarity 1

output: `bool`

description:

Returns whether or not the code is running in a regression test

example:

```clarity
(print is-in-regtest) ;; Will print 'true' if the code is running in a regression test
```

***

### none

Introduced in: Clarity 1

output: `(optional ?)`

description:

Represents the *none* option indicating no value for a given optional (analogous to a null value).

example:

```clarity
(define-public (only-if-positive (a int))
  (if (> a 0)
      (some a)
      none))
(only-if-positive 4) ;; Returns (some 4)
(only-if-positive (- 3)) ;; Returns none
```

```clarity
(print stx-liquid-supply) ;; Will print out the total number of liqui
```

***

### stacks-block-height

Introduced in: Clarity 3

output: `uint`

description:

Returns the current Stacks block height.

example:

```clarity
(print stacks-block-height) ;; Will print out the current Stacks block height
```

***

### stacks-block-time

Introduced in: Clarity 4

output: `uint`

description: Returns the timestamp of the current block in seconds since the Unix epoch

{% hint style="info" %}
This same timestamp can also be retrieved for previous blocks using `(get-stacks-block-info? time height)`, which exists since Clarity 3, but cannot be used for the current block.

Note that `stacks-block-time` will properly account for the context of an `at-block` expression. If the `at-block` sets the context to a block that is from before Clarity 4 has activated, attempting to use `stacks-block-time` in that context will result in a runtime error.
{% endhint %}

```
(if (> stacks-block-time 1755820800)
  (print "after 2025-07-22")
  (print "before 2025-07-22"))
```

***

### stx-liquid-supply

Introduced in: Clarity 1

output: `uint`

description:

Returns the total number of micro-STX (uSTX) that are liquid in the system as of this block.

example:

```clarity
(print stx-liquid-supply) ;; Will print out the total number of liquid uSTX
```

***

### tenure-height

Introduced in: Clarity 3

output: `uint`

description:

Returns the number of tenures that have passed. When the Nakamoto block-processing starts, this will be equal to the chain length.

example:

```clarity
(print tenure-height) ;; Will print out the current tenure height
```

***

### true

Introduced in: Clarity 1

output: `bool`

description:

Boolean true constant.

example:

```clarity
(and true false) ;; Evaluates to false
(or false true)  ;; Evaluates to true
```

***

### tx-sender

Introduced in: Clarity 1

output: `principal`

description:

Returns the original sender of the current transaction, or if `as-contract` was called to modify the sending context, it returns that contract principal.

example:

```clarity
(print tx-sender) ;; Will print out a Stacks address of the transaction sender
```

{% hint style="warning" %}
Use caution when leveraging all contract calls, particularly tx-sender and contract-caller as based on the design, you can unintentionally introduce attack surface area. [Read more](https://www.setzeus.com/community-blog-posts/clarity-carefully-tx-sender).
{% endhint %}

***

### tx-sponsor?

Introduced in: Clarity 2

output: `optional principal`

description:

Returns the sponsor of the current transaction if there is a sponsor, otherwise returns None.

example:

```clarity
(print tx-sponsor?) ;; Will print out an optional value containing the Stacks address of the transaction sponsor
```


# Types

The complete reference guide to all Clarity types.

### Clarity Type System

The type system contains the following types:

| Types                                                 | Notes                                                                                                                                                                                |
| ----------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `int`                                                 | signed 128-bit integer                                                                                                                                                               |
| `uint`                                                | unsigned 128-bit integer                                                                                                                                                             |
| `bool`                                                | boolean value (`true` or `false`)                                                                                                                                                    |
| `principal`                                           | object representing a principal (whether a contract principal or standard principal)                                                                                                 |
| `(buff max-len)`                                      | byte buffer of maximum length `max-len`.                                                                                                                                             |
| `(string-ascii max-len)`                              | ASCII string of maximum length `max-len`                                                                                                                                             |
| `(string-utf8 max-len)`                               | UTF-8 string of maximum length `max-len` (u"A smiley face emoji \u{1F600} as a utf8 string")                                                                                         |
| `(list max-len entry-type)`                           | list of maximum length `max-len`, with entries of type `entry-type`                                                                                                                  |
| `{label-0: value-type-0, label-1: value-type-1, ...}` | tuple, group of data values with named fields                                                                                                                                        |
| `(optional some-type)`                                | an option type for objects that can either be `(some value)` or `none`                                                                                                               |
| `(response ok-type err-type)`                         | object used by public functions to commit their changes or abort. May be returned or used by other functions as well, however, only public functions have the commit/abort behavior. |


# Example Contracts


# multi send

Multi send is a very simple but highly useful utility contract for executing multiple STX transfers in a single transaction.

It takes in a list of addresses and amounts and folds through them to execute a STX transfer for each one.

Mainnet contract: <https://explorer.hiro.so/txid/0x59665b756dc0fa9efb3fca9e05a28f572c9b14ca894c115fd3e7d81a563e14f8?chain=mainnet>

{% code title="multi-send.clar" %}

```clojure
;; send-many
(define-private (send-stx (recipient { to: principal, ustx: uint }))
  (stx-transfer? (get ustx recipient) tx-sender (get to recipient)))
(define-private (check-err (result (response bool uint))
                           (prior (response bool uint)))
  (match prior ok-value result
               err-value (err err-value)))
(define-public (send-many (recipients (list 200 { to: principal, ustx: uint })))
  (fold check-err
    (map send-stx recipients)
    (ok true)))
```

{% endcode %}


# audited starter contracts

Here's a list of sample contracts to learn Clarity or to serve as a starting point for your next project. All contracts come from the [Clarity book](https://book.clarity-lang.org/) and have been audited by [Coinfabrik](https://www.coinfabrik.com/).

* [Counter](https://github.com/clarity-lang/book/tree/main/projects/counter)
* [Multisig Vault](https://github.com/clarity-lang/book/tree/main/projects/multisig-vault)
* [Sip-009 NFT](https://github.com/clarity-lang/book/tree/main/projects/sip009-nft)
* [SIP-010 FT](https://github.com/clarity-lang/book/tree/main/projects/sip010-ft)
* [Timelocked Wallet](https://github.com/clarity-lang/book/tree/main/projects/timelocked-wallet)
* [Tiny Market (NFT marketplace)](https://github.com/clarity-lang/book/tree/main/projects/tiny-market)


# stacking

Stacking is implemented as a smart contract using Clarity. You can always find the Stacking contract identifier using the Stacks Blockchain API [`v2/pox` endpoint](https://docs.hiro.so/api#operation/get_pox_info).

Currently, stacking uses the pox-4 contract. The deployed pox-4 contract and included comments can be [viewed in the explorer](https://explorer.hiro.so/txid/SP000000000000000000002Q6VF78.pox-4?chain=mainnet).

In this walkthrough, we'll cover the entire stacking contract from start to finish, including descriptions of the various functions and errors, and when you might use/encounter them.

Rather than walking through the contract line by line, which you can do by simply reading the contract code and the comments, we'll instead explore it from the perspective of conducting stacking operations, including solo stacking, delegating, and running a pool.

At the bottom you will find a list of some errors you may run into and their explanations.

There are a few utilities that make interacting with this contract easier including [Leather Earn](https://earn.leather.io/) as an UI and the [@stacks/stacking package](https://www.npmjs.com/package/@stacks/stacking) for a JS library.

Hiro has a [detailed guide](https://docs.hiro.so/stacks.js/guides/how-to-integrate-stacking) available for stacking using this library as well as a [Nakamoto guide](https://docs.hiro.so/nakamoto/stacks-js) specifically for the additions made to work with `pox-4`.

### Prerequisites

If you are not familiar with stacking as a concept, it will be useful to [familiarize yourself with that first](https://docs.stacks.co/reference/clarity/example-contracts/broken-reference) before diving into the contract.

***

## Solo Stacking

Solo stacking is the simplest option, and begins by calling the `stack-stx` function.

### stack-stx

This function locks up the given amount of STX for the given lock period (number of reward cycles) for the `tx-sender`.

Here's the full code for that function, then we'll dive into how it works below that.

{% code title="pox-4: stack-stx" %}

```clojure
(define-public (stack-stx (amount-ustx uint)
                          (pox-addr (tuple (version (buff 1)) (hashbytes (buff 32))))
                          (start-burn-ht uint)
                          (lock-period uint)
                          (signer-sig (optional (buff 65)))
                          (signer-key (buff 33))
                          (max-amount uint)
                          (auth-id uint))
    ;; this stacker's first reward cycle is the _next_ reward cycle
    (let ((first-reward-cycle (+ u1 (current-pox-reward-cycle)))
          (specified-reward-cycle (+ u1 (burn-height-to-reward-cycle start-burn-ht))))
      ;; the start-burn-ht must result in the next reward cycle, do not allow stackers
      ;;  to "post-date" their `stack-stx` transaction
      (asserts! (is-eq first-reward-cycle specified-reward-cycle)
                (err ERR_INVALID_START_BURN_HEIGHT))

      ;; must be called directly by the tx-sender or by an allowed contract-caller
      (asserts! (check-caller-allowed)
                (err ERR_STACKING_PERMISSION_DENIED))

      ;; tx-sender principal must not be stacking
      (asserts! (is-none (get-stacker-info tx-sender))
        (err ERR_STACKING_ALREADY_STACKED))

      ;; tx-sender must not be delegating
      (asserts! (is-none (get-check-delegation tx-sender))
        (err ERR_STACKING_ALREADY_DELEGATED))

      ;; the Stacker must have sufficient unlocked funds
      (asserts! (>= (stx-get-balance tx-sender) amount-ustx)
        (err ERR_STACKING_INSUFFICIENT_FUNDS))

      ;; Validate ownership of the given signer key
      (try! (consume-signer-key-authorization pox-addr (- first-reward-cycle u1) "stack-stx" lock-period signer-sig signer-key amount-ustx max-amount auth-id))

      ;; ensure that stacking can be performed
      (try! (can-stack-stx pox-addr amount-ustx first-reward-cycle lock-period))

      ;; register the PoX address with the amount stacked
      (let ((reward-set-indexes (try! (add-pox-addr-to-reward-cycles pox-addr first-reward-cycle lock-period amount-ustx tx-sender signer-key))))
          ;; add stacker record
         (map-set stacking-state
           { stacker: tx-sender }
           { pox-addr: pox-addr,
             reward-set-indexes: reward-set-indexes,
             first-reward-cycle: first-reward-cycle,
             lock-period: lock-period,
             delegated-to: none })

          ;; return the lock-up information, so the node can actually carry out the lock.
          (ok { stacker: tx-sender, lock-amount: amount-ustx, signer-key: signer-key, unlock-burn-height: (reward-cycle-to-burn-height (+ first-reward-cycle lock-period)) }))))
```

{% endcode %}

First let's cover the needed parameters.

* `amount-ustx` is the amount of STX you would like to lock, denoted in micro-STX, or uSTX (1 STX = 1,000,000 uSTX).
* `pox-addr` is a tuple that encodes the Bitcoin address to be used for the PoX rewards, details below.
* `start-burn-ht` is the Bitcoin block height you would like to begin stacking. You will receive rewards in the reward cycle following `start-burn-ht`. Importantly, `start-burn-ht` may not be further into the future than the current reward cycle, and in most cases should be set to the current burn block height.
* `lock-period` sets the number of reward cycles you would like you lock your STX for, this can be between 1 and 12.
* `signer-sig` is a unique generated signature that proves ownership of this signer. Further details for its role and how to generate it can be found in the [How to Stack](https://docs.stacks.co/reference/clarity/example-contracts/broken-reference) document.
* `signer-key` is the public key of your signer, more details in the [How to Run a Signer](https://docs.stacks.co/reference/clarity/example-contracts/broken-reference) document.
* `max-amount` sets the maximum amount allowed to be stacked during the provided stacking period.
* `auth-id` is a unique string to prevent re-use of this stacking transaction.

{% hint style="warning" %}
It's important to make sure that these fields match what you pass in to the signer signature generation. If they don't, you will likely get error 35 (`ERR_INVALID_SIGNATURE_PUBKEY`) when trying to submit this transaction as the signer signature will not be valid.
{% endhint %}

### Supported Reward Address Types

{% hint style="info" %}
For the `pox-addr` field, the `version` buffer must represent what kind of bitcoin address is being submitted. These are all the possible values you can pass here depending on your address type:

```clojure
(define-constant ADDRESS_VERSION_P2PKH 0x00)
(define-constant ADDRESS_VERSION_P2SH 0x01)
(define-constant ADDRESS_VERSION_P2WPKH 0x02)
(define-constant ADDRESS_VERSION_P2WSH 0x03)
(define-constant ADDRESS_VERSION_NATIVE_P2WPKH 0x04)
(define-constant ADDRESS_VERSION_NATIVE_P2WSH 0x05)
(define-constant ADDRESS_VERSION_NATIVE_P2TR 0x06)
```

The `hashbytes` are the 20 hash bytes of the bitcoin address. You can obtain that from a bitcoin library, for instance using [`bitcoinjs-lib`](https://github.com/bitcoinjs/bitcoinjs-lib):

```javascript
const btc = require("bitcoinjs-lib");
console.log(
  "0x" +
    btc.address
      .fromBase58Check("1C56LYirKa3PFXFsvhSESgDy2acEHVAEt6")
      .hash.toString("hex")
);
```

{% endhint %}

The `stack-stx` function performs several checks including:

* The `start-burn-ht` results in the next reward cycle
* The function is being called by the `tx-sender` or an allowed contract caller
* The `tx-sender` is not currently stacking or delegating
* The `tx-sender` has enough funds
* The given `signer-key` is valid, proving ownership
* Stacking can be performed (amount meets minimum threshold, lock period and bitcoin address are valid)

Next the function registers the provided PoX address for the next reward cycle, assigns its specific reward slot, and adds it to the `stacking-state` map, which keeps track of all current stackers per reward cycle.

Finally it returns the lock-up information so the node can carry out the lock. This step is what actually locks the STX and prevents the stacker from using them on-chain.

From here, the locked STX tokens will be unlocked automatically at the end of the lock period. The stacker can also call `stack-increase` or `stack-extend` to increase the amount locked or extend the time.

***

## Delegated Stacking

Delegated stacking is essentially a multi-step process where delegators give pool operators permission to lock STX on their behalf. The typical flow:

{% stepper %}
{% step %}

### Step: Delegator delegates their STX to a pool operator

The delegator calls `delegate-stx` to record that they delegate a given amount to a specific pool operator. This does not lock the STX — it only records the delegation permission.
{% endstep %}

{% step %}

### Step: Pool operator stacks delegated STX (partial)

The pool operator calls `delegate-stack-stx` for each delegator they will lock on behalf of. This marks those STX as partially stacked (not yet in the official reward set).
{% endstep %}

{% step %}

### Step: Pool operator commits aggregated locks

When the pool operator has aggregated enough delegated STX, they call `stack-aggregation-commit-indexed` (wraps `inner-stack-aggregation-commit`) to commit the aggregated stake into the reward set for the reward cycle.
{% endstep %}
{% endstepper %}

There are also alternative actions like revoking delegation (see contract functions).

***

### delegate-stx

This function is called by the individual stacker delegating their STX to a pool operator. An individual stacker choosing to delegate does not need to run their own signer.

This function does not actually lock the STX, but just allows the pool operator to issue the lock.

{% code title="pox-4: delegate-stx" %}

```clojure
(define-public (delegate-stx (amount-ustx uint)
                             (delegate-to principal)
                             (until-burn-ht (optional uint))
                             (pox-addr (optional { version: (buff 1), hashbytes: (buff 32) })))

    (begin
      ;; must be called directly by the tx-sender or by an allowed contract-caller
      (asserts! (check-caller-allowed)
                (err ERR_STACKING_PERMISSION_DENIED))

      ;; delegate-stx no longer requires the delegator to not currently
      ;; be stacking.
      ;; delegate-stack-* functions assert that
      ;; 1. users can't swim in two pools at the same time.
      ;; 2. users can't switch pools without cool down cycle.
      ;;    Other pool admins can't increase or extend.
      ;; 3. users can't join a pool while already directly stacking.

      ;; pox-addr, if given, must be valid
      (match pox-addr
         address
            (asserts! (check-pox-addr-version (get version address))
                (err ERR_STACKING_INVALID_POX_ADDRESS))
         true)

      ;; tx-sender must not be delegating
      (asserts! (is-none (get-check-delegation tx-sender))
        (err ERR_STACKING_ALREADY_DELEGATED))

      ;; add delegation record
      (map-set delegation-state
        { stacker: tx-sender }
        { amount-ustx: amount-ustx,
          delegated-to: delegate-to,
          until-burn-ht: until-burn-ht,
          pox-addr: pox-addr })

      (ok true)))
```

{% endcode %}

Parameters:

* `amount-ustx`: amount delegating (uSTX)
* `delegate-to`: Stacks address of the pool operator
* `until-burn-ht`: optional expiry burn height for the delegation
* `pox-addr`: optional Bitcoin address where this delegator wants rewards sent (if supplied, pool operator must send rewards to this address)

Checks: caller allowed, `pox-addr` version valid if provided, delegator not already delegating. Updates `delegation-state`. No STX are locked yet — the pool operator must call `delegate-stack-stx`.

***

### delegate-stack-stx

Called by the pool operator to partially stack a delegator's STX.

{% code title="pox-4: delegate-stack-stx" %}

```clojure
(define-public (delegate-stack-stx (stacker principal)
                                   (amount-ustx uint)
                                   (pox-addr { version: (buff 1), hashbytes: (buff 32) })
                                   (start-burn-ht uint)
                                   (lock-period uint))
    ;; this stacker's first reward cycle is the _next_ reward cycle
    (let ((first-reward-cycle (+ u1 (current-pox-reward-cycle)))
          (specified-reward-cycle (+ u1 (burn-height-to-reward-cycle start-burn-ht)))
          (unlock-burn-height (reward-cycle-to-burn-height (+ (current-pox-reward-cycle) u1 lock-period))))
      ;; the start-burn-ht must result in the next reward cycle, do not allow stackers
      ;;  to "post-date" their `stack-stx` transaction
      (asserts! (is-eq first-reward-cycle specified-reward-cycle)
                (err ERR_INVALID_START_BURN_HEIGHT))

      ;; must be called directly by the tx-sender or by an allowed contract-caller
      (asserts! (check-caller-allowed)
        (err ERR_STACKING_PERMISSION_DENIED))

      ;; stacker must have delegated to the caller
      (let ((delegation-info (unwrap! (get-check-delegation stacker) (err ERR_STACKING_PERMISSION_DENIED))))
        ;; must have delegated to tx-sender
        (asserts! (is-eq (get delegated-to delegation-info) tx-sender)
                  (err ERR_STACKING_PERMISSION_DENIED))
        ;; must have delegated enough stx
        (asserts! (>= (get amount-ustx delegation-info) amount-ustx)
                  (err ERR_DELEGATION_TOO_MUCH_LOCKED))
        ;; if pox-addr is set, must be equal to pox-addr
        (asserts! (match (get pox-addr delegation-info)
                         specified-pox-addr (is-eq pox-addr specified-pox-addr)
                         true)
                  (err ERR_DELEGATION_POX_ADDR_REQUIRED))
        ;; delegation must not expire before lock period
        (asserts! (match (get until-burn-ht delegation-info)
                         until-burn-ht (>= until-burn-ht
                                           unlock-burn-height)
                      true)
                  (err ERR_DELEGATION_EXPIRES_DURING_LOCK))
        )

      ;; stacker principal must not be stacking
      (asserts! (is-none (get-stacker-info stacker))
        (err ERR_STACKING_ALREADY_STACKED))

      ;; the Stacker must have sufficient unlocked funds
      (asserts! (>= (stx-get-balance stacker) amount-ustx)
        (err ERR_STACKING_INSUFFICIENT_FUNDS))

      ;; ensure that stacking can be performed
      (try! (minimal-can-stack-stx pox-addr amount-ustx first-reward-cycle lock-period))

      ;; register the PoX address with the amount stacked via partial stacking
      ;;   before it can be included in the reward set, this must be committed!
      (add-pox-partial-stacked pox-addr first-reward-cycle lock-period amount-ustx)

      ;; add stacker record
      (map-set stacking-state
        { stacker: stacker }
        { pox-addr: pox-addr,
          first-reward-cycle: first-reward-cycle,
          reward-set-indexes: (list),
          lock-period: lock-period,
          delegated-to: (some tx-sender) })

      ;; return the lock-up information, so the node can actually carry out the lock.
      (ok { stacker: stacker,
            lock-amount: amount-ustx,
            unlock-burn-height: unlock-burn-height })))
```

{% endcode %}

This function validates the delegation record, ensures the delegator has the funds and is not already stacking, runs lightweight stacking checks, registers the partial stacked amount, and updates `stacking-state`. The STX remain partially stacked until the operator commits.

***

### stack-aggregation-commit-indexed / inner-stack-aggregation-commit

The `stack-aggregation-commit-indexed` function wraps the private `inner-stack-aggregation-commit`. The private function commits partially stacked amounts into the reward set so each pox-addr obtains a reward-slot index.

{% code title="pox-4: inner-stack-aggregation-commit" %}

```clojure
(define-private (inner-stack-aggregation-commit (pox-addr { version: (buff 1), hashbytes: (buff 32) })
                                                (reward-cycle uint)
                                                (signer-sig (optional (buff 65)))
                                                (signer-key (buff 33))
                                                (max-amount uint)
                                                (auth-id uint))
  (let ((partial-stacked
         ;; fetch the partial commitments
         (unwrap! (map-get? partial-stacked-by-cycle { pox-addr: pox-addr, sender: tx-sender, reward-cycle: reward-cycle })
                  (err ERR_STACKING_NO_SUCH_PRINCIPAL))))
    ;; must be called directly by the tx-sender or by an allowed contract-caller
    (asserts! (check-caller-allowed)
              (err ERR_STACKING_PERMISSION_DENIED))
    (let ((amount-ustx (get stacked-amount partial-stacked)))
      (try! (consume-signer-key-authorization pox-addr reward-cycle "agg-commit" u1 signer-sig signer-key amount-ustx max-amount auth-id))
      (try! (can-stack-stx pox-addr amount-ustx reward-cycle u1))
      ;; Add the pox addr to the reward cycle, and extract the index of the PoX address
      ;; so the delegator can later use it to call stack-aggregation-increase.
      (let ((add-pox-addr-info
                (add-pox-addr-to-ith-reward-cycle
                   u0
                   { pox-addr: pox-addr,
                     first-reward-cycle: reward-cycle,
                     num-cycles: u1,
                     reward-set-indexes: (list),
                     stacker: none,
                     signer: signer-key,
                     amount-ustx: amount-ustx,
                     i: u0 }))
           (pox-addr-index (unwrap-panic
                (element-at (get reward-set-indexes add-pox-addr-info) u0))))

        ;; don't update the stacking-state map,
        ;;  because it _already has_ this stacker's state
        ;; don't lock the STX, because the STX is already locked
        ;;
        ;; clear the partial-stacked state, and log it
        (map-delete partial-stacked-by-cycle { pox-addr: pox-addr, sender: tx-sender, reward-cycle: reward-cycle })
        (map-set logged-partial-stacked-by-cycle { pox-addr: pox-addr, sender: tx-sender, reward-cycle: reward-cycle } partial-stacked)
        (ok pox-addr-index)))))
```

{% endcode %}

Key points:

* Validates caller and signer signature.
* Validates stacking conditions.
* Adds the aggregated pox-addr to the reward cycle and returns its reward-set index.
* Deletes the partial-stacked entry and logs it.

***

## How Stacking Reward Distribution Works

All of the above stacking functions take a `pox-addr` field that corresponds to a Bitcoin address where BTC rewards will be sent. It's important to understand how these addresses are used and how reward distribution is handled.

How Bitcoin rewards are distributed is primarily up to the discretion of the pool operator. Since PoX reward distributions are handled using Bitcoin transactions, there is currently not an effective way to automate their distribution to individual delegated stackers.

Role of `pox-addr` by function:

* stack-stx: Bitcoin address for the solo stacker to receive rewards.
* delegate-stx: Optional. If omitted, the pool operator decides where to send this delegator's rewards. If provided, the pool operator must send rewards to that address. Note: if provided, the delegator must have enough STX to meet the minimum stacking amount (each unique `pox-addr` consumes a reward slot).
* delegate-stack-stx and stack-aggregation-commit-indexed: `pox-addr` is where the pool operator will receive BTC rewards for that aggregated stake. Pool operators typically use wrapper contracts or off-chain accounting to distribute BTC to delegators.

***

## Errors

You may encounter several errors when trying to perform stacking operations. Below are some of the more common errors with explanations and how to resolve them.

<details>

<summary>Error 35 - ERR_INVALID_SIGNATURE_PUBKEY</summary>

This is likely the most common error you will encounter, and you'll usually see it in a failed `stack-stx` or `stack-aggregation-commit` transaction.

This error occurs in `consume-signer-key-authorization` which is called any time a signer signature is provided.

Possible causes:

* The public key you used to generate the signer signature is not the same as the one you are passing in to the `signer-key` field.
* One of the fields you passed in to generate your signer signature does not match the field you passed in to either the `stack-stx` or `stack-aggregation-commit` function.

How to fix: verify that the signer signature was generated using the exact same signer public key and parameters (amount, pox-addr/reward-cycle, lock period, max-amount, auth-id, etc.) as what you are passing into the contract call.

</details>

<details>

<summary>Error 4 - ERR_STACKING_NO_SUCH_PRINCIPAL</summary>

This error means the contract lookup for a partially stacked entry failed. The stacking contract looks up partially stacked STX (after `delegate-stack-stx`) by the key `(pox-addr, stx-address, reward-cycle)`. If any of those parameters are wrong when generating the signature or calling `stack-aggregation-commit`, the lookup will fail.

How to fix: check that the `pox-addr`, `stacker` principal (stx address), and `reward-cycle` values match exactly what was used in `delegate-stack-stx` / the signature generation. See the [stacking guide](https://docs.stacks.co/reference/clarity/example-contracts/broken-reference) for delegation flow details.

</details>

<details>

<summary>Error 24 - ERR_INVALID_START_BURN_HEIGHT</summary>

This means the `start-burn-height` parameter parsed was invalid (it corresponded to a past or future cycle rather than the current next reward cycle). You will mostly see this in `stack-stx` or `delegate-stack-stx` failed transactions.

How to fix: set `start-burn-ht` to the current burn block height corresponding to the next reward cycle (or compute it using node APIs / libraries that map burn height to reward cycles).

</details>


# bns

The Bitcoin Name System (BNS) is implemented as a smart contract using Clarity.

Below is a list of public and read-only functions as well as error codes that can be returned by those methods.

***

## Public functions

### name-import

Signature:

{% code title="Signature" %}

```clojure
(name-import namespace name beneficiary zonefile-hash)
```

{% endcode %}

Input: `(buff 20), (buff 48), principal, (buff 20)`\
Output: `(response bool int)`

Description:\
Imports name to a revealed namespace. Each imported name is given both an owner and some off-chain state.

***

### name-preorder

Signature:

{% code title="Signature" %}

```clojure
(name-preorder hashed-salted-fqn stx-to-burn)
```

{% endcode %}

Input: `(buff 20), uint`\
Output: `(response uint int)`

Description:\
Preorders a name by telling all BNS nodes the salted hash of the BNS name. It pays the registration fee to the namespace owner's designated address.

***

### name-register

Signature:

{% code title="Signature" %}

```clojure
(name-register namespace name salt zonefile-hash)
```

{% endcode %}

Input: `(buff 20), (buff 48), (buff 20), (buff 20)`\
Output: `(response bool int)`

Description:\
Reveals the salt and the name to all BNS nodes, and assigns the name an initial public key hash and zone file hash.

***

### name-renewal

Signature:

{% code title="Signature" %}

```clojure
(name-renewal namespace name stx-to-burn new-owner zonefile-hash)
```

{% endcode %}

Input: `(buff 20), (buff 48), uint, (optional principal), (optional (buff 20))`\
Output: `(response bool int)`

Description:\
Depending on the namespace rules, a name can expire. For example, names in the .id namespace expire after 2 years. You need to send a name renewal every so often to keep your name.

You will pay the registration cost of your name to the namespace's designated burn address when you renew it. When a name expires, it enters a "grace period". The period is set to 5000 blocks (a month) but can be configured for each namespace.

It will stop resolving in the grace period, and all of the above operations will cease to be honored by the BNS consensus rules. You may, however, send a NAME\_RENEWAL during this grace period to preserve your name. After the grace period, everybody can register that name again. If your name is in a namespace where names do not expire, then you never need to use this transaction.

***

### name-revoke

Signature:

{% code title="Signature" %}

```clojure
(name-revoke namespace name)
```

{% endcode %}

Input: `(buff 20), (buff 48)`\
Output: `(response bool int)`

Description:\
Makes a name unresolvable. The BNS consensus rules stipulate that once a name is revoked, no one can change its public key hash or its zone file hash. The name's zone file hash is set to null to prevent it from resolving. You should only do this if your private key is compromised, or if you want to render your name unusable for whatever reason.

***

### name-transfer

Signature:

{% code title="Signature" %}

```clojure
(name-transfer namespace name new-owner zonefile-hash)
```

{% endcode %}

Input: `(buff 20), (buff 48), principal, (optional (buff 20))`\
Output: `(response bool int)`

Description:\
Changes the name's public key hash. You would send a name transfer transaction if you wanted to:

* Change your private key
* Send the name to someone else
* Update your zone file

When transferring a name, you have the option to also clear the name's zone file hash (i.e. set it to null). This is useful for when you send the name to someone else, so the recipient's name does not resolve to your zone file.

***

### name-update

Signature:

{% code title="Signature" %}

```clojure
(name-update namespace name zonefile-hash)
```

{% endcode %}

Input: `(buff 20), (buff 48), (buff 20)`\
Output: `(response bool int)`

Description:\
Changes the name's zone file hash. You would send a name update transaction if you wanted to change the name's zone file contents. For example, you would do this if you want to deploy your own Gaia hub and want other people to read from it.

***

### namespace-preorder

Signature:

{% code title="Signature" %}

```clojure
(namespace-preorder hashed-salted-namespace stx-to-burn)
```

{% endcode %}

Input: `(buff 20), uint`\
Output: `(response uint int)`

Description:\
Registers the salted hash of the namespace with BNS nodes, and burns the requisite amount of cryptocurrency. Additionally, this step proves to the BNS nodes that user has honored the BNS consensus rules by including a recent consensus hash in the transaction. Returns pre-order's expiration date (in blocks).

***

### namespace-ready

Signature:

{% code title="Signature" %}

```clojure
(namespace-ready namespace)
```

{% endcode %}

Input: `(buff 20)`\
Output: `(response bool int)`

Description:\
Launches the namespace and makes it available to the public. Once a namespace is launched, anyone can register a name in it if they pay the appropriate amount of cryptocurrency.

***

### namespace-reveal

Signature:

{% code title="Signature" %}

```clojure
(namespace-reveal namespace namespace-salt p-func-base p-func-coeff p-func-b1 p-func-b2 p-func-b3 p-func-b4 p-func-b5 p-func-b6 p-func-b7 p-func-b8 p-func-b9 p-func-b10 p-func-b11 p-func-b12 p-func-b13 p-func-b14 p-func-b15 p-func-b16 p-func-non-alpha-discount p-func-no-vowel-discount lifetime namespace-import)
```

{% endcode %}

Input: `(buff 20), (buff 20), uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, principal`\
Output: `(response bool int)`

Description:\
Reveals the salt and the namespace ID (after a namespace preorder). It reveals how long names last in this namespace before they expire or must be renewed, and it sets a price function for the namespace that determines how cheap or expensive names will be. All of the parameters prefixed by `p` make up the price function. These parameters govern the pricing and lifetime of names in the namespace.

Rules for a namespace:

* A name can fall into one of 16 buckets, measured by length. Bucket 16 incorporates all names at least 16 characters long.
* The pricing structure applies a multiplicative penalty for having numeric characters, or punctuation characters.
* The price of a name in a bucket is: ((coeff) \* (base) ^ (bucket exponent)) / ((numeric discount multiplier) \* (punctuation discount multiplier))

Example parameters:

* base = 10
* coeff = 2
* nonalpha discount: 10
* no-vowel discount: 10
* buckets 1, 2: 9
* buckets 3, 4, 5, 6: 8
* buckets 7–14: 7
* buckets 15, 16+: (not specified in source)

***

## Read-only functions

### can-name-be-registered

Signature:

{% code title="Signature" %}

```clojure
(can-name-be-registered namespace name)
```

{% endcode %}

Input: `(buff 20), (buff 48)`\
Output: `(response bool int)`

Description:\
Returns true if the provided name can be registered.

***

### can-namespace-be-registered

Signature:

{% code title="Signature" %}

```clojure
(can-namespace-be-registered namespace)
```

{% endcode %}

Input: `(buff 20)`\
Output: `(response bool UnknownType)`

Description:\
Returns true if the provided namespace is available.

***

### can-receive-name

Signature:

{% code title="Signature" %}

```clojure
(can-receive-name owner)
```

{% endcode %}

Input: `principal`\
Output: `(response bool int)`

Description:\
Returns true if the provided name can be received. That is, if it is not currently owned, a previous lease is expired, and the name wasn't revoked.

***

### get-name-price

Signature:

{% code title="Signature" %}

```clojure
(get-name-price namespace name)
```

{% endcode %}

Input: `(buff 20), (buff 48)`\
Output: `(response uint int)`

Description:\
Gets the price for a name.

***

### get-namespace-price

Signature:

{% code title="Signature" %}

```clojure
(get-namespace-price namespace)
```

{% endcode %}

Input: `(buff 20)`\
Output: `(response uint int)`

Description:\
Gets the price for a namespace.

***

### get-namespace-properties

Signature:

{% code title="Signature" %}

```clojure
(get-namespace-properties namespace)
```

{% endcode %}

Input: `(buff 20)`\
Output: `(response (tuple (namespace (buff 20)) (properties (tuple (can-update-price-function bool) (launched-at (optional uint)) (lifetime uint) (namespace-import principal) (price-function (tuple (base uint) (buckets (list 16 uint)) (coeff uint) (no-vowel-discount uint) (nonalpha-discount uint))) (revealed-at uint)))) int)`

Description:\
Get namespace properties.

***

### is-name-lease-expired

Signature:

{% code title="Signature" %}

```clojure
(is-name-lease-expired namespace name)
```

{% endcode %}

Input: `(buff 20), (buff 48)`\
Output: `(response bool int)`

Description:\
Return true if the provided name lease is expired.

***

### name-resolve

Signature:

{% code title="Signature" %}

```clojure
(name-resolve namespace name)
```

{% endcode %}

Input: `(buff 20), (buff 48)`\
Output: `(response (tuple (lease-ending-at (optional uint)) (lease-started-at uint) (owner principal) (zonefile-hash (buff 20))) int)`

Description:\
Get name registration details.

***

### resolve-principal

Signature:

{% code title="Signature" %}

```clojure
(resolve-principal owner)
```

{% endcode %}

Input: `principal`\
Output: `(response (tuple (name (buff 48)) (namespace (buff 20))) (tuple (code int) (name (optional (tuple (name (buff 48)) (namespace (buff 20)))))))`

Description:\
Returns the registered name that a principal owns if there is one. A principal can only own one name at a time.

***

## Error codes

* ERR\_INSUFFICIENT\_FUNDS — type: int, value: 4001
* ERR\_NAMESPACE\_ALREADY\_EXISTS — type: int, value: 1006
* ERR\_NAMESPACE\_ALREADY\_LAUNCHED — type: int, value: 1014
* ERR\_NAMESPACE\_BLANK — type: int, value: 1013
* ERR\_NAMESPACE\_CHARSET\_INVALID — type: int, value: 1016
* ERR\_NAMESPACE\_HASH\_MALFORMED — type: int, value: 1015
* ERR\_NAMESPACE\_NOT\_FOUND — type: int, value: 1005
* ERR\_NAMESPACE\_NOT\_LAUNCHED — type: int, value: 1007
* ERR\_NAMESPACE\_OPERATION\_UNAUTHORIZED — type: int, value: 1011
* ERR\_NAMESPACE\_PREORDER\_ALREADY\_EXISTS — type: int, value: 1003
* ERR\_NAMESPACE\_PREORDER\_CLAIMABILITY\_EXPIRED — type: int, value: 1009
* ERR\_NAMESPACE\_PREORDER\_EXPIRED — type: int, value: 1002
* ERR\_NAMESPACE\_PREORDER\_LAUNCHABILITY\_EXPIRED — type: int, value: 1010
* ERR\_NAMESPACE\_PREORDER\_NOT\_FOUND — type: int, value: 1001
* ERR\_NAMESPACE\_PRICE\_FUNCTION\_INVALID — type: int, value: 1008
* ERR\_NAMESPACE\_STX\_BURNT\_INSUFFICIENT — type: int, value: 1012
* ERR\_NAMESPACE\_UNAVAILABLE — type: int, value: 1004
* ERR\_NAME\_ALREADY\_CLAIMED — type: int, value: 2011
* ERR\_NAME\_BLANK — type: int, value: 2010
* ERR\_NAME\_CHARSET\_INVALID — type: int, value: 2022
* ERR\_NAME\_CLAIMABILITY\_EXPIRED — type: int, value: 2012
* ERR\_NAME\_COULD\_NOT\_BE\_MINTED — type: int, value: 2020
* ERR\_NAME\_COULD\_NOT\_BE\_TRANSFERRED — type: int, value: 2021
* ERR\_NAME\_EXPIRED — type: int, value: 2008
* ERR\_NAME\_GRACE\_PERIOD — type: int, value: 2009
* ERR\_NAME\_HASH\_MALFORMED — type: int, value: 2017
* ERR\_NAME\_NOT\_FOUND — type: int, value: 2013
* ERR\_NAME\_NOT\_RESOLVABLE — type: int, value: 2019
* ERR\_NAME\_OPERATION\_UNAUTHORIZED — type: int, value: 2006
* ERR\_NAME\_PREORDERED\_BEFORE\_NAMESPACE\_LAUNCH — type: int, value: 2018
* ERR\_NAME\_PREORDER\_ALREADY\_EXISTS — type: int, value: 2016
* ERR\_NAME\_PREORDER\_EXPIRED — type: int, value: 2002
* ERR\_NAME\_PREORDER\_FUNDS\_INSUFFICIENT — type: int, value: 2003
* ERR\_NAME\_PREORDER\_NOT\_FOUND — type: int, value: 2001
* ERR\_NAME\_REVOKED — type: int, value: 2014
* ERR\_NAME\_STX\_BURNT\_INSUFFICIENT — type: int, value: 2007
* ERR\_NAME\_TRANSFER\_FAILED — type: int, value: 2015
* ERR\_NAME\_UNAVAILABLE — type: int, value: 2004
* ERR\_PANIC — type: int, value: 0
* ERR\_PRINCIPAL\_ALREADY\_ASSOCIATED — type: int, value: 3001


# CLI Reference

The Clarinet CLI provides a comprehensive suite of tools for Clarity smart contract development. From project initialization to deployment, Clarinet streamlines your entire development workflow.

* Create a new project: `clarinet new`
* Generate a new smart contract: `clarinet contracts new`
* Validate contract syntax and types: `clarinet check`
* Interactive REPL for testing contracts: `clarinet console`
* Launch a local development network: `clarinet devnet start`
* Manage deployments: `clarinet deployments`

## Initialize a new project

### clarinet new

`clarinet new` creates a new project with all necessary configuration files and directory structure.

Usage

```
clarinet new [OPTIONS] <NAME>
```

```bash
$ clarinet new my-defi-protocol
Create directory my-defi-protocol
Create directory contracts
Create directory settings
Create directory tests
Create file Clarinet.toml
Create file settings/Mainnet.toml
Create file settings/Testnet.toml
Create file settings/Devnet.toml
Create directory .vscode
Create file .vscode/settings.json
Create file .vscode/tasks.json
Create file .gitignore
Create file .gitattributes
Create file package.json
Create file tsconfig.json
Create file vitest.config.js
```

| Option                | Description                                               |
| --------------------- | --------------------------------------------------------- |
| `--disable-telemetry` | Do not provide developer usage telemetry for this project |

## Manage your contracts

### clarinet contracts

`clarinet contracts` is a subcommand for working with contracts. It has two subcommands:

| Command | Description                                    |
| ------- | ---------------------------------------------- |
| `new`   | Generate files and settings for a new contract |
| `rm`    | Remove files and settings for a contract       |

Usage with `new`

```
clarinet contracts new <COMMAND> <OPTIONS>
```

```bash
$ clarinet contracts new fungible-token
Created file contracts/fungible-token.clar
Created file tests/fungible-token.test.ts
Updated Clarinet.toml
```

Usage with `rm`

```
clarinet contracts rm <COMMAND> <OPTIONS>
```

```bash
$ clarinet contracts rm old-token
Removed file contracts/old-token.clar
Removed file tests/old-token.test.ts
Updated Clarinet.toml
```

| Option                   | Description           |
| ------------------------ | --------------------- |
| `--manifest-path <path>` | Path to Clarinet.toml |

## Validate your contracts

### clarinet check

`clarinet check` checks contracts syntax and performs type checking.

Usage

```
clarinet check [FILE] [OPTIONS]
```

```bash
clarinet check
✔ 3 contracts checked
clarinet check contracts/token.clar
✔ contracts/token.clar syntax checks passed
```

| Option                           | Short | Description                                                                           |
| -------------------------------- | ----- | ------------------------------------------------------------------------------------- |
| `--manifest-path <path>`         | `-m`  | Path to Clarinet.toml                                                                 |
| `--deployment-plan-path <path>`  | `-p`  | If specified, use this deployment file                                                |
| `--use-on-disk-deployment-plan`  | `-d`  | Use on disk deployment plan (prevent updates computing)                               |
| `--use-computed-deployment-plan` | `-c`  | Use computed deployment plan (will overwrite on disk version if any update)           |
| `--enable-clarity-wasm`          |       | Allow the Clarity Wasm preview to run in parallel with the Clarity interpreter (beta) |

## Interact with your contracts in a local REPL

### clarinet console

`clarinet console` loads contracts in a REPL for an interactive session.

Usage

```
clarinet console [OPTIONS]
```

```bash
$ clarinet console
clarity-repl v1.0.0
Enter ".help" for usage hints.
Connected to a transient in-memory database.
```

The Clarinet console offers a variety of commands for contract interaction:

* `::help`: Lists all console commands
* `::functions`: Display all the native functions available in Clarity
* `::keywords`: Display all the native keywords available in Clarity
* `::describe <function> | <keyword>`: Display documentation for a given native function or keyword
* `::toggle_costs`: Display cost analysis after every expression
* `::toggle_timings`: Display the execution duration
* `::mint_stx <principal> <amount>`: Mint STX balance for a given principal
* `::set_tx_sender <principal>`: Set tx-sender variable to principal
* `::get_assets_maps`: Get assets maps for active accounts
* `::get_contracts`: Get contracts
* `::get_block_height`: Get current block height
* `::advance_chain_tip <count>`: Simulate mining of `<count>` blocks
* `::advance_stacks_chain_tip <count>`: Simulate mining of `<count>` stacks blocks
* `::advance_burn_chain_tip <count>`: Simulate mining of `<count>` burnchain blocks
* `::set_epoch <epoch>`: Update the current epoch
* `::get_epoch`: Get current epoch
* `::debug <expr>`: Start an interactive debug session executing `<expr>`
* `::trace <expr>`: Generate an execution trace for `<expr>`
* `::get_costs <expr>`: Display the cost analysis
* `::reload`: Reload the existing contract(s) in the session
* `::read <filename>`: Read expressions from a file
* `::encode <expr>`: Encode an expression to a Clarity Value bytes representation
* `::decode <bytes>`: Decode a Clarity Value bytes representation

| Option                                  | Short | Description                                                                           |
| --------------------------------------- | ----- | ------------------------------------------------------------------------------------- |
| `--manifest-path <path>`                | `-m`  | Path to Clarinet.toml                                                                 |
| `--deployment-plan-path <path>`         | `-p`  | If specified, use this deployment file                                                |
| `--use-on-disk-deployment-plan`         | `-d`  | Use on disk deployment plan (prevent updates computing)                               |
| `--use-computed-deployment-plan`        | `-c`  | Use computed deployment plan (will overwrite on disk version if any update)           |
| `--enable-remote-data`                  | `-r`  | Enable remote data fetching from mainnet or a testnet                                 |
| `--remote-data-api-url <url>`           | `-a`  | Set a custom Stacks Blockchain API URL for remote data fetching                       |
| `--remote-data-initial-height <height>` | `-b`  | Initial remote Stacks block height                                                    |
| `--enable-clarity-wasm`                 |       | Allow the Clarity Wasm preview to run in parallel with the Clarity interpreter (beta) |

## Start a local development network

### clarinet devnet

`clarinet devnet` is a subcommand for working with Devnet. It has two subcommands:

| Command   | Description                                                      |
| --------- | ---------------------------------------------------------------- |
| `start`   | Start a local Devnet network for interacting with your contracts |
| `package` | Generate package of all required devnet artifacts                |

Usage with `start`

```
clarinet devnet start [OPTIONS]
```

```bash
clarinet devnet start
```

| Option                           | Short | Description                                                                 |
| -------------------------------- | ----- | --------------------------------------------------------------------------- |
| `--manifest-path <path>`         | `-m`  | Path to Clarinet.toml                                                       |
| `--no-dashboard`                 |       | Display streams of logs instead of terminal UI dashboard                    |
| `--deployment-plan-path <path>`  | `-p`  | If specified, use this deployment file                                      |
| `--use-on-disk-deployment-plan`  | `-d`  | Use on disk deployment plan (prevent updates computing)                     |
| `--use-computed-deployment-plan` | `-c`  | Use computed deployment plan (will overwrite on disk version if any update) |
| `--package <path>`               |       | Path to Package.json produced by 'clarinet devnet package'                  |

Usage with `package`

```
clarinet devnet package [OPTIONS]
```

```bash
$ clarinet devnet package --name my-devnet
Packaging devnet artifacts...
Created file my-devnet.json
```

| Option                   | Short | Description           |
| ------------------------ | ----- | --------------------- |
| `--name <name>`          | `-n`  | Output json file name |
| `--manifest-path <path>` | `-m`  | Path to Clarinet.toml |

## Manage your deployments

### clarinet deployments

`clarinet deployments` is a subcommand for managing deployments on Devnet/Testnet/Mainnet.

| Command    | Description              |
| ---------- | ------------------------ |
| `check`    | Check deployments format |
| `generate` | Generate new deployment  |
| `apply`    | Apply deployment         |

Usage with `check`

```
clarinet deployments check [OPTIONS]
```

```bash
$ clarinet deployments check
✔ Deployment files are valid
```

| Option                   | Description           |
| ------------------------ | --------------------- |
| `--manifest-path <path>` | Path to Clarinet.toml |

Usage with `generate`

```
clarinet deployments generate [OPTIONS]
```

```bash
$ clarinet deployments generate --testnet
Generated deployment plan
Created file deployments/default.testnet-plan.yaml
```

| Option                   | Description                                                                   |
| ------------------------ | ----------------------------------------------------------------------------- |
| `--simnet`               | Generate a deployment file for simnet environments (console, tests)           |
| `--devnet`               | Generate a deployment file for devnet, using settings/Devnet.toml             |
| `--testnet`              | Generate a deployment file for testnet, using settings/Testnet.toml           |
| `--mainnet`              | Generate a deployment file for mainnet, using settings/Mainnet.toml           |
| `--manifest-path <path>` | Path to Clarinet.toml                                                         |
| `--no-batch`             | Generate a deployment file without trying to batch transactions (simnet only) |
| `--low-cost`             | Compute and set cost, using low priority (network connection required)        |
| `--medium-cost`          | Compute and set cost, using medium priority (network connection required)     |
| `--high-cost`            | Compute and set cost, using high priority (network connection required)       |
| `--manual-cost`          | Leave cost estimation manual                                                  |

Usage with `apply`

```
clarinet deployments apply [OPTIONS]
```

```bash
$ clarinet deployments apply --testnet
Applying deployment to testnet
✔ Broadcasting transaction for token.clar
  Transaction ID: 0x3d4f5...
  Contract: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.token
✔ All contracts deployed successfully
```

| Option                           | Short | Description                                                                 |
| -------------------------------- | ----- | --------------------------------------------------------------------------- |
| `--devnet`                       |       | Apply default deployment settings/default.devnet-plan.toml                  |
| `--testnet`                      |       | Apply default deployment settings/default.testnet-plan.toml                 |
| `--mainnet`                      |       | Apply default deployment settings/default.mainnet-plan.toml                 |
| `--manifest-path <path>`         | `-m`  | Path to Clarinet.toml                                                       |
| `--deployment-plan-path <path>`  | `-p`  | Apply deployment plan specified                                             |
| `--no-dashboard`                 |       | Display streams of logs instead of terminal UI dashboard                    |
| `--use-on-disk-deployment-plan`  | `-d`  | Use on disk deployment plan (prevent updates computing)                     |
| `--use-computed-deployment-plan` | `-c`  | Use computed deployment plan (will overwrite on disk version if any update) |

## Interact with Mainnet contracts

### clarinet requirements

`clarinet requirements` is a subcommand for interacting with Mainnet contracts.

| Command | Description                                            |
| ------- | ------------------------------------------------------ |
| `add`   | Add a mainnet contract as a dependency to your project |

Usage

```
clarinet requirements <COMMAND>
```

```bash
$ clarinet requirements add SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait
Added requirement SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait
Updated Clarinet.toml
```

| Option                   | Description           |
| ------------------------ | --------------------- |
| `--manifest-path <path>` | Path to Clarinet.toml |

## Editor Integrations

### clarinet lsp

`clarinet lsp` starts the Language Server Protocol service for Clarity, enabling intelligent code completion, error highlighting, and other IDE features in supported editors.

Usage

```
clarinet lsp
```

## Debugging

### clarinet dap

`clarinet dap` starts the Debug Adapter Protocol service, enabling debugging features like breakpoints, step-through execution, and variable inspection in supported editors.

Usage

```
clarinet dap
```

## Format your code

### clarinet format

`clarinet format` formats Clarity code files according to standard conventions.

Usage

```
clarinet format [OPTIONS]
```

```bash
clarinet format --check
clarinet format --dry-run
clarinet format --file contracts/token.clar --in-place
```

| Option                       | Short | Description                                            | Required |
| ---------------------------- | ----- | ------------------------------------------------------ | -------- |
| `--check`                    |       | Check if code is formatted without modifying files     | No       |
| `--dry-run`                  |       | Only echo the result of formatting                     | No       |
| `--in-place`                 |       | Replace the contents of a file with the formatted code | No       |
| `--manifest-path <path>`     | `-m`  | Path to Clarinet.toml                                  | No       |
| `--file <file>`              | `-f`  | If specified, format only this file                    | No       |
| `--max-line-length <length>` | `-l`  | Maximum line length                                    | No       |
| `--indent <size>`            | `-i`  | Indentation size, e.g. 2                               | No       |
| `--tabs`                     | `-t`  | Use tabs instead of spaces                             | No       |

## Utilities

### clarinet completions

`clarinet completions` generates shell completion scripts for your shell.

Usage

```
clarinet completions <SHELL>
```

```bash
clarinet completions zsh > ~/.zsh/completions/_clarinet
source ~/.zshrc
```

Supported Shells

* `bash`
* `zsh`
* `fish`
* `powershell`
* `elvish`

| Option            | Short | Description                                              |
| ----------------- | ----- | -------------------------------------------------------- |
| `--shell <shell>` | `-s`  | Specify which shell to generation completions script for |

## Environment Variables

Clarinet supports environment variables for configuration. All environment variables are prefixed with `CLARINET_`:

```bash
export CLARINET_MANIFEST_PATH=/path/to/project
```


# SDK Reference

The Clarinet JS SDK provides a comprehensive suite of helpers for testing and interacting with Clarity smart contracts. From simnet initialization to contract deployment, the SDK streamlines your entire testing workflow.

* Initialize a simulated network: `initSimnet`
* Manage contract state: `getDataVar`, `getMapEntry`
* Call contract functions: `callReadOnlyFn`, `callPublicFn`
* Transfer STX: `transferSTX`
* Deploy contracts: `deployContract`
* Mine blocks: `mineBlock`, `mineEmptyBlock`
* Custom assertions: `toBeOk`, `toBeErr`

## Installation

```bash
npm install @stacks/clarinet-sdk
```

## Initialize simulated network

### initSimnet

`initSimnet` initializes a simulated network for testing your smart contracts.

Usage:

```
initSimnet(manifestPath?: string): Promise<Simnet>
```

```ts
import { initSimnet } from '@stacks/clarinet-sdk';

const simnet = await initSimnet();
```

| Parameter      | Type     | Description                                  |
| -------------- | -------- | -------------------------------------------- |
| `manifestPath` | `string` | Optional path to Clarinet.toml manifest file |

## Simnet properties

### blockHeight

Returns the current block height of simnet.

```ts
const currentBlockHeight = simnet.blockHeight;
// Returns: 1
```

### deployer

Returns the default deployer address as defined in the project file.

```ts
const deployerAddress = simnet.deployer;
// Returns: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM
```

You can also update the deployer:

```ts
simnet.deployer = 'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5';
```

### currentEpoch

Returns the current epoch of simnet (e.g., 2.5 for Stacks 2.5).

```ts
const epoch = simnet.currentEpoch;
// Returns: 2.5
```

## Account management

### getAccounts

`getAccounts` retrieves all configured Stacks addresses including wallets, deployers, and faucets.

Usage:

```
getAccounts(): Map<string, string>
```

```ts
const accounts = simnet.getAccounts();
const wallet1 = accounts.get('wallet_1')!;
// Returns: ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5
```

## Asset balances

### getAssetsMap

`getAssetsMap` retrieves asset balances for all addresses, including STX, fungible, and non-fungible tokens.

Usage:

```
getAssetsMap(): Map<string, Map<string, bigint>>
```

```ts
const assets = simnet.getAssetsMap();
const stxBalances = assets.get('STX')!;
const deployerBalance = stxBalances.get(simnet.deployer)!;
// Returns: 100000000000000n
```

## Read contract state

### getDataVar

`getDataVar` retrieves the value of a data variable from a contract.

Usage:

```
getDataVar(contract: string, dataVar: string): ClarityValue
```

```ts
const count = simnet.getDataVar('counter', 'count');
// Returns: { type: 1, value: 1n }
```

| Parameter  | Type     | Description               |
| ---------- | -------- | ------------------------- |
| `contract` | `string` | Contract identifier       |
| `dataVar`  | `string` | Name of the data variable |

### getMapEntry

`getMapEntry` retrieves a value from a contract map by its key.

Usage:

```
getMapEntry(contract: string, mapName: string, mapKey: ClarityValue): ClarityValue
```

```ts
import { Cl } from '@stacks/transactions';

const hasParticipated = simnet.getMapEntry(
  "pool",
  "Participants",
  Cl.standardPrincipal(wallet)
);
// Returns: { type: 10, value: { type: 3 } }
```

| Parameter  | Type           | Description         |
| ---------- | -------------- | ------------------- |
| `contract` | `string`       | Contract identifier |
| `mapName`  | `string`       | Name of the map     |
| `mapKey`   | `ClarityValue` | Key to look up      |

## Call contract functions

### callReadOnlyFn

`callReadOnlyFn` calls read-only functions without mining a block.

Usage:

```
callReadOnlyFn(
  contract: string,
  method: string,
  args: ClarityValue[],
  sender: string
): ParsedTransactionResult
```

```ts
import { Cl } from '@stacks/transactions';

const result = simnet.callReadOnlyFn(
  'pool',
  'get-contribution-amount',
  [Cl.standardPrincipal(wallet)],
  wallet
);
// Returns: { result: { type: 1, value: 42000000n }, events: [] }
```

| Parameter  | Type             | Description         |
| ---------- | ---------------- | ------------------- |
| `contract` | `string`         | Contract identifier |
| `method`   | `string`         | Function name       |
| `args`     | `ClarityValue[]` | Function arguments  |
| `sender`   | `string`         | Sender address      |

### callPublicFn

`callPublicFn` calls public functions and mines a block.

Usage:

```
callPublicFn(
  contract: string,
  method: string,
  args: ClarityValue[],
  sender: string
): ParsedTransactionResult
```

```ts
import { Cl } from '@stacks/transactions';

const result = simnet.callPublicFn(
  'pool',
  'register-participant',
  [Cl.standardPrincipal(wallet)],
  wallet
);
// Mines block and returns result
```

### callPrivateFn

`callPrivateFn` calls private functions (testing only) and mines a block.

Usage:

```
callPrivateFn(
  contract: string,
  method: string,
  args: ClarityValue[],
  sender: string
): ParsedTransactionResult
```

```ts
const result = simnet.callPrivateFn(
  "pool",
  "reward-participant-points",
  [Cl.standardPrincipal(address1)],
  wallet
);
```

## Transfer STX

`transferSTX` transfers STX between addresses and mines a block.

Usage:

```
transferSTX(
  amount: number | bigint,
  recipient: string,
  sender: string
): ParsedTransactionResult
```

```ts
const transfer = simnet.transferSTX(
  42000000, // 42 STX in microSTX
  recipient,
  simnet.deployer
);
// Returns transaction result with transfer event
```

| Parameter   | Type               | Description        |
| ----------- | ------------------ | ------------------ |
| `amount`    | `number \| bigint` | Amount in microSTX |
| `recipient` | `string`           | Recipient address  |
| `sender`    | `string`           | Sender address     |

## Deploy contracts

`deployContract` deploys a new contract to simnet and mines a block.

Usage:

```
deployContract(
  name: string,
  content: string,
  options: DeployContractOptions | null,
  sender: string
): ParsedTransactionResult
```

```ts
const sourceCode = '(define-read-only (say-hi) (ok "Hello World"))';

const contract = simnet.deployContract(
  'hello-world',
  sourceCode,
  { clarityVersion: 2 },
  simnet.deployer
);
```

| Parameter | Type             | Description         |
| --------- | ---------------- | ------------------- |
| `name`    | `string`         | Contract name       |
| `content` | `string`         | Clarity source code |
| `options` | `object \| null` | Deployment options  |
| `sender`  | `string`         | Deployer address    |

## Block mining

### mineBlock

`mineBlock` mines a block with multiple transactions.

Usage:

```
mineBlock(txs: Tx[]): ParsedTransactionResult[]
```

```ts
import { tx } from '@stacks/clarinet-sdk';
import { Cl } from '@stacks/transactions';

const block = simnet.mineBlock([
  tx.callPublicFn("counter", "increment", [], simnet.deployer),
  tx.transferSTX(19000000, wallet, simnet.deployer),
]);
```

### mineEmptyBlock

`mineEmptyBlock` mines an empty block and increases block height.

Usage:

```
mineEmptyBlock(): number
```

```ts
simnet.mineEmptyBlock();
const newHeight = simnet.blockHeight;
// Returns: 2
```

### mineEmptyBlocks

`mineEmptyBlocks` mines multiple empty blocks.

Usage:

```
mineEmptyBlocks(count?: number): number
```

```ts
simnet.mineEmptyBlocks(5);
const newHeight = simnet.blockHeight;
// Returns: 6
```

## Utility methods

### runSnippet

`runSnippet` executes arbitrary Clarity code without deploying.

Usage:

```
runSnippet(snippet: string): string | ClarityValue
```

```ts
const result = simnet.runSnippet('(stx-account tx-sender)');
// Returns account balance information
```

### getContractsInterfaces

`getContractsInterfaces` returns contract interfaces with function signatures and storage.

Usage:

```
getContractsInterfaces(): Map<string, ContractInterface>
```

```ts
const interfaces = simnet.getContractsInterfaces();
const poolInterface = interfaces.get(`${simnet.deployer}.pool`);
// Returns contract interface with functions, maps, variables
```

### getContractSource

`getContractSource` retrieves the source code of a deployed contract.

Usage:

```
getContractSource(contract: string): string | undefined
```

```ts
const source = simnet.getContractSource('pool');
// Returns Clarity source code as string
```

### getContractAST

`getContractAST` returns the Abstract Syntax Tree of a contract.

Usage:

```
getContractAST(contractId: string): ContractAST
```

```ts
const ast = simnet.getContractAST('pool');
// Returns parsed AST structure
```

## Custom matchers

The SDK provides Vitest matchers for Clarity value assertions.

### Response matchers

#### toBeOk

Asserts that a response is `(ok <value>)`.

```ts
expect(result).toBeOk(Cl.uint(1));
```

#### toBeErr

Asserts that a response is `(err <value>)`.

```ts
expect(result).toBeErr(Cl.uint(500));
```

#### toBeSome

Asserts that a response is `(some <value>)`.

```ts
expect(result).toBeSome(Cl.bool(true));
```

#### toBeNone

Asserts that a response is `(none)`.

```ts
expect(result).toBeNone();
```

### Value matchers

#### toBeBool

Asserts a boolean value.

```ts
expect(result).toBeBool(true);
```

#### toBeInt

Asserts a signed integer value.

```ts
expect(result).toBeInt(1); // or 1n
```

#### toBeUint

Asserts an unsigned integer value.

```ts
expect(result).toBeUint(1); // or 1n
```

#### toBeAscii

Asserts a string-ascii value.

```ts
expect(result).toBeAscii('Hello World');
```

#### toBeUtf8

Asserts a string-utf8 value.

```ts
expect(result).toBeUtf8('Hello World');
```

#### toBePrincipal

Asserts a principal value.

```ts
expect(Cl.standardPrincipal(deployer)).toBePrincipal(deployer);
```

#### toBeBuff

Asserts a buffer value.

```ts
const buffer = Uint8Array.from([1, 2, 3, 4]);
expect(result).toBeBuff(buffer);
```

#### toBeList

Asserts a list of Clarity values.

```ts
expect(result).toBeList([
  Cl.standardPrincipal('ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM'),
  Cl.standardPrincipal('ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5')
]);
```

#### toBeTuple

Asserts a tuple value.

```ts
expect(result).toBeTuple({
  enrollmentBlock: Cl.some(Cl.uint(1)),
  contributionAmount: Cl.some(Cl.uint(19000000))
});
```

### Type checking

#### toHaveClarityType

Checks that a value has the expected Clarity type.

```ts
expect(result).toHaveClarityType(ClarityType.ResponseOk);
```

### Event matchers

#### toContainEqual

Asserts that an events array contains a specific event. This is useful for checking transaction events.

```ts
// STX transfer event
expect(events).toContainEqual({
  event: "stx_transfer_event",
  data: {
    amount: "1000000",
    memo: "",
    recipient: "ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM",
    sender: "ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5",
  },
});

// Fungible token transfer event
expect(events).toContainEqual({
  event: "ft_transfer_event",
  data: {
    amount: "1000",
    asset_identifier: "ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.token::my-token",
    recipient: recipientAddress,
    sender: senderAddress,
  },
});

// NFT transfer event
expect(events).toContainEqual({
  event: "nft_transfer_event",
  data: {
    asset_identifier: "ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.nft::my-nft",
    value: Cl.serialize(Cl.uint(1)),
    recipient: newOwner,
    sender: previousOwner,
  },
});

// Print event
expect(events).toContainEqual({
  event: "print_event",
  data: {
    contract_id: `${deployer}.my-contract`,
    value: Cl.serialize(Cl.tuple({ message: Cl.stringAscii("Hello") })),
  },
});

// Check only specific properties with objectContaining
expect(events).toContainEqual({
  event: "stx_transfer_event",
  data: expect.objectContaining({
    sender: senderAddress,
    recipient: recipientAddress,
  }),
});
```


# Browser SDK Reference

The browser build of the Clarinet SDK lets you interact with simnet directly from web experiences, so you can run Clarity tests without standing up a Node.js server.

## Installation

{% code title="Install" %}

```bash
npm install @stacks/clarinet-sdk-browser
```

{% endcode %}

## Usage

The browser SDK implements the same API as the Node.js Clarinet SDK. All methods, properties, and custom matchers work identically.

### Empty session

{% code title="Empty session (TypeScript)" %}

```ts
import { initSimnet } from '@stacks/clarinet-sdk-browser';

const simnet = await initSimnet();
await simnet.initEmptySession();

// Execute Clarity code directly
const result = simnet.runSnippet("(+ 1 2)");
console.log(result); // 3
```

{% endcode %}

### With a Clarinet project

For testing with an existing Clarinet project using a virtual file system:

{% code title="Using a Clarinet project (TypeScript)" %}

```ts
import { initSimnet } from '@stacks/clarinet-sdk-browser';

const simnet = await initSimnet();
await simnet.initSession("/project", "Clarinet.toml");

// Your contracts are now available
const count = simnet.getDataVar('counter', 'count');
```

{% endcode %}

{% hint style="info" %}
Virtual file system

Using a Clarinet project in the browser requires setting up a virtual file system. Documentation and examples for this advanced use case are coming soon.
{% endhint %}

## Common use cases

### Interactive contract playground

{% code title="Playground example (TypeScript)" %}

```ts
import { initSimnet } from '@stacks/clarinet-sdk-browser';
import { Cl } from '@stacks/transactions';

// Initialize simnet
const simnet = await initSimnet();
await simnet.initEmptySession();

// Deploy a simple contract
const sourceCode = `
(define-data-var counter uint u0)

(define-public (increment)
  (ok (var-set counter (+ (var-get counter) u1))))

(define-read-only (get-counter)
  (ok (var-get counter)))
`;

simnet.deployContract('counter', sourceCode, null, simnet.deployer);

// Interact with the contract
simnet.callPublicFn('counter', 'increment', [], simnet.deployer);
const count = simnet.callReadOnlyFn('counter', 'get-counter', [], simnet.deployer);
console.log(count.result); // (ok u1)
```

{% endcode %}

### Testing in browser-based IDEs

{% code title="Browser test example (TypeScript + Vitest)" %}

```ts
import { initSimnet } from '@stacks/clarinet-sdk-browser';
import { expect } from 'vitest';

const simnet = await initSimnet();
await simnet.initEmptySession();

// Run tests directly in the browser
test('counter increments correctly', () => {
  simnet.deployContract('counter', counterCode, null, simnet.deployer);
  
  const result = simnet.callPublicFn('counter', 'increment', [], simnet.deployer);
  expect(result.result).toBeOk(Cl.uint(1));
  
  const count = simnet.getDataVar('counter', 'counter');
  expect(count).toBeUint(1);
});
```

{% endcode %}

## Browser compatibility

The browser SDK works in all modern browsers that support:

* ES2020+ JavaScript features
* WebAssembly
* Dynamic imports

Tested browsers include:

* Chrome/Edge 90+
* Firefox 89+
* Safari 15+


# Rendezvous Reference

Complete reference for Rendezvous CLI commands, configuration options, and advanced usage.

This reference explains how to use Rendezvous in different situations. By the end, you'll know when and how to use its features effectively.

## What's Inside

[Running Rendezvous](#running-rendezvous)

* [Positional Arguments](#positional-arguments)
* [Options](#options)
* [Summary](#summary)

[Understanding Rendezvous](#understanding-rendezvous)

* [Example](#example)

[The Rendezvous Context](#the-rendezvous-context)

* [How the Context Works](#how-the-context-works)
* [Using the context to write invariants](#using-the-context-to-write-invariants)

[Discarding Property-Based Tests](#discarding-property-based-tests)

* [Discard Function](#discard-function)
* [In-Place Discarding](#in-place-discarding)
* [Discarding summary](#discarding-summary)

[Custom Manifest Files](#custom-manifest-files)

* [Why use a custom manifest?](#why-use-a-custom-manifest)
* [A test double for `sbtc-registry`](#a-test-double-for-sbtc-registry)
* [A Custom Manifest File](#a-custom-manifest-file)
* [How It Works](#how-it-works)

[Trait Reference Parameters](#trait-reference-parameters)

* [How Trait Reference Selection Works](#how-trait-reference-selection-works)
* [Example](#example-1)
* [Adding More Implementations](#adding-more-implementations)

***

## Running Rendezvous

To run Rendezvous, use the following command:

```bash
rv <path-to-clarinet-project> <contract-name> <type> [--seed] [--runs] [--bail] [--dial]
```

Let's break down each part of the command.

### Positional Arguments

Consider this example Clarinet project structure:

```
root
├── Clarinet.toml
├── contracts
│   ├── contract.clar
│   ├── contract.tests.clar
└── settings
    └── Devnet.toml
```

**1. Path to the Clarinet Project**

The `<path-to-clarinet-project>` is the relative or absolute path to the root directory of the Clarinet project. This is where the `Clarinet.toml` file exists. **It is not the path to the `Clarinet.toml` file itself**.

For example, if you're in the parent directory of `root`, the correct relative path would be:

```bash
rv ./root <contract-name> <type>
```

**2. Contract Name**

The `<contract-name>` is the name of the contract to be tested, as defined in `Clarinet.toml`.

For example, if `Clarinet.toml` contains:

```toml
[contracts.contract]
path = "contracts/contract.clar"
```

To test the contract named `contract`, you would run:

```bash
rv ./root contract <type>
```

**3. Testing Type**

The `<type>` argument specifies the testing technique to use. The available options are:

* `test` – Runs property-based tests.
* `invariant` – Runs invariant tests.

For a deeper understanding of these techniques and when to use each, see [Testing Methodologies](https://stacks-network.github.io/rendezvous/chapter_4.md) chapter of the [Rendezvous Docs](https://stacks-network.github.io/rendezvous/).

**Running property-based tests**

To run property-based tests for the `contract` contract, ensure that your test functions are defined in:

```
./root/contracts/contract.tests.clar
```

Then, execute:

```bash
rv ./root contract test
```

This tells Rendezvous to:

* Load the **Clarinet project** located in `./root`.
* Target the **contract** named `contract` as defined in `Clarinet.toml` by executing **property-based tests** defined in `contract.tests.clar`.

**Running invariant tests**

To run invariant tests for the `contract` contract, ensure that your invariant functions are defined in:

```
./root/contracts/contract.tests.clar
```

To run invariant tests, use:

```bash
rv ./root contract invariant
```

With this command, Rendezvous will:

* Randomly **execute public function calls** in the `contract` contract.
* **Randomly check the defined invariants** to ensure the contract's internal state remains valid.

If an invariant check fails, it means the contract's state has **deviated from expected behavior**, revealing potential bugs.

### Options

Rendezvous also provides additional options to customize test execution:

**1. Customizing the Number of Runs**

By default, Rendezvous runs **100** test iterations. You can modify this using the `--runs` option:

```bash
rv root contract test --runs=500
```

This increases the number of test cases to **500**.

**2. Replaying a Specific Sequence of Events**

To reproduce a previous test sequence, you can use the `--seed` option. This ensures that the same random values are used across test runs:

```bash
rv root contract test --seed=12345
```

**How to Find the Replay Seed**

When Rendezvous detects an issue, it includes the seed needed to reproduce the test in the failure report. Here’s an example of a failure report with the seed:

```
Error: Property failed after 2 tests.
Seed : 426141810

Counterexample:
...

What happened? Rendezvous went on a rampage and found a weak spot:
...
```

In this case, the seed is `426141810`. You can use it to rerun the exact same test scenario:

```bash
rv root contract test --seed=426141810
```

**3. Stop After First Failure**

By default, Rendezvous will start the shrinking process after finding a failure. To stop immediately when the first failure is detected, use the `--bail` option:

```bash
rv root contract test --bail
```

This is useful when you want to examine the first failure without waiting for the complete test run and shrinking process to finish.

**4. Using Dialers**

Dialers allow you to define **pre- and post-execution functions** using JavaScript **during invariant testing**. To use a custom dialer file, run:

```bash
rv root contract invariant --dial=./custom-dialer.js
```

A good example of a dialer can be found in the Rendezvous repository, within the example Clarinet project, inside the [sip010.js file](https://github.com/stacks-network/rendezvous/blob/272b9247cdfcd5d12da89254e622e712d6e29e5e/example/sip010.js).

In that file, you’ll find a **post-dialer** designed as a **sanity check** for SIP-010 token contracts. It ensures that the `transfer` function correctly emits the required **print event** containing the `memo`, as specified in [SIP-010](https://github.com/stacksgov/sips/blob/6ea251726353bd1ad1852aabe3d6cf1ebfe02830/sips/sip-010/sip-010-fungible-token-standard.md?plain=1#L69).

**How Dialers Work**

During **invariant testing**, Rendezvous picks up dialers when executing public function calls:

* **Pre-dialers** run **before** each public function call.
* **Post-dialers** run **after** each public function call.

Both have access to an object containing:

* `selectedFunction` – The function being executed.
* `functionCall` – The result of the function call (`undefined` for **pre-dialers**).
* `clarityValueArguments` – The generated Clarity values used as arguments.

**Example: Post-Dialer for SIP-010**

Below is a **post-dialer** that verifies SIP-010 compliance by ensuring that the `transfer` function emits a print event containing the `memo`.

```js
async function postTransferSip010PrintEvent(context) {
  const { selectedFunction, functionCall, clarityValueArguments } = context;

  // Ensure this check runs only for the "transfer" function.
  if (selectedFunction.name !== "transfer") return;

  const functionCallEvents = functionCall.events;
  const memoParameterIndex = 3; // The memo parameter is the fourth argument.

  const memoGeneratedArgumentCV = clarityValueArguments[memoParameterIndex];

  // If the memo argument is `none`, there's nothing to validate.
  if (memoGeneratedArgumentCV.type === "none") return;

  // Ensure the memo argument is an option (`some`).
  if (memoGeneratedArgumentCV.type !== "some") {
    throw new Error("The memo argument must be an option type!");
  }

  // Convert the `some` value to hex for comparison.
  const hexMemoArgumentValue = cvToHex(memoGeneratedArgumentCV.value);

  // Find the print event in the function call events.
  const sip010PrintEvent = functionCallEvents.find(
    (ev) => ev.event === "print_event"
  );

  if (!sip010PrintEvent) {
    throw new Error(
      "No print event found. The transfer function must emit the SIP-010 print event containing the memo!"
    );
  }

  const sip010PrintEventValue = sip010PrintEvent.data.raw_value;

  // Validate that the emitted print event matches the memo argument.
  if (sip010PrintEventValue !== hexMemoArgumentValue) {
    throw new Error(
      `Print event memo value does not match the memo argument: ${hexMemoArgumentValue} !== ${sip010PrintEventValue}`
    );
  }
}
```

This dialer ensures that any SIP-010 token contract properly emits the **memo print event** during transfers, helping to catch deviations from the standard.

### Summary

| Argument/Option              | Description                                                                      | Example                                           |
| ---------------------------- | -------------------------------------------------------------------------------- | ------------------------------------------------- |
| `<path-to-clarinet-project>` | Path to the Clarinet project (where `Clarinet.toml` is located).                 | `rv root contract test`                           |
| `<contract-name>`            | Name of the contract to test (as in `Clarinet.toml`).                            | `rv root contract test`                           |
| `<type>`                     | Type of test (`test` for property-based tests, `invariant` for invariant tests). | `rv root contract test`                           |
| `--runs=<num>`               | Sets the number of test iterations (default: 100).                               | `rv root contract test --runs=500`                |
| `--seed=<num>`               | Uses a specific seed for reproducibility.                                        | `rv root contract test --seed=12345`              |
| `--dial=<file>`              | Loads JavaScript dialers from a file for pre/post-processing.                    | `rv root contract test --dial=./custom-dialer.js` |

***

## Understanding Rendezvous

Rendezvous makes **property-based tests** and **invariant tests** first-class. Tests are written in the same language as the system under test. This helps developers master the contract language. It also pushes boundaries—programmers shape their thoughts first, then express them using the language's tools.

When Rendezvous initializes a **Simnet session** using a given Clarinet project, it **does not modify any contract** listed in Clarinet.toml—except for the **target contract**. During testing, Rendezvous updates the target contract by merging:

1. **The original contract source code**
2. **The test contract** (which includes property-based tests and invariants)
3. **The Rendezvous context**, which helps track function calls and execution details

### Example

Let’s say we have a contract named `checker` with the following source:

```clarity
;; checker.clar

(define-public (check-it (flag bool))
  (if flag (ok 1) (err u100))
)
```

And its test contract, `checker.tests`:

```clarity
;; checker.tests.clar

(define-public (test-1)
  (ok true)
)

(define-read-only (invariant-1)
  true
)
```

When Rendezvous runs the tests, it **automatically generates a modified contract** that includes the original contract, the tests, and an additional **context** for tracking execution. The final contract source deployed in the Simnet session will look like this:

```
(define-public (check-it (flag bool))
  (if flag (ok 1) (err u100))
)

(define-map context (string-ascii 100) {
    called: uint
    ;; other data
  }
)

(define-public (update-context (function-name (string-ascii 100)) (called uint))
  (ok (map-set context function-name {called: called}))
)

(define-public (test-1)
  (ok true)
)

(define-read-only (invariant-1)
  true
)
```

While the original contract source and test functions are familiar, the **context** is new. Let's take a closer look at it.

## The Rendezvous Context

Rendezvous introduces a **context** to track function calls and execution details during testing. This allows for better tracking of execution details and invariant validation.

### How the Context Works

When a function is successfully executed during a test, Rendezvous records its execution details in a **Clarity map**. This map helps track how often specific functions are called successfully and can be extended for additional tracking in the future.

Here’s how the context is structured:

```clarity
(define-map context (string-ascii 100) {
    called: uint
    ;; Additional fields can be added here
})

(define-public (update-context (function-name (string-ascii 100)) (called uint))
  (ok (map-set context function-name {called: called}))
)
```

**Breaking it down**

* **`context` map** → Keeps track of execution data, storing how many times each function has been called successfully.
* **`update-context` function** → Updates the `context` map whenever a function executes, ensuring accurate tracking.

### Using the context to write invariants

By tracking function calls, the context helps invariants ensure **stronger correctness guarantees**. For example, an invariant can verify that a counter **stays above zero by checking the number of successful `increment` and `decrement` calls**.

**Example invariant using the `context`**

```clarity
(define-read-only (invariant-counter-gt-zero)
  (let
    (
      (increment-num-calls
        (default-to u0 (get called (map-get? context "increment")))
      )
      (decrement-num-calls
        (default-to u0 (get called (map-get? context "decrement")))
      )
    )
    (if
      (<= increment-num-calls decrement-num-calls)
      true
      (> (var-get counter) u0)
    )
  )
)
```

By embedding execution tracking into the contract, Rendezvous enables **more effective smart contract testing**, making it easier to catch bugs and check the contract correctness.

## Discarding Property-Based Tests

Rendezvous generates a wide range of inputs, but not all inputs are valid for every test. To **skip tests with invalid inputs**, there are two approaches:

### Discard Function

A **separate function** determines whether a test should run.

> Rules for a Discard Function:
>
> * Must be **read-only**.
> * Name must match the property test function, prefixed with `"can-"`.
> * Parameters must **mirror** the property test’s parameters.
> * Must return `true` **only if inputs are valid**, allowing the test to run.

**Discard function example**

```clarity
(define-read-only (can-test-add (n uint))
  (> n u1)  ;; Only allow tests where n > 1
)

(define-public (test-add (n uint))
  (let
    ((counter-before (get-counter)))
    (try! (add n))
    (asserts! (is-eq (get-counter) (+ counter-before n)) (err u403))
    (ok true)
  )
)
```

Here, `can-test-add` ensures that the test **never executes** for `n <= 1`.

### In-Place Discarding

Instead of using a separate function, **the test itself decides whether to run**. If the inputs are invalid, the test returns `(ok false)`, discarding itself.

**In-place discarding example**

```clarity
(define-public (test-add (n uint))
  (let
    ((counter-before (get-counter)))
    (ok
      (if
        (<= n u1)  ;; If n <= 1, discard the test.
        false
        (begin
          (try! (add n))
          (asserts! (is-eq (get-counter) (+ counter-before n)) (err u403))
          true
        )
      )
    )
  )
)
```

In this case, if `n <= 1`, the test **discards itself** by returning `(ok false)`, skipping execution.

### Discarding summary

| **Discard Mechanism**   | **When to Use**                                                   |
| ----------------------- | ----------------------------------------------------------------- |
| **Discard Function**    | When skipping execution **before** running the test is necessary. |
| **In-Place Discarding** | When discarding logic is simple and part of the test itself.      |

In general, **in-place discarding is preferred** because it keeps test logic together and is easier to maintain. Use a **discard function** only when it's important to prevent execution entirely.

## Custom Manifest Files

Some smart contracts need a special `Clarinet.toml` file to allow Rendezvous to create state transitions in the contract. Rendezvous supports this feature by **automatically searching for `Clarinet-<target-contract-name>.toml` first**. This allows you to use test doubles while keeping tests easy to manage.

### Why use a custom manifest?

A great example is the **sBTC contract suite**.

For testing the [`sbtc-token`](https://github.com/stacks-network/sbtc/blob/b624e4a8f08eb589a435719b200873e8aa5b3305/contracts/contracts/sbtc-token.clar#L30-L35) contract, the `sbtc-registry` authorization function [`is-protocol-caller`](https://github.com/stacks-network/sbtc/blob/b624e4a8f08eb589a435719b200873e8aa5b3305/contracts/contracts/sbtc-registry.clar#L361-L369) is **too restrictive**. Normally, it only allows calls from protocol contracts, making it **impossible to directly test certain state transitions** in `sbtc-token`.

To work around this, you need two things:

### A test double for `sbtc-registry`

You can create an `sbtc-registry` test double called `sbtc-registry-double.clar`:

```clarity
;; contracts/sbtc-registry-double.clar

...

(define-constant deployer tx-sender)

;; Allows the deployer to act as a protocol contract for testing
(define-read-only (is-protocol-caller (contract-flag (buff 1)) (contract principal))
  (begin
    (asserts! (is-eq tx-sender deployer) (err u1234567))  ;; Enforces deployer check
    (ok true)
  )
)

...
```

This **loosens** the restriction just enough for testing by allowing the `deployer` to act as a protocol caller, while still enforcing an access check.

### A Custom Manifest File

Next, create `Clarinet-sbtc-token.toml` to tell Rendezvous to use the test double **only when targeting `sbtc-token`**:

```toml
# Clarinet-sbtc-token.toml

...

[contracts.sbtc-registry]
path = 'contracts/sbtc-registry-double.clar'
clarity_version = 3
epoch = 3.0

...
```

### How It Works

* When testing `sbtc-token`, Rendezvous **first checks** if `Clarinet-sbtc-token.toml` exists.
* If found, it **uses this file** to initialize Simnet.
* If not, it **falls back** to the standard `Clarinet.toml`.

This ensures that the test double is only used when testing `sbtc-token`, keeping tests realistic while allowing necessary state transitions.

## Trait Reference Parameters

Rendezvous automatically generates arguments for function calls. It handles most Clarity types without any setup from you. However, **trait references** require special handling since Rendezvous cannot generate them automatically.

### How Trait Reference Selection Works

When your functions accept trait reference parameters, you must include at least one trait implementation in your Clarinet project. This can be either a project contract or a requirement.

Here's how Rendezvous handles trait references:

1. **Project Scanning** – Before testing begins, Rendezvous scans your project for functions that use trait references.
2. **Implementation Discovery** – It searches the contract AST for matching trait implementations and adds them to a selection pool.
3. **Random Selection** – During test execution, Rendezvous randomly picks an implementation from the pool and uses it as a function argument.

This process allows Rendezvous to create meaningful state transitions and validate your invariants or property-based tests.

### Example

The `example` Clarinet project demonstrates this feature. The [send-tokens](https://github.com/stacks-network/rendezvous/blob/9c02aa7c2571b3795debc657bd433fd9bf7f19eb/example/contracts/send-tokens.clar) contract contains [one public function](https://github.com/stacks-network/rendezvous/blob/9c02aa7c2571b3795debc657bd433fd9bf7f19eb/example/contracts/send-tokens.clar#L3-L7) and [one property-based test](https://github.com/stacks-network/rendezvous/blob/9c02aa7c2571b3795debc657bd433fd9bf7f19eb/example/contracts/send-tokens.tests.clar#L24-L47) that both accept trait references.

To enable testing, the project includes [rendezvous-token](https://github.com/stacks-network/rendezvous/blob/9c02aa7c2571b3795debc657bd433fd9bf7f19eb/example/contracts/rendezvous-token.clar), which implements the required trait.

### Adding More Implementations

You can include multiple eligible trait implementations in your project. Adding more implementations allows Rendezvous to introduce greater randomness during testing and increases behavioral diversity. If a function that accepts a trait implementation parameter is called X times, those calls are distributed across the available implementations. As the number of implementations grows, Rendezvous has more options to choose from on each call, producing a wider range of behaviors — and uncovering edge cases that may be missed when relying on a single implementation.


# @stacks/network

The `@stacks/network` package exports network configurations and helper functions for working with different Stacks networks.

## Installation

{% code title="Install" %}

```bash
npm install @stacks/network
```

{% endcode %}

## Network constants

### STACKS\_MAINNET

`STACKS_MAINNET` provides the mainnet network configuration.

{% code title="TypeScript" %}

```ts
import { STACKS_MAINNET } from '@stacks/network';

console.log(STACKS_MAINNET);
// {
//   chainId: 1,
//   transactionVersion: 0,
//   peerNetworkId: 385875968,
//   magicBytes: "X2",
//   bootAddress: "SP000000000000000000002Q6VF78",
//   addressVersion: {
//     singleSig: 22,
//     multiSig: 20,
//   },
//   client: {
//     baseUrl: "https://api.mainnet.hiro.so",
//   },
// }
```

{% endcode %}

### STACKS\_TESTNET

`STACKS_TESTNET` provides the testnet network configuration.

{% code title="TypeScript" %}

```ts
import { STACKS_TESTNET } from '@stacks/network';

console.log(STACKS_TESTNET.chainId); // 2147483648
```

{% endcode %}

### STACKS\_DEVNET / STACKS\_MOCKNET

`STACKS_DEVNET` provides the devnet network configuration.

{% code title="TypeScript" %}

```ts
import { STACKS_DEVNET, STACKS_MOCKNET } from '@stacks/network';

// Use in transactions
import { makeSTXTokenTransfer } from '@stacks/transactions';

const tx = await makeSTXTokenTransfer({
  network: STACKS_DEVNET, // or STACKS_MOCKNET
  // ... other options
});
```

{% endcode %}

## networkFromName

`networkFromName` returns a network configuration for a given name string.

### Signature

```ts
function networkFromName(name: 'mainnet' | 'testnet' | 'devnet' | 'mocknet'): StacksNetwork
```

### Parameters

| Name   | Type                                              | Required | Description  |
| ------ | ------------------------------------------------- | -------- | ------------ |
| `name` | `'mainnet' \| 'testnet' \| 'devnet' \| 'mocknet'` | Yes      | Network name |

### Examples

{% code title="TypeScript" %}

```ts
import { networkFromName } from '@stacks/network';

const mainnet = networkFromName('mainnet'); // Same as STACKS_MAINNET
const testnet = networkFromName('testnet'); // Same as STACKS_TESTNET
const devnet = networkFromName('devnet');   // Same as STACKS_DEVNET
const mocknet = networkFromName('mocknet'); // Same as STACKS_MOCKNET
```

{% endcode %}

### Using with transactions

{% code title="TypeScript" %}

```ts
import { networkFromName } from '@stacks/network';
import { makeContractCall } from '@stacks/transactions';

const network = networkFromName('testnet');

const tx = await makeContractCall({
  network,
  contractAddress: 'ST2ZRX0K27GW0SP3GJCEMHD95TQGJMKB7G9Y0X1MH',
  contractName: 'hello-world',
  functionName: 'say-hi',
  functionArgs: [],
  senderKey: privateKey
});
```

{% endcode %}

## clientFromNetwork

`clientFromNetwork` extracts the API client configuration from a network.

### Signature

```ts
function clientFromNetwork(network: StacksNetwork): Required<ClientOpts>
```

### Parameters

| Name      | Type            | Required | Description                  |
| --------- | --------------- | -------- | ---------------------------- |
| `network` | `StacksNetwork` | Yes      | Network configuration object |

### Example

{% code title="TypeScript" %}

```ts
import { clientFromNetwork, STACKS_MAINNET } from '@stacks/network';

const client = clientFromNetwork(STACKS_MAINNET);
console.log(client.baseUrl); // 'https://api.mainnet.hiro.so'

// Use with custom fetch
const customClient = {
  ...client,
  fetch: customFetchFunction
};
```

{% endcode %}

## Network configuration properties

All network constants share these properties:

| Property             | Type   | Description                           |
| -------------------- | ------ | ------------------------------------- |
| `chainId`            | number | Unique identifier for the network     |
| `transactionVersion` | number | Transaction serialization version     |
| `peerNetworkId`      | number | P2P network identifier                |
| `magicBytes`         | string | Network magic bytes for serialization |
| `bootAddress`        | string | Boot contract address                 |

## Default values

The package also exports default configuration values:

{% code title="TypeScript" %}

```ts
import { DEFAULT_CHAIN_ID, DEFAULT_TRANSACTION_VERSION } from '@stacks/network';

console.log(DEFAULT_CHAIN_ID); // 1
console.log(DEFAULT_TRANSACTION_VERSION); // 0
```

{% endcode %}


# @stacks/connect

The `@stacks/connect` package provides a simple interface for connecting web applications to Stacks wallets, enabling user authentication, transaction signing, and message signing capabilities.

## Installation

{% code title="Install with npm" %}

```bash
npm install @stacks/connect
```

{% endcode %}

## Connection functions

### connect

`connect` initiates a wallet connection and stores user addresses in local storage.

Signature:

```ts
function connect(options?: ConnectOptions): Promise<ConnectResponse>
```

Parameters

| Name      | Type             | Required | Description                          |
| --------- | ---------------- | -------- | ------------------------------------ |
| `options` | `ConnectOptions` | No       | Configuration options for connection |

Examples

Basic connection

```ts
import { connect } from '@stacks/connect';

const response = await connect();
// Response contains user addresses stored in local storage
```

Connection with options

```ts
const response = await connect({
  forceWalletSelect: true,
  approvedProviderIds: ['LeatherProvider', 'xverse']
});
```

### isConnected

`isConnected` checks if a wallet is currently connected.

```ts
import { isConnected } from '@stacks/connect';

if (isConnected()) {
  console.log('Wallet is connected');
}
```

### disconnect

`disconnect` clears the connection state and local storage.

```ts
import { disconnect } from '@stacks/connect';

disconnect(); // Clears wallet connection
```

### getLocalStorage

`getLocalStorage` retrieves stored connection data.

```ts
import { getLocalStorage } from '@stacks/connect';

const data = getLocalStorage();
// {
//   "addresses": {
//     "stx": [{ "address": "SP2MF04VAGYHGAZWGTEDW5VYCPDWWSY08Z1QFNDSN" }],
//     "btc": [{ "address": "bc1pp3ha248m0mnaevhp0txfxj5xaxmy03h0j7zuj2upg34mt7s7e32q7mdfae" }]
//   }
// }
```

## Request method

### request

`request` is the primary method for interacting with connected wallets.

Signature:

```ts
function request<T extends StacksMethod>(
  options: RequestOptions | undefined,
  method: T,
  params?: MethodParams[T]
): Promise<MethodResult[T]>
```

Parameters

| Name      | Type              | Required          | Description                   |
| --------- | ----------------- | ----------------- | ----------------------------- |
| `options` | `RequestOptions`  | No                | Request configuration options |
| `method`  | `StacksMethod`    | Yes               | Method to call on the wallet  |
| `params`  | `MethodParams[T]` | Depends on method | Parameters for the method     |

Request options

| Name                  | Type             | Default       | Description                  |
| --------------------- | ---------------- | ------------- | ---------------------------- |
| `provider`            | `StacksProvider` | Auto-detect   | Custom provider instance     |
| `forceWalletSelect`   | `boolean`        | `false`       | Force wallet selection modal |
| `persistWalletSelect` | `boolean`        | `true`        | Persist wallet selection     |
| `enableOverrides`     | `boolean`        | `true`        | Enable compatibility fixes   |
| `enableLocalStorage`  | `boolean`        | `true`        | Store addresses locally      |
| `approvedProviderIds` | `string[]`       | All providers | Filter available wallets     |

Examples

Basic request

```ts
import { request } from '@stacks/connect';

const addresses = await request('getAddresses');
```

Request with options

```ts
const response = await request(
  { forceWalletSelect: true },
  'stx_transferStx',
  {
    amount: '1000000', // 1 STX in microSTX
    recipient: 'SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159'
  }
);
```

## Wallet methods

### getAddresses

`getAddresses` retrieves Bitcoin and Stacks addresses from the wallet.

```ts
const response = await request('getAddresses');
// {
//   "addresses": [
//     {
//       "address": "bc1pp3ha248m0mnaevhp0txfxj5xaxmy03h0j7zuj2upg34mt7s7e32q7mdfae",
//       "publicKey": "062bd2c825300d74f4f9feb6b2fec2590beac02b8938f0fc042a34254581ee69"
//     },
//     {
//       "address": "SP2MF04VAGYHGAZWGTEDW5VYCPDWWSY08Z1QFNDSN",
//       "publicKey": "02d3331cbb9f72fe635e6f87c2cf1a13cdea520f08c0cc68584a96e8ac19d8d304"
//     }
//   ]
// }
```

### sendTransfer

`sendTransfer` sends Bitcoin to one or more recipients.

```ts
const response = await request('sendTransfer', {
  recipients: [
    {
      address: 'bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4',
      amount: '1000' // Amount in satoshis
    },
    {
      address: 'bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh',
      amount: '2000'
    }
  ]
});
// { "txid": "0x1234..." }
```

### signPsbt

`signPsbt` signs a partially signed Bitcoin transaction.

```ts
const response = await request('signPsbt', {
  psbt: 'cHNidP...', // Base64 encoded PSBT
  signInputs: [{ index: 0, address }], // Optional: specify inputs to sign
  broadcast: false // Optional: broadcast after signing
});
// {
//   "psbt": "cHNidP...", // Signed PSBT
//   "txid": "0x1234..." // If broadcast is true
// }
```

## Stacks-specific methods

### stx\_transferStx

`stx_transferStx` transfers STX tokens between addresses.

```ts
const response = await request('stx_transferStx', {
  amount: '1000000', // Amount in microSTX (1 STX = 1,000,000 microSTX)
  recipient: 'SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159',
  memo: 'Payment for services', // Optional
  network: 'mainnet' // Optional, defaults to mainnet
});
// { "txid": "0x1234..." }
```

### stx\_callContract

`stx_callContract` calls a public function on a smart contract.

```ts
import { Cl } from '@stacks/transactions';

const response = await request('stx_callContract', {
  contract: 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.hello-world',
  functionName: 'say-hi',
  functionArgs: [Cl.stringUtf8('Hello!')],
  network: 'mainnet'
});
// { "txid": "0x1234..." }
```

### stx\_deployContract

`stx_deployContract` deploys a new smart contract.

```ts
const response = await request('stx_deployContract', {
  name: 'my-contract',
  clarityCode: `(define-public (say-hi (name (string-utf8 50)))
    (ok (concat "Hello, " name "!"))
  )`,
  clarityVersion: '2', // Optional
  network: 'testnet'
});
// { "txid": "0x1234..." }
```

### stx\_signMessage

`stx_signMessage` signs a plain text message.

```ts
const response = await request('stx_signMessage', {
  message: 'Hello, World!'
});
// {
//   "signature": "0x1234...",
//   "publicKey": "02d3331cbb9f72fe635e6f87c2cf1a13cdea520f08c0cc68584a96e8ac19d8d304"
// }
```

### stx\_signStructuredMessage

`stx_signStructuredMessage` signs a structured Clarity message following SIP-018.

```ts
import { Cl } from '@stacks/transactions';

const message = Cl.tuple({
  action: Cl.stringAscii('transfer'),
  amount: Cl.uint(1000000n)
});

const domain = Cl.tuple({
  name: Cl.stringAscii('MyApp'),
  version: Cl.stringAscii('1.0.0'),
  'chain-id': Cl.uint(1) // mainnet
});

const response = await request('stx_signStructuredMessage', {
  message,
  domain
});
// {
//   "signature": "0x1234...",
//   "publicKey": "02d3331cbb9f72fe635e6f87c2cf1a13cdea520f08c0cc68584a96e8ac19d8d304"
// }
```

### stx\_getAccounts

`stx_getAccounts` retrieves detailed account information including Gaia configuration.

```ts
const response = await request('stx_getAccounts');
// {
//   "addresses": [{
//     "address": "SP2MF04VAGYHGAZWGTEDW5VYCPDWWSY08Z1QFNDSN",
//     "publicKey": "02d3331cbb9f72fe635e6f87c2cf1a13cd...",
//     "gaiaHubUrl": "https://hub.hiro.so",
//     "gaiaAppKey": "0488ade4040658015580000000dc81e3a5..."
//   }]
// }
```

## Error handling

Handle wallet errors using standard Promise error handling patterns.

```ts
try {
  const response = await request('stx_transferStx', {
    amount: '1000000',
    recipient: 'SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159'
  });
  console.log('Transaction successful:', response.txid);
} catch (error) {
  console.error('Transaction failed:', error);
}
```

## Advanced usage

### requestRaw

`requestRaw` provides direct access to wallet providers without compatibility features.

Signature:

```ts
function requestRaw<T extends StacksMethod>(
  provider: StacksProvider,
  method: T,
  params?: MethodParams[T]
): Promise<MethodResult[T]>
```

Example

```ts
import { requestRaw } from '@stacks/connect';

const provider = window.StacksProvider;
const response = await requestRaw(provider, 'getAddresses');
```

## Migration notes

Version 8.x.x implements [SIP-030](https://github.com/janniks/sips/blob/main/sips/sip-030/sip-030-wallet-interface.md) wallet standards. For legacy JWT-based authentication, use version 7.10.1.


# @stacks/transactions

The `@stacks/transactions` package provides comprehensive functionality for creating, signing, and broadcasting transactions on the Stacks blockchain, including STX transfers, contract deployments, and contract calls.

## Installation

```bash
npm install @stacks/transactions
```

## Transaction functions

### makeSTXTokenTransfer

`makeSTXTokenTransfer` creates a signed STX token transfer transaction.

Signature

```ts
function makeSTXTokenTransfer(options: SignedTokenTransferOptions): Promise<StacksTransaction>
```

Parameters

| Name         | Type                      | Required | Description                    |
| ------------ | ------------------------- | -------- | ------------------------------ |
| `recipient`  | `string`                  | Yes      | Recipient STX address          |
| `amount`     | `bigint`                  | Yes      | Amount to transfer in microSTX |
| `senderKey`  | `string`                  | Yes      | Sender's private key           |
| `network`    | `StacksNetwork \| string` | Yes      | Network configuration          |
| `memo`       | `string`                  | No       | Optional memo field            |
| `fee`        | `bigint`                  | No       | Transaction fee in microSTX    |
| `nonce`      | `bigint`                  | No       | Account nonce                  |
| `anchorMode` | `AnchorMode`              | No       | Block anchoring mode           |

Examples

Basic transfer

```ts
import { makeSTXTokenTransfer, broadcastTransaction } from '@stacks/transactions';

const transaction = await makeSTXTokenTransfer({
  recipient: 'SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159',
  amount: 1000000n, // 1 STX in microSTX
  senderKey: 'b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01',
  network: 'mainnet'
});

const response = await broadcastTransaction({ transaction, network: 'mainnet' });
console.log(response.txid);
```

Transfer with memo

```ts
const transaction = await makeSTXTokenTransfer({
  recipient: 'SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159',
  amount: 2500000n,
  memo: 'Payment for services',
  senderKey: privateKey,
  network: 'testnet'
});
```

### makeUnsignedSTXTokenTransfer

`makeUnsignedSTXTokenTransfer` creates an unsigned STX token transfer transaction.

Signature

```ts
function makeUnsignedSTXTokenTransfer(options: UnsignedTokenTransferOptions): Promise<StacksTransaction>
```

Parameters

| Name        | Type                      | Required | Description                    |
| ----------- | ------------------------- | -------- | ------------------------------ |
| `recipient` | `string`                  | Yes      | Recipient STX address          |
| `amount`    | `bigint`                  | Yes      | Amount to transfer in microSTX |
| `publicKey` | `string`                  | Yes      | Sender's public key            |
| `network`   | `StacksNetwork \| string` | Yes      | Network configuration          |
| `memo`      | `string`                  | No       | Optional memo field            |
| `fee`       | `bigint`                  | No       | Transaction fee in microSTX    |
| `nonce`     | `bigint`                  | No       | Account nonce                  |

Example

```ts
import { makeUnsignedSTXTokenTransfer } from '@stacks/transactions';

const unsignedTx = await makeUnsignedSTXTokenTransfer({
  recipient: 'SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159',
  amount: 1000000n,
  publicKey: publicKeyString,
  network: 'mainnet'
});
```

### makeContractDeploy

`makeContractDeploy` creates a signed smart contract deployment transaction.

Signature

```ts
function makeContractDeploy(options: SignedContractDeployOptions): Promise<StacksTransaction>
```

Parameters

| Name             | Type                      | Required | Description                          |
| ---------------- | ------------------------- | -------- | ------------------------------------ |
| `contractName`   | `string`                  | Yes      | Name for the contract                |
| `codeBody`       | `string`                  | Yes      | Clarity contract source code         |
| `senderKey`      | `string`                  | Yes      | Deployer's private key               |
| `network`        | `StacksNetwork \| string` | Yes      | Network configuration                |
| `clarityVersion` | `ClarityVersion`          | No       | Clarity version (defaults to latest) |
| `fee`            | `bigint`                  | No       | Transaction fee in microSTX          |
| `nonce`          | `bigint`                  | No       | Account nonce                        |

Examples

Deploy a contract

```ts
import { makeContractDeploy, broadcastTransaction } from '@stacks/transactions';
import { readFileSync } from 'fs';

const codeBody = readFileSync('./contract.clar', 'utf-8');

const transaction = await makeContractDeploy({
  contractName: 'my-contract',
  codeBody,
  senderKey: privateKey,
  network: 'testnet'
});

const response = await broadcastTransaction({ transaction, network: 'testnet' });
```

Deploy with Clarity version

```ts
const transaction = await makeContractDeploy({
  contractName: 'clarity-v3-contract',
  codeBody: contractCode,
  clarityVersion: 3,
  senderKey: privateKey,
  network: 'mainnet'
});
```

### makeContractCall

`makeContractCall` creates a signed contract function call transaction.

Signature

```ts
function makeContractCall(options: SignedContractCallOptions): Promise<StacksTransaction>
```

Parameters

| Name              | Type                      | Required | Description                    |
| ----------------- | ------------------------- | -------- | ------------------------------ |
| `contractAddress` | `string`                  | Yes      | Contract address               |
| `contractName`    | `string`                  | Yes      | Contract name                  |
| `functionName`    | `string`                  | Yes      | Function to call               |
| `functionArgs`    | `ClarityValue[]`          | Yes      | Function arguments             |
| `senderKey`       | `string`                  | Yes      | Caller's private key           |
| `network`         | `StacksNetwork \| string` | Yes      | Network configuration          |
| `postConditions`  | `PostCondition[]`         | No       | Post conditions                |
| `validateWithAbi` | `boolean \| ClarityAbi`   | No       | Validate arguments against ABI |
| `fee`             | `bigint`                  | No       | Transaction fee in microSTX    |
| `nonce`           | `bigint`                  | No       | Account nonce                  |

Examples

Basic contract call

```ts
import { makeContractCall, broadcastTransaction, Cl } from '@stacks/transactions';

const transaction = await makeContractCall({
  contractAddress: 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR',
  contractName: 'hello-world',
  functionName: 'say-hi',
  functionArgs: [Cl.stringUtf8('Hello!')],
  senderKey: privateKey,
  network: 'testnet'
});

const response = await broadcastTransaction({ transaction, network: 'testnet' });
```

Call with post conditions

```ts
import { makeContractCall, Cl, Pc } from '@stacks/transactions';

const postCondition = Pc.principal('SP2ZD731ANQZT6J4K3F5N8A40ZXWXC1XFXHVVQFKE')
  .willSendLte(1000000n)
  .ustx();

const transaction = await makeContractCall({
  contractAddress: 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR',
  contractName: 'token-contract',
  functionName: 'transfer',
  functionArgs: [
    Cl.principal('SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159'),
    Cl.uint(100n)
  ],
  postConditions: [postCondition],
  validateWithAbi: true,
  senderKey: privateKey,
  network: 'mainnet'
});
```

### sponsorTransaction

`sponsorTransaction` adds a sponsor signature to a transaction, enabling sponsored transactions.

Signature

```ts
function sponsorTransaction(options: SponsorTransactionOptions): Promise<StacksTransaction>
```

Parameters

| Name                | Type                | Required | Description               |
| ------------------- | ------------------- | -------- | ------------------------- |
| `transaction`       | `StacksTransaction` | Yes      | Transaction to sponsor    |
| `sponsorPrivateKey` | `string`            | Yes      | Sponsor's private key     |
| `fee`               | `bigint`            | Yes      | Fee to be paid by sponsor |
| `sponsorNonce`      | `bigint`            | No       | Sponsor account nonce     |

Example

```ts
import { sponsorTransaction, deserializeTransaction, broadcastTransaction } from '@stacks/transactions';

// Deserialize the transaction from the origin
const deserializedTx = deserializeTransaction(serializedTx);

// Sponsor the transaction
const sponsoredTx = await sponsorTransaction({
  transaction: deserializedTx,
  sponsorPrivateKey: sponsorKey,
  fee: 1000n,
  sponsorNonce: 0
});

const response = await broadcastTransaction({ transaction: sponsoredTx, network: 'testnet' });
```

### fetchCallReadOnlyFunction

`fetchCallReadOnlyFunction` calls a read-only contract function without creating a transaction.

Signature

```ts
function fetchCallReadOnlyFunction(options: CallReadOnlyFunctionOptions): Promise<ClarityValue>
```

Parameters

| Name              | Type             | Required | Description           |
| ----------------- | ---------------- | -------- | --------------------- |
| `contractAddress` | `string`         | Yes      | Contract address      |
| `contractName`    | `string`         | Yes      | Contract name         |
| `functionName`    | `string`         | Yes      | Function to call      |
| `functionArgs`    | `ClarityValue[]` | Yes      | Function arguments    |
| `network`         | `StacksNetwork`  | Yes      | Network configuration |
| `senderAddress`   | `string`         | Yes      | Address of the caller |

Example

```ts
import { fetchCallReadOnlyFunction, Cl } from '@stacks/transactions';
import { STACKS_MAINNET } from '@stacks/network';

const result = await fetchCallReadOnlyFunction({
  contractAddress: 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR',
  contractName: 'data-store',
  functionName: 'get-value',
  functionArgs: [Cl.stringUtf8('key')],
  network: STACKS_MAINNET,
  senderAddress: 'SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159'
});

console.log(result);
```

### broadcastTransaction

`broadcastTransaction` broadcasts a signed transaction to the network.

Signature

```ts
function broadcastTransaction(options: BroadcastTransactionOptions): Promise<TxBroadcastResult>
```

Parameters

| Name          | Type                      | Required | Description                     |
| ------------- | ------------------------- | -------- | ------------------------------- |
| `transaction` | `StacksTransaction`       | Yes      | Signed transaction to broadcast |
| `network`     | `StacksNetwork \| string` | Yes      | Network to broadcast to         |

Example

```ts
import { broadcastTransaction } from '@stacks/transactions';

const result = await broadcastTransaction({
  transaction: signedTx,
  network: 'mainnet'
});

if (result.error) {
  console.error('Broadcast failed:', result.reason);
} else {
  console.log('Transaction ID:', result.txid);
}
```

## Clarity value construction

### Primitive values

```ts
import { Cl } from '@stacks/transactions';

// Boolean values
const isTrue = Cl.bool(true);
const isFalse = Cl.bool(false);

// Integer values (signed 128-bit)
const positiveInt = Cl.int(42n);
const negativeInt = Cl.int(-100n);

// Unsigned integer values (unsigned 128-bit)
const unsignedInt = Cl.uint(100n);

// Buffer values
const buffer = Cl.bufferFromUtf8('hello world');
const hexBuffer = Cl.bufferFromHex('0x1234');

// String values
const asciiStr = Cl.stringAscii('Hello ASCII');
const utf8Str = Cl.stringUtf8('Hello UTF-8! 👋');
```

### Complex values

```ts
// Principal values
const standardPrincipal = Cl.principal('SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159');
const contractPrincipal = Cl.contractPrincipal('SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159', 'my-contract');

// Optional values
const none = Cl.none();
const some = Cl.some(Cl.uint(42n));

// Response values
const okResponse = Cl.ok(Cl.stringUtf8('Success'));
const errResponse = Cl.error(Cl.uint(404n));

// Tuple values
const tuple = Cl.tuple({
  name: Cl.stringUtf8('Alice'),
  age: Cl.uint(30n),
  active: Cl.bool(true)
});

// List values
const list = Cl.list([Cl.uint(1n), Cl.uint(2n), Cl.uint(3n)]);
```

## Post conditions

### STX post conditions

```ts
import { Pc } from '@stacks/transactions';

// Standard principal STX post condition
const stxPostCondition = Pc.principal('SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159')
  .willSendGte(1000000n)
  .ustx();

// Contract principal STX post condition
const contractStxCondition = Pc.principal('SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159.my-contract')
  .willSendEq(500000n)
  .ustx();
```

### Fungible token post conditions

```ts
// Standard principal fungible token post condition
const ftPostCondition = Pc.principal('SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159')
  .willSendLte(100n)
  .ft('SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.token-contract', 'my-token');

// Contract principal fungible token post condition
const contractFtCondition = Pc.principal('SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159.vault')
  .willNotSend()
  .ft('SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.token-contract', 'my-token');
```

### Non-fungible token post conditions

```ts
// Standard principal NFT post condition
const nftPostCondition = Pc.principal('SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159')
  .willSend()
  .nft('SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.nft-contract', 'my-nft', Cl.uint(1n));

// Contract principal NFT post condition
const contractNftCondition = Pc.principal('SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159.marketplace')
  .willNotSend()
  .nft('SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.nft-contract', 'my-nft', Cl.uint(1n));
```

## Multi-signature transactions

Multi-signature transactions require multiple signatures before broadcasting.

{% stepper %}
{% step %}

### Create an unsigned multi-sig transaction

```ts
import {
  makeUnsignedSTXTokenTransfer,
} from '@stacks/transactions';

const transaction = await makeUnsignedSTXTokenTransfer({
  recipient: 'SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159',
  amount: 1000000n,
  fee: 200n,
  numSignatures: 2, // Require 2 of 3 signatures
  publicKeys: [publicKey1, publicKey2, publicKey3],
  network: 'mainnet'
});
```

{% endstep %}

{% step %}

### Deserialize and prepare signer

```ts
import {
  deserializeTransaction,
  TransactionSigner,
} from '@stacks/transactions';

const deserializedTx = deserializeTransaction(transaction.serialize());
const signer = new TransactionSigner(deserializedTx);
```

{% endstep %}

{% step %}

### Add required signatures

```ts
// Add required signatures
signer.signOrigin(privateKey1);
signer.signOrigin(privateKey2);

// Append public key of non-signing party
signer.appendOrigin(publicKey3);
```

{% endstep %}

{% step %}

### Broadcast the multi-sig transaction

```ts
// Broadcast the multi-sig transaction
const signedTx = deserializedTx;
const response = await broadcastTransaction({ transaction: signedTx, network: 'mainnet' });
```

{% endstep %}
{% endstepper %}

## Key generation utilities

### randomPrivateKey

`randomPrivateKey` generates a new random private key.

```ts
import { randomPrivateKey } from '@stacks/transactions';

const privateKey = randomPrivateKey();
console.log(privateKey); // Random 32-byte hex string with optional compression flag
```

### privateKeyToPublicKey

`privateKeyToPublicKey` derives a public key from a private key.

```ts
import { privateKeyToPublicKey } from '@stacks/transactions';

const privateKey = 'b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01';
const publicKey = privateKeyToPublicKey(privateKey);
console.log(publicKey); // Compressed public key
```

## Utility functions

### deserializeTransaction

`deserializeTransaction` converts a serialized transaction back to a transaction object.

```ts
import { deserializeTransaction } from '@stacks/transactions';

const serializedTx = '0x00000000...'; // Hex string
const transaction = deserializeTransaction(serializedTx);
```

### cvToJSON

`cvToJSON` converts Clarity values to JSON format for easier manipulation.

```ts
import { cvToJSON, hexToCV } from '@stacks/transactions';

const clarityValue = hexToCV('0x0100000000000000000000000000000001');
const json = cvToJSON(clarityValue);
console.log(json); // { type: 'uint', value: '1' }
```


# sbtc

Build and manage sBTC deposits and withdrawals on Bitcoin and Stacks.

The `sbtc` package provides functions for creating sBTC deposits on Bitcoin and interacting with the sBTC protocol across Bitcoin and Stacks networks.

## Installation

```bash
npm install sbtc
```

## Deposit functions

### buildSbtcDepositAddress

`buildSbtcDepositAddress` creates a Bitcoin address for sBTC deposits with embedded metadata.

Signature

```ts
function buildSbtcDepositAddress(options: DepositAddressOptions): DepositAddress
```

Parameters

| Name               | Type             | Required | Description                                    |
| ------------------ | ---------------- | -------- | ---------------------------------------------- |
| `stacksAddress`    | `string`         | Yes      | Stacks address to receive sBTC                 |
| `signersPublicKey` | `string`         | Yes      | Aggregated public key of signers               |
| `maxSignerFee`     | `number`         | No       | Maximum fee for signers (default: 80,000 sats) |
| `reclaimLockTime`  | `number`         | No       | Lock time for reclaim script (default: 6,000)  |
| `network`          | `BitcoinNetwork` | No       | Bitcoin network to use (default: MAINNET)      |

Example

```ts
import { buildSbtcDepositAddress, SbtcApiClientMainnet } from 'sbtc';

const client = new SbtcApiClientMainnet();

// Build deposit address
const deposit = buildSbtcDepositAddress({
  stacksAddress: 'SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159',
  signersPublicKey: await client.fetchSignersPublicKey(),
  maxSignerFee: 80_000, // Fee taken from deposit amount
  reclaimLockTime: 6_000
});

// Send BTC to deposit.address using any Bitcoin wallet
const txid = await wallet.sendTransfer({
  recipient: deposit.address,
  amount: 1_000_000 // 0.01 BTC
});

// Notify signers about the deposit
await client.notifySbtc({ txid, ...deposit });
```

### buildSbtcDepositTx

`buildSbtcDepositTx` creates a complete Bitcoin transaction for sBTC deposits.

Signature

```ts
function buildSbtcDepositTx(options: DepositTxOptions): DepositTransaction
```

Parameters

| Name               | Type               | Required | Description                                    |
| ------------------ | ------------------ | -------- | ---------------------------------------------- |
| `amountSats`       | `number \| bigint` | Yes      | Amount to deposit in satoshis                  |
| `stacksAddress`    | `string`           | Yes      | Stacks address to receive sBTC                 |
| `signersPublicKey` | `string`           | Yes      | Aggregated public key of signers               |
| `maxSignerFee`     | `number`           | No       | Maximum fee for signers (default: 80,000 sats) |
| `reclaimLockTime`  | `number`           | No       | Lock time for reclaim (default: 144)           |
| `network`          | `BitcoinNetwork`   | No       | Bitcoin network to use                         |

Example

```ts
import { buildSbtcDepositTx, SbtcApiClientMainnet } from 'sbtc';

const client = new SbtcApiClientMainnet();

// Build deposit transaction
const deposit = buildSbtcDepositTx({
  amountSats: 100_000,
  stacksAddress: 'SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159',
  signersPublicKey: await client.fetchSignersPublicKey()
});

// Sign transaction
deposit.transaction.sign(privateKey);
deposit.transaction.finalize();

// Broadcast and notify
const txid = await client.broadcastTx(deposit.transaction);
await client.notifySbtc(deposit);
```

### sbtcDepositHelper

`sbtcDepositHelper` creates a fully-formed deposit transaction from UTXOs.

Signature

```ts
function sbtcDepositHelper(options: DepositHelperOptions): Promise<DepositTransaction>
```

Parameters

| Name                   | Type               | Required | Description                          |
| ---------------------- | ------------------ | -------- | ------------------------------------ |
| `amountSats`           | `number \| bigint` | Yes      | Amount to deposit in satoshis        |
| `stacksAddress`        | `string`           | Yes      | Stacks address to receive sBTC       |
| `signersPublicKey`     | `string`           | Yes      | Aggregated public key of signers     |
| `feeRate`              | `number`           | Yes      | Fee rate in sat/vbyte                |
| `utxos`                | `UtxoWithTx[]`     | Yes      | UTXOs to fund the transaction        |
| `bitcoinChangeAddress` | `string`           | Yes      | Address for change output            |
| `reclaimPublicKey`     | `string`           | No       | Public key for reclaiming deposits   |
| `reclaimLockTime`      | `number`           | No       | Lock time for reclaim (default: 144) |
| `maxSignerFee`         | `number`           | No       | Maximum signer fee (default: 80,000) |
| `network`              | `BitcoinNetwork`   | No       | Bitcoin network (default: MAINNET)   |

Example

```ts
import { sbtcDepositHelper, SbtcApiClientMainnet } from 'sbtc';

const client = new SbtcApiClientMainnet();
const btcAddress = 'bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4';

// Create complete deposit transaction
const deposit = await sbtcDepositHelper({
  amountSats: 1_000_000,
  stacksAddress: 'SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159',
  signersPublicKey: await client.fetchSignersPublicKey(),
  feeRate: await client.fetchFeeRate('medium'),
  utxos: await client.fetchUtxos(btcAddress),
  bitcoinChangeAddress: btcAddress
});

// Sign and broadcast
deposit.transaction.sign(privateKey);
deposit.transaction.finalize();

const txid = await client.broadcastTx(deposit.transaction);
await client.notifySbtc(deposit);
```

## API clients

### SbtcApiClientMainnet

`SbtcApiClientMainnet` provides mainnet API access for sBTC operations.

```ts
import { SbtcApiClientMainnet } from 'sbtc';

const client = new SbtcApiClientMainnet();
```

### SbtcApiClientTestnet

`SbtcApiClientTestnet` provides testnet API access for sBTC operations.

```ts
import { SbtcApiClientTestnet } from 'sbtc';

const client = new SbtcApiClientTestnet();
```

### SbtcApiClientDevenv

`SbtcApiClientDevenv` provides local development API access.

```ts
import { SbtcApiClientDevenv } from 'sbtc';

const client = new SbtcApiClientDevenv();
```

## Client methods

### fetchSignersPublicKey

`fetchSignersPublicKey` retrieves the aggregated public key of sBTC signers.

```ts
const publicKey = await client.fetchSignersPublicKey();
// '02abc123...' (32-byte hex string)
```

### fetchSignersAddress

`fetchSignersAddress` retrieves the Bitcoin address of sBTC signers.

```ts
const address = await client.fetchSignersAddress();
// 'bc1p...' (p2tr address)
```

### fetchFeeRate

`fetchFeeRate` retrieves current Bitcoin network fee rates.

```ts
const feeRate = await client.fetchFeeRate('medium');
// 15 (sat/vbyte)

// Also supports 'low' and 'high'
const lowFee = await client.fetchFeeRate('low');
const highFee = await client.fetchFeeRate('high');
```

### fetchUtxos

`fetchUtxos` retrieves unspent transaction outputs for a Bitcoin address.

```ts
const utxos = await client.fetchUtxos('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
// Array of UTXOs with transaction data
```

### broadcastTx

`broadcastTx` broadcasts a Bitcoin transaction to the network.

```ts
const txid = await client.broadcastTx(transaction);
// '0x1234abcd...'
```

### notifySbtc

`notifySbtc` notifies the sBTC API about a deposit transaction.

```ts
const response = await client.notifySbtc({
  txid,
  stacksAddress,
  reclaimScript,
  depositScript
});
// { status: 200, statusMessage: 'OK' }
```

### fetchSbtcBalance

`fetchSbtcBalance` retrieves the sBTC balance for a Stacks address.

```ts
const balance = await client.fetchSbtcBalance('SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159');
// 1000000n (in micro-sBTC)
```

## Configuration

### Client configuration options

| Name           | Type     | Description               |
| -------------- | -------- | ------------------------- |
| `sbtcContract` | `string` | sBTC contract address     |
| `sbtcApiUrl`   | `string` | sBTC API (Emily) base URL |
| `btcApiUrl`    | `string` | Bitcoin API base URL      |
| `stxApiUrl`    | `string` | Stacks API base URL       |

### Custom client configuration

```ts
import { SbtcApiClient } from 'sbtc';

const client = new SbtcApiClient({
  sbtcContract: 'SP000000000000000000002Q6VF78.sbtc',
  sbtcApiUrl: 'https://api.sbtc.tech',
  btcApiUrl: 'https://mempool.space/api',
  stxApiUrl: 'https://api.mainnet.hiro.so'
});
```

## Complete deposit example

```ts
import { sbtcDepositHelper, SbtcApiClientMainnet } from 'sbtc';

async function depositBtcForSbtc() {
  const client = new SbtcApiClientMainnet();
  const btcAddress = 'bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4';
  const stxAddress = 'SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159';

  // 1. Create deposit transaction
  const deposit = await sbtcDepositHelper({
    amountSats: 100_000,
    stacksAddress: stxAddress,
    signersPublicKey: await client.fetchSignersPublicKey(),
    feeRate: await client.fetchFeeRate('medium'),
    utxos: await client.fetchUtxos(btcAddress),
    bitcoinChangeAddress: btcAddress
  });

  // 2. Sign transaction
  deposit.transaction.sign(privateKey);
  deposit.transaction.finalize();

  // 3. Broadcast to Bitcoin network
  const txid = await client.broadcastTx(deposit.transaction);
  console.log('Bitcoin transaction:', txid);

  // 4. Notify sBTC signers
  await client.notifySbtc(deposit);
  console.log('Deposit submitted successfully');

  // 5. Check sBTC balance (after confirmation)
  const balance = await client.fetchSbtcBalance(stxAddress);
  console.log('sBTC balance:', balance);
}
```


# Welcome to Tutorials

Your end-to-end learning experience.

<div data-with-frame="true"><figure><img src="https://1720374836-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FskGYu79qDNfITOqDNU3s%2Fuploads%2Fjpn46AFY3yNeLdSRypcO%2Fbuild-better-apps.png?alt=media&#x26;token=287464e3-ba92-4a4c-8386-fd2c8e335ec4" alt=""><figcaption></figcaption></figure></div>

This tutorials section consists of end-to-end guides on building complete applications with Stacks. The goal with these tutorials is to learn by building. They will walk you through the process of building complete apps from start to finish.

> ***A tutorial is a lesson**, that takes a student by the hand through a learning experience. - diataxis*

Our tutorials section has launched with its first complete tutorial: the Bitcoin Primer, which gives a holistic introduction to both Bitcoin and Stacks. Additional tutorials are in the works to walk through how to build different things with Stacks.

<table data-card-size="large" data-view="cards"><thead><tr><th></th><th></th><th data-type="content-ref"></th><th data-hidden data-card-cover data-type="image">Cover image</th></tr></thead><tbody><tr><td>Bitcoin Primer</td><td>A high-level introduction to Bitcoin and how to expand its functionality with Stacks.</td><td><a href="bitcoin-primer">bitcoin-primer</a></td><td><a href="https://1720374836-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FskGYu79qDNfITOqDNU3s%2Fuploads%2FUC0raCf6F9Xau4CFXMPg%2Fbitcoin-primer.jpg?alt=media&#x26;token=216c2545-f516-4ffa-80fa-1001c5f6e151">bitcoin-primer.jpg</a></td></tr></tbody></table>


# Introduction

An Intro to Building Full-Stack Dapps on Bitcoin | By Kenny Rogers

<figure><img src="https://1720374836-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FskGYu79qDNfITOqDNU3s%2Fuploads%2FUC0raCf6F9Xau4CFXMPg%2Fbitcoin-primer.jpg?alt=media&#x26;token=216c2545-f516-4ffa-80fa-1001c5f6e151" alt=""><figcaption></figcaption></figure>

Welcome to **the Bitcoin Builder's Primer.** This course is meant to be a comprehensive guide to building full-stack dapps on Bitcoin. It is composed of two parts that cover different aspects of building on Bitcoin.

The first half of the course consists of teaching how Bitcoin works and how to begin building on it. You’ll soon realize that the amount of things you can build on Bitcoin is relatively limited compared to other chains like Ethereum.

This is by design, as Bitcoin is designed to be as simple, secure, and decentralized as possible. So we instead take advantage of layers in order to add scalability and functionality to Bitcoin.

In the second half of the course we'll explore how to expand what you can build on Bitcoin by adding smart contract functionality using Stacks and Clarity.

We'll do that by building out a basic crowdfunding application. This crowdfunding application will allow us to organize crowdfunding campaigns using sBTC, the decentralized Bitcoin peg on Stacks.

This will allow us to get introduced to the basics of Bitcoin, Stacks, Clarity, sBTC, and how they all connect to each other, although it's only scratching the surface of what's possible.

You'll also gain a holistic introduction to the world of Bitcoin dapp development. The world of Bitcoin development is very fragmented and it can be difficult for developers to figure out what tools they should use and how they should go about building full-stack decentralized applications.

The Bitcoin Primer is an opinionated guide to how to do this using Bitcoin, Stacks, Clarity, sBTC, and React.

If you aren't familiar with how Bitcoin development works, especially the role that L2s play, don't worry, we're going to cover all that.

Stacks is an L2 for Bitcoin that expands the functionality and allows us to build fully expressive decentralized applications and smart contracts that are anchored to Bitcoin.&#x20;

The ultimate goal is to build Bitcoin financial apps and products that are as practical and easy to use as traditional web2 financial products.

The big, audacious vision of this is that we can do for the economy what Bitcoin did for the money. Money does not exist in a vacuum. It exists as part of an economy with myriad financial tools and instruments that utilize it.

Bitcoin has the potential to usher in a new economy that is built on fairness and truth, but it will not succeed unless we succeed in building an economy on top of it.

It is the opinion of this author that we should do that in a way that seeks to be as decentralized as possible, rather than relying on traditional, custodial systems where the money is decentralized but the economy is not.

That is where Stacks comes in, to allow us to ultimately build an economy on top of Bitcoin that is as decentralized as Bitcoin itself.

After the course, you’ll walk away with a basic understanding how to build dapps with functionality like you might find on Ethereum.

More importantly, though, you'll have been thoroughly introduced to building full-stack dapps and Bitcoin and will have a clear path forward to continue your learning and begin building projects.

As you go through the course, we'll make recommendations on how and where to dive deeper into your knowledge depending on what you are interested in building.

The primary goals of this course are to give you a comprehensive introduction to the entire Bitcoin dapp stack, familiarize you with the basics of how to use it to build full-stack dapps, and provide resources for further learning, building, and getting involved in the community.

There is an entire decentralized economy sitting on Bitcoin waiting to be created. Learning how to build things is the first step in your journey to being a Bitcoin builder.


# Why Build on Bitcoin?

When thinking of opportunities for web3 development, most people will immediately think of Ethereum as the go-to chain for building web3 dapps. Historically, Bitcoin has been seen as the OG cryptocurrency that is great at being money but is wasteful, boring, and somewhat of a dinosaur. It was useful for kicking off the cryptocurrency revolution, but it hasn't innovated and is being left behind by more modern, useful chains like Ethereum.

Let's challenge that idea. Bitcoin is currently a sleeping giant in the web3 ecosystem, and it's an excellent opportunity for developers to launch projects and careers.

### A Brief Note for Crypto Skeptics

If you are skeptical of the whole blockchain/crypto/web3 space, we get it. The industry is filled with hype and there is a good chunk that is not useful. This is a major reason why the Bitcoin space is an especially good opportunity.

Bitcoin is currently being used around the world to help people preserve wealth when they find themselves in situations like living under an authoritarian regime or their country's currency is suffering from hyperinflation.

There are billions of people around the world that live in highly volatile, unpredictable places where their ability to function in the economy is completely out of their control. Censorship-resistant money like Bitcoin empowers them to collect and preserve wealth despite controls placed on centralized alternatives.

{% embed url="<https://youtu.be/KG0Q05Lnm7s>" %}

But the money itself is only half the battle. It's necessary to build decentralized systems on top of this money and build a global economy that is as (or close to) decentralized as Bitcoin itself.

If we don't do that, people can't use Bitcoin to meaningfully participate in the economy without having to eventually resort to some sort of traditionally centralized system, which can derail things.

**The core thesis of The Bitcoin Primer is that Bitcoin is a fantastic decentralized system of money, and now it's our job as developers to build the tools and systems for people to create an economy on top of it.**

The how and why of doing that are the focus of this series. So if you consider yourself a skeptic, we invite you to come along for the ride and see the massive opportunity latent in Bitcoin for building useful technology while also building a successful career for yourself.


# Bitcoin Economy vs Ethereum Economy

As of the time of this writing, June 2025, the market cap of Ethereum sits at about $300 billion, while the market cap of Bitcoin sits at about $2 trillion.

There is a massive blue ocean of opportunity to build a decentralized economy on top of Bitcoin.

Yet if we look at the size of the economies built on top of these two ecosystems, we can see that Ethereum's is large and robust, while Bitcoin's is nearly non-existent.

Why is this?

Historically, Bitcoin's functionality has been very limited. You can't build robust decentralized apps with it. This is by design. A core ethos of Bitcoin has always been to be as secure and simple as possible.

One tradeoff with adding functionality is that it also adds complexity, which in turn adds potential points of failure.

Bitcoin's simplicity is its strength, but it also makes it difficult for developers to do cool things with it.

On top of that, the culture of Bitcoin has largely been one of buy and hold, so there wasn't much demand for a decentralized economy from hardcore Bitcoiners.

Ethereum has proven that the market is hungry for more use cases of cryptocurrency beyond just holding, and we are reaching a stage now where many Bitcoiners want to use their Bitcoin and make it productive, rather than just holding on to it and waiting for "number go up".

On top of this, Bitcoin is beginning to be used as a real tool for freedom for oppressed people across the world. For stories of how Bitcoin is being used in the real world to fight oppression, is good for the environment, resist big bank corruption, counter inflation, and help the poor and marginalized, we highly recommend the work of Alex Gladstein and C. Jason Maier.

If you're an Austrian economics buff, [The Bitcoin Standard](https://saifedean.com/tbs) and [The Fiat Standard](https://saifedean.com/tfs) are great places to start to see how Bitcoin can fix the broken and corrupt financial system that currently governs the world.

This is the ultimate goal of crypto/web3/Bitcoin: to create a better economic system that doesn't allow a small group of powerful elite to dictate the global economy.

But this vision requires builders to create the products that will compose this new economy. That vision is finding renewed traction in the Bitcoin world as we enter a renaissance of building on Bitcoin.

But it would take significant changes to Bitcoin's core protocol to enable the same kind of functionality as Ethereum, changes that come with compromises that many argue are not worth the cost.

However, new technologies are emerging that allow us to achieve the same functionality that we get with Ethereum, without modifying Bitcoin itself.

We'll talk about those later in the section, but for now, Ethereum *does* exist, so why build on Bitcoin?

To get us in the right frame of mind, we need to think about the whole purpose of blockchain technology: to create a completely decentralized, permissionless, trust-minimized form of money.

It is our opinion that Bitcoin is the superior technology for this purpose, and we'll explain why in this and the next few lessons. But it's important to not get caught up in the hype of the crypto industry and to remember the foundational reason why we are building these things.

The technology we use needs to align with this purpose, and if the technology itself creates incentive structures that don't align with this purpose, we shouldn't be using it for a global decentralized economy.

Much of this module will discuss one of the key differences between Bitcoin and Ethereum/most other chains: proof of work vs proof of stake.

The technological architecture blockchains are built with makes a huge difference in the behavior of the users of those chains, and it's crucial to build them in a way that incentivizes the behavior required to build the decentralized economy we are after.


# Energy Usage

One of the most common arguments for why proof of stake is a superior system to proof of work is the concept of energy usage.

This is a vast, complex, nuanced topic that deserves a serious study of its own. The TL;DR version is that the solution is not nearly as simple as many people would make it seem.

Usually, you hear some argument along these lines:

"We all know that consuming too much energy is a bad thing, and if we could have a system that uses 99.9% less energy than proof of work while maintaining all of the security benefits, why wouldn't we do that?"

Let's look at each premise, both explicit and implicit, contained in this line of reasoning piece by piece because while the logic of this thought process makes sense, every single premise is flawed.

"Bitcoin Uses Too Much Energy"

This statement is just a rephrasing of what the person stating it believes: "I don't think Bitcoin is valuable enough compared to the amount of energy it uses."

This is a better, more intellectually honest place to start, and gives us a solid place to start examining if this is a logical position to hold.

For context, nobody thinks that energy consumption is bad on its own, it's just whether or not the value being produced as a result of that energy consumption is worth it or not.

For example, here is a partial list of things that use more energy than the entire Bitcoin network and how they compare.

<figure><img src="https://lwfiles.mycourse.app/635fe723662899c6bfb19e1d-public/1f2dbcd16002e90956ee743fc594ae84.png" alt=""><figcaption><p>source: <a href="https://www.lynalden.com/bitcoin-energy/">https://www.lynalden.com/bitcoin-energy/</a></p></figcaption></figure>

If we want to go with the argument that Bitcoin uses too much energy, we also need to admit that everything on this list should also not exist since it uses too much energy.

But we don't do that because we understand these things have value that is created as a result of energy usage.

So, then the question becomes, is Bitcoin's energy usage worth it?

Even if Bitcoin becomes wildly successful with trillions of dollars of utility and billions of users, it might rise to consume more than 1% of global energy usage. But is it that much when we consider the fact that it would be running the entire decentralized economy at that point, and all of the benefits that come with that?

Don't forget that part of this argument is assuming that proof of stake can replicate Bitcoin's security and decentralization, we'll get to that soon.

in addition to this, Bitcoin is a very large driver of unique energy sources that would otherwise be completely wasted.

This is a rabbit hole of a topic too deep for this course, so we recommend any interested developers read the work of [Lyn Alden](https://x.com/LynAldenContact), [Nic Carter](https://x.com/nic__carter), [Troy Cross](https://x.com/thetrocro), or [C. Jason Maier](https://www.bitcoinprogressive.com/) to get a better handle on the nuances of the energy debate.

Here is an excellent piece to get you started. I took a lot of the information contained here from this source.

[Bitcoin's Energy Usage Isn't a Problem](https://www.lynalden.com/bitcoin-energy/) - Lyn Alden

Let's quickly address the idea of "cost per transaction." This comparison is made by advocates of other chains constantly, that so-and-so chain is energy efficient and each transaction only uses as much electricity as sending an email or something like that.

This is a flawed way to think about Bitcoin's energy usage and is comparing apples to oranges.

Bitcoin's energy usage comes from miners creating new blocks and earning the new block subsidy, and the network uses largely the same amount of energy regardless of how many transactions are contained in a block.

While it is true that Bitcoin's energy usage scales with how many users are on the network, thinking about the cost per transaction is nonsensical.

Covering the rest of the implicit assumptions requires looking at things from an economic and technological angle, so let's do that now.


# Technology & Economic Incentives

Blockchain technology is inherently tied to economic incentives. The technology itself is built to be a financial asset, and we can create tools and software that utilize it, but the economic structures and incentives are a key piece of how a particular chain functions.

With blockchains, the economic incentives and technological structure are closely linked, so we'll look at them together.

Proof of stake is not a good economic model on which to build a global reserve currency, for several reasons:

* No connection to real-world resources
* No unforgeable costliness
* Centralization risks
* Increased cost of running a node

Let's go through these.

If you aren't familiar with how these consensus mechanisms work, here's a decent very quick, [high-level overview](https://www.coindesk.com/learn/proof-of-work-vs-proof-of-stake-what-is-the-difference) or you can take a look at [Lyn Alden's article](https://www.lynalden.com/proof-of-stake/) on proof of stake for a more detailed comparison.

### No connection to real-world resources

One of the crucial components of Bitcoin is that it is connected to a real-world resource: energy. Mining new Bitcoin costs something tangible in the physical world.

With proof of stake, there is no such connection to real-world resources. New ether are created as a result of validators staking their ether.

Why does this matter?

In proof of work, miners are not directly punished by the network for attempting to write invalid data, the punishment is simply that they waste the resources that they spent to attempt the invalid data write.

In a proof of stake system, it needs to be more complex. Validators need to have some sort of incentive system and be punished for attempting to manipulate data, that is why they stake their existing resources.

If they attempt to produce invalid data, they are slashed, meaning they lose their staked resources.

At first glance, that doesn't sound like much of a problem. Why waste the energy on needing to solve complex cryptographic puzzles when we can just utilize staked resources to accomplish the same goal?

A proof of work protocol's connection to the real world keeps the incentive structure simple. With proof of stake, the system needs to get exponentially more complex to invent incentive structures that solve the same problems that are solved by proof of work inherently.

This complexity creates too many attack vectors and is too experimental to serve as a global decentralized currency.

I understand that there are very smart people working on solutions to these problems, but the technology is too experimental and too complex for building things that are supposed to run a global economy.

Complexity always introduces potential attack vectors or even just possible avenues for error. Ethereum is a behemoth with hundreds of thousands of lines of code.

Every new piece of complexity comes with new possibilities for error that need to be corrected with more code and more complexity.

### No Unforgeable Costliness

Another aspect of proof of work is that it is not possible to forge a copy of a chain. The literal proof of work of the chain prohibits that from happening. Since Bitcoin is programmed to adjust the difficulty of the algorithm automatically to produce blocks on average every 10 minutes, the number of Bitcoin blocks is proof of time passed.

It's not possible to write a block without solving that puzzle, so it's not possible to recreate a Bitcoin chain without doing that work all over again.

Proof of stake does not have this benefit, so you can spin up a copy of a proof of stake chain that looks just as valid as the original.

So again, we have added complexity in figuring out how to determine how the protocol punishes bad actors who are attempting to vote on multiple chains.

Before proof of stake went live, Ben Edginton, an Ethereum developer, spoke about some of the drawbacks and potential complexity implications of a proof of stake system on the [Compass Mining Podcast](https://compassmining.io/education/heres-how-ethereum-developers-are-thinking-about-mev-and-eth2).

Here's what he said:

> "The reason it has taken a while, you know we’ve relied on proof-of-work in Ethereum for five plus years, is that proof-of-stake is complicated. Proof-of-work is fundamentally very simple, is easy to analyze, is easy to implement and deploy, and proof-of-stake has a lot of moving parts. You can code up a proof-of-work algorithm in a hundred lines \[of code] or so. Our current clients are a hundred thousand lines or so for proof-of-stake.
>
> And I think the theoretical foundations for proof-of-stake have taken time to mature. It’s not obvious how to make it robust, there are attacks like long-range attacks and things that just don’t exist in proof-of-work, that we’ve had to think through and come up with solutions to, so that’s just taken time. So we’ve relied on the tried and tested proof-of-work algorithm and it served Ethereum well."

### Centralization Risks

In addition to the technical risks, proof of stake systems come with serious centralization risks as well.

There is no cost to staking in a proof of stake network. Whoever has the most coins has the most influence over which transactions get processed, and since they are earning the most rewards from an absolute standpoint, they can keep staking more and more and earn more and more influence over the network.

It's a "rich get richer" system from the ground up.

They can exponentially grow their stake, rewards, and influence over the network forever, and have no incentive to pull their stake and allow new entrants to overtake them.

Imagine this analogy [laid out by Lyn Alden](https://www.lynalden.com/proof-of-stake/).

> It would be like a political system where you get a vote for every hundred dollars you have, and then also get paid a dollar by the government for casting each vote. Mary the high school science teacher with $20,000 in net worth gets 200 votes, and earns $200 from the government for voting. Jeff Bezos, with $200 billion in net worth, gets 2 billion votes, and earns $2 billion from the government for voting. He’s a more valuable citizen than Mary, by a factor of a million, and also gets paid more by the government for already being wealthy.
>
> That’s not a system many folks would like to live in. Eventually it would likely consolidate into an oligopoly (if it wasn’t already), with a handful of multi-billionaires controlling most of the votes and ruling everything. If it gets too centralized, that kind of defeats the purpose of a decentralized blockchain.

Contrast this to the fact that Bitcoin miners need to constantly be keeping up with and investing in new technology to keep up with new market entrants, it's much more difficult to develop an entrenched set of miners.

On top of this, there are popular mining protocols in the works, like Stratum, that make it so that rather than pool operators dictating what transactions get included, it is the individual pool contributor that does.

This is big benefit to decentralization, and prevents pool operators from forming an oligopoly. In staking pools, we do not get this benefit.

In addition, it costs physical resources to mine, which need to be continually spent, whereas staking is a one-time action that compounds over time.

This is great for stakers, but arguably not so great for the network as a whole.

A common misconception is that stakers can control a proof of stake system at a protocol level. That is not true. Just like Bitcoin miners don't have much control over the protocol, that's more in the hands of the users.

But what validators and stakers do have control over is which transactions are included in the chain, which gives them power over what transactions can be added, a serious detriment to the censorship-resistance property of blockchains.

In addition to centralization risks posed by single entities influencing what transactions get added to the chain, we need to remember that a proof of stake chain's liveness is also determined by stakers.

The liveness of the Ethereum chain is also affected by the proof of stake process, meaning that over 33% of staked eth would be required to negatively affect the liveness of the chain.

Sounds great, except when you think about the fact that the 33% is very nearly achieved through a single entity, Lido. The issue here is that the liveness of the chain now rests not on the entirety of the Ethereum network, but rests on organizations like Lido functioning correctly, regardless of their intent.

If we extrapolate this out to a global, decentralized currency and economy, it means that the stability of that system can potentially rest on the intent and functionality of a few entities.

Even if these entities do become completely decentralized they are still largely responsible for maintaining the liveness of the Ethereum chain.

This is fine for a blockchain that is meant to function more like a development platform or company, but far from ideal for something that is designed to serve as a global decentralized money and economy.

But isn't Bitcoin primarily mined by pools as well? Yes, the primary difference again comes back to this issue of mining being connected to real-world resources, along with decentralization-focused protocols like Stratum.

Remember that staking means that the more money you have staked and the longer amount of time you have it staked, the more influence you have over the network.

This makes it extremely difficult for new actors to come in and disrupt the big validators. They are economically incentivized to just continue letting their stake grow perpetually.

The fact that your ability to become a validator is connected to the internal token makes it somewhat of a zero-sum game. Once the big players have been established, other actors can't collect enough tokens to catch up with how much they will be exponentially gaining as a result of their staking reward.

With proof of work, someone's ability to disrupt a large player's mining control is dependent on external factors. A mining pool that begins to act maliciously cannot simply coast because it has the most hash power. Its hash power does not continue to compound without having to spend anything as in proof of stake.

This effect is somewhat mitigated by staking pools, but only if they are able to maintain decentralization and avoid an oligopoly, which is again made more difficult due to the nature of proof of stake.

We recommend reading Scott Sullivan's [guide to proof of stake](https://scottmsul.substack.com/p/a-bitcoiners-guide-to-proof-of-stake) for a detailed breakdown of these and other issues.

One final note: there are many answers and proposed solutions to these issues, and we're not discounting those or saying that any of these things will happen with 100% certainty, but the tradeoff of all this experimental technology and relying on so many of these inter-related ifs to all go according to plan is not a bet many are willing to make when building a system so foundational to society.

This topic is a rabbit hole, and there are many responses and nuanced arguments to the points raised here. Every developer needs to do their research and decide which tradeoffs are worth it for their values and what they are trying to build.

With that in mind, if you are interested in learning how to build on Bitcoin but wondering how, we're going to cover that next.


# How to Build on Bitcoin

Until now, developers and users who wanted to build decentralized tools and to build an open, permissionless, decentralized economy didn't have much choice other than Ethereum or other chains like Solana, Avalanche, NEAR, etc.

Sure, we can build apps that utilize Bitcoin, but not at much more than the saving and payment level. I'm not discounting the importance of these things, but they aren't of much interest to developers and they aren't enough on which to build an economy.

We can't create a decentralized financial system using only Bitcoin. If you want to do things with your Bitcoin other than buy, hold, or pay (and even that is tough), you need to use centralized services and trusted intermediaries, or bridge over to other ecosystems.

If we want decentralized money, we also need the infrastructure and tools utilizing that money to be decentralized as well.

What are some examples of this? Many DeFi tools tend to function much like ponzis, but how we can recreate existing financial instruments and come up with new ones that not only utilize Bitcoin as the money but also run on rails that are decentralized as well?

Can we use Bitcoin in order to create decentralized financial products that are built on real money instead of thin air?

A decent framework for understanding the use cases here is to think of anything that utilizes a contractual agreement between two parties. Once you start to think about this, you realize that almost every interaction you have in your daily life involves something like this.

The majority of these are "handshake agreements" between two trusted parties, but a significant chunk of them are more official agreements with paperwork and terms laid out between two parties that may or may not have a personal relationship.

Or look at any existing financial instrument like loans and investments. How can we build these on decentralized rails so that they are accessible to everyone?

These are good examples of where smart contracts can help.

Loans are a prime example. If you want to borrow or lend Bitcoin in exchange for interest, you currently have to go through a centralized entity and custody your Bitcoin. If we can make that system decentralized as well, we unlock a whole new category of activity, utilizing Bitcoin, but without having to go through centralized entities.

We can use things like DLCs to recreate some of this functionality, but DLCs are still relatively limited in what they can accomplish.

Remember that Bitcoin itself is designed to create a form of money that is permissionless and trust-minimized. Smart contracts are a way for us to take the actions that we actually take with that money and make them decentralized and trust-minimized as well.

So how can we unlock robust smart contract functionality for Bitcoin without modifying the crucial properties that make it so secure and decentralized?

That's where Bitcoin layers come in.

This will be the main focus of the second half of this course, as we go in-depth into how to build things on Bitcoin using the Stacks L2 and the Clarity smart contract language.

For now, let's get a high-level overview of the earlier claim that we can build apps with comparable functionality to Ethereum on Bitcoin without modifying the core protocol.

### Bitcoin's Limited Functionality

The first thing we need to understand is that Bitcoin does have some fundamental programming ability utilizing its programming language, Script.

However, what you can do with it is limited. We'll be covering this in great detail in future lessons, but you can't fundamentally trigger certain actions to happen based on Bitcoin transactions, you can't utilize any real-world data from oracles, and you can't create a robust state management system.

Outside of very limited use cases like DLCs or HTLCs, you can't write expressive smart contracts on Bitcoin.

Similarly, Bitcoin can handle only a few transactions per second, so the transactions don't scale well. Again, this is by design as it helps to keep the requirements to run a full node very low, increasing decentralization.

Bitcoin layers can solve both of these problems. For now, we'll take a brief look at two of them: Lightning for scaling and Stacks for smart contracts.

### Bitcoin Layer 2 Solutions

#### Lightning <a href="#heading-lightning" id="heading-lightning"></a>

Lightning is a P2P scaling solution for Bitcoin that utilizes Bitcoin's native script language and HTLCs to create a payment solution that can handle more transactions per second than the Visa network.

It allows users to open channels with each other, make a series of transactions, and then write them all back to the main chain as a single batch transaction.

Individual transactions occur off-chain on the P2P Lightning network and then settle back to Bitcoin. This allows for much faster transactions and a high capacity but fundamentally does not expand the functionality of Bitcoin.

That's where things like Stacks come in.

Lightning is very interesting and will likely play a key role in the growth, evolution, and adoption of Bitcoin as usage grows, but it suffers from some key shortcomings that need to be overcome (things like liquidity issues) and doesn't enable us to build decentralized financial systems or more complex programming systems.

#### Stacks <a href="#heading-stacks" id="heading-stacks"></a>

Where Lightning allows the Bitcoin network to scale as far as the capacity for payments, Stacks is what expands the functionality and allows us to write smart contracts.

We'll cover Stacks in detail in the second half of this course, but the short version is that Stacks is a blockchain protocol that is connected to Bitcoin via its proof of transfer consensus mechanism.

It has its own token but is anchored to Bitcoin and can't exist without Bitcoin.

It allows for fully expressive smart contract functionality using a language called Clarity, which is designed for security and safety.

The takeaway is that Stacks allows us to write smart contracts for Bitcoin, and with sBTC, allows us to do this *using* Bitcoin itself, so Stacks can function more like an invisible programming layer, all done in a trust-minimized and decentralized manner.

The key takeaway is that it allows us to create the same level of functionality on Ethereum but on Bitcoin, without changing any of the things that make Bitcoin resilient.


# How Bitcoin Works

You are probably already familiar with how Bitcoin works at a high level, that it uses proof of work, has miners, etc. But to be able to start building with it, it's important to get an in-depth knowledge of how it works under the hood.

This module is going to serve as an introduction to how Bitcoin operates under the hood. We'll look at how mining works, the hashing algorithm Bitcoin uses, transactions, UTXOs, basic public key cryptography and address generation, and more.

We'll go through step by step, looking at how each component works and how they all interact to create the blockchain itself.


# Introduction

The first basic building block of Bitcoin is the network of nodes that comprises it. Remember that the entire point of Bitcoin is that is a distributed network of computers. These computers are called nodes. A node is just a computer that is running the Bitcoin software and is also connected to other nodes doing the same.

Anybody can run a Bitcoin node and the requirements to do so are relatively low, this is a major part of the reason why Bitcoin can be so decentralized. As blockchain protocols add complexity and speed, the hardware requirements to run a node increase, making fewer people able to run a node.

But why are more nodes good, and what role do they play in Bitcoin?

Nodes are the backbone of Bitcoin and what makes it secure and decentralized. They do three main things:

1. Follow the rules of the protocol
2. Broadcast new transactions
3. Store confirmed transactions

The Bitcoin protocol has pre-defined rules that nodes are required to follow. If they receive a broadcasted transaction that does not follow these rules, they simply ignore it.

If the transaction is legit and follows the rules, they broadcast it to the rest of the network. This transaction gets sent around the network to other nodes, in what's called the mempool until is confirmed and written to a block.

A node's mempool is where it collects all of the new transactions it has received while it waits to package them up into a candidate block.

We'll get more into blocks next, but at a high level, they are a collection of different transactions.

Each node will then try to get its block added to the chain through the mining process.

Nodes can also broadcast confirmed transactions, which are transactions that have been verified as legitimate and accurate. These transactions are batched into blocks and broadcasted that way by nodes.

Note that any node can be a miner, but not all nodes have to mine. Some nodes are only responsible for relaying newly created blocks and storing the history of the chain, but they don't participate in the mining process, as this can be costly.

We'll get into the makeup of blocks and how nodes which transactions and blocks to include next.

Finally, nodes also keep a copy of all confirmed blocks of transactions, which is what is collectively called the blockchain. The fact that all nodes are required to maintain this history of transactions is what makes Bitcoin immutable.

There is a verifiable history of transactions that all nodes agree on, and no single node can change.

You don't have to be a node to utilize Bitcoin. Anybody that has an address can use Bitcoin and initiate new transactions. If you want to be able to independently verify all transactions and the history of the chain yourself, and contribute to Bitcoin's decentralization, you should run a node, but you don't have to if you want to use Bitcoin.

Addresses and the public key cryptography that generates them are separate topics, and we'll cover them later. For now, just know that a Bitcoin address corresponds to what can be thought of as a user account, and those user accounts can initiate transactions that get relayed to nodes.

Then the nodes conduct the process we went over above.


# Transactions

Before we look at how blocks are constructed, let's first take a look at how Bitcoin transactions work.

As we noted above, any Bitcoin address can generate a new transaction to be broadcasted to the network.

A transaction is just a set of data that indicates the amount of Bitcoin being sent, what address it is being sent from, and what address it is being sent to.

The entire collective history of these transactions is what forms the Bitcoin blockchain.

All you are doing when you make a transaction is sending these pieces of data to the Bitcoin network. Eventually, a miner will add this transaction to a block and it will be confirmed on-chain, living on in perpetuity.

A transaction is a record of moving coins from one wallet to another, but it's not like how you might picture a bank account, where you are just moving a number from one bucket to another.

Instead, Bitcoin addresses (covered more below) are a record of every transaction that the address has ever sent or received, and this is how we can read the balance of a transaction.

Additionally, when you send bitcoins from your address to someone else, you are not directly sending a portion of your total bitcoins, you are batching transactions you have already received and sending that as a new transaction to someone else.

That's a little confusing, so let's lay it out with an example.

Let's say I receive three bitcoin transactions for 1, 2, and 3 BTC. I might have 6 BTC total, but it is recorded simply as me having received these three transactions.

So if I want to send 5 BTC to someone, my two transactions for 2 and 3 BTC will be batched together and sent as one new transaction. These batches are called outputs.

What if want to send 5.5 BTC to someone? In that case, Bitcoin will batch each of my transactions into a new output for 6 BTC, and then create an additional output to send 0.5 BTC back to myself.

It's weird but works better from a programming perspective.

Each transaction is locked using cryptography, so I can't just submit a new transaction that sends 1 BTC from your address to mine. We'll cover this in more detail below in the Addresses section.

If you've seen the term UTXO, that stands for "unspent transaction output".

If we modify our example above and I have a fourth transaction in my address for another 3 BTC, that output was not used in me paying the 5.5 BTC, so that is known as an unspent transaction output.

All of my other outputs are considered spent and cannot be used again, but this other one can because it is unspent.

Similarly, the 0.5 BTC that I sent back to myself is now a new UTXO that I can spend in the future.

UTXOs are critical because the total number of bitcoins an address owns is simply the sum of all of its UTXOs.

### The Mempool

When someone first initiates a new transaction, it does not immediately get written to a block. Instead, it gets sent to the mempool, which is a waiting room for transactions until they get picked up by a miner to be written to a block.


# Blocks

Bitcoin blocks consist of a couple of key components: transactions and a header.

Transactions are bundled together and written to a block in the form of a merkle tree. Starting at the bottom, we have all of the transactions in a block and each is hashed with the SHA-256 algorithm. Then, two of those resulting hashes are hashed together, and so on up the tree until we reach a single root.

<figure><img src="https://lwfiles.mycourse.app/635fe723662899c6bfb19e1d-public/652ba74c6638659efab8272a87d1aa6b.png" alt=""><figcaption><p>You can visualize this using this graphic from Subhan Nadeem's <a href="https://www.freecodecamp.org/news/how-bitcoin-mining-really-works-38563ec38c87/">excellent guide to Bitcoin mining.</a></p></figcaption></figure>

\
This merkle root is the foundation of how the Bitcoin blockchain maintains perpetual data integrity. This single merkle root is the unique "summary" of all of the transactions contained in this block. If even one byte of data in any of these transactions was changed, the merkle root would be completely different, rendering a block invalid.

Since this violates the rules of the Bitcoin protocol, a node would catch this change and reject that block as invalid.

Next is the block header, which is made of 6 components:

* Bitcoin software version number
* Block timestamp
* The merkle root of this block's transactions
* The hash of the previous block
* A nonce
* The target

By containing the hash of the previous block in every block header, we can create an immutable chain of blocks and an ongoing ledger of every transaction that has ever occurred. This is where we get the term blockchain.

Nonce and target are two components that are critical to the mining process, and we'll cover them below when we dive deeper into mining.


# Miners

As you probably know, Bitcoin uses proof-of-work mining. What does that mean? The Bitcoin protocol uses a SHA-256 hashing algorithm. SHA-256 is a one-way deterministic hashing algorithm that takes an input and returns a hash in the form of a 256-bit number.

That means:

1. One-way: we provide an input to the hashing function, and it gives us an output, but we cannot then take that output and get back the original input
2. Deterministic: If we provide the same input, we will get the same output every time. If we change even one character, we get a completely different hash

Let's look at an example of this using this [hash calculator](https://xorbin.com/tools/sha256-hash-calculator).

If we type "Hello World" into the input box, we get a hash back.

<figure><img src="https://lwfiles.mycourse.app/635fe723662899c6bfb19e1d-public/b28da6003c2fbb4219b851ffa66c4cad.png" alt=""><figcaption></figcaption></figure>

We get the hash a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e.\
\
Let's see what happens if we change even one little character, let's change the "H" to be lowercase.

<figure><img src="https://lwfiles.mycourse.app/635fe723662899c6bfb19e1d-public/25cd7a3bf92a507e766a8fb597d5083b.png" alt=""><figcaption></figcaption></figure>

SHA-256 gives us a completely different hash. But, if we switch back to a capital "H", you'll see that we get the same hash that we got before, that's the deterministic part of the hash function.

But we said the output is a 256-bit number, what's with the letters?

The output is represented as a hexadecimal number, which uses base 16 instead of the base 10 representation most of us are used to with the decimal system. In decimal notation we can only represent values with 0-9, and with hexadecimal we expand that to use the symbols a-f to represent the values 10-15.

So in a hexadecimal number, 3a would actually represent the values 3 and 10.

Okay, so what do these hash values have to do with mining?

When someone becomes a miner, their Bitcoin software will take a megabyte worth of transactions (remember that transactions are sent to all nodes) run it through SHA-256, and continue trying different pieces of data until it gets to a number that the network accepts, in which case they are given the block reward.

The block reward is how new Bitcoin is minted and is also the financial incentive for miners to spend computational energy to try to guess this hash value.

But what data is getting submitted to the hash function by the miners? And how does the network decide which is acceptable? More importantly, how does this process ensure that only valid data is written to the chain?

### Bitcoin Mining In-Depth

Let's go back up to the target and nonce fields of the block header we mentioned above.\
Now that we have some context into how hashing plays a role in mining, we can see what these fields are used for.

Remember that the output of a SHA-256 function is just a hexadecimal number.

The target field of the block header is also a number but in traditional base 10 notation.

The goal of miners is to take the information contained in the current block header, add a random number to it called a nonce, and calculate the hash. If the hash value is lower than the target value, then the miner writes the block to the chain and is rewarded with the block subsidy.

The "work" part of the proof of work consensus mechanism consists of mining software trying an extremely large number of different nonces to get a hash value that is lower than the target.

So a miner will start with a nonce of 0, and then increase the nonce one at a time until the hash outputs a number that is lower than the set target.

Even for the Genesis block, the highest the target number will ever be, required 2,083,236,893 attempts to get the final acceptable nonce.

Miners get their rewards by adding a transaction to their block rewarding themselves, this is a special transaction called a generation transaction and is accepted by the network upon publishing a valid block.

So that is how things work from the miner side, but how do the other nodes know that the transactions contained in this published block are legitimate?

The rules that transactions need to follow are coded into every Bitcoin node, so a receiving node will first check to make sure that all transactions contained in the new block follow the rules.

If they do, it will then double-hash the header of the published block to verify that it is lower than the target. The miner publishes the successful nonce with their header, so the validating nodes only need to run the hash function with the provided nonce to ensure it is correct.

Even if a miner goes through the costly process of trying to mine a new block, they still need to include valid transactions or their efforts will be wasted, since the validating nodes won't accept an invalid block.

### Difficulty Adjustment

Trying all the different inputs required to generate an accepted hash requires an immense amount of energy, and this energy expenditure is the core of what secures the Bitcoin chain.

Bitcoin has a built-in difficulty adjustment, which automatically adjusts the difficulty of guessing the correct hash depending on how many miners are online.

Every two weeks, Bitcoin analyzes miner activity and adjusts the difficulty so that the average time to write a block is 10 minutes.

It does this by raising or lowering the target number to make it so that the odds of guessing the nonce roughly match up with it taking 10 minutes to occur based on the current hashrate of the Bitcoin network.

Because of this, we can verify the real Bitcoin chain by determining which is the longest, we'll get into this a bit more in the Blockchain section below.


# Addresses and Keys

So other than being a node, how do we actually become a Bitcoin user and participate in the network?

And since transactions are just lines of data, what's to stop me from initiating a transaction sending BTC from your address to mine?

This is where addresses and keys come in.

Rather than a traditional web app, where you might be identified by a username or an email address, and authenticate with a password, Bitcoin uses the concept of addresses with public and private keys to establish identities and verify transactions.

Let's see how this works.

Bitcoin identities or accounts or composed of two primary components, a public key and a private key. You can think of a public key as your username, it's publicly visible and is used to establish your identity and separate it from everyone else.

Your private key should not be shared with anyone and this is how you prove that you are the owner of said public key. You can receive bitcoins with a public key, but you can't send them without also having access to the private key.

Public keys are long and unwieldy, so the Bitcoin protocol also generates condensed versions of these called addresses. This is usually how you will interact with other Bitcoin users. Addresses contain a few other neat little tricks that make things easier, Learn Me A Bitcoin has some interesting information on this.

How do these get generated?

The first step is to generate a private key, which is a really big random number in hexadecimal format.

Then we use this private key to generate our public key, which is publicly visible. Since we don't want anyone to be able to determine our private key from our public key, we use a one-way mathematical function to generate this public key.

This is a deterministic function, so anytime we pass our private key into this function, we will get this same public key.

That's how we can authenticate our transactions. Anytime we send out a new transaction, it gets sent out with a lock on it. Remember that all of the bitcoins we own are really just sets of outputs that were sent to us.

Well when they were sent, the sender placed a lock that said that only we can open it, or only this address can open it. And the key we use to open that lock is our private key.

So even though outputs are being broadcast to the entire chain, they are being broadcast with these locks so that only the owners can take them and use them as inputs in new transactions.

Something else that is useful to know is that you can tell what network an address belongs to based on how it begins. Addresses are generated differently depending on their encoding scheme and network.

First, we have two different encoding schemes for addresses, base58 (aka legacy) and bech32.

Base58 mainnet addresses will start with either a '3' or a '1'.

Bech 32 mainnet addresses will start with 'bc'.

Base58 testnet addresses will start with 'm' or '2'.

Bech 32 testnet addresses will start with 'tb'.

Base58 regtest addresses will start with 'm' or '2' (same as testnet).

Bech32 regtest addresses will start with 'bcrt'.

This will come in handy as you are developing to know which network and address type you are working with.

For more on bitcoin addresses, check out a deeper [explainer](https://www.hiro.so/blog/understanding-the-differences-between-bitcoin-address-formats-when-developing-your-app) on the Hiro blog.


# Blockchain

Now that we've covered the essential components of Bitcoin, let's zoom out and take a look at the Bitcoin blockchain as a whole.

The blockchain is a file containing every Bitcoin transaction that has ever occurred, added in blocks, which are all connected to each other, hence, blockchain.

When you run a Bitcoin node, the first thing it will do is download a copy of the entire blockchain.

It will do this by connecting to other nodes on the network and asking for a copy of the blockchain from them. As part of this process, nodes communicate the height (how many blocks) of their chain. Nodes do this continuously so they are always sharing the current state of the chain and replicating it across every node in the network.

As we discussed above in the mining section, new blocks are generated by miners, which then broadcast that new block to the other nodes, and they add it to their copy of the blockchain.

One thing we didn't address in the mining section is what happens when two blocks are mined at the same time. It is possible, and normal, for two miners to solve for two blocks at roughly the same time.

Since it takes time for changes to propagate across the network, nodes will receive different blocks at different times.

When this happens, nodes will take the first block they receive as part of their chain, and they will also accept the second, but it won't be considered part of the active chain.

At this point, some nodes in the network will be in disagreement about which block belongs at the tip of the chain.

How does this problem get solved?

When the next block is mined, it will be mined on top of only one of these two blocks, which now makes that particular chain the longest.

As a result, the nodes will drop the other chain since it is no longer the longest. This process of removing blocks from an older, inactive chain in favor of the blocks from the newer, active chain is called a chain reorganization.

What happens to the transactions in the block that was dropped? According to the network, they are invalid and do not exist. So if you try to spend bitcoins from an output that was contained in this dropped (orphan) block, it won't work.

But when two blocks are mined at about the same time they usually contain the same transactions, so nothing usually happens.

But even if there were some transactions contained in the orphan block that were not contained in the accepted block, they would just get sent back to the mempool to be picked up again, so the worst-case scenario is that it takes a little longer for the transaction to be processed.

But, this is not a guarantee, so it's a good idea to wait for your transaction to be included more than one block deep before considering it final.

So technically, Bitcoin blocks can be replaced. If theoretically, you were able to somehow produce enough blocks to create a longer chain than the one currently accepted by the nodes, then you could take over the network and put whatever data you wanted in those blocks.

The problem is this is technically next to impossible due to one of the key innovations we briefly touched on above, the difficulty adjustment.

The difficulty adjustment ensures that a certain amount of time has passed to create the current state of the chain. That's why I can't just create my own private Bitcoin chain and then push it out onto the network for nodes to adopt.

Okay but couldn't I just take the existing chain and build a new chain on top of it? You could, but you would need to be able to outpace the entire network of miners building on the longest chain.

Remember that the difficulty adjustment uses the average hashrate over the last two weeks, meaning that you would get nowhere trying to outpace the network at the current hashrate unless you hate over 50% of the mining power. At that point it would just be a matter of time until you were able to perform a re-org, depending on how far down the chain you wanted to replace transactions.

This is known as a 51% attack and while it is technically possible, it has never been done before.

Note that this is another thing that differentiates proof of work from proof of stake. In proof of stake protocols, we don't have this proof of the passage of time functionality built-in, so I can create as many false copies of a proof of stake chain as I want without having to expend any resources.

This means that a validator in a proof of stake system able to gain a majority of the required staked asset can [swap the entire chain](https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/attack-and-defense/) with one of their choosing and there would be no recourse, aside from hoping that the community would voluntarily adopt an honest version of the chain.

In a proof of work system, even if an attacker was able to successfully conduct a 51% attack, they still have to continue to maintain that power over a progressively longer period to reorg further down the chain. In a proof of stake system, it's game over.


# Script

[Script](https://learnmeabitcoin.com/technical/script/) is a stack-based mini programming language built-in to the Bitcoin protocol. It is primarily used for locking outputs and setting certain rules that must be met to unlock them.

A locking script is placed on every output and must be unlocked with an unlocking script before that output can be spent and used as an input for another transaction. All conditions on both scripts must be valid for the output to be unlocked and used.

Script is a very basic language and consists of two basic building blocks:

1. Data (signatures, public keys)
2. Opcodes (simple functions that operate on that same data, here's a [list of all opcodes](https://en.bitcoin.it/wiki/Script#Opcodes))

We'll go over the basics of how Script works here and we'll experiment with it and dive deeper in the next lesson.

Script is a bit funky, especially if you are used to more web-oriented programming languages like JavaScript, Solidity, PHP, etc. It's a stack-based programming language.

What does that mean?

A stack is just a low-level data structure or a way to store data.

You write a script and it is read from left to write, interacting with the data via a stack. You can think of the stack as an empty silo that data is pushed into.

So you have a piece of data on the left of a script, and then OPCODES can pull data out of the stack, do something with them, and push new data back onto the stack.

Stacks follow the LIFO principle, or last-in, first-out, to determine the order in which the pieces of data are operated on. You have to add to the top of the stack and you can only pull from the top of the stack.

A script follows this process until it reaches the end and is considered valid if the only value left in the stack is a 1 or greater.

<figure><img src="https://lwfiles.mycourse.app/635fe723662899c6bfb19e1d-public/bfaed54dc765fe9904fd17508f989f37.gif" alt=""><figcaption><p>Here is a good visualization from <a href="https://learnmeabitcoin.com/technical/script/">Learn Me A Bitcoin</a></p></figcaption></figure>

This is what's called a P2PKH script, and is the most common script used. This locking script is the one used any time you send bitcoins to someone.

I recommend [learning how it works](https://learnmeabitcoin.com/technical/script/p2pkh/) before moving on.

There are two primary pieces of functionality that we can use to work with stacks: push and pop. Push will add a piece of data to the top, and pop will pull a piece of data from the top and return it.

Then we can take this data and run it through an OPCODE function to turn it into something else, and then push it back onto the stack.

This is all a bit complex and is difficult to wrap your head around at first, but this basic lock/unlock process using scripts is how every output is sent and unlocked by the appropriate user. Don't worry too much about completely understanding this right now, we'll do some concrete practice with Script in the next section when we begin building our app.

We have these scripts instead of just basic public/private key verification so that we can create different types of locks that do different things. This is how Bitcoin offers programmability.

But part of the reason that we can't do nearly as much with Bitcoin as we can with Ethereum is that these scripts and OPCODES are very limited. And, as an additional limitation, there is a very small subset of OPCODE combinations called standard scripts that nodes relay.

5 standard scripts offer a few different pieces of functionality that nodes will relay. You can read more about these on Learn Me A Bitcoin, but the basic reason is safety and security.

Not all scripts have been tested, so it's a security risk to allow all these different combinations and open up attack vectors.

This limitation is part of what makes Bitcoin extremely secure, but it also makes it so that we can't build robust smart contracts on Bitcoin.

When people talk about smart contracts on Bitcoin, this Script language is what they are referring to, and it is extremely limited by design.

Let's look at two common use cases for modern smart contracts, DeFi and DAOs.

Let's say we want to build a DeFi application that allows us to lend our bitcoins in exchange for interest.

Right now, we can't do that without giving someone else custody of our bitcoins and letting them do it for us.

This introduces a trusted intermediary which defeats the entire purpose of having decentralized money. Ethereum users realize this and they have created a robust ecosystem of DeFi applications that allow users to earn on their assets.

How can we do this trustlessly with how limited Bitcoin's Script language is?

This is where Bitcoin layers like Stacks come in. Stacks allows us to build separate systems that hook into Bitcoin and expand its functionality.

We'll dive deeper into these limitations and how we can still build robust smart contracts with layers (Stacks specifically) in the second part of this course.


# Updates & Forks

While Bitcoin is generally resistant to change and doesn't change as often as other chains might, that doesn't mean it is completely stagnant. There have been several changes and upgrades over the years.

In general, these changes can be divided into two categories: hard forks and soft forks.

### Hard Forks

A hard fork is where the chain splits and creates an entirely new version. The new chain is not backward compatible and nodes need to choose between the two.

There have only been a few long-lasting hard forks in Bitcoin's history, Bitcoin Cash is one of them after the heated blocksize war, which is a [fascinating read](https://www.amazon.com/Blocksize-War-control-Bitcoins-protocol-ebook/dp/B08Z18GWD6/ref=sr_1_1?keywords=blocksize+war\&qid=1676010906\&sprefix=blocksize%2Caps%2C125\&sr=8-1).

Bitcoin also accidentally hard forks relatively frequently for a short amount of time, we discussed this when we talked about chain reorganization above.

Hard forks are a radical change that should only be carried out when absolutely necessary, as it is necessary to get the entire network to agree in order to have them switch to the new chain and not create two versions, as with Bitcoin Cash.

### Soft Forks

In contrast, soft forks are backward compatible changes where nodes see both versions of that chain as valid. SegWit was a major upgrade to the Bitcoin network that we'll talk a bit more about below and was a soft fork.

Bitcoin also has a very cool ability called user-activated soft forks. UASFs allow users of Bitcoin like wallet operators, exchanges, businesses, and other users running full nodes to move to a new version of a chain that will have some activation point in the future.

This forces miners to utilize this new forked version or else end up mining a separate chain, killing their profits. This is primarily to prevent control of the network from being in the hands of the miners, which was a major concern during the blocksize war.

We recommend anybody interested in the surprisingly dramatic history of Bitcoin forks read the book linked above, The Blocksize War.

Two major upgrades to Bitcoin that we recommend you read more about are [SegWit](https://river.com/learn/what-is-segwit/) and [Taproot](https://river.com/learn/what-is-taproot/), as they both have impacted how Bitcoin works in relatively major ways.


# Bitcoin Development Basics

In the last sections, we talked about why now is an excellent time for developers to start building on Bitcoin and how Bitcoin works. Now we're going to start applying some of that knowledge and get started programming.

We're going to start by looking at the fundamentals of Bitcoin scripting and how Bitcoin transactions are constructed. Along the way, you'll learn important fundamentals about how Bitcoin works, but you'll also begin to see the major drawbacks of trying to build with only Bitcoin.

We're going to start off in this module by utilizing the command line to get Bitcoin set up on our local machine and begin working with it.

The first thing we need to do is get Bitcoin set up on our machine. Start by [downloading Bitcoin Core](https://bitcoin.org/en/bitcoin-core/).

<figure><img src="https://lwfiles.mycourse.app/635fe723662899c6bfb19e1d-public/363e23022af117cdd932b0f3cadfe860.jpeg" alt=""><figcaption></figcaption></figure>

Once it's installed you'll want to run `bitcoind`, which is the CLI we use to actually run Bitcoin.

Note that you don't need to run and download a full node in order to follow along here. We can run Bitcoin is `regtest` mode in order to create our own localized private Bitcoin network.

You can do that by running `bitcoind -regtest -daemon` which will run a regtest version of Bitcoin in the background as a daemon.

The next thing you need to familiarize yourself with is the Bitcoin CLI.

The first thing we are going to do is generate some new blocks and send the block reward to a new address that we'll generate.

We can do that with `bitcoin-cli -regtest generatetoaddress 101 $(bitcoin-cli -regtest getnewaddress)`

Here were telling the CLI to enter regtest mode, then generate 101 new blocks and send the block reward to the provided address, which in this case is a script to generate a new address using the CLI.

An array of the generated block hashes will be returned to us.

<figure><img src="https://lwfiles.mycourse.app/635fe723662899c6bfb19e1d-public/8700e9c212639634619e84ad5deda276.jpeg" alt=""><figcaption></figcaption></figure>

Now we can see the list of UTXOs we have created:

`bitcoin-cli -regtest listunspent`

And get the balance of our newly generated address:

`bitcoin-cli -regtest getbalance`

Alright we now have Bitcoin running locally and have a basic understanding of how to interact with it. Let's pause and take a look at how Bitcoin Script works before coming back and using the CLI to create some transactions.


# Bitcoin Script Fundamentals

In the last lesson, we briefly covered Bitcoin's scripting language, Script. Now let's dive a little deeper into that and look at how we can actually use Script to write Bitcoin applications that do useful things.

We're going to start with a very simple Hello World script to learn the basics, then we'll look at how we can create some more complex scripts down below as we create the MVP of our app.

We'll be using an [online Bitcoin IDE](https://siminchen.github.io/bitcoinIDE/build/editor.html) in order to write and visualize our script.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676575449444/230898b8-c0ac-4362-9650-b38fc072a5b2.png?auto=compress,format\&format=webp)

This visualization is extremely helpful for understanding how Bitcoin Script actually works. We have some code here by default: `1 2 OP_ADD`.

Take a second to try and guess what this code will do. Then use the 'Step' button to go through the operations step by step and see what happens.

What we've done here is added each number to the stack, and then applied the `OP_ADD` function to them. `OP_ADD` takes two inputs and adds them together. You can see all the available OPCODES and what they do in the [OPCODE reference](https://en.bitcoin.it/wiki/Script#Opcodes).

Now let's try adding another number here, running through the step function and seeing what happens. It might not be what you expect.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676575954167/a96fe443-e718-4db7-881d-71fec13f07e6.png?auto=compress,format\&format=webp)

Why did we not get a single `0x6` back instead of this `0x5`? Because remember that we go data by data and apply these OPCODE functions. The `OP_ADD` function takes the top *two* pieces of data, adds them, and then pushes the result back on to the stack.

So here we are adding 2 and 3 last, so `OP_ADD` will then take those, add them, and push them. If we want to add all of these numbers together we could add another `OP_ADD` function and see what that does.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676576076195/94b52849-13f6-4328-a7bc-c5ca7b332976.png?auto=compress,format\&format=webp)

Now I want you to try and write a script that does the following:

1. Adds together two integers.
2. Checks to see if the value of those integers is greater than 7.

If it is, the execution will be successful, otherwise it won't be. Recall that a script is considered successful and valid if it returns 1 or greater. Look at the OPCODES and figure out what that means for this particular challenge.

You'll need to explore the OPCODE reference in order to complete this task.

Try to do this on your own before looking at the solution below 👇🏻

No cheating.

🔽

🔽

🔽

🔽

🔽

🔽

🔽

🔽

🔽

🔽

Ready for the solution?

`2 2 op_add 7 op_greaterthan`

Add this to the IDE and step through each step to figure out why this is the solution if you got something different.

We are first adding together 2 and 2, resulting in 4. Then the op\_greaterthan opcode checks to see if \`a\` is greater than \`b\`. In this case, 4 is not greater than 7, so the execution is unsuccessful. If you were to replace 2 and 2 with 4 and 5, or something else more than 7, it would work.

How does scripting work in the context of transactions? Remember that fundamentally, Bitcoin is built on UTXOs. The UTXO set consists of all of the unspent transaction outputs and represents the current state of the network as far as who can spend what bitcoins.

Scripting is how we actually create and enforce these spending conditions.

So if I have 1 bitcoin, that might mean that I have two UTXOs, each representing half a bitcoin. Scripting is what makes it impossible for anybody but me, with my private key, to spend that UTXO.

How does this work?

Each UTXO comes with a locking script that is a sort of cryptographic puzzle that needs to be solved before it can be used as a valid input to another transaction.

So if I want to use one of my UTXOs, I need to solve that puzzle. When I go to create a new transaction, I provide an unlocking script along with the UTXO that I want to use as input.

This unlocking script serves as the solution to the puzzle provided by the locking script.

Usually, these puzzles will utilize our public and private keys to verify that we are in fact the owners of these UTXOs, so that the only way to unlock the UTXO is to provide the correct combination of public and private key.

Depending on the block explorer, we can see the output scripts included in transactions. For example, take a look at [this transaction](https://mempool.space/tx/d084830f0b8cfadc340b0575fe4543979cd1900e8a3ade9a045b94070f848a49), scroll down and you can see the scripts that were included with these outputs:

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676583583094/ea088e1f-60a3-4e9b-9166-fee0c8a6c419.png?auto=compress,format\&format=webp)

This is the locking script or the script that the receiver of this output must be able to unlock in order to use this output.

So when we go to use this output by providing it as an input to another transaction, we then give an unlocking script in order to unlock it and actually be able to do that.

If we click this little arrow next to the input, we can go to the previous transaction containing the output used for this input.

Then we can see the locking script that was provided for this new input. The unlocking script provides the signature of the private key and the public key that are required to fulfill the requirements of the locking script.

Upon creating a new transaction, these two values are combined with the locking script via the stack and the result needs to be valid for this transaction to be considered valid.

Walkthrough of a P2PKH Script

In the above transaction example, you can see that the first output has a P2PKH script.

P2PKH stands for pay to public key hash, and it is the most common type of script in Bitcoin. This is the script that gets run when you make a basic transaction from one address to another.

That script consists of the following code:

`OP_DUP OP_HASH160 f1304d590d8f1a6b8cefd655c584616f8f68ea81 OP_EQUALVERIFY OP_CHECKSIG`

Let's walk through exactly what this script is doing when we initiate a transaction.

When we use our wallet to initiate a transaction, remember that what we are actually doing is creating a new input by utilizing one of our existing outputs, or UTXOs more specifically, as that new input. When we do that, we provide the transaction ID of the output we want to use.

The wallet will then go find the output that matches that transaction ID, look at the locking script, the `scriptPubKey` field, and see if the unlocking script we are providing with our new input satisfies the conditions required.

We do this by combining these two scripts together. In the Input Scripts section of the screenshot, we can see the P2PKH script consists of two large hexadecimal numbers.

These represent hashes of the signature of the sender's public key and their public key, respectively.

We will place the unlocking script in front of the locking script and run the code. If it evaluates to `true` then we are allowed to spend this as a valid input to a new transaction.

So using the transaction above, the whole thing would look like this:

`47304402203939a0a60876c330fd5165f4648cd431d8b379a6ac1a9022e31afa10ef30d827022035e07560ca6068669ce17d7acaac193 54a148ac453d2feb518b236aa8fc1cc2a012102dc109689e8655dc90d09544397d8b04989cd42b8037d15ba629b12d5ab77c068 OP_DUP OP_HASH160 f1304d590d8f1a6b8cefd655c584616f8f68ea81 OP_EQUALVERIFY OP_CHECKSIG`

Okay there's a lot here, but try and go through this step by step and figure out what exactly it is doing by using what we've already learned about stack-based languages and Bitcoin OPCODES.

You can refer to Learn Me a Bitcoin if you get stuck. But writing down how this script works step-by-step will be an excellent exercise to help you understand how scripting in Bitcoin works.

Then, go through all of the standard scripts on Learn Me a Bitcoin and familiarize yourself with how they work.


# Creating & Sending a Bitcoin Transaction

The first thing we are going to do is list all of our UTXOs using `bitcoin-cli -regtest listunspent`. If you followed the original setup steps from the previous lesson, this will list out a few outputs with 50 bitcoins and our generated address should have 350.

We're going to be creating a transaction to send money to someone else, so we need to generate a new address with `bitcoin-cli -regtest getnewaddress` which will give us a new address to work with.

In my case the new address is `bcrt1q3cwy2hv9qkff8dtn3jgv0fh7rtwdvpu6dmt9pc`, yours will be different.

Now we need to open up a code editor to actually build our transaction.

I'm going to create a new folder called `bitcoin101` and a new file in there called `transaction.json`. This is where we'll build our transaction.

```json
[
    {
        "txid": "9031a74d6a920032d46519a789f7854b996ec7d98e446c3751d24b1df68257fb",
        "vout": 0
    }
]

{
    "bcrt1q3cwy2hv9qkff8dtn3jgv0fh7rtwdvpu6dmt9pc": 49,

}
```

The first item here is the transaction ID that I pulled from our terminal output when we ran `bitcoin-cli -regtest listunspent`. Note that this is represented as the first object in an array. You might get some syntax errors here depending on your code editor, we need to do some work to get this to work with `bitcoin-cli`, but let's keep going for now.

Next, we have an item called `vout` which corresponds to which output of this transaction we are referring to. Since this particular transaction only has one output, we have an index of 0 here, indicating the first (and only in this case) output of this particular transaction.

Finally, we have another JSON object that has a key of a Bitcoin address (this is the address that we generated in the previous step) and the amount of bitcoins we are going to be transferring to this address.

Now we need to wrap each of these sections in quotes to create separate strings from each of them to pass to the CLI.

Then we need to escape the double quotes for the keys and indices of the objects.

Now we need to put it all in one row.

Mine looks like this at the end:

```json
"[{\"txid\": \"9031a74d6a920032d46519a789f7854b996ec7d98e446c3751d24b1df68257fb\",\"vout\": 0}]" "[{\"bcrt1q3cwy2hv9qkff8dtn3jgv0fh7rtwdvpu6dmt9pc\": 49}]"
```

Yes, this is weird and kind of a pain. But now we have two strings representing JSON objects that we can pass to our Bitcoin script. When we work with libraries and layers in future tutorials, we won't need to deal with things like this.

We're just constructing things from scratch for now so you understand how it all works.

Next we need to run the following to create this transaction:

```bash
bitcoin-cli -regtest createrawtransaction "[{\"txid\": \"9031a74d6a920032d46519a789f7854b996ec7d98e446c3751d24b1df68257fb\",\"vout\": 0}]" "[{\"bcrt1q3cwy2hv9qkff8dtn3jgv0fh7rtwdvpu6dmt9pc\": 49}]"
```

And we get back a raw transaction hexadecimal string:

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1679086844200/bf063cba-96ef-46db-a402-c0c5ca9a8a67.png?auto=compress,format\&format=webp)

This contains the inputs we want to use, but it does not give us the unlocking scripts we would need to actually utilize these inputs as an output if we were the recipient.

Before we look at those, let's decode this raw transaction.

We can do that with `bitcoin-cli -regtest decoderawtransaction 0200000001fb5782f61d4bd251376c448ed9c76e994b85f789a71965d43200926a4da731900000000000fdffffff0100111024010000001600148e1c455d85059293b5738c90c7a6fe1adcd6079a00000000`.

That will give us the decoded transaction:

```json
{
  "txid": "f51169cbc1744817ef5ff52a972f241641247b871d55c96d71c00308388cef3a",
  "hash": "f51169cbc1744817ef5ff52a972f241641247b871d55c96d71c00308388cef3a",
  "version": 2,
  "size": 82,
  "vsize": 82,
  "weight": 328,
  "locktime": 0,
  "vin": [
    {
      "txid": "9031a74d6a920032d46519a789f7854b996ec7d98e446c3751d24b1df68257fb",
      "vout": 0,
      "scriptSig": {
        "asm": "",
        "hex": ""
      },
      "sequence": 4294967293
    }
  ],
  "vout": [
    {
      "value": 49.00000000,
      "n": 0,
      "scriptPubKey": {
        "asm": "0 8e1c455d85059293b5738c90c7a6fe1adcd6079a",
        "desc": "addr(bcrt1q3cwy2hv9qkff8dtn3jgv0fh7rtwdvpu6dmt9pc)#4grm02gz",
        "hex": "00148e1c455d85059293b5738c90c7a6fe1adcd6079a",
        "address": "bcrt1q3cwy2hv9qkff8dtn3jgv0fh7rtwdvpu6dmt9pc",
        "type": "witness_v0_keyhash"
      }
    }
  ]
}
```

Notice that we are missing the `scriptSig` field of the input (`vin`)here. We have both an input and an output in this transaction, but our *unlocking* script is missing, meaning we have no conditions that need to be met in order to use this UTXO. We'll need to create this in the next step so that we set some script that can meet the conditions set by the locking script in `vout`.

We have an input which has no script conditions to be used as an input, but if we look at the `vout` field we do have a `scriptPubKey` which corresponds to the locking script that we need to solve if we want to use this UTXO as an output for a new transaction.

Now we need to sign this transaction by providing the unlocking scripts for the outputs.

We can do this with the CLI by running `bitcoin-cli -regtest signrawtransactionwithwallet 0200000001fb5782f61d4bd251376c448ed9c76e994b85f789a71965d43200926a4da731900000000000fdffffff0100111024010000001600148e1c455d85059293b5738c90c7a6fe1adcd6079a00000000` where we paste in that same raw transaction.

This will give us another raw transaction:

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1679120801109/79ea2274-f303-41cc-b2f1-b8e40e550fb2.png?auto=compress,format\&format=webp)

Let's decode that as well with `bitcoin-cli -regtest decoderawtransaction 02000000000101fb5782f61d4bd251376c448ed9c76e994b85f789a71965d43200926a4da731900000000000fdffffff0100111024010000001600148e1c455d85059293b5738c90c7a6fe1adcd6079a02473044022007edd24d8867fa81ee96e54eb8041443ce84cef346e6039a2c0a055d01e2792302202159c07be4c07e2d1c679cdd4b2f5d3953da3c05845493bff3365b8dbd52ed7b012102f815159d7e6e2d1b2ec6c7c8c9d0863274999d4cfb28b6e6081ed448211fe54700000000`.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1679120829663/1c290909-ecd7-4729-be44-e55ff8819df3.png?auto=compress,format\&format=webp)

We have something important to learn here. Pay attention to the `txinwitness` field here. Notice that the `scriptSig` field is still empty, but now we have something in this new `txinwitness` field.

This is a new script we haven't seen yet, and it has to do with the SegWit update. This new script is a P2WPKH, or pay to witness public key hash. It's very similar to a P2PKH script, except it occurs when a native SegWit wallet wallet sends a UTXO to another SegWit wallet.

The `scriptPubKey`, which is our locking script, also doesn't actually look like a script. It's just a `0` with what looks like an address behind it.

What's going on here?

This P2WPKH transaction actually has all the same information as a P2PKH transaction, but the data is in funky places.

The entire point of SegWit is to "segregate the witness" data (segregated witness) in order to save space taken up by transaction data. The public keys and signatures are what the witness data is composed of, so those get pulled out of the transaction itself in order to decrease the amount of space the transaction takes up.

So where does the data go?

That's where the `txinwitness` field comes in.

These two values are a signature and a public key. The `0` plus long string in the `scriptPubKey` field is the SegWite version plus the public key hash.

You can read more about how this works on a non-SegWit node here, although this is quite rare these days.

A SegWit node just knows to hash the public key in the `txinwitness` field, check that against the already-hashed key in the `scriptPubKey` field, and then finally run `OP_CHECKSIG` against the public key and signature provided in the `txinwitness` data.

Basically, the P2PKH script has been embedded in the core protocol as the default way to process transactions.

Now we need to actually send this transaction.

Remember that due to the way UTXOs work we need to not only send this transaction but we also need to create another transaction to send our change back to ourselves.

Let's first generate a change transaction with `bitcoin-cli -regtest getrawchangeaddress` which gives us a new address.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1679124725931/f8ba5bb8-3d54-4704-a0a6-72c88f87c1cf.png?auto=compress,format\&format=webp)

Now we're going to take that and append it to our previous transaction with the amount of change we want to send back.

```bash
bitcoin-cli -regtest createrawtransaction "[{\"txid\": \"9031a74d6a920032d46519a789f7854b996ec7d98e446c3751d24b1df68257fb\",\"vout\": 0}]" "{\"bcrt1q3cwy2hv9qkff8dtn3jgv0fh7rtwdvpu6dmt9pc\": 49, \"bcrt1q6ktd4t8vwtqww6882v5xk7d3k9a65xqelamqk2\": 0.99}"
```

What we are saying here is that we want to take our UTXO of 50 bitcoins, send 49 to one address, send 0.99 back to ourselves as change, and use the remainder as a transaction fee.

If we run this we get a new raw transaction.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1679125128230/18a958ab-a075-48bf-a950-46f7b09c7355.png?auto=compress,format\&format=webp)

Now we need to sign this with `bitcoin-cli -regtest signrawtransactionwithwallet 0200000001fb5782f61d4bd251376c448ed9c76e994b85f789a71965d43200926a4da731900000000000fdffffff0200111024010000001600148e1c455d85059293b5738c90c7a6fe1adcd6079ac09ee60500000000160014d596daacec72c0e768e753286b79b1b17baa181900000000`.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1679125271728/71942cf4-d62f-4ca7-8431-754505ecdd97.png?auto=compress,format\&format=webp)

And then we copy the hex code and broadcast the transaction with `bitcoin-cli -regtest sendrawtransaction 02000000000101fb5782f61d4bd251376c448ed9c76e994b85f789a71965d43200926a4da731900000000000fdffffff0200111024010000001600148e1c455d85059293b5738c90c7a6fe1adcd6079ac09ee60500000000160014d596daacec72c0e768e753286b79b1b17baa18190247304402201d1e720b1847bd4e020c1f82012917f99a16bddd4e4d053efad03192b510e67a02202ceb0f604c81630628aee1c44152647c836aa66f5e95e83756080810391bc7be012102f815159d7e6e2d1b2ec6c7c8c9d0863274999d4cfb28b6e6081ed448211fe54700000000`.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1679125362966/e23bdf29-2943-451a-b89f-7929fc726b20.png?auto=compress,format\&format=webp)

That gives us a transaction hash. Now we can generate a new block with `bitcoin-cli -regtest -generate 1` and this transaction will be included.

Then we can list our UTXOs with `bitcoin-cli -regtest listunspent` and see the new UTXOs listed at the top.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1679125494985/328c8442-3e95-4841-aa20-f560b42530c7.png?auto=compress,format\&format=webp)

That was a lot. Most of this functionality is handled by whatever wallet software you use. But now you know how transactions are created and sent.

This will come in handy in a future lesson when we need to take an existing transaction and check that it actually occurred. Don't worry though if this was all super complex, the wallet software we'll be using will handle all the heavy lifting of the transaction generation and sending, all we need to do is integrate it with a few lines of JS.


# Getting Started with Stacks

Up until now, we've lived mainly inside of Bitcoin itself, learning about the internals of how it works.

During that, we've also been exposed to some of the main drawbacks of attempting to build fully decentralized applications on Bitcoin.

First, it is difficult. The existing tooling for Bitcoin is not great for building apps like you would with Ethereum. It's confusing, clunky, and difficult to build robust apps, especially for someone used to making things on the web.

There isn't actually much programming. We have mainly worked directly with Bitcoin transactions in the command line.

If you paid attention to the last tutorial, you might be wondering how we would actually go about creating a real app with a web interface.

For example, we talked about how the main functionality of Bitfund is to operate as a decentralized crowdfunding mechanism. But how would we use Bitcoin script to maintain an escrow system or implement safeguards where backers could get their funds back if certain milestones were not met?

There are ways we could do these things, but they would involve trusting a custodian to handle the Bitcoin and do what is necessary with it, which is exactly what we are trying to avoid.

Or on the flip side, it would require backers to completely trust the person requesting the funding, another problem we want to avoid.

And how would the user interact with the web app like they would using something like Metamask for Ethereum?

What we would likely have to do is use that JS library to create something like a QR code with a pre-formatted transaction, we could then scan that with a mobile wallet and send a Bitcoin transaction.

That's a terrible UX for what should be as simple as interacting with a web app to make a basic payment transfer.

What if we wanted to create an app where someone could lend that Bitcoin out in a decentralized way? Or mint an NFT for some record of ownership? There's no way to do those things with Bitcoin transactions alone.

With a Stacks and Clarity based smart contract approach, all of the verification is happening in a Clarity smart contract on the Stacks chain, which works in lockstep with Bitcoin.

We don't need to completely trust someone else with our Bitcoin in order to actually use it.

Instead, we can leverage the power of Clarity to programmatically verify certain conditions that will allow the BTC to be either released to the project creator or sent back to the backers.

This process is what we'll be covering in the remainder of the course and will serve as the foundation for how we build decentralized financial tools and a decentralized economy on top of Bitcoin.

sBTC is the linchpin that makes all this possible and we'll be covering it in detail as we go through.

For now, let's get set up for Stacks development.


# Initial Setup

### Set Up Your Wallet

In order to continue, you'll need to have a web wallet in order to interact with the app we'll be creating.

Download and set up [Leather](https://leather.io/) or [Xverse](https://www.xverse.app/). This is how we'll be interacting with our dapp. If you've ever used Metamask, they are very similar.

We'll be using Leather throughout the course, but the process is similar for both.

After you get the wallet set up, you'll want to get some testnet STX and sBTC.

For both, you can use the faucet within the Hiro Platform.

### Hiro Platform

Hiro is a developer tool company building developer tools for Stacks and Bitcoin. One of their main tools is the [Hiro Platform](https://www.hiro.so/platform), a suite of tools to build complete apps on Bitcoin. We'll be using it extensively throughout the rest of the course.

The first thing you'll want to do is [sign up for an account](https://platform.hiro.so/) and get some testnet STX and sBTC via the faucet within the platform.

<figure><img src="https://1720374836-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FskGYu79qDNfITOqDNU3s%2Fuploads%2F6OggrwIqv4ejID8Z1ROd%2Fimage.png?alt=media&#x26;token=d7960b29-4203-4125-b18a-65dddf986efc" alt=""><figcaption></figcaption></figure>

After you have your wallet and testnet coins, you're ready to start building.

If you aren't familiar with how Stacks works, you'll want to take a few minutes to learn the basics over in the [Stacks 101](https://docs.stacks.co/tutorials/bitcoin-primer/getting-started-with-stacks/broken-reference) section of the docs.

That will walk you through the basics of how Stacks actually operates. Then you can come back here and get building.

### Your Dev Environment

Your developer environment is largely a personal choice, but you'll need some basics to proceed with the rest of this course.

### Code Editor

You'll need a code editor, ideally VS Code or a fork of it. We'll be using [Cursor](https://cursor.com) throughout this tutorial and we'll be heavily embracing and using AI-assisted coding throughout.

Hiro has also created a Clarity VS Code extension which makes it much easier to work with Clarity code in our projects.

### Terminal

You'll also want a terminal of some kind. You can use the built-in terminal provided by Cursor or you can download a standalone termainl such as [Warp](https://warp.dev).

### Node

We'll be making heavy use of Node, npm, and JavaScript in this course, so make sure you have Node and NPM installed on your machine.

As of this writing I am using Node version 22.14.0 and NPM version 10.9.2.

### Video Walkthrough

Here's a brief video walking you through setting up a new wallet and getting some initial test STX and sBTC from the Hiro Platform faucet.

{% embed url="<https://www.loom.com/share/59d6f92fc8f9409a87dc0b3f2ae94a57>" %}


# Creating Our Project

In order to create Crowdforge, we're going to take advantage of the Hiro Platform project templates. These are starter templates with a full-stack setup with best practices already implemented.

By using these templates, we'll be able to learn best practices from them and get started on the right foot.

For the rest of this course, we'll be working from this template, first getting a walkthrough of the template structure itself, getting introduced to the Stacks dev tooling ecosystem along the way.

Then we'll add a new feature, following the same practices as the template uses so we can see how to work with it ourselves.

For a walkthrough of the templates themselves and the ideas/goals behind their design, be sure to check out the [Hiro Dev n' Tell with Leah](https://www.youtube.com/watch?v=S3fRUUgFxsA), one of the software engineers in charge of building them.

{% embed url="<https://www.loom.com/share/3641fb42332f49b8b50c57ff47ed41ab>" %}


# The Stacks Stack

In order to be an effective Stacks developer, you need to be familiar with the Stacks stack, or the different components you'll be using to build out a full-stack Stacks application and the different developer tools available to you.

We'll be using each of these as we add our feature to Crowdforge, but let's go through an overview of each of the primary pieces.

### Clarity

Clarity is the smart contract language that we use to write smart contracts on Stacks. We'll cover the basics when we look at and add to our fundraising contract, and we have an entire [section of the documentation](https://docs.stacks.co/tutorials/bitcoin-primer/getting-started-with-stacks/broken-reference) and a [whole book](https://book.clarity-lang.org) dedicated to learning Clarity.

### Platform

The Hiro Platform is what we've been using so far to get our application set up. This is likely going to be one of the main tools you use to handle a lot of your DevOps related tasks as you go through building out Stacks applications.

### Clarinet

[Clarinet](https://www.hiro.so/clarinet) is a tool for local smart contract development, although the Platform utilizes it to some extent under the hood. Clarinet is used to set up some of our configurations for our smart contracts and used to do things like execute tests on our smart contract and set up our deployment workflows.

### Stacks.js

[Stacks.js](https://www.hiro.so/stacks-js) is the JavaScript library you can use to hook your frontend up to both your contracts and the Stacks chain itself.

### Stacks API

The [Stacks API](https://www.hiro.so/stacks-api) is how you can bring chain data into your application and to broadcast new transaction data. You can call the API directly, but many of its functions are built-in as utility functions in Stacks.js.

### Explorer

Finally, the [Explorer](https://explorer.hiro.so/) is how we can view transaction data in our browser. The explorer can also be used to quickly experiment with a deploy contracts to testnet.

There are some other tools like Chainhook that are useful to be familiar with as well, but we won't be using them in this course. Readers are encouraged to check out Hiro's website and documentation to familiarize themselves with these additional tools.


# Anatomy of a Full-Stack Stacks App

Let's take a look at the code that we just pulled down from the Hiro Platform template we set up for Crowdforge.

One of the best, and underrated, ways to learn code and learn a new technology is to read well-written code. That's one of the reasons why the platform templates are so great. They are an excellent starting point for you as a developer to work from so you can build your project on a solid foundation.

Let's go through and dig into the architecture of this app so we can see how it's put together and familiarize ourselves with how Stacks apps are architected.

{% embed url="<https://www.youtube.com/watch?index=1&list=PLap8Z_BpFFPrsux49eOzCHS75RnaaOPCb&pp=iAQB&v=Vw8YaIdC_cE>" %}


# Stacks Development Fundamentals

Now that we have a good overview of what all goes into creating a Stacks app, let's dive into the process for actually building on Stacks.

We'll start by going over what our local development workflow should look like and what tools we need to be familiar with.

Then we'll go through each component of a Stacks app by adding a new end to end feature to our crowdfunding platform.


# Local Stacks Dev Workflow

There are a few tools you'll want to be familiar with when you start working on your Stacks projects locally.

The big one is [Clarinet](https://docs.stacks.co/build/learn-clarinet/overview).&#x20;

Clarinet is going to be your go-to tool for building Stacks projects.

It's how you'll configure your local devnet environment, orchestrate your contracts and deployments, write and test your contracts locally, and write your test suite.

{% embed url="<https://www.youtube.com/watch?index=2&list=PLap8Z_BpFFPrsux49eOzCHS75RnaaOPCb&pp=iAQB0gcJCRUKAYcqIYzv&v=Mw_ICh4-5jY>" %}


# Working with Clarity

Now it's time to start working a bit more with Clarity by adding a new feature to our project. We're going to take a look at Clarity, testing, and working with our frontend by adding a new feature where we can attach a message to our campaign donations.

The written version of the tutorial is below, with a video coming soon.

If you haven't yet, going through the [Clarity Crash Course](https://docs.stacks.co/get-started/clarity-crash-course) is highly recommended. It will give you a high-level introduction to the basics of Clarity.

Here's we'll assume basic familiarity with Clarity. You should be able to follow along with what we're doing either way, but it will make more sense if you've already familiarized yourself with the basics of Clarity.

In addition, you'll notice that we are utilizing sBTC here. If you aren't familiar with sBTC yet, go ahead and take a look at the [Learn sBTC](https://docs.stacks.co/learn/sbtc) section of the docs to get a handle on what it is and how it works.

You can also refer to the [sBTC Integration](https://docs.stacks.co/clarinet-integrations/sbtc-integration) guide to see how to integrate sBTC into your projects for more background. This setup is taken care of for you in this particular Platform template.

{% stepper %}
{% step %}

### Add the message storage map

First, we need a place to store donation messages. Add a new map in `clarity/contracts/fundraising.clar`:

```clarity
;; donor -> message (max 280 characters)
(define-map donation-messages
  principal
  (string-utf8 280)
)
```

This maps each donor's principal to their message. We limit messages to 280 characters.
{% endstep %}

{% step %}

### Modify the donate-stx function

Update the function signature to accept an optional message:

```clarity
;; Donate STX. Pass amount in microstacks. Optionally include a message.
(define-public (donate-stx (amount uint) (message (optional (string-utf8 280))))
  (begin
    (asserts! (var-get is-campaign-initialized) err-not-initialized)
    (asserts! (not (var-get is-campaign-cancelled)) err-campaign-cancelled)
    (asserts!
      (< burn-block-height
        (+ (var-get campaign-start) (var-get campaign-duration))
      )
      err-campaign-ended
    )
    (try! (stx-transfer? amount tx-sender (as-contract tx-sender)))
    (map-set stx-donations tx-sender
      (+ (default-to u0 (map-get? stx-donations tx-sender)) amount)
    )
    ;; Handle the optional message
    (match message
      msg (map-set donation-messages tx-sender msg)
      true
    )
    (var-set total-stx (+ (var-get total-stx) amount))
    (var-set donation-count (+ (var-get donation-count) u1))
    (ok true)
  )
)
```

The change we made here is adding this `match` function. We've also added a new optional argument to the function signature. This means that we can either pass a `string-utf8` or we can pass `none`.

Then our `match` function determines what should happen based on whether we have an actual message or `none` passed in.

You can take a look at the [function](https://docs.stacks.co/reference/clarity/functions) and [keyword](https://docs.stacks.co/reference/clarity/keywords) reference pages for Clarity to understand more about how these work.

**Understanding the `match` Expression**

The `match` expression is how Clarity handles optional values:

```clarity
(match message
  msg (map-set donation-messages tx-sender msg)  ;; If some: bind to `msg`, execute this
  true                                            ;; If none: return true, continue
)
```

{% endstep %}

{% step %}

### Modify the donate-sbtc function

Apply the same changes to sBTC donations:

```clarity
;; Donate sBTC. Pass amount in Satoshis. Optionally include a message.
(define-public (donate-sbtc (amount uint) (message (optional (string-utf8 280))))
  (begin
    (asserts! (var-get is-campaign-initialized) err-not-initialized)
    (asserts! (not (var-get is-campaign-cancelled)) err-campaign-cancelled)
    (asserts!
      (< burn-block-height
        (+ (var-get campaign-start) (var-get campaign-duration))
      )
      err-campaign-ended
    )
    (try! (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token
      transfer amount contract-caller (as-contract tx-sender) none
    ))
    (map-set sbtc-donations tx-sender
      (+ (default-to u0 (map-get? sbtc-donations tx-sender)) amount)
    )
    (match message
      msg (map-set donation-messages tx-sender msg)
      true
    )
    (var-set total-sbtc (+ (var-get total-sbtc) amount))
    (var-set donation-count (+ (var-get donation-count) u1))
    (ok true)
  )
)
```

{% endstep %}

{% step %}

### Add a getter function

Add a read-only function to retrieve donation messages:

```clarity
(define-read-only (get-donation-message (donor principal))
  (ok (map-get? donation-messages donor))
)
```

This returns `(ok (some "message"))` if a message exists, or `(ok none)` if not.
{% endstep %}
{% endstepper %}


# Testing Clarity Contracts

Now we need to modify our tests to make sure we handled this new message functionality.

There are two sections of the docs to check to understand how to write Clarity unit tests.

The first is the series of [Clarinet JS SDK guides](https://docs.stacks.co/clarinet-js-sdk/overview) in the Build section. These will show you how to work with the SDK to write your tests.

The second is the [Clarinet JS SDK reference](https://docs.stacks.co/reference/clarinet-js-sdk/sdk-reference) section. This will show you all of the available functions you can use to write your tests.

Let's make a few modifications to our test file.

{% stepper %}
{% step %}

### Test donate with a message

Add a new test to the `fundraising.test.ts` file.

```typescript
it("accepts STX donation with a message", () => {
  initCampaign(100000);
  const message = "Great project! Happy to support.";
  const response = simnet.callPublicFn(
    "fundraising",
    "donate-stx",
    [Cl.uint(5000), Cl.some(Cl.stringUtf8(message))],
    donor1,
  );
  expect(response.result).toBeOk(Cl.bool(true));

  // verify donation was recorded
  const getDonationResponse = simnet.callReadOnlyFn(
    "fundraising",
    "get-stx-donation",
    [Cl.principal(donor1)],
    donor1,
  );
  expect(getDonationResponse.result).toBeOk(Cl.uint(5000));

  // verify message was recorded
  const getMessageResponse = simnet.callReadOnlyFn(
    "fundraising",
    "get-donation-message",
    [Cl.principal(donor1)],
    donor1,
  );
  expect(getMessageResponse.result).toBeOk(Cl.some(Cl.stringUtf8(message)));
});
```

You can see here that we are using `Cl.some(Cl.stringUtf8(message))` to pass an optional with a value, then using `Cl.some(...)` to get the actual message wrapped in the optional when we retrieve it.    &#x20;
{% endstep %}

{% step %}

### Update message on subsequent donations

We also want to make sure the message gets updated when we make a new donation.

```typescript
it("allows updating message with subsequent donation", () => {
  initCampaign(100000);

  // first donation with message
  simnet.callPublicFn(
    "fundraising",
    "donate-stx",
    [Cl.uint(5000), Cl.some(Cl.stringUtf8("First message"))],
    donor1,
  );

  // second donation with new message
  simnet.callPublicFn(
    "fundraising",
    "donate-stx",
    [Cl.uint(3000), Cl.some(Cl.stringUtf8("Updated message"))],
    donor1,
  );

  // verify total donation amount
  const getDonationResponse = simnet.callReadOnlyFn(
    "fundraising",
    "get-stx-donation",
    [Cl.principal(donor1)],
    donor1,
  );
  expect(getDonationResponse.result).toBeOk(Cl.uint(8000));

  // verify message was updated
  const getMessageResponse = simnet.callReadOnlyFn(
    "fundraising",
    "get-donation-message",
    [Cl.principal(donor1)],
    donor1,
  );
  expect(getMessageResponse.result).toBeOk(
    Cl.some(Cl.stringUtf8("Updated message")),
  );
});
```

{% endstep %}

{% step %}

### Test that it returns none with no message

Then we also need to make sure that if a donor did not pass a message the getter returns `none`.

```typescript
it("returns none for donor with no message", () => {
  initCampaign(100000);

  // donate without message
  simnet.callPublicFn(
    "fundraising",
    "donate-stx",
    [Cl.uint(5000), Cl.none()],
    donor1,
  );

  const getMessageResponse = simnet.callReadOnlyFn(
    "fundraising",
    "get-donation-message",
    [Cl.principal(donor1)],
    donor1,
  );
  expect(getMessageResponse.result).toBeOk(Cl.none());
});
```

You can see here that we use the `Cl.none()` Clarity value helper to denote the `none` value.
{% endstep %}

{% step %}

### Update existing tests

Finally, we need to update all of our existing tests to pass in `Cl.none()` when there is no message being passed.

Optionals in Clarity still require a value of some kind to be passed in to the function, it's just that value can either be the value type or `none`.

```typescript
// Before
simnet.callPublicFn("fundraising", "donate-stx", [Cl.uint(5000)], donor1);

// After
simnet.callPublicFn("fundraising", "donate-stx", [Cl.uint(5000), Cl.none()], donor1);
```

{% endstep %}

{% step %}

### Run the tests

Finally we can run our tests to make sure they pass.

```bash
cd clarity
npm test
```

{% endstep %}
{% endstepper %}


# Frontend with Stacks.js

Now we need to make some frontend changes to our app to handle the UI to add this new message.

To better understand how to work with Stacks.js and build frontends for your Stacks app, you'll want to be familiar with stacks.js as a whoel using the [Stacks.js Build Guides](https://docs.stacks.co/learn-stacks.js/overview).

You'll also likely use the @stacks/connect package the most, which has its own dedicated [build guides](https://docs.stacks.co/stacks-connect/connect-wallet).

You can find the full reference implementation for [@stacks/connect](https://docs.stacks.co/reference/stacks.js/stacks-connect) and [@stacks/transactions](https://docs.stacks.co/reference/stacks.js/stacks-transactions) in the reference section of the docs.

These are the two packages you'll likely work with the most.

{% stepper %}
{% step %}

### Update the ContributeParams interface

The first thing we need to do is update our TypeScript interface to handle the new message parameter. This can be found in the `campaign-utils.ts` file.

```typescript
interface ContributeParams {
  address: string;
  amount: number;
  message?: string;
}
```

{% endstep %}

{% step %}

### Add new imports

We also need to add a few new imports from the `@stacks/transactions` package to work with our new Clarity values.

```typescript
import {
  AnchorMode,
  FungiblePostCondition,
  noneCV,
  Pc,
  PostConditionMode,
  someCV,
  stringUtf8CV,
  uintCV,
} from "@stacks/transactions";
```

{% endstep %}

{% step %}

### Update getContributeStx

Next we need to update the utility function that actually handles creating our donation transaction. All we are doing here is adding the new optional `message` parameter and setting the value based on if it is present or not.

```typescript
export const getContributeStxTx = (
  network: Network,
  params: ContributeParams
): ContractCallRegularOptions => {
  const { address, amount, message } = params;

  return {
    anchorMode: AnchorMode.Any,
    postConditionMode: PostConditionMode.Deny,
    contractAddress: FUNDRAISING_CONTRACT.address || "",
    contractName: FUNDRAISING_CONTRACT.name,
    network,
    functionName: "donate-stx",
    functionArgs: [
      uintCV(amount),
      message ? someCV(stringUtf8CV(message)) : noneCV(),
    ],
    postConditions: [Pc.principal(address).willSendEq(amount).ustx()],
  };
};
```

{% endstep %}

{% step %}

### Update getContributeSbtcTx

Next we'll do the same thing for the function that creates our sBTC donation transaction.

```typescript
export const getContributeSbtcTx = (
  network: Network,
  params: ContributeParams
): ContractCallRegularOptions => {
  const { address, amount, message } = params;

  // ... postCondition setup ...

  return {
    // ...
    functionName: "donate-sbtc",
    functionArgs: [
      uintCV(amount),
      message ? someCV(stringUtf8CV(message)) : noneCV(),
    ],
    postConditions: [postCondition],
  };
};
```

{% endstep %}

{% step %}

### Update the donation modal

Now we need to update the actual UI that handles the donation. This can be found in the `DonationModal.tsx` file.

We need to do a few different things here.

Add state for the message.

```typescript
const [donationMessage, setDonationMessage] = useState("");
```

Add a textarea to the form:

```tsx
<Text fontSize="lg" fontWeight="bold">
  Add a Message (Optional)
</Text>

<Textarea
  placeholder="Share why you're supporting this campaign..."
  value={donationMessage}
  onChange={(e) => setDonationMessage(e.target.value.slice(0, 280))}
  maxLength={280}
  resize="none"
  rows={3}
/>
<Text fontSize="xs" color="gray.500" textAlign="right">
  {donationMessage.length}/280 characters
</Text>
```

Pass the message when building transaction options:

```typescript
const txOptions = getContributeStxTx(getStacksNetworkString(), {
  address: currentWalletAddress || "",
  amount: Math.round(Number(stxToUstx(usdToStx(amount, prices?.stx || 0)))),
  message: donationMessage || undefined,
});
```

Reset the message after successful donation:

```typescript
setDonationMessage("");
```

{% endstep %}
{% endstepper %}


# Deploying Stacks Apps

Finally, we need to deploy our new fundraising dapp.

We won't cover deploying the frontend in this guide, as that is up to the user. Vercel is a solid option for Next apps.

Just make sure you have appropriately handled your environment variables. You'll want to make sure that you set up your environment variables in your Vercel deployments so they use the appropriate network.

You can create multiple environments in Vercel and set these to correspond to different branches of your repo, so you can have a dev branch the connects to testnet and a production branch that connects to mainnet.

### Deploying your contracts

Because we are using a Platform template, deployment plans are handled for us. For a detailed guide on using Clarinet for deployment, check out the [Contract Deployment guide](https://docs.stacks.co/learn-clarinet/contract-deployment) in the docs.

For us, we already have a testnet deployment plan in `default.testnet-plan.yaml` that we can use.

One thing we do need to do is set up our credentials for the testnet account we want to use to deploy. You can see a sample of this file at the above guide, but it looks like this.

This file should live at `settings/Testnet.toml`.

```toml
[network]
name = "testnet"
deployment_fee_rate = 10

[accounts.deployer]
mnemonic = "<YOUR TESTNET MNEMONIC>"
balance = 100_000_000_000_000
derivation = "m/44'/5757'/0'/0/0"
```

Add your mnemonic for the testnet account you want to deploy from. Then run the following command in your `clarity` folder. Make sure your wallet has some STX in it. You can use the faucet in the Hiro Platform if it does not.

```bash
clarinet deployments apply --testnet
```

Clarinet will ask if you want to use the newly generated deployment plan. In this case we want to say yes because our expected sender is going to be different.

After you confirm you can see your contracts being deployed to testnet and can watch as they are confirmed.

You can see my fundraising contract [here](https://explorer.hiro.so/txid/STCDSEQ1MQV2S6K09CPG9VZYQA40EKNKJ835RZRK.fundraising?chain=testnet).


# Bitcoin Theses

This list will be updated monthly and capture notable investor theses or industry commentary on Stacks and the Bitcoin ecosystem.

| Title                                                                                                                                                                                              | Outlet / Author       |          Date |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------- | ------------: |
| [TradFi Tomorrow: DeFi and the Rise of Extensible Finance](https://www.paradigm.xyz/2025/03/tradfi-tomorrow-defi-and-the-rise-of-extensible-finance)                                               | Paradigm              |    March 2025 |
| 💭 [It's time to make your It’s time to make your BTC productive again](https://medium.com/@aspendigitalAMP/its-time-to-make-your-btc-productive-again-7532ea788a32)                               | Aspen Digital         |    March 2025 |
| 💭 [The Bitcoin Renaissance: Unlocking Trillions in Value](https://www.forbes.com/sites/leeorshimron/2024/08/13/the-bitcoin-renaissance-unlocking-trillions-in-value/)                             | Leeor Shimron, Forbes |   August 2024 |
| 💭 [My journey with the Blockchain Ecosystem and why do I like Stacks?](https://www.linkedin.com/pulse/my-journey-blockchain-ecosystem-why-do-i-like-stacks-ali-farid-khwaja-wkybf?ref=stacksblog) | Ali Farid Khwaja      |     July 2024 |
| 🖋️ [Bitcoin and Future Infracon Highlights](https://arkstreamcapital.medium.com/arkstream-capital-bitcoin-and-future-infracon-highlights-b9b3ac4777cd)                                            | Arkstream Capital     |     June 2024 |
| 📊 [The Build on Bitcoin Era is Here](https://mythofmoney.substack.com/p/build-on-bitcoin-era-is-here)                                                                                             | Myth of Money         | February 2024 |
| 📊 [2024 Bitcoin Halving: This Time It's Different](https://www.grayscale.com/research/reports/2024-halving-this-time-its-actually-different)                                                      | Grayscale             | February 2024 |
| 🌱 [The Year Ahead](https://panteracapital.com/blockchain-letter/the-year-ahead-2024/)                                                                                                             | Pantera               |  January 2024 |
| 🌱 [State of Bitcoin Q4 2023](https://messari.io/report/state-of-bitcoin-q4-2023)                                                                                                                  | Messari               |  January 2024 |
| 🖋️ [Notable Moments for Bitcoin in 2024](https://trustmachines.co/blog/notable-moments-for-bitcoin-in-2024/?ref=stacksblog)                                                                       | Trust Machines        |  January 2024 |
| 📙 [Bitcoin Layers: Tapestry of a Trustless Financial Era](https://bitcoinlayersreport.com/)                                                                                                       | Spartan Group         | December 2023 |
| 🧪 [A Technical History of Blockchain Design, Innovation, and Narratives](https://foundationcapital.com/a-technical-history-of-blockchain-design-innovation-and-narratives-part-i/)                | Foundation Capital    | December 2023 |
| 📊 [2024 Crypto Market Outlook](https://www.coinbase.com/nl/institutional/research-insights/research/market-intelligence/2024-crypto-market-outlook)                                               | Coinbase              | December 2023 |
| 👀 [STX Thesis Update](https://medium.com/@halp1120/stx-thesis-update-cd09b7f2cce8)                                                                                                                | Hal Press             | December 2023 |


# Bitcoin Reports

This list will be updated monthly and capture notable investor theses or industry commentary on Stacks and the Bitcoin ecosystem.

| Title                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Outlet / Author              | Date           |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------- | -------------- |
| 🧪 [Unlocking Bitcoin \[Presentation\]: The Bitcoin Tipping Point](https://syphercapital.substack.com/p/unlocking-bitcoin-presentation-the)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Sypher Capital               | March 2025     |
| 📊 [State of Crypto: 2025 Market Outlet](https://www.globalxetfs.com.au/state-of-crypto-2025-market-outlook/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Global X                     | February 2025  |
| 🟧 [Stacks Q4 2024 Brief](https://messari.io/report/stacks-q4-2024-brief)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Messari                      | February 2025  |
| 📈 [Top 'Made in USA' Coins by MarketCap](https://x.com/Stacks/status/1881640502149390473?utm_source=stackssnacks.com\&utm_medium=newsletter\&utm_campaign=stacks-thrives-amid-regulatory-changes-stacking-dao-unveils-sbtc-product&_bhlid=42f17e5c11b1222a7ddd2cf3de42eb1c121496bc)                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | CoinGecko                    | January 2025   |
| 📙 [GTM in Asia Report: The Driving Force Behind Crypto Market Growth](https://www.theblock.co/post/333733/foresight-ventures-and-primitive-ventures-unveil-game-changing-apac-crypto-go-to-market-insights)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Primitive Ventures           | January 2025   |
| 📈 [Top 10 Digital Assets Market Predictions](https://x.com/AspenDigitalAMP/status/1877289981166731741)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Aspen Digital                | January 2025   |
| 📙 [State of Tokenized BTC: A $1 Trillion Opportunity](https://app.gitbook.com/s/H74xqoobupBWwBsVMJhK/sbtc/sbtc-operations/deposit)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Bitcoin Builders Association | December 2024  |
| 🟧 [Our Thesis on Stacks](https://candidcontemplation.substack.com/p/our-thesis-on-stx)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Portal Ventures              | December 2024  |
| 📊 [Scaling Bitcoin](https://www.gsr.io/reports/scaling-bitcoin/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | GSR                          | November 2024  |
| 📊 [Bitcoin L2s: A Modular Future](https://www.galaxy.com/insights/research/bitcoin-layer-2-modular-future/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Galaxy Digital               | November 2024  |
| 📊 [Crypto Sectors in Q4 2024](https://www.grayscale.com/research/market-commentary/grayscale-research-insights-crypto-sectors-in-q4-2024)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Grayscale                    | September 2024 |
| 📈 [Stacks August 2024 Snapshot](https://x.com/signal21btc/status/1833117479024963728)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Signal21                     | August 2024    |
| 🟧 [Building Block: Stacks](https://www.grayscale.com/research/reports/building-block-stacks?ref=stacksblog)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Grayscale                    | August 2024    |
| 📙 [Bitcoin Layer 2 Ecosystems](https://unhashed.aarna.ai/p/bitcoin-layer2-ecosystems?ref=stacksblog)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Alpha Unhashed               | June 2024      |
| 📙 [Stacks Snapshot June 2024](https://app.signal21.io/reports/stacks-snapshot-june-2024)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Signal21                     | June 2024      |
| 🧪 [The Future of Bitcoin #3: Scaling Bitcoin](https://www.binance.com/en/research/analysis/the-future-of-bitcoin-3-scaling-bitcoin?ref=stacksblog)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Binance Research             | May 2024       |
| 🟧 [Q4 2023: No Denying Demand For Bitcoin L2s](https://newsletters.stacks.org/p/q4-2023)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Stacks Foundation            | January 2024   |
| 📊 [Stacks established developers up 51%](https://flight.beehiiv.net/v2/clicks/eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1cmwiOiJodHRwczovL3R3aXR0ZXIuY29tL0tlblRoZVJvZ2Vycy9zdGF0dXMvMTc0ODA2MDU5OTcwMjE5MjYyNj9zPTIwJnJlZj1zdGFja3NibG9nJnV0bV9zb3VyY2U9c3RhY2tzc25hY2tzLmNvbSZ1dG1fbWVkaXVtPXJlZmVycmFsJnV0bV9jYW1wYWlnbj1kaXNjb3Zlci1zdGFja3MtaW4tc3BhcnRhbi1ncm91cC1iaXRjb2luLWwyLXJlcG9ydC1lbGVjdHJpYy1jYXBpdGFsLWRldmVsb3Blci1yZXBvcnQiLCJwb3N0X2lkIjoiZTdmYWFkODEtZmI3Ni00MjBmLTk3YWItNGJjMjdmM2RiYjdiIiwicHVibGljYXRpb25faWQiOiIzY2ZhYmZjYy0xNDU5LTQ0NTAtODI3MC1iOGJmM2RkMmFiOTciLCJ2aXNpdF90b2tlbiI6ImQxNDQwNWJiLWMxOWEtNDJiYi05NGQxLTY4MmRiNzZkOWQ3ZSIsImlhdCI6MTcwODA5NzQyMSwiaXNzIjoib3JjaGlkIn0.t0UBYmIXoMyGWCemN_n36kslOn35rIcv2v7LQR3nMLs) | Electric Capital             | January 2024   |
| 📙 [Binance Research: Top 10 Narratives to Follow in 2024](https://public.bnbstatic.com/static/files/research/top-10-narratives.pdf)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Binance Research             | December 2023  |
| 📙 [Bitcoin Layers Report: Tapestry of a Trustless Financial Era](https://bitcoinlayersreport.com/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Spartan Group                | December 2023  |


# 2024

This page indexes top stories, press, and reports related to Stacks on a monthly basis.

For weekly stories delivered to your inbox, subscribe to [Stacks Snacks](https://stackssnacks.com/). For quarterly ecosystem recaps, subscribe to the [Stacks Foundation newsletter](https://newsletters.stacks.org/).

{% content-ref url="broken-reference" %}
[Broken link](https://docs.stacks.co/press-and-reports/press-and-top-links/broken-reference)
{% endcontent-ref %}

{% content-ref url="broken-reference" %}
[Broken link](https://docs.stacks.co/press-and-reports/press-and-top-links/broken-reference)
{% endcontent-ref %}

{% content-ref url="broken-reference" %}
[Broken link](https://docs.stacks.co/press-and-reports/press-and-top-links/broken-reference)
{% endcontent-ref %}

{% content-ref url="broken-reference" %}
[Broken link](https://docs.stacks.co/press-and-reports/press-and-top-links/broken-reference)
{% endcontent-ref %}

{% content-ref url="broken-reference" %}
[Broken link](https://docs.stacks.co/press-and-reports/press-and-top-links/broken-reference)
{% endcontent-ref %}

{% content-ref url="broken-reference" %}
[Broken link](https://docs.stacks.co/press-and-reports/press-and-top-links/broken-reference)
{% endcontent-ref %}

{% content-ref url="broken-reference" %}
[Broken link](https://docs.stacks.co/press-and-reports/press-and-top-links/broken-reference)
{% endcontent-ref %}

{% content-ref url="broken-reference" %}
[Broken link](https://docs.stacks.co/press-and-reports/press-and-top-links/broken-reference)
{% endcontent-ref %}

{% content-ref url="broken-reference" %}
[Broken link](https://docs.stacks.co/press-and-reports/press-and-top-links/broken-reference)
{% endcontent-ref %}

{% content-ref url="broken-reference" %}
[Broken link](https://docs.stacks.co/press-and-reports/press-and-top-links/broken-reference)
{% endcontent-ref %}

{% content-ref url="broken-reference" %}
[Broken link](https://docs.stacks.co/press-and-reports/press-and-top-links/broken-reference)
{% endcontent-ref %}

{% content-ref url="broken-reference" %}
[Broken link](https://docs.stacks.co/press-and-reports/press-and-top-links/broken-reference)
{% endcontent-ref %}


# January 2024

For weekly stories delivered to your inbox, subscribe to [Stacks Snacks](https://stackssnacks.com/). For quarterly ecosystem recaps, subscribe to the [Stacks Foundation newsletter](https://newsletters.stacks.org/).

<details>

<summary><strong>📙 Bitcoin Layers Report by Spartan Group</strong></summary>

**Tapestry of a Trustless Financial Era**

Diving deep into the layers of Bitcoin's blossoming ecosystem, the first edition of the Bitcoin Layers Report unveils the emerging reality of a financial world where trust is embedded in technology rather than institutions. As Bitcoin evolves beyond a Store of Value, we stand on the cusp of a revolution in trustless finance and a new era of economic possibilities. <https://bitcoinlayersreport.com/>

</details>

<table><thead><tr><th width="507">Title</th><th>Outlet/Author</th></tr></thead><tbody><tr><td>🌱 <a href="https://panteracapital.com/blockchain-letter/the-year-ahead-2024/">The Year Ahead | Pantera Blockchain Letter</a></td><td>Pantera</td></tr><tr><td>🟧 <a href="https://newsletters.stacks.org/p/q4-2023">Q4 2023: No Denying Demand For Bitcoin L2s</a></td><td>Stacks Foundation</td></tr><tr><td>📙 <a href="https://public.bnbstatic.com/static/files/research/top-10-narratives.pdf">Binance Research: Top 10 Narratives to Follow in 2024</a></td><td>Binance Research</td></tr><tr><td>📕 <a href="https://www.bankless.com/the-bankless-guide-to-stacks">The Bankless Guide to Stacks</a></td><td>Bankless</td></tr><tr><td>📊 Electric Capital Report: <a href="https://flight.beehiiv.net/v2/clicks/eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1cmwiOiJodHRwczovL3R3aXR0ZXIuY29tL0tlblRoZVJvZ2Vycy9zdGF0dXMvMTc0ODA2MDU5OTcwMjE5MjYyNj9zPTIwJnJlZj1zdGFja3NibG9nJnV0bV9zb3VyY2U9c3RhY2tzc25hY2tzLmNvbSZ1dG1fbWVkaXVtPXJlZmVycmFsJnV0bV9jYW1wYWlnbj1kaXNjb3Zlci1zdGFja3MtaW4tc3BhcnRhbi1ncm91cC1iaXRjb2luLWwyLXJlcG9ydC1lbGVjdHJpYy1jYXBpdGFsLWRldmVsb3Blci1yZXBvcnQiLCJwb3N0X2lkIjoiZTdmYWFkODEtZmI3Ni00MjBmLTk3YWItNGJjMjdmM2RiYjdiIiwicHVibGljYXRpb25faWQiOiIzY2ZhYmZjYy0xNDU5LTQ0NTAtODI3MC1iOGJmM2RkMmFiOTciLCJ2aXNpdF90b2tlbiI6ImQxNDQwNWJiLWMxOWEtNDJiYi05NGQxLTY4MmRiNzZkOWQ3ZSIsImlhdCI6MTcwODA5NzQyMSwiaXNzIjoib3JjaGlkIn0.t0UBYmIXoMyGWCemN_n36kslOn35rIcv2v7LQR3nMLs">Stacks established developers up 51%</a></td><td>Electric Capital</td></tr><tr><td>📰 <a href="https://www.coindesk.com/tech/2024/01/18/bitcoin-could-see-growth-in-layer-2-ecosystem-drawing-on-ethereums-experience/">Bitcoin Could See Growth in Layer-2 Ecosystem, Drawing on Ethereum's Experience</a></td><td>Coindesk, Yahoo Finance</td></tr><tr><td>🔮 <a href="https://www.coindesk.com/consensus-magazine/2023/12/20/6-predictions-for-crypto-in-2024-panteras-paul-veradittakit">Paul Veradittakit of Pantera Capital Lists Stacks In 6 Predictions Crypto 2024</a></td><td>Coindesk</td></tr><tr><td>🏛️ <a href="https://x.com/fti_us/status/1747708193378025475?s=46">Franklin Templeton: Ordinals &#x26; Layer 2 solutions on Bitcoin shouldn’t be ignored</a></td><td>Franklin Templeton</td></tr><tr><td>🔉 <a href="https://twitter.com/TheSpartanGroup/status/1747546980321304629">Podcast: Muneeb Ali joins us in The Blueprint</a></td><td>The Blueprint</td></tr><tr><td>🎨 <a href="https://x.com/jackbutcher/status/1745557822203470022?t=ps-Sn2Ohh0TWBR4ptywL-Q&#x26;s=33">Jack Butcher: Onboarding to Bitcoin</a></td><td>Jack Butcher</td></tr><tr><td>👀 <a href="https://4pillars.io/en/articles/2024-Bitcoin-Outlook-Ecosystem-Beyond-ETFs/public">2024 Bitcoin Outlook: Ecosystem Beyond ETFs</a></td><td>Four Pillars</td></tr><tr><td>Ⓜ️ <a href="https://x.com/cosmo_jiang/status/1752870233231212747?s=20">This Bitcoin ecosystem is having its moment</a></td><td>Cosmo Jiang, Pantera Capital</td></tr><tr><td>🧪 <a href="https://www.gate.io/learn/articles/stacks-nakamoto-is-about-to-be-upgraded-to-inject-new-impetus-into-the-bitcoin-ecosystem/1211">MT Capital Research Report: Stacks Nakamoto is about to be upgraded to inject new impetus into the Bitcoin ecosystem</a></td><td>MT Capital via Gate.io</td></tr><tr><td>📊 <a href="https://twitter.com/HouseofChimera/status/1745452755681218792">House of Chimera Analyzes Rapid Growth in Stacks Transactions</a></td><td>House of Chimera</td></tr><tr><td>👛 <a href="https://crypto.news/ryder-to-operate-fast-pool-become-signer-in-stacks-nakamoto-upgrade/">Ryder to operate FAST Pool, become signer in Stacks’ Nakamoto upgrade</a></td><td>Crypto.news</td></tr><tr><td>🔶 <a href="https://flight.beehiiv.net/v2/clicks/eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1cmwiOiJodHRwczovL3d3dy5va3guY29tL25sL2xlYXJuL3ZlbnR1cmVzLTIwMjQtYml0Y29pbi1vdXRsb29rP3V0bV9zb3VyY2U9c3RhY2tzc25hY2tzLmNvbSZ1dG1fbWVkaXVtPXJlZmVycmFsJnV0bV9jYW1wYWlnbj1iaXRjb2luLWwyLWRleC1yYWlzZXMtMS0zbS1pbi1wcmUtc2VlZC1mdW5kaW5nLXRoZS1sYXVuY2gtb2YtbjIxIiwicG9zdF9pZCI6IjU5MjAwM2Q5LTI0YjktNGMxOS1hNDc0LWYwNDRkYzlhMWUxNCIsInB1YmxpY2F0aW9uX2lkIjoiM2NmYWJmY2MtMTQ1OS00NDUwLTgyNzAtYjhiZjNkZDJhYjk3IiwidmlzaXRfdG9rZW4iOiJkMTQ0MDViYi1jMTlhLTQyYmItOTRkMS02ODJkYjc2ZDlkN2UiLCJpYXQiOjE3MDgwOTczNDAsImlzcyI6Im9yY2hpZCJ9.ZpuDlatRCYz537iRKwlGojFXDCZWCxl1NAGfCYZ_S7Y">Bitcoin 2024 Outlook</a> (featuring Stacks and ALEX)</td><td>OKX</td></tr><tr><td>💰 Bitcoin DEX Bitflow raises <a href="https://flight.beehiiv.net/v2/clicks/eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1cmwiOiJodHRwczovL3R3aXR0ZXIuY29tL0JpdGZsb3dfRmluYW5jZS9zdGF0dXMvMTc1MDQ5NDc0MDc0NTc5MzkxMD91dG1fc291cmNlPXN0YWNrc3NuYWNrcy5jb20mdXRtX21lZGl1bT1yZWZlcnJhbCZ1dG1fY2FtcGFpZ249Yml0Y29pbi1sMi1kZXgtcmFpc2VzLTEtM20taW4tcHJlLXNlZWQtZnVuZGluZy10aGUtbGF1bmNoLW9mLW4yMSIsInBvc3RfaWQiOiI1OTIwMDNkOS0yNGI5LTRjMTktYTQ3NC1mMDQ0ZGM5YTFlMTQiLCJwdWJsaWNhdGlvbl9pZCI6IjNjZmFiZmNjLTE0NTktNDQ1MC04MjcwLWI4YmYzZGQyYWI5NyIsInZpc2l0X3Rva2VuIjoiZDE0NDA1YmItYzE5YS00MmJiLTk0ZDEtNjgyZGI3NmQ5ZDdlIiwiaWF0IjoxNzA4MDk3MzQwLCJpc3MiOiJvcmNoaWQifQ.gAwmYWnQwFlQhmA3A__Mu0CGlhS7riNoZbzOefU-c2U">$1.3M in pre-seed funding</a></td><td>Bitflow</td></tr><tr><td>😈 DeFi Researcher Ignas: <a href="https://flight.beehiiv.net/v2/clicks/eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1cmwiOiJodHRwczovL3R3aXR0ZXIuY29tL2RlZmlpZ25hcy9zdGF0dXMvMTc0NDY5MDQyNzczNzgyMTQxMT9zPTQ2JnV0bV9zb3VyY2U9c3RhY2tzc25hY2tzLmNvbSZ1dG1fbWVkaXVtPXJlZmVycmFsJnV0bV9jYW1wYWlnbj1wb3RlbnRpYWwtc2NhbGluZy1zb2x1dGlvbi1mb3Itb3JkaW5hbHMtb24tbDItc3RhY2tzLWV0Zi1hcHByb3ZhbCIsInBvc3RfaWQiOiJkMmIzNjMxMi1jMTNhLTQyNDctODRiZS1mNzIzOTMxOTIyMzQiLCJwdWJsaWNhdGlvbl9pZCI6IjNjZmFiZmNjLTE0NTktNDQ1MC04MjcwLWI4YmYzZGQyYWI5NyIsInZpc2l0X3Rva2VuIjoiZDE0NDA1YmItYzE5YS00MmJiLTk0ZDEtNjgyZGI3NmQ5ZDdlIiwiaWF0IjoxNzA4MDk3NTM2LCJpc3MiOiJvcmNoaWQifQ.wYm07ZsU_dzCGsvPc2IuHoYLwRXFXQtRnQkJcIAr1KM">“Degen Playbook for Stacks”</a></td><td><a href="https://twitter.com/DefiIgnas">Ignas</a> via <a href="https://tldr.tech/crypto/2024-01-10">TLDR</a></td></tr><tr><td>📺 <a href="https://flight.beehiiv.net/v2/clicks/eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1cmwiOiJodHRwczovL3R3aXR0ZXIuY29tL2hlcm9nYW1lcjIxYnRjL3N0YXR1cy8xNzQyOTY0MDgzNjQzNTY0MTczP3V0bV9zb3VyY2U9c3RhY2tzc25hY2tzLmNvbSZ1dG1fbWVkaXVtPXJlZmVycmFsJnV0bV9jYW1wYWlnbj1zdGFja3MtYXBwcy1jZWxlYnJhdGUtYWxsLXRpbWUtdHZsLWhpZ2gtYXMtbmV3LWRlZmktcHJvdG9jb2xzLWVtZXJnZSIsInBvc3RfaWQiOiJmYTkyOTQ4YS0xNDU2LTRlOTktYjBmOS1hNWYyMTczY2I4YjQiLCJwdWJsaWNhdGlvbl9pZCI6IjNjZmFiZmNjLTE0NTktNDQ1MC04MjcwLWI4YmYzZGQyYWI5NyIsInZpc2l0X3Rva2VuIjoiZDE0NDA1YmItYzE5YS00MmJiLTk0ZDEtNjgyZGI3NmQ5ZDdlIiwiaWF0IjoxNzA4MDk3NjA3LCJpc3MiOiJvcmNoaWQifQ.hHQdRz61DrxCRXTRuv7vGEyvuh2gTFl2Mc4u2EG6ks4">Why DeFi on Stacks is the Next Bitcoin Bull</a></td><td>Block Runner</td></tr><tr><td>📊 <a href="https://flight.beehiiv.net/v2/clicks/eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1cmwiOiJodHRwczovL2RlZmlsbGFtYS5jb20vY2hhaW4vU3RhY2tzP3V0bV9zb3VyY2U9c3RhY2tzc25hY2tzLmNvbSZ1dG1fbWVkaXVtPXJlZmVycmFsJnV0bV9jYW1wYWlnbj1zdGFja3MtYXBwcy1jZWxlYnJhdGUtYWxsLXRpbWUtdHZsLWhpZ2gtYXMtbmV3LWRlZmktcHJvdG9jb2xzLWVtZXJnZSIsInBvc3RfaWQiOiJmYTkyOTQ4YS0xNDU2LTRlOTktYjBmOS1hNWYyMTczY2I4YjQiLCJwdWJsaWNhdGlvbl9pZCI6IjNjZmFiZmNjLTE0NTktNDQ1MC04MjcwLWI4YmYzZGQyYWI5NyIsInZpc2l0X3Rva2VuIjoiZDE0NDA1YmItYzE5YS00MmJiLTk0ZDEtNjgyZGI3NmQ5ZDdlIiwiaWF0IjoxNzA4MDk3NjA3LCJpc3MiOiJvcmNoaWQifQ.f6dic2OuZV_EPpARzcBBfeH11hoE8SL9xXyXAgXprac">All time high Total Value Locked (TVL) for Bitcoin L2 Stacks</a></td><td>DefiLlama</td></tr><tr><td>📊 <a href="https://twitter.com/StxOrds/status/1745882592430215626">sOrdinals: 100k Inscriptions in less than 24 hours</a></td><td>sOrdinals</td></tr><tr><td>📊 <a href="https://twitter.com/stx20stacks/status/1747684225074053606">STX20 Protocol Surpasses 1M Transactions in 1 Month</a></td><td>STX20</td></tr><tr><td>📊 <a href="https://twitter.com/StackingDao/status/1751684775797002269">StackingDAO celebrates $20M in TVL one month in</a></td><td>StackingDAO</td></tr><tr><td>📙 <a href="https://bitcoinlayersreport.com/">Bitcoin Layers Report: Tapestry of a Trustless Financial Era</a></td><td>Spartan Group</td></tr></tbody></table>


# February 2024

*For weekly stories delivered to your inbox, subscribe to* [Stacks Snacks](https://stackssnacks.com/). *For quarterly ecosystem recaps, subscribe to the* [Stacks Foundation newsletter](https://newsletters.stacks.org/).

<details>

<summary>📊 <a href="https://messari.io/report/state-of-stacks-q4-2023">Messari's Q4 2023 'State of Stacks' Report</a></summary>

<https://messari.io/report/state-of-stacks-q4-2023>

**Key Insights**

* **Stacks revenue (USD) increased 3,386% QoQ and 3,028% YoY to $637,000.** Much of this revenue was driven by inscription protocol STX20.
* **STX’s market cap increased 203% QoQ and 598% YoY to $2.0 billion.** STX’s growth outpaced BTC and the overall crypto market.
* **DeFi TVL (USD) increased 363% QoQ and 763% YoY to $61 million.** ALEX firmly remained the leader in TVL, but Arkadiko and StackingDAO considerably increased their own TVL dominance in Q3 and Q4.
* **Average daily miner revenue increased 1,015% YoY to $78,000.** STX’s price increase and Stacks’ increased revenue made it significantly more profitable for Bitcoin miners to participate in Stacks’ consensus.
* **The Nakamoto upgrade is expected in April 2024.** This update will enable faster blocks, give transactions 100% Bitcoin finality, reduce MEV, and eliminate forking on the Stacks layer to set the stage for the upcoming sBTC release.

</details>

| Title                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Outlet/Author             |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------- |
| 🌱 [The Year Ahead](https://panteracapital.com/blockchain-letter/the-year-ahead-2024/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Pantera Blockchain Letter |
| 📊 [Q1 2024 Bitcoin ecosystem map](https://flight.beehiiv.net/v2/clicks/eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1cmwiOiJodHRwczovL3R3aXR0ZXIuY29tL3NvcmFfdmVudHVyZXMvc3RhdHVzLzE3NTQ2ODc4ODg3NTgwODM5MjI_dXRtX3NvdXJjZT1zdGFja3NzbmFja3MuY29tJnV0bV9tZWRpdW09cmVmZXJyYWwmdXRtX2NhbXBhaWduPWFsZXgtZ292ZXJuYW5jZS1wcm9wb3NhbC1mb3IteGxuay1zdGFja2luZy1kYW8taGl0cy0zNW0taW4tdHZsIiwicG9zdF9pZCI6IjQ1NTY3YzAzLWFkZDUtNGQzNi1iZGM2LTk4Y2YwYzkyMDA5YyIsInB1YmxpY2F0aW9uX2lkIjoiM2NmYWJmY2MtMTQ1OS00NDUwLTgyNzAtYjhiZjNkZDJhYjk3IiwidmlzaXRfdG9rZW4iOiJkMTQ0MDViYi1jMTlhLTQyYmItOTRkMS02ODJkYjc2ZDlkN2UiLCJpYXQiOjE3MDgwOTcxMjksImlzcyI6Im9yY2hpZCJ9.Ga_H469MIGKuovy5WVHfd3Fit9x6IiqAr0qhNCW575E)                                                                                                                  | Sora Ventures             |
| 🪴 [Peak Total Value Locked (TVL) and Rising Developer Engagement on Stacks](https://twitter.com/HouseofChimera/status/1757792122692911207?ref=stacksblog)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | House of Chimera          |
| 📊 [40% of Bitcoin developers are working on Bitcoin L2s](https://twitter.com/MohamedFFouda/status/1752407779640295480?s=20\&utm_source=stackssnacks.com\&utm_medium=referral\&utm_campaign=nakamoto-release-launch-date-velar-raises-3-5m-in-funding-round)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Mohamed Fouda             |
| 📈 [Bitcoin is 25% below its record high -- but Layer 2 Stacks is even closer](https://blockworks.co/news/layer-2-stacks-approaching-bitcoin?ref=stacksblog)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Blockworks                |
| 👛 Stacks L2 DeFi protocol [Velar raises $3.5M](https://flight.beehiiv.net/v2/clicks/eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1cmwiOiJodHRwczovL3d3dy5jb2luZGVzay5jb20vYnVzaW5lc3MvMjAyNC8wMi8wMS9jcnlwdG8tc3RhcnR1cC12ZWxhci1wbGFucy1wZXJwZXR1YWwtc3dhcHMtZXhjaGFuZ2UtZm9yLWJpdGNvaW4tZGVmaS1hZnRlci1yYWlzaW5nLTMtNW0vPXR1dG1fc291cmNlPXN0YWNrc3NuYWNrcy5jb20mdXRtX21lZGl1bT1yZWZlcnJhbCZ1dG1fY2FtcGFpZ249bmFrYW1vdG8tcmVsZWFzZS1sYXVuY2gtZGF0ZS12ZWxhci1yYWlzZXMtMy01bS1pbi1mdW5kaW5nLXJvdW5kIiwicG9zdF9pZCI6ImYxODVmMmM4LTM0ZTQtNDM0My1hMWFkLTM4YmRlODAyYzY0OCIsInB1YmxpY2F0aW9uX2lkIjoiM2NmYWJmY2MtMTQ1OS00NDUwLTgyNzAtYjhiZjNkZDJhYjk3IiwidmlzaXRfdG9rZW4iOiJkMTQ0MDViYi1jMTlhLTQyYmItOTRkMS02ODJkYjc2ZDlkN2UiLCJpYXQiOjE3MDgwOTcyNDUsImlzcyI6Im9yY2hpZCJ9.FjGMmkbPat9qWNoUR5SJsfnwDWqfUQutXW-ScvveCjc) | Coindesk                  |
| 📊 Report: [Stacks could present a $90 Billion opportunity](https://flight.beehiiv.net/v2/clicks/eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1cmwiOiJodHRwczovL3R3aXR0ZXIuY29tL1RhbmdDaGFuMHgvc3RhdHVzLzE3NTM0MTcyNDMxMzUwMTMwMTA_dD05N19DMkItaTJqZi11OGgwZEpWV2NBJnM9MzMmdXRtX3NvdXJjZT1zdGFja3NzbmFja3MuY29tJnV0bV9tZWRpdW09cmVmZXJyYWwmdXRtX2NhbXBhaWduPW5ha2Ftb3RvLXJlbGVhc2UtbGF1bmNoLWRhdGUtdmVsYXItcmFpc2VzLTMtNW0taW4tZnVuZGluZy1yb3VuZCIsInBvc3RfaWQiOiJmMTg1ZjJjOC0zNGU0LTQzNDMtYTFhZC0zOGJkZTgwMmM2NDgiLCJwdWJsaWNhdGlvbl9pZCI6IjNjZmFiZmNjLTE0NTktNDQ1MC04MjcwLWI4YmYzZGQyYWI5NyIsInZpc2l0X3Rva2VuIjoiZDE0NDA1YmItYzE5YS00MmJiLTk0ZDEtNjgyZGI3NmQ5ZDdlIiwiaWF0IjoxNzA4MDk3MjQ1LCJpc3MiOiJvcmNoaWQifQ.dons_3VaS_GyWvr5OZs-StFlDP-PX2ToMqIVB9pGVCQ)                                                   | Tang Chan                 |
| 📊 [ABCDE 2024 BTC Recap](https://flight.beehiiv.net/v2/clicks/eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1cmwiOiJodHRwczovL3R3aXR0ZXIuY29tL0FCQ0RFTGFicy9zdGF0dXMvMTc0MDYyNzc3NTg2MDcyNzkxOT90PUo1ODlrWGtMNGlOblFJRXZyRW55TXcmcz0zMyZ1dG1fc291cmNlPXN0YWNrc3NuYWNrcy5jb20mdXRtX21lZGl1bT1yZWZlcnJhbCZ1dG1fY2FtcGFpZ249bmFrYW1vdG8tcmVsZWFzZS1sYXVuY2gtZGF0ZS12ZWxhci1yYWlzZXMtMy01bS1pbi1mdW5kaW5nLXJvdW5kIiwicG9zdF9pZCI6ImYxODVmMmM4LTM0ZTQtNDM0My1hMWFkLTM4YmRlODAyYzY0OCIsInB1YmxpY2F0aW9uX2lkIjoiM2NmYWJmY2MtMTQ1OS00NDUwLTgyNzAtYjhiZjNkZDJhYjk3IiwidmlzaXRfdG9rZW4iOiJkMTQ0MDViYi1jMTlhLTQyYmItOTRkMS02ODJkYjc2ZDlkN2UiLCJpYXQiOjE3MDgwOTcyNDUsImlzcyI6Im9yY2hpZCJ9.qhu0w9pHUMhY5ASnL74i7ixBbVw7LRrF3MJGJDbcoAs)                                                                                       | ABCDE Labs                |
| 👀 [2024 Halving: This Time It’s Actually Different](https://www.grayscale.com/research/reports/2024-halving-this-time-its-actually-different?ref=stacksblog)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Grayscale                 |
| 📈 [While everyone theorizes about when $BTC will make new highs, $STX...](https://x.com/cburniske/status/1757951005654978872?t=_cLI0sby6lmp9V1Yj6-6kQ\&s=33\&ref=stacksblog)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Chris Burniske            |
| [What Are Bitcoin Layer 2 Networks?](https://academy.binance.com/en/articles/what-are-bitcoin-layer-2-networks?viastacksblog\&ref=stacksblog)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Binance Academy           |


# March 2024

* 🔏 [Bitcoin layer-2 Stacks partners with eight companies ahead of its Nakamoto upgrade](https://cryptobriefing.com/stacks-network-expansion-new-signers/) — Crypto Briefing
* 🤝 [Stacks expands with Blockdaemon, Near Foundation amid Bitcoin surge](https://cointelegraph.com/news/stacks-welcomes-new-signers-blockdaemon-near-foundation-bitcoin-surge) — Cointelegraph
* 📈 [More Validation for Bitcoin Builders: Industry Leaders to Integrate Stacks, the Leading Bitcoin L2](https://www.benzinga.com/pressreleases/24/03/37487866/more-validation-for-bitcoin-builders-industry-leaders-to-integrate-stacks-the-leading-bitcoin-l2) — Benzinga
* 💼 [Bitcoin layer-2 Stacks partners with eight companies ahead of its Nakamoto upgrade](https://www.coindesk.com/tech/2024/04/16/og-bitcoin-l2-stacks-is-getting-a-major-overhaul/) — Coindesk
* 🔏 [Stacks L2 Bolsters Network Security with 8 New Signers](https://www.cryptotimes.io/2024/03/06/stacks-l2-bolsters-network-security-with-8-new-signers/) — The Crypto Times
* 📈 [Stacks: The Nakamoto Upgrade](https://twitter.com/FTI_DA/status/1771166481880944693?utm_source=stackssnacks.com\&utm_medium=referral\&utm_campaign=franklin-templeton-highlights-the-nakamoto-release-velar-amm-mainnet) — Franklin Templeton
* 🪴 [Stacks reaches 1,000,000 unique wallets](https://flight.beehiiv.net/v2/clicks/eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1cmwiOiJodHRwczovL3R3aXR0ZXIuY29tL1N0YWNrcy9zdGF0dXMvMTc2NTg2NTQzOTc2OTMwNTU3MT91dG1fc291cmNlPXN0YWNrc3NuYWNrcy5jb20mdXRtX21lZGl1bT1yZWZlcnJhbCZ1dG1fY2FtcGFpZ249bmFrYW1vdG8tcmVsZWFzZS12b3RpbmctcGVyaW9kLWVuZHMtY2VsZWJyYXRpbmctb25lLW1pbGxpb24tdW5pcXVlLXdhbGxldHMiLCJwb3N0X2lkIjoiYTY0NTBlYTAtY2U4MC00ZjRlLTg0YjMtNjNmNWFhNzRiMTY1IiwicHVibGljYXRpb25faWQiOiIzY2ZhYmZjYy0xNDU5LTQ0NTAtODI3MC1iOGJmM2RkMmFiOTciLCJ2aXNpdF90b2tlbiI6ImRhZTNjOGUxLWVkZTUtNDQxMC1hNWFkLTU3MTc2NmYyMGQ3OSIsImlhdCI6MTcxMzcyNTM5MiwiaXNzIjoib3JjaGlkIn0.allLoCyKRwaGltRK4_zwV80JFbHr6s8SGxr7zPwSZ44) — Signal21


# April 2024

| Title                                                                                                                                                                                                                                                                                                                                                                                                                                         | Outlet/Author      |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------ |
| 👀 [Disruptor To Disruptee: Bitcoin Institutionalization Needs L2 Shakeup](https://www.forbes.com/sites/nimrodlehavi/2024/04/11/disruptor-to-disruptee-bitcoin-institutionalization-needs-l2-shakeup/?sh=1745f76c629b)                                                                                                                                                                                                                        | Forbes             |
| 🟪 [Q\&A: What will the Bitcoin halving mean for Bitcoin L2s?](https://blockworks.co/news/bitcoin-halving-layer-2-impact-stacks)                                                                                                                                                                                                                                                                                                              | Blockworks         |
| [Bitcoin Layer 2 Stacks Prepares for Nakamoto Upgrade, its Largest Hard-Fork Ever](https://thedefiant.io/news/blockchains/bitcoin-layer-2-stacks-prepares-for-nakamoto-upgrade-its-largest-hard-fork-ever)                                                                                                                                                                                                                                    | The Defiant        |
| 🟧 [Stacks, Bitcoin Layers, and the Nakamoto Upgrade: Here’s What’s Going On](https://decrypt.co/225801/stacks-stx-nakamoto-upgrade-bitvm-rollups-defi)                                                                                                                                                                                                                                                                                       | Decrypt            |
| 📈 [BTCFi is an ‘enormous opportunity’ to make Bitcoin a productive asset — Stacks](https://cointelegraph.com/news/btcfi-opportunity-make-bitcoin-productive-asset)                                                                                                                                                                                                                                                                           | Cointelegraph      |
| ₿ [‘Real opportunity’ for Bitcoin Runes will come after first wave of investor hype](https://cointelegraph.com/news/real-opportunity-bitcoin-runes-after-first-wave-investor-hype)                                                                                                                                                                                                                                                            | Cointelegraph      |
| 🟧 [OG Bitcoin L2 Stacks Is Getting a Major Overhaul](https://www.coindesk.com/tech/2024/04/16/og-bitcoin-l2-stacks-is-getting-a-major-overhaul/)                                                                                                                                                                                                                                                                                             | Coindesk           |
| 📻 [Bitcoin L2 with Muneeb Ali of Stacks and Andy Fajar Handika of Loka Mining](https://www.charlieshrem.com/bitcoin-l2-with-muneeb-ali-of-stacks-and-andy-fajar-handika-of-loka-mining/)                                                                                                                                                                                                                                                     | Charlie Shrem Show |
| 📧 [April 15th Newsletter](https://milkroad.com/daily/what-happened-to-prices-this-weekend/?ref=stacksblog)                                                                                                                                                                                                                                                                                                                                   | Milroad            |
| 🗞️ [TEAMZ Web3/AI Summit2024 Day 1 has ended successfully!](https://prtimes.jp/main/html/rd/p/000000143.000031083.html?ref=stacksblog)                                                                                                                                                                                                                                                                                                       | PR Times (Japan)   |
| 👀 [The Bitcoin Halving's Degen Bets](https://www.bankless.com/the-bitcoin-halvings-degen-bets)                                                                                                                                                                                                                                                                                                                                               | Bankless           |
| 🌱 [Top 5 Pioneering Bitcoin Projects Poised For Growth Post-2024 Halving](https://cryptodaily.co.uk/2024/04/top-5-pioneering-bitcoin-projects-poised-for-growth-post-2024-halving)                                                                                                                                                                                                                                                           | Crypto Daily UK    |
| 💰 [Spartan Capital leads $10 million strategic funding round for Bitcoin DeFi developer ALEX](https://www.theblock.co/post/284556/spartan-capital-leads-10-million-funding-round-for-bitcoin-defi-developer-alex)                                                                                                                                                                                                                            | The Block          |
| ₿ [‘Bitcoin has as many functionalities as other blockchains’: Trust Machines member weighs in Bitcoin DeFi](https://cryptobriefing.com/bitcoin-functionality-other-blockchains/?ref=stacksblog)                                                                                                                                                                                                                                              | Crypto Briefing    |
| 🗞️ [A Look into The Upcoming Bitcoin Halving & Bitcoin Layer 2s](https://figment.io/insights/a-look-into-the-upcoming-bitcoin-halving-bitcoin-layer-2s/?ref=stacksblog)                                                                                                                                                                                                                                                                      | Figment            |
| 📕 [Bitcoin could gain new smart-contract superpowers](https://links.coinbase.com/e/evib?_t=3aca56371967418192255878e9689713&_m=fde47e8c40c24182b7cab3a6b10c9d3a&_e=DT1gXnNeiWLsEoKsYDSIAUCWVJr21XSvYbLTlg_uJ63W2CLdvG0Q8MPxsoVG5vCKM9SLV_5n-owzOqH_yPS9iQ%3D%3D\&utm_source=stackssnacks.com\&utm_medium=referral\&utm_campaign=stacks-apps-celebrate-all-time-tvl-high-as-new-defi-protocols-emerge) with the Lightning Network and Stacks. | Coinbase Bytes     |


# May 2024

| Title                                                                                                                                                                                                                                         | Outlet/Author   |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------- |
| [👀 Stacks active accounts reach record high amid growing interest in Bitcoin DeFi](https://cointelegraph.com/news/bitcoin-defi-surge-stacks-l2-record-users)                                                                                 | Cointelegraph   |
| [🗞️ Newsletter: BTC’s Streak Is Coming To An End](https://milkroad.com/daily/btcs-streak-is-coming-to-an-end-%EF%B8%8F/?ref=stacksblog)                                                                                                      | Milkroad        |
| [📕 The Imperative for Bitcoin Layers](https://chorus.one/articles/the-imperative-for-bitcoin-layers-2?ref=stacksblog)                                                                                                                        | Chorus One      |
| [First Bitcoin-backed synthetic dollar to launch with 25% yield](https://cointelegraph.com/news/hermetica-usdh-bitcoin-backed-synthetic-dollar)                                                                                               | Cointelegraph   |
| [🔗 Stacks, Moonriver, Hedera Network and Iron Fish Join Axelar’s Interchain Amplifier](https://cryptonews.com/news/stacks-hedera-network-and-iron-fish-join-axelar-interchain.htm)                                                           | Crypto News     |
| [🔗 Axelar Integrates With Stacks To Bridge Bitcoin Across Over 65 Blockchains](https://cryptodaily.co.uk/news-in-crypto/coincodex:axelar-integrates-with-stacks-to-bridge-bitcoin-across-over-65-blockchains)                                | Crypto Daily UK |
| 🌱 [LunarCrush Unveils AI-Driven Web3 Platform for Creators](https://www.altcoinbuzz.io/cryptocurrency-news/lunarcrush-unveils-ai-driven-web3-platform-for-creators/)                                                                         | Altcoin Buzz    |
| [Despite Bitcoin price volatility, factors point to BTC’s long-term success](https://cointelegraph.com/news/bitcoin-price-volatility-btc-success)                                                                                             | CoinTelegraph   |
| [Satoshi’s Vision Or Not, Bitcoin DeFi Is Here To Stay](https://www.thestreet.com/crypto/markets/satoshis-vision-or-not-bitcoin-defi-is-here-to-stay-)                                                                                        | The Street      |
| [📣 Stacks Foundation joins Uphold to drive Bitcoin adoption](https://www.binance.com/en/square/post/8093584158561)                                                                                                                           | Binance Square  |
| [Stacks & Uphold Team Up to Boost Bitcoin Beyond Just a Store of Value](https://coinpaper.com/4190/stacks-and-uphold-team-up-to-boost-bitcoin-beyond-just-a-store-of-value)                                                                   | Coinpaper       |
| [Stacks and Uphold Partner Up to Boost Bitcoin Adoption](https://coinmarketcap.com/community/articles/66437419d7905c7145a4c38e/)                                                                                                              | CoinMarketCap   |
| [Stacks & Uphold Team Up to Boost Bitcoin Beyond Just a Store of Value](https://coinstats.app/news/e879f032aa90aad3a51213254a35691ddc897bbfc7200d3d95b95ff87bb4ca0e_Stacks-%26-Uphold-Team-Up-to-Boost-Bitcoin-Beyond-Just-a-Store-of-Value/) | CoinStats       |
| [Stacks Foundation joins Uphold to drive Bitcoin adoption](https://www.coinlive.com/id/news-flash/514530)                                                                                                                                     | CoinLive        |
| [Stacks Partners With Uphold To Further Increase Bitcoin Adoption](https://www.investingcube.com/stacks-partners-with-uphold-to-further-increase-bitcoin-adoption/)                                                                           | InvestingCube   |
| [Stacks and Uphold Partner Up to Boost Bitcoin Adoption](https://www.cryptotimes.io/2024/05/14/stacks-and-uphold-partner-up-to-boost-bitcoin-adoption/)                                                                                       | Crypto Times    |


# June 2024

| Title                                                                                                                                                                                                                       | Outlet/Author     |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------- |
| 📊 [Layer-2 Networks Mark The Dawn Of A New Golden Age For Bitcoin](https://www.analyticsinsight.net/cryptocurrency-analytics-insight/layer-2-networks-mark-the-dawn-of-a-new-golden-age-for-bitcoin?ref=stacksblog)        | Analytics Insight |
| 📈 [Stacks Layer 2 for Bitcoin already hosts projects, STX token among top gainers](https://www.cryptopolitan.com/stacks-layer-2-bitcoin-stx-token-top-gainers/?ref=stacksblog)                                             | Cryptopolitan     |
| 📖 [Top Bitcoin Layer 2 Projects & Coins in 2024](https://cryptonews.com/cryptocurrency/bitcoin-layer-2-projects/?ref=stacksblog/)                                                                                          | Cryptonews        |
| 📖 [Layer-2 Networks Mark The Dawn Of A New Golden Age For Bitcoin](https://www.analyticsinsight.net/cryptocurrency-analytics-insight/layer-2-networks-mark-the-dawn-of-a-new-golden-age-for-bitcoin)                       | Analytics Insight |
| 🧩 [Haruko Integrates Stacks to Deliver Institutional Asset Management on Bitcoin L2](https://www.financemagnates.com/thought-leadership/haruko-integrates-stacks-to-deliver-institutional-asset-management-on-bitcoin-l2/) | Finance Magnates  |
| 🧩 [Haruko to enhance digital asset management with Stacks integration](https://finbold.com/haruko-to-enhance-digital-asset-management-with-stacks-integration/)                                                            | Finbold           |
| 🧩 [Haruko to Streamline Bitcoin Asset Management With Stacks Integration](https://u.today/haruko-to-streamline-bitcoin-asset-management-with-stacks-integration)                                                           | U Today           |
| 💲 [Stacking DAO Bi-Weekly Update: $560k in Stacking rewards over two cycles](https://medium.com/@stackingdao/stacking-dao-bi-weekly-update-560k-in-stacking-rewards-over-two-cycles-c012256c1622)                          | Medium            |
| 🧩 [Kiln: We're thrilled to unveil our latest integration](https://x.com/Kiln_finance/status/1797612820537729354?ref=stacksblog)                                                                                            | Kiln              |


# July 2024

Bitcoin Summer continued in July: BitGo stepped up to join the Stacks signer network, Stacks teams Bitflow and Hermetica landed their own media and builders everywhere convened in Nashville.

| Title                                                                                                                                                                                                                       | Outlet / Author     |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------- |
| 📈 [All Time High in Monthly Active Accounts for Stacks](https://app.signal21.io/stacks?utm_source=stackssnacks.com\&utm_medium=referral\&utm_campaign=all-time-high-in-monthly-active-accounts-for-stacks)                 | Signal21            |
| 💎 [Bitflow Unveils Liquidity Hub Upgrade, Enabling Functionality Like Ethereum DeFi](https://blockchainreporter.net/bitflow-unveils-liquidity-hub-upgrade-enabling-functionality-like-ethereum-defi/)                      | Blockchain Reporter |
| 💎 [Bitflow’s Liquidity Hub Elevates Bitcoin DeFi to Ethereum DeFi Ecosystem Standard](https://coinmarketcap.com/community/articles/667c6188dd97c85264ba1fc1/)                                                              | CoinMarketCap       |
| [Hermetica's Synthetic Dollar Sparks DeFi Revolution](https://hackernoon.com/hermeticas-synthetic-dollar-sparks-defi-revolution?ref=stacksblog)                                                                             | Hackernoon          |
| 🛡️ [Hypernative Bolsters Bitcoin L2 Security as Stacks Ecosystem Gets Real-Time Protection](https://hackernoon.com/hypernative-bolsters-bitcoin-l2-security-as-stacks-ecosystem-gets-real-time-protection)                 | Hackernoon          |
| 🎫 [Bitcoin Builders Conference Set to Spotlight Innovation and the Future of the Bitcoin Economy](https://decrypt.co/239086/bitcoin-builders-conference-set-to-spotlight-innovation-and-the-future-of-the-bitcoin-economy) | Decrypt             |
| 🪙 [Bitcoin Developers Launch BTC-Backed Stablecoin As Rune Token](https://decrypt.co/239925/bitcoin-developers-launch-btc-backed-stablecoin-as-rune-token)                                                                 | Decrypt             |
| 📰 [BitGo integrates Stacks for Bitcoin rewards, following institutional Bitcoin demand](https://cointelegraph.com/news/bitgo-stacks-bitcoin-rewards-institutional-bitcoin-demand)                                          | CoinTelegraph       |
| 📰 [BitGo Launches Support for Bitcoin L2 Stacks and sBTC](https://cryptopotato.com/bitgo-launches-support-for-bitcoin-l2-stacks-and-sbtc/?amp)                                                                             | Crypto Potato       |
| 🟧 [Protocol Village: Bitrue Ventures Launches $40M Fund for 'Nascent Web3 Companies'](https://www.coindesk.com/tech/2024/07/17/protocol-village/)                                                                          | Coindesk            |


# August 2024

| Title                                                                                                                                                                                                                                                         | Outlet/Author                |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------- |
| 🧩 [Deploy Stacks nodes on AWS with the AWS Blockchain Node Runners](https://aws.amazon.com/blogs/database/how-to-deploy-stacks-blockchain-nodes-on-aws-with-the-aws-blockchain-node-runners-stacks-blueprint/?ref=stacksblog)                                | Amazon Web Services          |
| 🗞️ [Bitflow and Leather Wallet Join Forces to Simplify Bitcoin L2 Asset Swaps](https://hackernoon.com/bitflow-and-leather-wallet-join-forces-to-simplify-bitcoin-l2-asset-swaps)                                                                             | Hackernoon                   |
| 🤝 [Aptos and Stacks Forge New Partnership for Bitcoin Innovation](https://www.altcoinbuzz.io/cryptocurrency-news/aptos-and-stacks-forge-new-partnership-for-bitcoin-innovation/)                                                                             | Altcoin Buzz                 |
| 🖊 [Millions of Dollars Worth of BTC Earned by New Institutional Signers Since Nakamoto Instantiation](https://stacks.org/institutional-signers-earn-millions)                                                                                                | Stacks Foundation            |
| 💲[Liquidium Raises $2.5M, Accelerating L1 Borrowing and Lending](https://subscribe.bitcoinbuildersassociation.com/p/liquidium-raises-25m-accelerating?ref=stacksblog)                                                                                        | Bitcoin Builders Association |
| 🧡[Bitcoin Network Stacks Begins Rollout of Speed-Boosting Nakamoto Upgrade](https://decrypt.co/246543/bitcoin-stacks-rollout-speed-boosting-nakamoto-upgrade)                                                                                                | Decrypt                      |
| 📙[Bitcoin Network Stacks Devs 'Can See the Finish Line' With Nakamoto Upgrade](https://decrypt.co/247247/bitcoin-network-stacks-devs-see-finish-line-nakamoto-upgrade)                                                                                       | Decrypt                      |
| 📙[Stacks co-creator on how the Nakamoto upgrade will drive a $70bn market for Bitcoin DeFi](https://www.dlnews.com/articles/defi/stacks-nakamoto-upgrade-brings-bitcoin-defi-with-sbtc-token/?utm_source=telegram\&utm_medium=organic_social\&utm_campaign=) | DL News                      |
| 🗞️[Bitcoin Layer-2 Network Stacks Begins Nakamoto Upgrade](https://www.coindesk.com/tech/2024/08/28/bitcoin-layer-2-network-stacks-begins-nakamoto-upgrade/amp/)                                                                                             | Coindesk                     |
| 🗞️[Bitcoin Layer 2 Stacks readies for Nakamoto upgrade activation](https://crypto.news/bitcoin-layer-2-stacks-readies-for-nakamoto-upgrade-activation/)                                                                                                      | Crypto News                  |
| [Stacks (STX) prepares for Nakamoto upgrade: here’s what to expect](https://coinjournal.net/news/stacks-stx-prepares-for-nakamoto-upgrade-heres-what-to-expect/) 🗞️                                                                                          | Coin Journal                 |
| 🗞️[Stacks (STX) poised for recovery as game-changer Nakamoto upgrade approaches](https://invezz.com/news/2024/08/26/stacks-stx-poised-for-recovery-as-game-changer-nakamoto-upgrade-approaches/)                                                             | Invezz                       |
| 🗞️[Bitcoin Layer-2 Stacks Set to Receive Its Nakamoto Upgrade, Will Enhance DeFi on Bitcoin](https://www.livebitcoinnews.com/bitcoin-layer-2-stacks-set-to-receive-its-nakamoto-upgrade-will-enhance-defi-on-bitcoin/)                                       | Live Bitcoin News            |
| 🗞️[Nakamoto Activation Begins: Leading L2 Stacks Sets the Stage for a Bitcoin-Led Future](https://markets.businessinsider.com/news/currencies/nakamoto-activation-begins-leading-l2-stacks-sets-the-stage-for-a-bitcoin-led-future-1033729689)               | Markets Insider              |
| 🧡 [Bitcoin L2s Are Eating the World](https://hackernoon.com/bitcoin-l2s-are-eating-the-world)                                                                                                                                                                | Hackernoon                   |
| 💰 [The Bitcoin Renaissance: Unlocking Trillions in Value](https://www.forbes.com/sites/leeorshimron/2024/08/13/the-bitcoin-renaissance-unlocking-trillions-in-value/?ref=stacksblog)                                                                         | Forbes                       |


# September 2024

| Article                                                                                                                                                                                                                                         | Outlet / Author              |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------- |
| 📈 [New Milestone for Bitcoin DeFi: Over 1,400 Smart Contracts Deployed on Stacks](https://coinchapter.com/new-milestone-for-bitcoin-defi-over-1400-smart-contracts-deployed-on-stacks-even-before-major-upgrade/)                              | Coin Chapter                 |
| 📈 [Bitcoin layer-2 Stacks witnessed 1,400 smart contract deployments month over month](https://www.livebitcoinnews.com/stacks-registers-unseen-smart-contract-deployment-days-away-from-its-nakamoto-upgrade/)                                 | Live Bitcoin News            |
| 🗞️ [Stacks' smart contracts reach record high ahead of Nakamoto upgrade](https://cointelegraph.com/news/stacks-record-smart-contracts-nakamoto-upgrade?ref=stacksblog)                                                                         | Cointelegraph                |
| 🤝🏻 [Anchorage Digital Announces Custody Support for Stacks](https://x.com/Stacks/status/1831335327300309174?utm_source=stackssnacks.com\&utm_medium=referral\&utm_campaign=anchorage-digital-supporting-stacks-btc-bash-and-other-highlights) | X / Anchorage Digital        |
| 🚀 [Hermetica Labs Launches USDh, the first Bitcoin-native synthetic USD](https://cryptobriefing.com/bitcoin-synthetic-dollar-25-percent-yield/?ref=stacksblog)                                                                                 | Crypto Briefing              |
| 💡 [What is sBTC? A Guide to the Non-Custodial Native Bitcoin DeFi](https://www.xverse.app/blog/what-is-sbtc?ref=stacksblog)                                                                                                                    | Xverse                       |
| ₿ [Over $1.5B worth of BTC is now locked in Bitcoin Layers](https://subscribe.bitcoinbuildersassociation.com/p/over-15b-worth-of-btc-is-now-locked?ref=stacksblog)                                                                              | Bitcoin Builders Association |
| 🤝 [Stacks x Aptos Foundations Join Forces to Bring Bitcoin to Aptos Network via sBTC](https://decrypt.co/249825/bitcoin-stacks-l2-brings-its-sbtc-to-the-aptos-network)                                                                        | Decrypt                      |
| 🖼️ [Gamma's United Bitcoin Ordinals and Stacks Platform Enters Beta](https://nftinsider.io/gamma-bitcoin-beta/?ref=stacksblog)                                                                                                                 | NFT Insider                  |
| 🤝 [Tokensoft partners with Stacks Foundation and Bitcoin Frontier Fund to Accelerate Bitcoin Builders](https://cryptobriefing.com/bitcoin-builders-acceleration-partnership/?ref=stacksblog)                                                   | Crypto Briefing              |
| 🗞️ [Stacks Asia Foundation Launches with $15M in Funding to Boost Bitcoin Layer-2 Adoption](https://coinmarketcap.com/community/articles/66e2998ae0c16b2dea22b4f1/?ref=stacksblog)                                                             | CoinMarketCap                |
| 🚀 [Zest Introduces BTCz, leveraging Babylon and Stacks](https://subscribe.bitcoinbuildersassociation.com/p/zest-introduces-btcz-leveraging-babylon?ref=stacksblog)                                                                             | Zest                         |


# October 2024

| Article                                                                                                                                                                                                                              | Outlet/Author                |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------- |
| 🚀 [Stacks fortifies Bitcoin ties with Nakamoto upgrade](https://blockworks.co/news/stacks-sbtc-bitcoin-alignment-nakamoto?ref=stacksblog)                                                                                           | Blockworks                   |
| 🚀 [Stacks, Prominent Bitcoin Layer-2 Project, Activates Long-Awaited 'Nakamoto' Upgrade](https://www.coindesk.com/tech/2024/10/29/stacks-prominent-bitcoin-layer-2-project-activates-long-awaited-nakamoto-upgrade/?ref=stacksblog) | Coindesk                     |
| 🤝 [Asymmetric Research Joins Stacks Ecosystem as Security Contributor to Bitcoin L2](https://hackernoon.com/asymmetric-research-joins-stacks-ecosystem-as-security-contributor-to-bitcoin-l2)                                       | Hackernoon                   |
| 🟧 [A Beginner's Guide to Bitcoin Layers](https://www.hiro.so/blog/read-a-beginners-guide-to-bitcoin-layers?ref=stacksblog)                                                                                                          | Hiro                         |
| 🌱 [Bitcoin-backed stablecoin developer Hermetica raises $1.7M in seed funding](https://www.theblock.co/post/321141/bitcoin-backed-stablecoin-developer-hermetica-raises-1-7-million-in-seed-funding?ref=stacksblog)                 | The Block                    |
| 🌱 [Blockstream raises $210M to accelerate Bitcoin adoption](https://subscribe.bitcoinbuildersassociation.com/p/blockstream-raises-210m-to-accelerate?ref=stacksblog)                                                                | Bitcoin Builders Association |
| 🟧 [BoostVC, Draper Associates, and Thesis Announce BitcoinFi Accelerator](https://subscribe.bitcoinbuildersassociation.com/p/boostvc-draper-associates-and-thesis?ref=stacksblog)                                                   | Bitcoin Builders Association |


# November 2024

| Article                                                                                                                                                                                                                                                                                              | Outlet / Author |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------- |
| 🧡 [CoinFlip, the #1 Global Bitcoin ATM Network Is Making Programmable Bitcoin More Accessible with Stacks, the Leading Bitcoin L2](https://www.theblock.co/post/327328/coinflip-the-1-global-bitcoin-atm-network-is-making-programmable-bitcoin-more-accessible-with-stacks-the-leading-bitcoin-l2) | TheBlock        |
| 🧡 [Leading Crowdsourced Security Platform Immunefi Teams Up with Asymmetric Research & Bitcoin L2 Labs to Bolster sBTC Security](https://www.theblock.co/post/326835/leading-crowdsourced-security-platform-immunefi-teams-up-with-asymmetric-research-bitcoin-l2-labs-to-bolster-sbtc-security)    | TheBlock        |
| 🧡 [CoinFlip, the #1 Global Bitcoin ATM Network Is Making Programmable Bitcoin More Accessible with Stacks, the Leading Bitcoin L2](https://coinmarketcap.com/community/articles/673e0069c291c94bd18e68fb/)                                                                                          | CoinMarketCap   |
| 🧡 [Bitcoin Frontier Fund, Home of the Top Bitcoin Accelerator, To Invest in Teams Built on sBTC](https://www.theblock.co/post/328240/bitcoin-frontier-fund-home-of-the-top-bitcoin-accelerator-to-invest-in-teams-built-on-sbtc)                                                                    | TheBlock        |


# December 2024

| Article                                                                                                                                                                                                                                                           | Outlet / Author     |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------- |
| 🧡 [Portal Ventures, the Leading Pre-seed VC Firm and the First to Call the Bitcoin Thesis, to Back sBTC](https://www.theblock.co/post/329292/portal-ventures-the-leading-pre-seed-vc-firm-and-the-first-to-call-the-bitcoin-thesis-to-back-sbtc?ref=stacksblog)  | The Block           |
| 🧡 [LearnWeb3, the Largest Educational Platform for Web3, Set to Onboard New Wave of sBTC Developers](https://www.theblock.co/post/330037/learnweb3-the-largest-educational-platform-for-web3-set-to-onboard-new-wave-of-sbtc-developers)                         | The Block           |
| 🧡 [Xverse, Leading Bitcoin Ecosystem Wallet, Adopts sBTC as Preferred Scaling Solution for the Bitcoin Economy](https://www.theblock.co/post/330649/xverse-leading-bitcoin-ecosystem-wallet-adopts-sbtc-as-preferred-scaling-solution-for-the-bitcoin-economy)   | The Block           |
| 🧡 [Hex Trust Expands Collaboration with Stacks Asia Foundation to Bolster sBTC Adoption](https://blockchainreporter.net/hex-trust-expands-collaboration-with-stacks-asia-foundation-to-bolster-sbtc-adoption/)                                                   | Blockchain Reporter |
| 🧡 [Fordefi, the First MPC Wallet to Fully Support Bitcoin DeFi, Joins Cohort of sBTC Backers](https://www.theblock.co/post/331016/fordefi-the-first-mpc-wallet-to-fully-support-bitcoin-defi-joins-cohort-of-sbtc-backers)                                       | The Block           |
| 🧡 [Travala, The #1 Bitcoin and Crypto Travel Booking Portal, Announces Support for sBTC and STX](https://www.theblock.co/post/331020/travala-the-1-bitcoin-and-crypto-travel-booking-portal-announces-support-for-sbtc-and-stx)                                  | The Block           |
| 🚀 [Double-dipping with sBTC on Stacks](https://blockworks.co/news/stacks-sbtc-double-dipping)                                                                                                                                                                    | Blockworks          |
| 🚀 [Bitcoin Gets DeFi Upgrade: Stacks Launches Bitcoin-Backed sBTC for Smart Contracts](https://hackernoon.com/bitcoin-gets-defi-upgrade-stacks-launches-bitcoin-backed-sbtc-for-smart-contracts)                                                                 | Hackernoon          |
| 🚀 [sBTC Launches on Stacks Mainnet, Bringing Bitcoin DeFi to Life](https://beincrypto.com/sbtc-launches-on-stacks-mainnet/)                                                                                                                                      | BeInCrypto          |
| 🚀 [sBTC Launches on Stacks Mainnet With Deposit-Only Functionality](https://cryptopotato.com/sbtc-launches-on-stacks-mainnet-with-deposit-only-functionality/?amp)                                                                                               | Crypto Potato       |
| 🚀 [Stacks Launches sBTC on Mainnet with 1,000 BTC Cap, Offering 5% Yield and Up to 60% APY Staking](https://thedefiant.io/news/blockchains/stacks-launches-sbtc-on-mainnet-1000-btc-cap-offering-5-yield-up-to-60-apy-b70deae1)                                  | The Defiant         |
| 🚀 [sBTC Kicks Off on Stacks Mainnet: Details](https://u.today/sbtc-kicks-off-on-stacks-mainnet-details)                                                                                                                                                          | Crypto Economy      |
| 🟧 [Bitcoin's Memecoin-Like 'Runes' Get a Boost With AMM Launch on Stacks](https://www.coindesk.com/tech/2024/12/18/bitcoins-memecoin-like-runes-get-a-boost-with-amm-launch-on-stacks)                                                                           | Coindesk            |
| 🧡 [Ankr, the #1 Provider of Bitcoin-Secured, Physical Infrastructure, Becomes Signer for Stacks as sBTC Launches](https://www.theblock.co/post/331411/ankr-the-1-provider-of-bitcoin-secured-physical-infrastructure-becomes-signer-for-stacks-as-sbtc-launches) | The Block           |
| 📙 [New Report Finds Tokenized BTC Landscape Worth $1T (18 Dec)](https://coinmarketcap.com/community/articles/6762f62b09984e48933a1ec1/)                                                                                                                          | CoinMarketCap       |
| 📙 [New Report Finds Tokenized BTC Landscape Worth $1T (18 Dec)](https://www.binance.com/en/square/post/17739664161346)                                                                                                                                           | Binance             |


# 2025

For weekly stories delivered to your inbox, subscribe to [Stacks Snacks](https://stackssnacks.com/). For quarterly ecosystem recaps, subscribe to the [Stacks Foundation newsletter](https://newsletters.stacks.org/).

<table data-view="cards"><thead><tr><th>Issue</th><th data-card-target data-type="content-ref">Target</th></tr></thead><tbody><tr><td>january-2024.md</td><td><a href="broken-reference">Broken link</a></td></tr><tr><td>february-2025.md</td><td><a href="broken-reference">Broken link</a></td></tr><tr><td>march-2025.md</td><td><a href="broken-reference">Broken link</a></td></tr><tr><td>march-2025-1.md</td><td><a href="broken-reference">Broken link</a></td></tr><tr><td>march-2025-2.md</td><td><a href="broken-reference">Broken link</a></td></tr><tr><td>june-2025.md</td><td><a href="broken-reference">Broken link</a></td></tr><tr><td>june-2025-1.md</td><td><a href="broken-reference">Broken link</a></td></tr><tr><td>june-2025-2.md</td><td><a href="broken-reference">Broken link</a></td></tr><tr><td>june-2025-2-1.md</td><td><a href="broken-reference">Broken link</a></td></tr></tbody></table>


# January 2025

For weekly stories delivered to your inbox, subscribe to [Stacks Snacks](https://stackssnacks.com/). For quarterly ecosystem recaps, subscribe to the [Stacks Foundation newsletter](https://newsletters.stacks.org/).

| Article                                                                                                                                                                                                                                                                                        | Outlet/Publication  |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------- |
| [🧡 Stacks’ Muneeb Ali: Let the Bitcoin L2s Bloom](https://www.coindesk.com/consensus-hong-kong-2025-coverage/2025/01/13/stacks-muneeb-ali-let-the-bitcoin-l2s-bloom)                                                                                                                          | Coindesk            |
| [🚀 Why Stacks Is Leading the Bitcoin Layer 2 Revolution](https://www.crypto-news-flash.com/why-stacks-is-leading-the-bitcoin-layer-2-revolution/)                                                                                                                                             | Crypto News Flash   |
| [🗞️ Bitcoin-Based Stablecoin USDh Secures $3M in Liquidity](https://www.coindesk.com/tech/2025/01/22/bitcoin-based-stablecoin-usdh-secures-usd3m-in-liquidity)                                                                                                                                | Coindesk            |
| [🗞️ Hermetica's Bold Move to Dominate Stacks DeFi With its USDh Stablecoin and sBTC Yield Trade Program](https://hackernoon.com/hermeticas-bold-move-to-dominate-stacks-defi-with-its-usdh-stablecoin-and-sbtc-yield-trade-program)                                                           | Hackernoon          |
| [🪙 Hermetica Launches New sBTC Yield Product, USDh Liquidity Faces Boost](https://u.today/hermetica-launches-new-sbtc-yield-product-usdh-liquidity-faces-boost)                                                                                                                               | U Today             |
| [🪙 Hermetica Unveils $sBTC for Yield-Bearing $USDh in Partnership with Zest Protocol](https://blockchainreporter.net/hermetica-unveils-sbtc-for-yield-bearing-usdh-in-partnership-with-zest-protocol/)                                                                                        | Blockchain Reporter |
| [🪙 USDh set to become the leading stablecoin on Stacks as Hermetica introduces sBTC yield product](https://invezz.com/news/2025/01/23/usdh-set-to-become-the-leading-stablecoin-on-stacks-as-hermetica-introduces-sbtc-yield-product/)                                                        | Invezz              |
| [🧡 Making Bitcoin Go Further: How sBTC Is Expanding the Possibilities of DeFi](https://bitcoinist.com/making-bitcoin-go-further-how-sbtc-is-expanding-the-possibilities-of-defi/)                                                                                                             | Bitcoinist          |
| [🚀 Bitcoin DeFi: The Most Pivotal Innovation On Bitcoin’s Evolutionary Path](https://www.cryptopolitan.com/bitcoin-defi-the-most-pivotal-innovation-on-bitcoins-evolutionary-path/)                                                                                                           | Cryptopolitan       |
| [🟧 Stacks Bridges the Gap to Bitcoin as Strategic US Reserve Materializes](https://www.financemagnates.com/thought-leadership/stacks-bridges-the-gap-to-bitcoin-as-strategic-us-reserve-materializes/)                                                                                        | Finance Magnates    |
| [🗞️ Bitcoin DeFi Protocol Velar Unveils .BTC Name Grant Program for Unified Identities on Stacks](https://cryptopotato.com/bitcoin-defi-protocol-velar-unveils-btc-name-grant-program-for-unified-identities-on-stacks/)                                                                      | CryptoPotato        |
| [🚀](https://www.crypto-news-flash.com/why-stacks-is-leading-the-bitcoin-layer-2-revolution/) [Bitcoin DeFi: The Most Pivotal Innovation On Bitcoin’s Evolutionary Path](https://www.cryptopolitan.com/bitcoin-defi-the-most-pivotal-innovation-on-bitcoins-evolutionary-path/?ref=stacksblog) | Cryptopolitan       |


# February 2025

| Article                                                                                                  | Publication / Link                                                                                                                                      |
| -------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 🧡 Bitcoin's Correlation With Markets Grows, Challenging 'Safe Haven' Narrative                          | [Bitcoin.com](http://bitcoin.com/)                                                                                                                      |
| 🪙 How sBTC Unlocks Bitcoin DeFi – And Why It Matters                                                    | [Coincu.com](http://coincu.com/)                                                                                                                        |
| 🟧 sBTC Is Fast Emerging As The Missing Link In Bitcoin’s Cross-Chain Evolution                          | [Bitcoinist](https://bitcoinist.com/sbtc-is-fast-emerging-as-the-missing-link-in-bitcoins-cross-chain-evolution/)                                       |
| 🧡 The Overlooked Bitcoin Layer-2 Sector: Why and What to Expect Moving Forward                          | [Binance](https://www.binance.com/en-IN/square/post/20381520919281)                                                                                     |
| 🟧 Bitcoin L2 ‘honeymoon phase’ is over, most projects will fail — Muneeb Ali                            | [CoinTelegraph](https://cointelegraph.com/news/bitcoin-layer2-projects-fade-stacks-muneeb-ali)                                                          |
| 🗞️ Blockchair Launches Stacks Explorer, Enhancing Bitcoin Layer 2 Visibility and sBTC Support           | [DL News](https://www.dlnews.com/research/external/blockchair-launches-stacks-explorer-enhancing-bitcoin-layer-2-visibility-and-sbtc-support/)          |
| 🗞️ Blockchair Launches Stacks Explorer, Enhancing Bitcoin Layer 2 Visibility and sBTC Support           | [CoinMarketCap](https://coinmarketcap.com/community/articles/67bf2560ae03156d954313b6/)                                                                 |
| 🟧 SNZ, UTXO Capital, Jump Crypto Among Leaders to Deposit Early in sBTC, Unlocking Bitcoin DeFi Utility | [Decrypt](https://decrypt.co/307910/snz-utxo-capital-jump-crypto-among-leaders-to-deposit-early-in-sbtc-unlocking-bitcoin-defi-utility)                 |
| 🚀 Stacks’ sBTC Sees Rapid Adoption as Second Cap Hits 3,000 BTC Limit                                   | [Bitcoinist](https://bitcoinist.com/stacks-sbtc-sees-rapid-adoption-as-second-cap-hits-3000-btc-limit/)                                                 |
| 🚀 SNZ, UTXO Capital, Jump Crypto Among Leaders to Deposit Early in sBTC, Unlocking Bitcoin DeFi Utility | [DL News](https://www.dlnews.com/research/external/snz-utxo-capital-jump-crypto-among-leaders-to-deposit-early-in-sbtc-unlocking-bitcoin-defi-utility/) |


# March 2025

* 🟧 [America’s Crypto Renaissance: Why Stacks and Bitcoin Layers Are Poised for Growth](https://www.cryptopolitan.com/americas-crypto-renaissance-why-stacks-and-bitcoin-layers-are-poised-for-growth/) — Cryptopolitan
* 🧡 [Bitcoin Layers and the Path to Universal Utility](https://www.google.com/url?q=https://cfc-stmoritz.com/industry-insights/bitcoin-layers-and-the-path-to-universal-utility?utm_source%3DCfC%2BSt.%2BMoritz%2B-%2BGlobal%2BMailing%2BList%26utm_campaign%3D61bc405f9f-EMAIL_CAMPAIGN_2024_04_03_02_27_COPY_01%26utm_medium%3Demail%26utm_term%3D0_-4a9e5b2e5d-296312470\&sa=D\&source=editors\&ust=1743526707117175\&usg=AOvVaw2GQInrk1FYUbGiwB0hw6Jt) — Cfc Moritz (Kyle Ellicott)
* 🚀 [Velar PerpDex Launches on Stacks as First Bitcoin-Native Perpetual DEX](https://www.dlnews.com/research/external/velar-perpdex-launches-on-stacks-as-first-bitcoin-native-perpetual-dex/) — DL News
* 🧡 [Stacks Reaches New All-Time High TVL](https://x.com/signal21btc/status/1902742256068514010) — Signal21


# April 2025

| Article Title & Link                                                                                                                                                                                                          | Media Outlet  |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------- |
| [🧡 Experts: Gold’s Rise Doesn’t Undermine Bitcoin’s Digital Gold Status](https://news.bitcoin.com/experts-golds-rise-doesnt-undermine-bitcoins-digital-gold-status/)                                                         | Bitcoin.com   |
| [🗞️ Veteran crypto exchange Bitfinex bets big on Bitcoin-based DeFi, deepens integration with Stacks](https://u.today/bitfinex-lists-stx-token-by-stacks-becomes-network-signer)                                             | U Today       |
| [🟧 Bitfinex Throws Its Full Weight Behind Bitcoin’s Leading Layer-2 Stacks](https://www.coincarp.com/learn/bitfinex-throws-its-full-weight-behind-bitcoins-leading-layer-2-stacks/)                                          | Coincarp      |
| [🚀 Hex Trust Expands Institutional Support for Stacks (STX) and sBTC Amid Growing Adoption](https://www.dlnews.com/research/external/hex-trust-expands-institutional-support-for-stacks-stx-and-sbtc-amid-growing-adoption/) | DL News       |
| [🟧 Hermetica brings 5% yield to Bitcoin traders on Velar PerpDEX](https://crypto.news/hermetica-brings-5-yield-to-bitcoin-traders-on-velar-perpdex/)                                                                         | Crypto.News   |
| [🗞️ BitGo Launches Institutional Support for SBTC, Expanding Bitcoin DeFi Accessibility (22 Apr)](https://www.binance.com/en/square/post/23264351434353)                                                                     | Binance       |
| [🪙 Stacks' STX Is Week's Best Performer as Bitgo Link Seen Boosting Institutional Use](https://www.coindesk.com/markets/2025/04/25/stacks-stx-is-week-s-best-performer-as-bitgo-link-seen-boosting-institutional-use)        | Coindesk      |
| [🚀 Stacks Asia bets big on Middle East Bitcoin boom with Abu Dhabi partnership](https://cointelegraph.com/news/stacks-asia-adgm-partnership-boosts-bitcoin-adoption-middle-east)                                             | Cointelegraph |


# May 2025

| Article Title & Link                                                                                                                                                           | Media Outlet    |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------- |
| 🚀 [Stacks roadmap update and STX surge](https://blockchain.news/flashnews/stacks-announces-new-roadmap-after-nakamoto-and-sbtc-launch-key-updates-for-crypto-traders-in-2025) | Blockchain News |
| 🤝 [Stacks Asia partners with HEX Trust](https://cointelegraph.com/news/stacks-asia-hex-trust-bitcoin-defi-opportunity)                                                        | Cointelegraph   |
| 📈 [STX rallies 30% ahead of mainnet upgrade](https://cointelegraph.com/news/stacks-stx-makes-30-gain-as-mainnet-upgrade-and-stablecoin-launch-approach)                       | Cointelegraph   |
| 💡 [Tech Expert Predicts $1 Million Bitcoin — 'Only One More 10x Left'](https://www.binance.com/en-IN/square/post/24043258936257)                                              | Binance         |


# June 2025

| Article Title & Link                                                                                                                                                                                                                                                        | Outlet            |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------- |
| 📰 [Stacks to be Showcased at Blockchain and Digital Assets Virtual Investor Conference on June 5](https://www.globenewswire.com/news-release/2025/06/04/3093569/0/en/Stacks-to-be-Showcased-at-Blockchain-and-Digital-Assets-Virtual-Investor-Conference-on-June-5th.html) | Globe Newswire    |
| 🤝 [Copper Launches Support for sBTC](https://www.crowdfundinsider.com/2025/06/241658-digital-assets-copper-introduces-sbtc-stacking-functionality/)                                                                                                                        | Crowdfund Insider |
| 🧩 [Hex Trust Adds sBTC Support and SIP-010 Integration](https://bitcolumnist.com/release/hex-trust-integrates-sbtc-via-sip-010-to-enable-institutional-bitcoin-defi-access/)                                                                                               | BitColumnist      |


# July 2025

| Article Title & Link                                                                                                                                                                                   | Outlet        |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------- |
| 📰 [$1.5B Stacks sBTC and STX Adopt Wormhole NTT Standard to Expand Multichain](https://wormhole.com/blog/usd1-5b-stacks-sbtc-and-stx-adopt-wormhole-ntt-standard-to-expand-multichain?ref=stacksblog) | Wormhole Blog |
| [Top Interop Protocol Wormhole Adds Stacks to Bridge Bitcoin to Multi-Chain DeFi](https://thedefiant.io/news/defi/wormhole-integrates-stacks-tokens-for-multi-chain-bitcoin-defi)                      | The Defiant   |


# August 2025

| Article Title & Link                                                                                                          | Outlet         |
| ----------------------------------------------------------------------------------------------------------------------------- | -------------- |
| [BTCFi #2: Inside the Infrastructure Layer of BTCFi](https://x.com/Tiger_Research_/status/1957703731308556340?ref=stacksblog) | Tiger Research |


# September 2025

| Article Title & Link                                                                                                                                                           | Outlet                 |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------- |
| [LAB: Africa’s First Bitcoin Layer 2 Development Hub & Incubator](https://stacks.org/let-africa-build?ref=stacksblog)                                                          | Stacks Foundation Blog |
| [Unlocking Bitcoin's value - Will the BTCFi narrative push Stacks to $20?](https://eng.ambcrypto.com/unlocking-bitcoins-value-will-the-btcfi-narrative-push-stacks-stx-to-20/) | AMB Crypto             |


# October 2025

| Article Title & Link                                                                                                            | Outlet                 |
| ------------------------------------------------------------------------------------------------------------------------------- | ---------------------- |
| [Dual Stacking: What It Means for Stackers and the Broader Ecosystem](https://stacks.org/dual-stacking-overview?ref=stacksblog) | Stacks Foundation Blog |


# November 2025

| Article Title & Link                                                                                                                   | Outlet      |
| -------------------------------------------------------------------------------------------------------------------------------------- | ----------- |
| [Stacks to integrate Circle xReserve for USDC interoperability](https://www.stacks.co/blog/stacks-circle-xreserve-usdc?ref=stacksblog) | Stacks Labs |


# Contribute

### Contribute to Stacks Core

There is a [detailed contribution guide](https://github.com/stacks-network/stacks-core/blob/master/CONTRIBUTING.md) that lives in the Stacks core GitHub repository that is the best place to get started contributing to Stacks.

### Contribute to these Docs

The Stacks docs are built using GitBook with a two-way sync with the [docs repository on GitHub](https://github.com/stacks-network/docs).

Because of this two-way sync, you can contribute to the documentation in one of two ways:

{% stepper %}
{% step %}

### Fork the repo and create a PR

You can fork the docs repo, add your change, and then create a PR to be merged into the main docs.
{% endstep %}

{% step %}

### Create an issue

You can create an issue, and someone that works on the docs will take a look and implement it if it is a necessary change.
{% endstep %}
{% endstepper %}

What kinds of changes are we looking for?

If you see a typo, a missing tutorial, an unclear explanation, or really anything else you think could improve the quality of the documentation, please feel free to open an issue or create a pull request.


# Stacks Brand Kit

The most current brand resources are always available via [stacks.co/brand](https://stacks.co/brand). Stacks brand materials can be found and downloaded (exported) via the linked Figma space.&#x20;

<a href="https://stacks.co/brand" class="button primary">Stacks Brand Kit</a>


